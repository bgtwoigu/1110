/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

              C D M A   T R A N S L A T I O N    S E R V I C E S

GENERAL DESCRIPTION
  This module contains the services which translate a CDMA message between
  the internal format used by the Main Control task and the external format
  used by the Transmit and Receive tasks.

EXTERNALIZED FUNCTIONS
  caix_int_to_ext
    Translates a message from internal to external format.

  caix_ext_to_int
    Translates a message from external to internal format.

INITIALIZATION AND SEQUENCING REQUIREMENTS
  None

Copyright (c) 1990-2005 by QUALCOMM, Incorporated.  All Rights Reserved.

*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/*===========================================================================

                        EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order.

$PVCSPath: L:/src/asw/MSM5100/CP_REL_A/vcs/caix.c_v   1.121   02 Oct 2002 22:52:22   louiel  $
$Header: //source/qcom/qct/modem/1x/cp/rel/1h08/src/caix.c#1 $ $DateTime: 2009/05/29 03:54:56 $ $Author: prabhuk $

when       who     what, where, why
--------   ---     ---------------------------------------------------------- 
03/30/09   pk      Added new information record MEID_ME parser and modified 
                   existing ESN_ME to be supported for FEATURE_HWID_SUPPORT
03/13/09   jj      Fixed discrepancy in array reference mismatch. 
12/14/07   an      Added Passport Mode
05/11/07   pg      More Lint Cleanup.
03/19/07   pg      Lint Cleanup.
03/08/07   an      Fixed Critical Lint Errors
01/30/07   sb      Changed function prototype of caix_get_message_type.
01/15/07   sb      VOIP-1X handoff updates.
11/21/06   sb      Added support for VOIP-1X handoffs.
09/29/06   fh      AKA/AES: removed the AES testing code, and eliminated the
                            AES testing featurization of 
                            FEATURE_IS2000_REL_A_AES_BS_SUPPORTS
09/29/06   fh      Added a new parameter to caix_int_to_ext to indicate whether
                   the function call is for calculating access channel message 
                   size or for parsing before transmitting the message.
09/14/06   fh      Moved AES field setting from caix.c back into mccsa.c and rxtx.c
09/13/06   fh      Moved integrity field setting back into mccsa.c and rxtx.c
09/02/06   fh      AKA/AES: Miscellaneous code review changes
08/31/06   fc      Fixed TMSI address discrepanies for parser testing.
08/31/06   an      Rel D Addendum Sync Id Feature
08/29/06   fh      AKA/AES: removed mccap_ms_supports_aes condition check for
                            parser.
08/29/06   fh      AKA/AES: cleaned up the usage of AES capability functions
08/16/06   pg      Added support for release D Packet Zone Hysteresis.
08/07/06   fc      Fixed discrepanies for parser testing.
08/01/06   fc      Removed the p_rev_in_use check for maci paring on common 
                   channel messages.
07/25/06   fc      Fixed discrepanies for parser testing.
07/25/06   fh      AKA/AES: put part of lab testing that is dependent on BS AES
                            support under a temporary feature of  
                            FEATURE_IS2000_REL_A_AES_BS_SUPPORTS
07/07/06   fh      AKA/AES: Cleaned up AES capability helper functions.
06/13/06   fh      AES change: removed TREX_DORA, not necessary, just for debugging
06/12/06   fc      Changes for UMTS.
06/12/06   fh      fixed lint error during the merge when UMTS feature is turned on
06/07/06   fh      Added Voice Service AES encryption/decryption under the features
06/01/06   fc      Cleanup umts interface.
05/24/06   fh      AKA/AES: misclaneous fixes within AKA/AES features
05/17/06   fh      Merged in new development of AKA/AES features
05/12/06   fh      Changes under AES feature: the parser function caix_int_to_ext
                   carries an extra argument to indicate whether to just
                   get the buffer length for access channel messages, or parsing
                   and AES encrypting the whole message.
04/26/06   an      Fixed Lint Errors
04/27/06   fc      Fixed Rel C featurization.
04/24/06   fc      Fixed Rel A featurization.
02/24/06   fh      Fixed the parsing error for Retry Order in traffic channel
02/21/06   fc      Fixed parser issue on r-tch SRPM and UZURM.
02/16/06   fc      Fixed parser discrepancies.
01/20/06   fc      Merged the following :
           fh      Added support for AKA and MI.
10/19/05   sb      Added support for Band Class 14, Band Subclass I, J, K.
10/17/05   sb      Added reserved bits to MC Extended Display rec.
09/22/05   an      Fixed Lint Errors
09/21/05   an      Added support for published Release D Addendum new Info Recs
09/19/05   pg      Added support for published Release D Addendum f-dsch and 
                   r-dsch message changes.
09/15/05   fc      Added support for published Release D Addendum f-csh 
                   message changes.
08/29/05   fc      Changed FEATURE_MSG_PACK_UNIT_TEST_1 to
                   FEATURE_MSG_PACK_UNIT_TEST.
08/08/05   pg      Fixed merge error.
08/04/05   pg      Added support for Rel D Addendum f-dsch and r-dsch messages.
08/01/05   an      Added support for Rel D Addendum r-csh messages, IRs and 
                   Orders.
07/25/05   fc      Added support for Rel D Addendum f-csh messages.
07/15/05   fc      Fixed lint errors.
07/12/05   ht      Added MEID Addressing support
07/08/05   sb      Merged the following from MSMSHARED:
07/05/05   sb       Added MEID support.
05/20/05   fc      Merged the following from MSMSHARED:
05/20/05   an       Added band subclass info record
05/16/05   fc      Merged the following from MSMSHARED:
05/11/05   an       Added CAI_NTL_SUP_SVC_REC to xlate_ext_tc_eawim.
05/03/05   fc      Fixed structure reference error in xlate_int_ac_rem.
03/23/05   fc      Merged the following from MSMSHARED:
03/22/05   an       Mainlined FEATURE_ENHANCED_BAND_CLASS. Eliminated
                    FEATURE_CDMA_800 and FEATURE_CDMA_1900
03/21/05   an       Mainlined IS2000 features and implemented the new
                    Dynamic Feature Design.
02/18/05   fc      Merged the following from MSMSHARED:
02/09/05   ph       When parsing PPM order from BS for >=PREV7, don't validate ORDQ range.
02/08/05   an       Mainlined IS95B features
09/28/04   fc       Fixed a merge error.
01/11/05   sb      Expanded arrays in NN-SCR so they correspond to bitmaps.
10/01/04   sb      More lint fixes.
09/30/04   sb      Fixed lint warning.
09/27/04   va      Merged following from REL B/C archive
07/21/04   sj        Added support for umts to 1x handover.
09/22/04   az      ECAM parser changes
09/16/04   sb      Added Rel C Addendum fields to BS Status Reponse Msg.
09/02/04   az      Added (add_record_len >= 2) check for retry order in
                   xlate_ext_tc_ord()
08/19/04   az      ECAM parser changes - AM5
08/18/04   fc      Removed silk incl flags on overhead messages.
08/13/04   fc      Resolved silk discrepancies on overhead messages.
08/13/04   az      Some more ECAM parser changes. Fixed Lint errors.
08/12/04   pg      Fixed a bug in Enhanced Multi-character Extended Record.
08/12/04   bkm     Added initialization of T79 in cai_tmo structure.
08/06/04   az      Few ECAM AM5 fixes.
08/04/04   sb      Fixed misc. lint errors.
08/03/04   ht      Added Rel D MEID LAC support
08/02/04   bkm     Corrected a compile error.
08/02/04   pg      Corrected some indentation issues.
07/28/04   pg      Added Enhanced Multi-character Extended Record.
07/28/04   fc      Latest Rel C addendum changes on GNLM and UNLM.
07/26/04   az      Updated ECAM Assign mode 4 with some bug fixes
07/21/04   sb      Added fix for info recs so they can handle /Zp1 flag.
07/12/04   az      Updated ECAM. Still has some problems with AM4 and AM5
07/09/04   sb      Added support for Release D orders.
07/07/04   sb      More Release D updates to info recs.
07/07/04   bkm     Lint cleanup.
07/06/04   bkm     #if 0 bits_to_pack variable.
07/06/04   sb      Made Release D updates to the info recs.
06/18/04   fc      Dword alignment fix for ECAM.
06/17/04   pg      Bug fix for a release D UHDM change. 
06/17/04   fc      Rel C addendum changes on GNLM, UNLM and ECAM.
06/17/04   bkm     Put BCMCS msgs under Rel D subfeature.
06/16/04   va      Rel C addendum changes for Reg, Orig and Orig continuation
06/14/04   fc      Release C addendum changes on common channel messages.
06/11/04   sb      Release C Addendum changes for: GHDM, ERM, RATCHGM, ITSPM.
06/09/04   sb      Release C Addendum changes for UHDM.
06/09/04   pg      Added P_REV check for all the release D fields in UHDM.
06/08/04   fc      Changes on BSPM.
06/08/04   bkm     Fixed typos in feature names within comments.
06/08/04   bkm     More lint cleanup.
06/03/04   fc      Added support for Release D common channel messages.
06/04/04   bkm     Lint cleanup.  More to go.
06/03/04   bkm     Merged the following from IS2000_REL_B_C:
  06/01/04   sb      Fixed lint errors.
  05/21/04   fc      Fixed indentation.
06/02/04   bkm     Updated GHDM parsing for Rel D.
06/02/04   pg      Bug fix for NNSCR Rel D parsing.
05/28/04   bkm     Merged the following from IS2000_REL_B_C
  03/05/04   bkm     Lint cleanup.
05/21/04   bkm     A few changes to compile with FEATURE_IS2000_REL_D undefined.
05/20/04   va      Bug fix for RRRM  and ITBSPMRM
05/19/04   az      Added support for ECAM Rel D parsing
05/14/04   va      Support for REL D access chan & rev TC messages
05/06/04   pg      Added Release D fields for UHDM.
                   Added UNPACKQ_PG macro.
04/23/04   az      Added Release D fields for 
                   Service Connect Message
                   Service Configuration Record
                   Non-Negotiable Service Configuration record
04/19/04   bkm     Added Release D fields for RATCHGM and ITBSPM.
04/16/04   bkm     Added Release D fields for CLAM, ERM, ESPM and BSSRSPM.
                   Use struct in PCNM for pz_hyst* fields.
04/13/04   bkm     Added Release D fields for ITSPM and Power Control Msg.
04/01/04   bkm     Updates for more concise cai_ext_chind enums.
02/29/04   yll     Revert back the JCDMA JTACS changes because of new JCDMA
                    requirements.
03/12/04   fc      Fixed merge error.
02/10/04   fc      Added PD validation.
02/12/04   va      Pack p_rev 7 fields in CCC IR only if p_rev_in_use
                   is 7
02/05/04   bkm     Merged the following from IS2000_REL_B.
  02/05/04   va      Merged from MSMSHARED but actual bug fixes already in here.
  01/13/04   sb      UHDM fix to get rid of SILK discrepancies for unknown ch_inds.
  01/12/04   sb      Rel C Registration Accepted Order fields only for ordq 7.
  01/12/04   sb      Maci fix for EHDM.
  01/12/04   sb      RTC Reject Order bug fixes; add Security Mode Completion Order.
  01/06/04   sb      Added Release C Order fields.
  12/19/03   sb      Added dword alignment to EAWIM/EFWIM, and fixed for loops.
01/20/04   bkm     Fixed compile warnings.
12/19/03   va      Merged following from msmshared:
 11/18/03  lh      Added dependency for qpch_code_chan on sr3_incl in MC_RR.
 11/11/03  yll     For JCDMA, the mobile shall ignore and discard the 
                   (Extended) Global Service Redirection Message that 
                   contains a JTACS or TACS record.
12/09/03   sb      Added Release C fields of UHDM and GHDM.
11/14/03   sb      Added Release C fields of Power Control Message.
11/13/03   sb      Miscellaneous Release C fixes.
11/11/03   sb      Added Release C fields of FTC Security Mode Command Msg.
11/10/03   sb      Added Release C fields of In-Traffic System Parameters Msg.
11/04/03   sb      Added Release C fields of Service Connect Message.
11/03/03   sb      Fixed len in RATCHGM and Auth Request on FTC.
10/24/03   fc      Fixed discrepancies on MC Extedned Dsplay Info Rec.
                   Fixed discrepancies on Feature Notification message.
10/22/03   va      Fixed REL_C turned off compilation errors.
10/21/03   va      Fixed misc Parser bugs
10/20/03   fc      Fixed discrepancies in band class info rec parsing.
10/17/03   fc      Fixed band class info rec size.
10/17/03   sb      Fixed bug in ERM.
10/16/03   fc      Fixed Extended Display Info Rec discrepancies. 
10/15/03   lh      Changed access_ho_allowed[i] to access_ho_allowed inside
                   the FSIZ macro.
10/15/03   fc      Fixed FTC Maintenance Order and Continuous DTMF Order.
10/15/03   fc      Fixed User Zone Reject Message and info recs.
10/09/03   fc      Fixed FTC Order message and Power Up Function Completion 
                   message.
                   Fixed AC Extended Status Response message.
10/08/03   fc      Fixed Alert With Info message, Flash With Info message
                   and Feature Notification message.
10/07/03   fc      Fixed Retrieve Paremeter message, Set Parameter message,
                   Neighbor List Update message and Analog Handoff Direction
                   message issues.
                   Changes for ECAM AM5 and  non-negotiable service configuration.
10/06/03   fc      Changes for CAM and order.
10/03/03   sb      Fixed bug in Mobile Station Registered Message.
10/03/03   fc      Fixed ECAM AM5 issues.
10/03/03   sb      Added Authentication Request Message on FTC.
10/03/03   sb      Fixed bug in Mobile Station Registered Message.
10/02/03   fc      Fixed PLCM issues.
10/01/03   fc      Fixed ECAM issues.
09/26/03   fc      Changes for f-csh data burst message, authentication
                   challenge message, SSD update message and feature
                   notification messages.
09/25/03   fc      Fixed bugs in status request message, feature notification
                   message and multi-character extended display information 
                   record translation.
09/24/03   fc      Fixed FTC encryption translation.
09/23/02   lh      Parsing IT-SPM based on P_REV coming in the message, rather
                   than based on P_REV_IN_USE.
09/23/03   fc      Fixed access channel encryption and maci translation.
                   Fixed reverse traffic channel maci translation.
                   Fixed bugs in TMSI assignment message and PACA message.
09/23/03   va      Added unsupported record_types to EOM
                   Fixed bugs in Orig and EOM
09/21/03   fc      Changes for ECAM.
09/18/03   sb      Added Rate Change Msg, Rel C fields of ERM and CLAM.
09/18/03   fc      Changes for message integrity fields parsing.
09/17/03   fc      Fixed rtc header translation.
09/17/03   va      Fixed parser bugs
09/16/03   fc      Corrected extended enryption fields parsing for RTC
                   messages.
09/15/03   fc      Changes for system parameter message.
                   Changes for ANSI-41 System Parameter message.
09/08/03   va      Changed name to for_pdch_fields in Orig & page
                   Response caii structs
09/04/03   fc      Added support for UIM_ID and ESN_ME info recs.
09/04/03   sb      Fixed compiler warning.
09/02/03   az      Featurized mcc_burst_overflow_size within
                   FEATURE_MSG_PACK_UNIT_TEST
09/02/03   fc      Fixed buffer size sanity check for extended channel 
                   assignment message.
                   Corrected the featurization for reference to 
                   mcc_burst_overflow_size. 
08/11/03   bkm     Made loop condition for record processing CAM same as ECAM,
                   adds error protection against case of len < order_pos,though
                   this should never happen.
08/08/03   fc      Added support for IS2000 Release C messages.
07/30/03   az      Added support to return overflow size for MO SDB
07/30/03   az      Added support for FEATURE_SO_8026
07/03/03   fc      Removed minimum message length check for ANSI-41 system
                   parameter message and MC-RR parameter message.
07/01/03   az      Added FEATURE_ENHANCED_BAND_CLASS
06/18/03   fc      Added support for the decoupling of FCH and DCCH MUX.
06/02/03   bkm     Lint cleanup.
04/09/03   sb      Removed featurization from alignment since SILK supports it.
03/31/03   sb      Moved cadence_type to fixed part of Para Alert info rec.
03/21/03   lh      Fixed a bug of skipping msg_pos when REL_A is not defined.
03/14/03   va      Fixed the bug in traversing recs after CCC in TC stat rsp
                   if REL_A is not defined.
02/27/03   sb      Removed unnecessary is2000_rel_a_incl from Sync Channel Message.
02/27/03   sb      Added Release B changes.
02/19/03   fc      Added Release B f-csh changes.
02/19/03   va      Added Release B changes.
02/19/03   fc      Corrected length comparsion on xlate_ext_gen_nl.
02/05/03   fc      Cleanup for f-csh forward compability.
01/31/03   bkm     Added MSG_HIGH on tranmsit of SCH errors Pwr Msg Rpt Msg.
01/14/03   sb      Removed checking for 0 frequency in CCLM.
01/03/03   sb      Only align ECAM if not in SILK.
12/12/02   sb      Added reserved field to MC-RR.
12/05/02   ph      Fixed cc_info_incl reference in UHDM parsing.
11/13/02   sb      Fixed featurization.
11/07/02   az      Removed FEATURE_IS2000_REV0_PREADDENDUM
11/07/02   az      Mainlined FEATURE_IS95B
10/31/02   va      Added support for dynamic p_rev
10/02/02   yll     Linted the code.
10/01/02   az      Mainlined FEATURE_IS2000 and FEATURE_IS2000_2_1_ADDENDUM
07/17/02   ph      fixed call wait ind rec parsing to skip the reserved field also.
06/27/02   fc      Changes for caii_univ_page_interleaved_addr_type.
06/25/02   az      Changed the name of the union for IMSI type specific
                   subfields from class to class_type.
06/18/02   yll     Added support for Base Station Status Req/Rsp Message.
06/13/02   yll     Changed the BCSMS feature name to be under Rel A CC.
06/11/02   fc      Removed num_page_recs from UPM structure.
06/10/02   sb      Removed P_PARAMS macro; changed page_pos to ext_msg_pos.
                   Changed Sync Channel Message parsing to be more efficient.
06/04/02   sb      Sync Channel Message now rejects messages with missing fields.
05/28/02   fc      Changes to match UPM interleaved address structure with
                   message pack unit test.
05/22/02   fc      Changes for message pack unit test.
                   Fixed length comparsion on xlate_ext_e_cl().
                   Fixed translation for Universal Page Message.
05/20/02   fc      Added support for Universal Page Message.
05/06/02   yll     Removed FEATURE_IS2000_REL_A_BCSMS for correct message
                   parsing.
04/16/02   va      Fixed emergency record packing for EFWIM.
04/12/02   lh      Added support for subaddress in Orig_C.
04/09/02   yll     Added Broadcast SMS support on IS2000 RelA common channel.
03/25/02   ph      Initialized cc_info_incl for REL_A
03/25/02   fc      Removed obsolete messages processing in xlate_ext_fccch_msg.
03/24/02   sb      Include ba_parms_len and ra_parms_len in caii_en_ac_parm_type.
03/08/02   sb      Updated CAM, ESP, ECAM, Ansi-41, MC-RR, EAPM and SMCM to be in
                   sync with Addendum 2 published version.
03/12/02   lh      Added CMEA support for release A messages.
03/06/02   sb      Fixed macro calls for ACCT fields in EAPM
03/04/02   ph      Updated with changes to SCM format to sync up with Add 2 pub version.
                   Also, fixed bug in filling reserved fields for Global Emer Rec
                   in FWIM and EFWIM.
03/04/02   sb      Removed +1's in xlate_ext_bcch_msg function calls (merge error)
02/06/02   lh      Fixed NNSCR.
02/22/02   fc      Added support for Release A common channels.
02/15/02   sb      qpch_power_level_config in MC-RR is now parsed conditionally
02/11/02   va      Fixed Global Emer record packing
02/08/02   lh      Fixed FTC messages blindly return CAIX_DONE_S.
02/07/02   lh      Changed some info rec in RTC msg from byte arry to dword array.
01/24/02   ph      Fixed packing of QOS record in outgoing TC msgs (EOM for now)
01/04/02   sb      Check p_rev only in SILK (ECCLM)
12/06/01   lh      Merged from MSM_CP.05.108.
  11/30/01   hxw     Added FEATURE_GPSONE_NEW_L2_ACK to support delay L2 Ack
                     mechanism.
  11/13/01   ph      In xlate_int_orig(), filled reserved field with '0' before
                     packing rev_fch_gating_req.
11/27/01   va      Merged from MSM_CP.05.100.01.00
  10/17/01 lcc     When sending release order on access channel, do not include
                   ORDQ if it is 0.
11/12/01   sb      Replaced length check in ECCLM with p_rev check (for Release A fields)
10/15/01   kk      Fixed compiler errors when Release A is not defined.
10/12/01   sb      Replaced probe_pn_ran in EAPM with reserved field, fixed spelling error
10/03/01   ph      fixed dword-alignment problem for Access STRSP and DIM.
10/02/01   ph      Merged in from CP VU 96
                   09/17/01   ht      Added a check for null freq in Channel List Message.
                   09/14/01   lcc     Added dword alignment in between translation of each record
                                      in ECAM to make sure that each record starts from a dword
                                      aligned address.
                   08/21/01   sj      Changed rs1_20ms_incl -> rc3_rc5_20ms_incl(Power Control
                                      Msg), rs2_20ms_incl ->rc4_rc6_20ms_incl(Power Control Msg)
                                      & num_visits -> max_num_visits(Candidate Frequency Search
                                      Response message).
09/28/01   kk      Added missing position location indicator to Flash msg.
09/10/01   lh      Taking out CC fields from GHDM.
09/06/01   sb      Replaced length fields in xlate_en_ac_parm with local vars.
08/23/01   ph      Fixed typo-bug in nnscr processing
08/20/01   lh      Paging channel fixes.
08/16/01   ph      Rel A Addendum 2 changes for the FTC
08/16/01   lh      Addendum 2 Changes for F-CSCH and R-CSCH.
08/15/01   kk      Addendum 2 Changes on Reverse Traffic Channel Added.
06/26/01   kk      Added missing field in EOM.
06/26/01   kk      Merge from main archive
  06/15/01 lcc     In xlate_ext_ho_msg, allows extra field to be included at
                   the end of the message.
  06/15/01 lcc     Added FEATURE_IS2000 around align_timing in CFSCM.
  06/14/01 lcc     Corrected Candidate Frequency Search Control Message and
                   Channel Configuration Capability Information Record to be
                   Rel. 0 Addendum 2 compliant.
05/29/01   kk      Fixed Resource Release msg.
05/22/01   ph      some fixes to FTC messages.
05/16/01   lh      Merged following changes from common archive.
  05/11/01   jq      Added length field in ERRM/RRM sending.
  05/03/01   lh      No logical changes, just added some more parenthesis in
                     ALIGN_DWORD macro calls, and type casting.
  05/02/01   fc      Added support of T_ADD_ABORT.
  05/02/01   lh      Fixed possible mis-alignment for FWD and REV info records.
  04/10/01   jq      Added msg process related to DCCH and contorl hold support.
05/07/01   ph      Fix con_ref so it is not extracted for lock_or_maint order
04/26/01   lh      Clean up Band Class Info Rec.
04/18/01   lh      Fixes in RTC Status Rsp Msg.
04/18/01   ph      some fixes to Ext Disp, changes to sync up "cadence_type" for testing.
04/17/01   lh      Changes for unit testing.
04/12/01   ph/kk   support for new power control fields, other fixes for FTC msgs.
04/09/01   lh      Added capability info rec.
04/09/01   ph      FTC uhdm/ghdm fixes.
03/27/01   lh      PCH and ACH fixes.
03/27/01   kk      Fixed warnings in various functions
03/26/01   kk      supplemental channel request message fixes.
03/22/01   ph      FTC and RTC fixes in the parser
03/14/01   kk      Order fixes
03/13/01   ph      Fixes related to FTC msgs
03/12/01   lh      UNLM optimization.
03/09/01   lh      Fixed compilation problem when FEATURE_IS2000_REL_A is off.
03/08/01   kk      Reverse traffic fixes.
03/07/01   lh      Release A PCH/ACH bug fixes.
03/06/01   kk      Various fixes, removal of pre rel 0 flags.
03/06/01   ph      Fixes of bugs found during parser test mostly related
                   to For traffic channel msgs of Rel A.
03/01/01   kk      Maerged changes from the mainline.
02/01/01   cah     Correct merge problem in xlate_int_page_resp().
01/24/01   ych     Merged T53 and JCDMA features.
01/02/01   lcc     Added 6 reserved bits in F/R SCH type specifics fields for BRV
                   which were missed before.
02/20/02   lh      Bug fixes.
02/09/01   lh      QOS support in Orig added for unit test.
02/02/01   lh      Bug fix in sync msg.
12/21/00   kk/lh   Added IS-2000 Release A support.
10/02/00   yll     Removed the packing of MSID type. MSID packing was moved
                   to PDSM.
08/31/00   lcc     Added reserved bits in nn-SCR for BRV version of CDMA 2000.
                   Also removed some lint warnings.
08/18/00   fc      Changed F3 PMRM message to use decimal system to indicate
                   FCH and/or SCH frame statistics.
08/03/00   fc      Added #ifdef FEATURE_IS2000 around F3 PMRM message which
                   indicates SCH statistics.
08/03/00   fc      Modified xlate_int_tc_msg() to clarify F3 PMRM message to
                   indicate FCH and SCH frame statitics.
07/06/00   yll     Added packing the MSID to be used by PDSM IS801 services.

07/06/00   yll     Added packing the MSID to be used by PDSM IS801 services.
07/06/00   jq      Added parser for ECCLM and EGSRM. Modified CFS_RSP and GSRM
                   parsing for addendum compliance.
06/19/00   jrw     1. Corrected a problem with power control message where the
                   init_setpt shouldn't have been included with the SCH set points.
                   2. Added checking for P_REV before parsing the new fields in PMRM.
06/16/00   ks      Removed the ifdef FEATURE_IS2000_REV0_PREADDENDUM checking
                   for flash record tyhpe CAI_FEAT_REC in xlate_int_flash()
06/12/00   ks      Added support for align_timing field in CFSRQM message.
06/02/00   jrw     Changes to support IS2000 Rev 0 published addendum.
05/25/00   ks      Added support for Neighbor Search Window offsets in
                   Candidate Frequency Search Request Message.
04/24/00   jrw     Added ESCAM, outer loop report message, and changes to PMRM.
03/30/00   ry      Added a check back to xlate_ext_srv_cfg() that was removed
                   during the previous merge, and featurized the check under
                   #ifndef FEATURE_IS2000
03/28/00   ry      Fixed compiler warning for Pink Panther build
03/23/00   va      Added back support for FEAT_REC_TYPE
                   Info records alogned at dword boundaries in caii_acstrsp_type
03/07/00   ry      Added IS2000 featurization
           ry      Replaced FEATURE_SILK with FEATURE_MSG_PACK_UNIT_TEST
02/24/00   jrw     Fixed access channel bug (layer 2 length field)
02/15/00   jrw     Added IS2000 check for new fields in Service Config Rec
02/11/00   jrw     Added support for IS2000 Addendum
12/17/99   jrw     Added support for IS2000 Phase 1.
10/18/99   kk      Added an extra sanity check for Service Redirection message
                   processing.
08/09/99   ry      Initialize pre_proc_done to FALSE in xlate_ext_tc_cfs_req()
                   and xlate_ext_tc_cfs_ctrl() for action time processing
06/30/99   kmp     in the cai_tmo enum correctly made the FEATURE definition
                   FEATURE_IS95B instead of FEATURE_ACCESS_HO.
06/17/99   kmp     Added T72m and N13m to cai_tmo if certain IS-95B features
                   are defined.
06/02/99   kmp     Merged the 2 changes below into the ASW archive.
           lh      Support release order on access channel, name change
                   from reserve to auth_mode.
           lh      Updated for Published version of IS-95B.
05/19/99   doj     Consolidated the parsers for HDM, EHDM and GHDM into one
                   generic handoff message parser.  Added macros UNPACKB_PG,
                   UNPACKW_PG, UNPACKB_PG_DRF, UNPACKW_PG_DRF.
02/13/99   doj     Added support for General Handoff Direction Message (GHDM).
                   Also includes several misc. updates by many people to
                   support FEATURE_SPECIAL_MDR.
01/18/99   ram     Added redirect_type field for SERVICE REDIRECTION Message
                   as part of IS95B MDR changes.
01/16/99   ram     Merged in the changes for IS95B MDR from MDR branch.
01/07/99   lh      Not include tmsi.h if FEATURE_TMSI is not defined.
01/06/99   lh      Extended Status Response and Status Response now share the
                   same internal formats.
01/06/99   lh      FEATURE_JSTD008 replaced with run-time P_REV and Band
                   Class checking.
12/23/98   lh      Modified ECAM. Now parser will parse the ECAM and pass the
                   caller a packed internal format.
11/24/98   lh      Added comments.
10/29/98   jcw     Modify parsing of 95B extended display records to support
                   new structure fields needed by MC
10/12/98   lh      Change soft_slop to soft_slope in ESPM processing.
10/05/98   jcw     Parsing of extended display record has been updated to
                   not treat blank & skip subrecords specially.
09/15/98   lh      IS-95B support.
08/12/98   lh      IS-95B WLL support added.
01/15/98   lh      Added IS-95B Line Control info record parsing.
01/14/98   dna     Add support for Korean PCS in Band Class Status Response
04/18/97   dna     Changed some #ifdefs to make class 1 IMSI its own feature
12/13/96   jca     Processing new fields in Channel Assignment Message
                   where the ASSIGN_MODE is set to '010'.
09/03/96   dna     Fixed unpack of nom_pwr_ext field in access params.
06/28/96   dna     Created xlate_ext_tc_hdr and xlate_int_tc_hdr functions.
05/30/96   dna     #ifdef JSTD_008 class 1 IMSI packing for access channel.
05/28/96   dna     Added Class 1 IMSI support for Access Channel messages.
04/09/96   day     Added TMSI addressing modifications.  Using T_TMSI ifdef.
03/13/96   day     Added J-STD-008 PCS message modifications.  Using FEATURE_JSTD008
                   ifdef.
10/10/95   jca     Fixed specific bug where IS95 formatted Analog Handoff
                   Direction Message was being dropped and in general made
                   code more robust to future message modifications.
10/03/95   dna     Fixed 2 bugs in xlate_ext_ext_ho_dir.
09/18/95   jca     Fixed bug in parsing Service Option Control messages.
08/28/95   rdb     Fixed processing of type 2 qualification info in
                   xlate_ext_pc_streq.
08/24/95   rdb     Added translation function for information records that
                   was inadvertently omitted.
08/22/95   gb      Fixed NLU message processing.
08/22/95   dna     Modified Sync Channel Message unpacking for new field
08/18/95   dna     Added assign mode '101' EXT_PAGING_CHAN_ASSIGN
08/10/95   rdb     Added translation routines for Status Request and Status
                   Response Messages, and for new information records
                   introduced in the IS-95-A TSB.
08/09/95   jca     Added General Page Message.  Added new Paging and Access
                   Channel address types including support for IMSI addresses.
08/03/95   dna     Added support for message encryption.
07/27/95   gb      Fixed a field in Extended Handoff Direction Message.
07/20/95   gb      Added Extended Handoff Direction Message.
07/13/95   rdb     Added support for service negotiation messages and
                   for assign mode 4 of chan assign message.
06/25/95   dy      Added Data Burst SMS message validation checks.
05/12/94   gb      Added F3 screen messages for every TC message.
04/25/94   gb      Parameterised all IS95 timeouts in cai_tmo.
04/21/94   jca     Fixed spec bug in Parameters Response Message.
12/22/93   jca     Switched to IS-95 message formats.
01/23/91   jai     Created module.

===========================================================================*/

/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/

#include "comdef.h"
#include "qw.h"
#include "cai.h"
#include "caii.h"
#include "caix.h"
#include "bit.h"
#include "msg.h"
#include "target.h"
#include "customer.h"
#ifdef FEATURE_AUTH
#include "auth.h"
#endif /* FEATURE_AUTH */
#include "tmsi.h"
#ifndef FEATURE_MSG_PACK_UNIT_TEST
#include "mc.h"

#if defined(FEATURE_IS2000_REL_A_CC) || defined(FEATURE_IS2000_REL_A_AES)
#include "mccdma.h"
#endif /* FEATURE_IS2000_REL_A_CC  || FEATURE_IS2000_REL_A_AES */

#endif /* !FEATURE_MSG_PACK_UNIT_TEST */
#include "err.h"

#if defined(FEATURE_IS2000_REL_A_AES) || defined(FEATURE_IS2000_REL_C_AKA)
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES || FEATURE_IS2000_REL_C_AKA */

/*===========================================================================

                DEFINITIONS AND DECLARATIONS FOR MODULE

This section contains definitions for constants, macros, types, variables
and other items needed by this module.

===========================================================================*/
#if defined(FEATURE_IS2000_REL_C_AKA) || defined(FEATURE_IS2000_REL_A_AES)
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA || FEATURE_IS2000_REL_A_AES */

byte caix_p_rev_in_use;

void caix_set_p_rev_in_use(byte p_rev_in_use)
{
  caix_p_rev_in_use = p_rev_in_use;
}

#define AC_L2_LENGTH_NUM_BITS 5
word ac_l2_length_pos = 0;
word ac_l2_start_pos = 0;
word ac_l2_num_bits = 0;
word ac_l2_num_bytes = 0;
word ac_l2_num_reserved = 0;
word ac_plt_rpt_len = 0;

word xlate_int_plt_rpt
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  word buffer_offset,
    /* offset into buffer to start placing the message */
  caii_plt_rpt_type *int_ptr
    /* Pointer to internal message to be transmitted */
);

word global_buf_pos = 0;

/* Structure to hold all IS95 timeout values that may be changed for
 * debug purposes.
 */

cai_tmo_type cai_tmo =
{
  CAI_T1M,
  CAI_T2M,
  CAI_T3M,
  CAI_T4M,
  CAI_T5M,
  CAI_T20M,
  CAI_T21M,
  CAI_T30M,
  CAI_T31M,
  CAI_T40M,
  CAI_T41M,
  CAI_T42M,
  CAI_T50M,
  CAI_T51M,
  CAI_T52M,
  CAI_T53M,
  CAI_T55M,
  CAI_T57M,
  CAI_T69M,
  CAI_T72M,
  CAI_T75M,
  CAI_T79M,
  CAI_N1M,
  CAI_N2M,
  CAI_N3M,
  CAI_N5M,
  CAI_N6M,
  CAI_N7M,
  CAI_N8M,
  CAI_N9M,
  CAI_N10M,
  CAI_N11M
 ,CAI_N13M
};


/*-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/
/*                       MACROS                                            */
/*-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/
/* Suppress the following lint messages:
   e413: Likely use of null pointer in left argument to operator '->',
         which is heavily used in FPOS and FSIZ macros.
   e734:
   e713: Loss of precision (assignment).
   e737: Loss of sign in promotion from int to unsigned int.
   e715: Not referenced
   e573: Signed-unsigned mix with divide
   e574:
   e740: Unusual pointer cast (incompatible indirect types)
   e641: Converting enum to int
   e826: Suspicious Pointer to Pointer Conversion
   e834: Operator '-' followed by operator -
   e818: Pointer constant
  */

/*lint -e413 -e734 -e713 -e737 -e715 -e573 -e574 -e740 -e641 -e834 -e818 -e826 */

/* Macro to build parameters for use in b_unpack and b_pack routines while
   packing and unpacking messages other than Paging Channel orders */
#define PARAMS( field ) \
  buf_ptr, FPOS( MTYPE, field ), FSIZ( MTYPE, field )

/* Macro to compute the offset, in bytes, of the end of a specified field
   of a specified structure type */
#define FENDPOS( type, field ) \
  (FPOS( type, field ) + FSIZ( type, field ))

/* Macro to build parameters for packing and unpacking
   information record headers. */
#define  REC_P( field ) \
  buf_ptr, buf_pos + FPOS( cai_rec_hdr_type, field ), \
  FSIZ( cai_rec_hdr_type, field )

/* Macro to build parameters for packing and unpacking
   service configuration header records. */
#define  HDR_P( field ) \
  buf_ptr, buf_pos + FPOS( cai_srv_cfg_hdr_type, field ), \
  FSIZ( cai_srv_cfg_hdr_type, field )

/* Macro to build parameters for packing and unpacking
   service configuration connection records. */
#define  CON_P( field ) \
  buf_ptr, buf_pos + FPOS( cai_srv_cfg_con_type, field ), \
  FSIZ( cai_srv_cfg_con_type, field )

/* Macro to unpack a byte and advance the
   page position */
#define UNPACKB_PG(ext, type, field)                                \
  int_ptr->ext = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(type, field));   \
  ext_msg_pos += FSIZ(type, field)

/* Macro to unpack a word and advance the
   page position */
#define UNPACKW_PG(ext, type, field)                                \
  int_ptr->ext = b_unpackw(buf_ptr, ext_msg_pos, FSIZ(type, field));   \
  ext_msg_pos += FSIZ(type, field)


/* Macro to unpack a dword and advance to
   page position */
#define UNPACKD_PG(ext, type, field)                                \
  int_ptr->ext = b_unpackd(buf_ptr, ext_msg_pos, FSIZ(type, field));   \
  ext_msg_pos += FSIZ(type, field)

/* Macro to unpack a qword and advance to
   page position */
#define UNPACKQ_PG(ext, type, field)                                \
  b_unpackq(buf_ptr, ext_msg_pos, FSIZ(type, field), int_ptr->ext);   \
  ext_msg_pos += FSIZ(type, field)

#define UNPACK_MSG_TYPE(dest, msg_type)                             \
  dest = msg_type & 0x3F;

#define UNPACK_PD(dest, msg_type)                                         \
  dest = ( (msg_type & 0xC0) >> 6 ) & 0x03;


/* Macro to unpack a byte and advance the dereferenced
   page position pointer */
#define UNPACKB_PG_DRF(ext, type, field)                            \
  int_ptr->ext = b_unpackb(buf_ptr, *ext_msg_pos, FSIZ(type, field));  \
  *ext_msg_pos += FSIZ(type, field)

/* Macro to unpack a word and advance the dereferenced
   page position pointer */
#define UNPACKW_PG_DRF(ext, type, field)                            \
  int_ptr->ext = b_unpackw(buf_ptr, *ext_msg_pos, FSIZ(type, field));  \
  *ext_msg_pos += FSIZ(type, field)

void xlate_int_non_neg_srv_cfg
(
  byte *buf_ptr,
    /* Pointer to message buffer which is to contain translated
       service configuration record. */

  word *buf_pos,
    /* Offset in message buffer at which to start non-neg service
       configuration record. */

  caii_non_neg_srv_cfg_type *i_ptr
    /* Pointer to internal non_neg service configuration record to be
       translated */
);

#ifdef FEATURE_IS2000_REL_C
#define CAIX_MACI_REQUIRED     TRUE
#define CAIX_MACI_NOT_REQUIRED FALSE

/*===========================================================================

FUNCTION xlate_ext_mi_and_validate_maci

DESCRIPTION
  This function translates the message integrity fields 
  from external to internal format and validates MACI.

DEPENDENCIES
  None

RETURN VALUE
  CAIX_DONE_S - if everything is good.
  
SIDE EFFECTS
  buf_pos updated.

===========================================================================*/

word xlate_ext_mi_and_validate_maci
(
  word len,
    /* Length of message */
  word chn,
    /* Physical Channel this message is received on */
  byte pd,
    /* Protocol discriminator */
  boolean maci_expected,
    /* Indicates if MACI field is expected */
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_msg_int_type *int_ptr,
    /* Pointer to place translated message integrity fields */
  byte msg_type,
    /* Message type */  
  boolean ack_req
    /* Whether this message requires an Ack to be sent back or not */
)
{
  word status = CAIX_DONE_S;
  word maci_pos;

  #ifndef FEATURE_MSG_PACK_UNIT_TEST
  MSG_LOW("fwd link msg - chan %d, pd %d, prev %d", chn, pd, caix_p_rev_in_use);
  #endif /* !FEATURE_MSG_PACK_UNIT_TEST */

  /* No Message Integrity for messages on BCCH */
  if (chn == CAIX_BCCH)
  {
    return status;
  }

  /* PD == 2 implies Message Integrity fields are included */
  if ( ( ( chn == CAIX_FCCCH ) || ( chn == CAIX_PC ) ) &&
       ( pd != 2 )
     )
  {
    return status;
  }

  /* If the message is received on traffic channel and prev < 9 */
  if ( (chn == CAIX_TC) && (caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C) )
  {
    return status;
  }

  /* Unpack Message Integrity fields. */
  #define FTYPE cai_msg_int_type

  int_ptr->maci_incl = b_unpackb(buf_ptr, *pos_ptr, FSIZ(FTYPE, maci_incl));
  *pos_ptr += FSIZ(FTYPE, maci_incl);

  if (int_ptr->maci_incl)
  {
    int_ptr->randc = b_unpackb(buf_ptr, *pos_ptr, FSIZ(FTYPE, randc));
    *pos_ptr += FSIZ(FTYPE, randc);

    int_ptr->sdu_key_id = b_unpackb(buf_ptr, *pos_ptr,
      FSIZ(FTYPE, sdu_key_id));
    *pos_ptr += FSIZ(FTYPE, sdu_key_id);

    int_ptr->sdu_integrity_algo = b_unpackb(buf_ptr, *pos_ptr,
      FSIZ(FTYPE, sdu_integrity_algo));
    *pos_ptr += FSIZ(FTYPE, sdu_integrity_algo);

    int_ptr->sdu_sseq_or_sseqh = b_unpackb(buf_ptr, *pos_ptr,
      FSIZ(FTYPE, sdu_sseq_or_sseqh));
    *pos_ptr += FSIZ(FTYPE, sdu_sseq_or_sseqh);

    if (!int_ptr->sdu_sseq_or_sseqh)
    {
      /* 8 bit SSEQ is supplied by the BS */
      int_ptr->sdu_sseq = b_unpackb(buf_ptr, *pos_ptr,
        FSIZ(FTYPE, sdu_sseq));
      *pos_ptr += FSIZ(FTYPE, sdu_sseq);
    }
    else
    {
      /* 24 bit SSEQ is supplied by the BS */
      int_ptr->sdu_sseq_h = b_unpackd(buf_ptr, *pos_ptr,
        FSIZ(FTYPE, sdu_sseq_h));
      *pos_ptr += FSIZ(FTYPE, sdu_sseq_h);
    }

    /* ECAM is a special case since it can have multiple records and 
       MACI is at the end of each record instead of just being at the end..

       For ECAM, the record addressed to this mobile has to be extracted.
       8 bit msg_type field (2 bits PD + 6 bits msg id) has to be appended
       at the start of this record. This constructed bit stream 
       (8 bit msg_type + mobile addressed record) is then fed to EHMACSHA 
       algorithm.
    */
    if ( ( (chn != CAIX_PC) && ( chn != CAIX_FCCCH ) ) ||
         ( msg_type != CAI_EXT_CHN_ASN_MSG ) )
    {
      /* Parse the MACI field itself */
      maci_pos = len - FSIZ(FTYPE, maci);
      int_ptr->maci = b_unpackd(buf_ptr, maci_pos, FSIZ(FTYPE, maci));
    }
  } /* if (int_ptr->maci_incl) */
  
  #undef FTYPE


 #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
  #endif /* FEATURE_IS2000_REL_C_MI */
  
  return status;

} /* xlate_ext_mi_and_validate_maci */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
 
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*===========================================================================

FUNCTION xlate_ext_ext_enc_tc

DESCRIPTION
  This function translates a Traffic Channel Message Extended Encryption
  fields from external to internal format.

DEPENDENCIES
  The decryption function is defined in AUTH module.

RETURN VALUE
  CAIX_DONE_S - if everything is good.
  CAIX_INV_MSG_S - if anything wrong.
  CAIX_INV_ENC_MODE_NOT_SUP_S - if encryption is not supported.

SIDE EFFECTS
  buf_pos updated. Extended encryption fields are put into the internal format
  just to preserve them. The message may be translated from crypto text into
  plain text.

===========================================================================*/

word xlate_ext_ext_enc_tc
(
  word *len_ptr,
    /* Pointer to Length of message, used by encryption*/
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_tc_hdr_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  uint8 msg_type,
  uint8 order,
  uint8 ordq
)
{
  word status = CAIX_DONE_S;

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  /* at this point the hdr.encryption is already filled
     by XLATE_EXT_TC_HDR function call */

  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    if (int_ptr->encryption == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
    {
      int_ptr->sdu_encrypt_mode = b_unpackb(buf_ptr, *pos_ptr,
        FSIZ( cai_tc_hdr_ext_enc_type, sdu_encrypt_mode));
      *pos_ptr += FSIZ(cai_tc_hdr_ext_enc_type, sdu_encrypt_mode);

      if (((int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
           (int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_REA))
#ifdef FEATURE_IS2000_REL_C
          && ((caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C) ||
              !int_ptr->msg_int.maci_incl)
#endif /* FEATURE_IS2000_REL_C */
         )
      {
        int_ptr->enc_seq = b_unpackb( buf_ptr, *pos_ptr,
          FSIZ( cai_tc_hdr_ext_enc_type, enc_seq ));
        *pos_ptr += FSIZ( cai_tc_hdr_ext_enc_type, enc_seq );
      }

#ifndef FEATURE_MSG_PACK_UNIT_TEST
      #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
      #endif /* FEATURE_IS2000_REL_A_AES */
#endif /* ! FEATURE_MSG_PACK_UNIT_TEST */
    } /* enc_fields_incl */
#ifndef FEATURE_MSG_PACK_UNIT_TEST
    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #else
    if ( ( int_ptr->encryption == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG ) &&
         ( int_ptr->sdu_encrypt_mode != CAI_ENC_MODE_DISABLED )
       )
    {
      return CAIX_INV_ENC_MODE_NOT_SUP_S;
    }
    #endif /* FEATURE_IS2000_REL_A_AES */
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */
  } /* P_REV >= 7 */

  return status;

} /* xlate_ext_ext_enc_tc() */
#endif /* FEATURE_IS2000_REL_A  */

/*===========================================================================

FUNCTION XLATE_EXT_TC_HDR

DESCRIPTION
  This function translates a Traffic Channel Message header from external to
  internal format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

void xlate_ext_tc_hdr
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_tc_hdr_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
    int_ptr->ack_seq = b_unpackb( buf_ptr,
                                  (word)FPOS( cai_gen_tc_type, hdr.ack_seq ),
                                  FSIZ( cai_gen_tc_type, hdr.ack_seq ));
    int_ptr->msg_seq = b_unpackb( buf_ptr,
                                  (word)FPOS( cai_gen_tc_type, hdr.msg_seq ),
                                  FSIZ( cai_gen_tc_type, hdr.msg_seq ));
    int_ptr->ack_req = b_unpackb( buf_ptr,
                                  (word)FPOS( cai_gen_tc_type, hdr.ack_req ),
                                  FSIZ( cai_gen_tc_type, hdr.ack_req ));
    int_ptr->encryption = b_unpackb( buf_ptr,
                                (word)FPOS( cai_gen_tc_type, hdr.encryption ),
                                     FSIZ( cai_gen_tc_type, hdr.encryption ));
} /* xlate_ext_tc_hdr() */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*===========================================================================

FUNCTION XLATE_EXT_TC_ORD

DESCRIPTION
  This function translates a Traffic Channel Order Message from external to
  internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Order message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_ord
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word add_record_len;
    /* Used to store additional record length */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_ftc_gen_ord_type )
#ifdef FEATURE_IS2000_REL_A
            - FSIZ(cai_ftc_gen_ord_type, con_ref_incl)
            - FSIZ(cai_ftc_gen_ord_type, con_ref)
#endif /* FEATURE_IS2000_REL_A */
     )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    #define FTYPE cai_ftc_ord_type

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_ord.gen.hdr);

    /* Initialize msg_pos */
    msg_pos = FENDPOS(FTYPE, gen.hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(
                                len,
                                CAIX_TC, 
                                0, 
                                CAIX_MACI_REQUIRED, 
                                &msg_pos, 
                                buf_ptr, 
                                &int_ptr->tc_ord.gen.hdr.msg_int,
                                int_ptr->tc_ord.gen.msg_type,
                                int_ptr->tc_ord.gen.hdr.ack_req                                                                
                                )) == CAIX_DONE_S)

#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
           &int_ptr->tc_ord.gen.hdr,
           int_ptr->tc_ord.gen.msg_type,
           int_ptr->tc_ord.gen.order,
           int_ptr->tc_ord.ordq.ordq
          )
         ) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {

        int_ptr->tc_ord.gen.use_time = b_unpackb(buf_ptr, msg_pos,
          FSIZ(FTYPE, gen.use_time));
        msg_pos += FSIZ(FTYPE, gen.use_time);

        int_ptr->tc_ord.gen.action_time = b_unpackb(buf_ptr, msg_pos,
          FSIZ(FTYPE, gen.action_time));
        msg_pos += FSIZ(FTYPE, gen.action_time);

        int_ptr->tc_ord.gen.order = b_unpackb(buf_ptr, msg_pos,
          FSIZ(FTYPE, gen.order));
        msg_pos += FSIZ(FTYPE, gen.order);

        add_record_len = b_unpackb(buf_ptr, msg_pos,
          FSIZ(FTYPE, gen.add_record_len));
        msg_pos += FSIZ(FTYPE, gen.add_record_len);

        if (add_record_len > 0)
        {
          word start_msg_pos = msg_pos;

          /* parse the order related info */
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

          int_ptr->tc_ord.ordq.ordq = b_unpackb(buf_ptr, start_msg_pos,
            FSIZ(FTYPE, ordq.ordq));
          start_msg_pos += FSIZ(FTYPE, ordq.ordq);

          switch (int_ptr->tc_ord.gen.order)
          {
            case CAI_BS_CHAL_CONF_ORD:
              if (add_record_len >= 4)
              {
                int_ptr->tc_ord.chal.authbs =
                  b_unpackd( buf_ptr, start_msg_pos, FSIZ(FTYPE, chal.authbs));
                start_msg_pos += FSIZ(FTYPE, chal.authbs);

              }
              break;

            case CAI_SO_REQ_ORD:
              if (add_record_len >= 3)
              {
                int_ptr->tc_ord.so_req.service_option = b_unpackw(buf_ptr, 
                  start_msg_pos, FSIZ(FTYPE, so_req.service_option));
                start_msg_pos += FSIZ(FTYPE, so_req.service_option);
              }
              break;

            case CAI_SO_RESP_ORD:
              if (add_record_len >= 3)
              {
                int_ptr->tc_ord.so_res.service_option = b_unpackw(buf_ptr, 
                  start_msg_pos, FSIZ(FTYPE, so_res.service_option));
                start_msg_pos += FSIZ(FTYPE, so_res.service_option);
              }
              break;

            case CAI_PILOT_MEASURE_ORD:
              if ((add_record_len >= 3)
#ifndef FEATURE_MSG_PACK_UNIT_TEST /* ordq range validation only for <= PREV 6 */
                  && ( (int_ptr->tc_ord.ordq.ordq >= CAI_VAL_RPT_PER) ||
                       (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
                     )
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */
                 )
              {
                int_ptr->tc_ord.ppm.min_pilot_pwr_thresh = b_unpackw(buf_ptr,
                  start_msg_pos, FSIZ(FTYPE, ppm.min_pilot_pwr_thresh));
                start_msg_pos += FSIZ(FTYPE, ppm.min_pilot_pwr_thresh);

                int_ptr->tc_ord.ppm.min_pilot_ec_io_thresh = b_unpackw(buf_ptr,
                  start_msg_pos, FSIZ(FTYPE, ppm.min_pilot_ec_io_thresh));
                start_msg_pos += FSIZ(FTYPE, ppm.min_pilot_ec_io_thresh);

#ifdef FEATURE_IS2000_REL_A
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
                {
                  int_ptr->tc_ord.ppm.incl_setpt = b_unpackw(buf_ptr,
                    start_msg_pos, FSIZ(FTYPE, ppm.incl_setpt));
                  start_msg_pos += FSIZ(FTYPE, ppm.incl_setpt);
                }
#endif /* FEATURE_IS2000_REL_A */

              }
              break;

            case CAI_RETRY_ORD:
              if (add_record_len >= 2)
              {
                int_ptr->tc_ord.retry.retry_type = b_unpackb(buf_ptr, 
                  start_msg_pos, FSIZ(FTYPE, retry.retry_type));
                start_msg_pos += FSIZ(FTYPE, retry.retry_type);

                if (int_ptr->tc_ord.retry.retry_type)
                {
                  int_ptr->tc_ord.retry.retry_delay = b_unpackb(buf_ptr, 
                    start_msg_pos, FSIZ(FTYPE, retry.retry_delay));
                  start_msg_pos += FSIZ(FTYPE, retry.retry_delay);
                }

              }
              else
              {
                status = CAIX_INV_LEN_S;
              }
              break;

#ifdef FEATURE_IS2000_REL_A
            case CAI_BS_REJ_ORD:
              /* -------------------------------------------------------
              ** Prior to Release C, there were no additional fields, so
              ** there's no need to do anything.
              ** ------------------------------------------------------- */
  #ifdef FEATURE_IS2000_REL_C
              if (int_ptr->tc_ord.ordq.ordq == CAI_BS_REJ_ORDER_MSG_NOT_ACCEPTED)
              {
                int_ptr->tc_ord.bsrej.reject_reason =
                b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, bs_rej.reject_reason));
                start_msg_pos += FSIZ(FTYPE, bs_rej.reject_reason);

                int_ptr->tc_ord.bsrej.rejected_msg_type =
                b_unpackb(buf_ptr, start_msg_pos,
                          FSIZ(FTYPE, bs_rej.rejected_msg_type));
                start_msg_pos += FSIZ(FTYPE, bs_rej.rejected_msg_type);

                int_ptr->tc_ord.bsrej.rejected_msg_seq =
                b_unpackb(buf_ptr, start_msg_pos,
                          FSIZ(FTYPE, bs_rej.rejected_msg_seq));
                start_msg_pos += FSIZ(FTYPE, bs_rej.rejected_msg_seq);
              }
  #endif /* FEATURE_IS2000_REL_C */
              break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

           default:
              /* -------------------------------------------------------
              ** Must be an order which only requires an order qualifier
              ** ------------------------------------------------------- */
              break;

          } /* end switch */

          msg_pos += add_record_len * 8; 

        } /* end if (add_record_len > 0) */

#ifdef FEATURE_IS2000_REL_A
        if ((int_ptr->tc_ord.gen.order == CAI_DTMF_ORD) ||
            (int_ptr->tc_ord.gen.order == CAI_MAINT_ORD))
        {
          int_ptr->tc_ord.ordq.con_ref_incl = b_unpackb(buf_ptr, msg_pos,
            FSIZ(FTYPE, ordq.con_ref_incl));
          msg_pos += FSIZ(FTYPE, ordq.con_ref_incl);

          if (int_ptr->tc_ord.ordq.con_ref_incl)
          {
            int_ptr->tc_ord.ordq.con_ref = b_unpackb(buf_ptr, msg_pos,
              FSIZ(FTYPE, ordq.con_ref));
            msg_pos += FSIZ(FTYPE, ordq.con_ref);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

      } /* decryption successful */
    }  /* MI Validation successful */

    #undef FTYPE

  } /* end if length is ok */

  return (status);

} /* xlate_ext_tc_ord */

/*===========================================================================

FUNCTION XLATE_EXT_AUTH_CH

DESCRIPTION
  This function translates a Traffic Channel Authentication Challenge
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Authentication Challenge message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_auth_ch
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_auth_ch_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    #define FTYPE cai_auth_ch_type

    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->auth_ch.hdr );

    ext_msg_pos = FENDPOS( cai_auth_ch_type, hdr.encryption );

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_NOT_REQUIRED, 
         &ext_msg_pos, buf_ptr, &int_ptr->auth_ch.hdr.msg_int,
         int_ptr->auth_ch.msg_type, 
         int_ptr->auth_ch.hdr.ack_req                                      
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &ext_msg_pos, buf_ptr, 
          &int_ptr->auth_ch.hdr, int_ptr->auth_ch.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */

      {
        UNPACKD_PG(auth_ch.randu, FTYPE, randu);
      }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    }

    #undef FTYPE
  }

  return (status);

} /* xlate_ext_auth_ch */

/*===========================================================================

INFORMATION RECORD PARSING FUNCTIONS

DESCRIPTION
  The functions that follow consolidate code used to parse information
  records created by IS-95B that appear on the Paging and Forward Traffic
  Channel, specifically in the Feature Notification Message and the
  Alert With Information and Flash With Information messages.

===========================================================================*/

/*===========================================================================

FUNCTION XLATE_EXT_SUB_REC

DESCRIPTION
  This function translates the Called Party Subaddress/Calling Party
  Subaddress/Redirect Subaddress/Connected Subaddress information records
  appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_sub_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte *msg_ptr,
    /* Pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
 word i;
    /* Index for looping through neighbors */
 word status;
   /* Status to be returned to calling procedure */
 word msg_pos;
   /* Position of record inside the message */
 msg_pos = *msg_pos_ptr;

 /* --------------------------------------------------------
  ** Calling Party Subaddress or Called Party Subaddress
  ** or Redirecting Subaddress or Connected Subaddress info record
  ** -------------------------------------------------------- */
   ((caii_subaddr_rec_type *) msg_ptr)->fix.extension_bit =
      b_unpackb( buf_ptr, msg_pos,
                 FSIZ( cai_subaddr_fix_type, extension_bit ));
   msg_pos += FSIZ( cai_subaddr_fix_type, extension_bit );

   ((caii_subaddr_rec_type *) msg_ptr)->fix.subadd_type =
      b_unpackb( buf_ptr, msg_pos,
                 FSIZ( cai_subaddr_fix_type, subadd_type ));
   msg_pos += FSIZ( cai_subaddr_fix_type, subadd_type );

   ((caii_subaddr_rec_type *) msg_ptr)->fix.odd_even_ind =
      b_unpackb( buf_ptr, msg_pos,
                 FSIZ( cai_subaddr_fix_type, odd_even_ind ));
   msg_pos += FSIZ( cai_subaddr_fix_type, odd_even_ind );

   msg_pos += FSIZ( cai_subaddr_fix_type, reserved );
   /* End Unpacking of Fixed Type */

   /* Begin packing Variable Type */
   ((caii_subaddr_rec_type *) msg_ptr)->fix.num_char =
      (byte) (((rec_len - sizeof( cai_subaddr_fix_type ))
                / sizeof( cai_subaddr_var_type )));

   for (i=0;
        i < ((caii_subaddr_rec_type *) msg_ptr)->fix.num_char; i++)
   {
     (( caii_subaddr_rec_type*) msg_ptr)->var[i] =
        b_unpackb( buf_ptr, msg_pos,
                   FSIZ( cai_subaddr_var_type, chari ));
     msg_pos += FSIZ( cai_subaddr_var_type, chari );
   }

   status = CAIX_DONE_S;
   *msg_pos_ptr = msg_pos;
      /* Update the position inside the message which is to be parsed */

   return ( status );
}

/* <EJECT> */
/*===========================================================================

FUNCTION XLATE_EXT_REDIR_NUM_REC

DESCRIPTION
  This function translates the Redirecting Number information record
  appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_redir_num_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte *msg_ptr,
    /* Pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
  word i;
     /* Index for looping through neighbors */
  word status;
    /* Status to be returned to calling procedure */
  word msg_pos;
    /* Position of record inside the message */
  word start_pos;
    /* Temporary storage for the start point of the msg */
  msg_pos = *msg_pos_ptr;


  /* --------------------------------------------------------
  ** Redirecting Number info record
  ** -------------------------------------------------------- */
  start_pos = msg_pos;

  ((caii_redir_rec_type *) msg_ptr)->fix.extension_bit1 =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_redir_fix_type, extension_bit1 ));
  msg_pos += FSIZ( cai_redir_fix_type, extension_bit1 );

  ((caii_redir_rec_type *) msg_ptr)->fix.number_type =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_redir_fix_type, number_type ));
  msg_pos += FSIZ( cai_redir_fix_type, number_type );

  ((caii_redir_rec_type *) msg_ptr)->fix.number_plan =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_redir_fix_type, number_plan ));
  msg_pos += FSIZ( cai_redir_fix_type, number_plan );

  if( !((caii_redir_rec_type *) msg_ptr)->fix.extension_bit1 )
  {
    /* ---------------------------------------------------
    ** If EXTENSION_BIT1 is 0, the following is included
    ** --------------------------------------------------- */
    ((caii_redir_rec_type *) msg_ptr)->fix.extension_bit2 =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_redir_fix_type, extension_bit2 ));
    msg_pos += FSIZ( cai_redir_fix_type, extension_bit2 );

    ((caii_redir_rec_type *) msg_ptr)->fix.pi =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_redir_fix_type, pi ));
    msg_pos += FSIZ( cai_redir_fix_type, pi );

    msg_pos += FSIZ( cai_redir_fix_type, reserved1 );

    ((caii_redir_rec_type *) msg_ptr)->fix.si =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_redir_fix_type, si ));
    msg_pos += FSIZ( cai_redir_fix_type, si );

    /* ---------------------------------------------------
    ** If EXTENSION_BIT2 is ALSO 0, the following is included
    ** --------------------------------------------------- */
    if( !((caii_redir_rec_type *) msg_ptr)->fix.extension_bit2 )
    {
      ((caii_redir_rec_type *) msg_ptr)->fix.extension_bit3 =
         b_unpackb( buf_ptr, msg_pos,
                    FSIZ( cai_redir_fix_type, extension_bit3 ));
      msg_pos += FSIZ( cai_redir_fix_type, extension_bit3 );

      msg_pos += FSIZ( cai_redir_fix_type, reserved2 );

      ((caii_redir_rec_type *) msg_ptr)->fix.redir_reason =
         b_unpackb( buf_ptr, msg_pos,
                    FSIZ( cai_redir_fix_type, redir_reason ));
      msg_pos += FSIZ( cai_redir_fix_type, redir_reason );
    }
  }

  ((caii_redir_rec_type *) msg_ptr)->fix.num_char =
     (byte) (((rec_len - (msg_pos - start_pos))
             / sizeof( cai_redir_var_type )));

  for (i=0;
     i < ((caii_redir_rec_type *) msg_ptr)->fix.num_char; i++)
  {
    (( caii_redir_rec_type*) msg_ptr)->var[i] =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_redir_var_type, chari ));
    msg_pos += FSIZ( cai_redir_var_type, chari );
  }

  status = CAIX_DONE_S;
  *msg_pos_ptr = msg_pos;
    /* Update the pointer position inside the message which is
     being parsed */

  return ( status );
}


/* <EJECT> */
/*===========================================================================

FUNCTION XLATE_EXT_PARA_ALERT_REC

DESCRIPTION
  This function translates the Parametric Alerting information record
  appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_para_alert_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte *msg_ptr,
    /* Pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
  word i;
     /* Index for looping through neighbors */
  word status;
    /* Status to be returned to calling procedure */
  word msg_pos;
    /* Position of record inside the message */

  msg_pos = *msg_pos_ptr;


  /* --------------------------------------
  ** Parametric Alerting Information Record
  ** -------------------------------------- */
  ((caii_para_alert_rec_type *) msg_ptr)->fix.cadence_cnt =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_para_alert_fix_type, cadence_cnt ));
  msg_pos += FSIZ( cai_para_alert_fix_type, cadence_cnt );

  ((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups =
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_para_alert_fix_type, num_groups ));

  /* Range check */
  if(((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups
        > CAII_PARA_ALERT_MAX )
  {
    ((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups =
       CAII_PARA_ALERT_MAX;
  }
  msg_pos += FSIZ( cai_para_alert_fix_type, num_groups );

  for (i=0;
       i < ((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups;
       i++)
  {
    ((caii_para_alert_rec_type *) msg_ptr)->var[i].amplitude =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, amplitude ));
    msg_pos += FSIZ( cai_para_alert_var_type, amplitude );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].freq_1 =
       b_unpackw( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, freq_1 ));
    msg_pos += FSIZ( cai_para_alert_var_type, freq_1 );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].freq_2 =
       b_unpackw( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, freq_2 ));
    msg_pos += FSIZ( cai_para_alert_var_type, freq_2 );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].on_time =
       b_unpackb( buf_ptr, msg_pos,
                 FSIZ( cai_para_alert_var_type, on_time ));
    msg_pos += FSIZ( cai_para_alert_var_type, on_time );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].off_time =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, off_time ));
    msg_pos += FSIZ( cai_para_alert_var_type, off_time );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].repeat =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, repeat ));
    msg_pos += FSIZ( cai_para_alert_var_type, repeat );

    ((caii_para_alert_rec_type *) msg_ptr)->var[i].delay =
       b_unpackb( buf_ptr, msg_pos,
                  FSIZ( cai_para_alert_var_type, delay ));
    msg_pos += FSIZ( cai_para_alert_var_type, delay );
  }

#ifdef FEATURE_IS2000_REL_A
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
  ((caii_para_alert_rec_type *) msg_ptr)->fix.cadence_type =
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
     b_unpackb( buf_ptr, msg_pos,
                FSIZ( cai_para_alert_fix1_type, cadence_type ));
#endif /* FEATURE_IS2000_REL_A */

  msg_pos += 4;     /* Increment past reserved bit at end */

  status = CAIX_DONE_S;
  *msg_pos_ptr = msg_pos;
   /* Update the pointer position inside the message which is
      being parsed */

  return ( status );
}

/*===========================================================================

FUNCTION XLATE_EXT_EXT_DISP_REC

DESCRIPTION
  This function translates the Extended Display information record
  appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Updates the msg_ptr to point to the first byte past the translated
  message.

===========================================================================*/
word xlate_ext_ext_disp_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte **message_ptr,
    /* Pointer to pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
 word i;
    /* Index for looping through neighbors */
 word status = CAIX_DONE_S;
   /* Status to be returned to calling procedure */
 byte *rec_ptr;
   /* Pointer to sub-record */
 word end_pos;
   /* Temporary storage for the end point of the msg */
 byte len;
   /* temp storage for length of subrecord */
 byte *msg_ptr;
   /* Temporary storage for message pointer */

 msg_ptr = *message_ptr;
 end_pos = rec_len + *msg_pos_ptr;     /* End Position of this record */

 /* ------------------------------
 ** Extended Display Info Record
 ** ------------------------------ */

 #define RTYPE caii_ext_disp_type
 #define RVTYPE caii_ext_disp_var_type
 #define FTYPE cai_ext_disp_fix_type
 #define V1TYPE cai_ext_disp_var1_type
 #define V2TYPE cai_ext_disp_var2_type

 ((RTYPE *) msg_ptr)->fix.ext_display_ind =
   b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(FTYPE , ext_display_ind));
 *msg_pos_ptr += FSIZ(FTYPE, ext_display_ind);

 ((RTYPE *) msg_ptr)->fix.display_type =
   b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(FTYPE, display_type));
 *msg_pos_ptr += FSIZ(FTYPE, display_type);

 ((RTYPE *) msg_ptr)->fix.rec_len = 0;

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

 /* ------------------------------------------------------
 ** Here comes the hard part. The variable part of
 ** this record can contain variable length sub-records.
 ** To avoid excessive RAM requirement, the internal
 ** format is tightly packed. Be very careful when
 ** unpack the internal format !!!
 ** ------------------------------------------------------ */
 rec_ptr = &(((RTYPE *)msg_ptr)->var[0]);

 while ((end_pos - *msg_pos_ptr) >= sizeof(V1TYPE)) /*lint !e574*/
 {

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

   ((RVTYPE *) rec_ptr)->display_tag =
     b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(V1TYPE, display_tag));
   *msg_pos_ptr += FSIZ(V1TYPE, display_tag);

   ((RVTYPE *) rec_ptr)->display_len = len = 
     b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(V1TYPE, display_len));
   *msg_pos_ptr += FSIZ(V1TYPE, display_len);

   if ((((RVTYPE *) rec_ptr)->display_tag != CAI_EXT_DISP_BLANK) &&
       (((RVTYPE *) rec_ptr)->display_tag != CAI_EXT_DISP_SKIP))
   {
     for (i=0; (i < len) && (*msg_pos_ptr < end_pos); i++)
     {
       ((RVTYPE *) rec_ptr)->chari[i] =
         b_unpackb(buf_ptr, *msg_pos_ptr, FSIZ(V2TYPE, chari));
       *msg_pos_ptr += FSIZ(V2TYPE, chari);
     }

#ifndef FEATURE_MSG_PACK_UNIT_TEST
     /* update length (use i incase loop ended because we hit the msg end) */
     ((RVTYPE *) rec_ptr)->display_len = (byte) i;
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */

     /* ----------------------------------------------
     ** One more record - calculate addition length
     ** ---------------------------------------------- */
      ((RTYPE *) msg_ptr)->fix.rec_len += FENDPOS(RVTYPE, display_len) + 
                                          ((RVTYPE *)rec_ptr)->display_len;

#ifndef FEATURE_MSG_PACK_UNIT_TEST
     if (i != len)
     { 
       /* we hit the message end before the subrecord length */
       /* something is wrong */
       status = CAIX_INV_LEN_S;
       /* Fix internal message buffer */
       rec_ptr = *message_ptr + (rec_len /8);
       break; /* stop processing this record */
     }
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */

     /* --------------------------------------------------
     ** Update sub-record pointer in the internal format
     ** -------------------------------------------------- */
     rec_ptr += FENDPOS(RVTYPE, chari[((RVTYPE *)rec_ptr)->display_len - 1] );
   }
   else
   {
     // we are here because the display_tag was CAI_EXT_DISP_BLANK or CAI_EXT_DISP_SKIP

     // Normally, in this case, the BS will set display_len to 0, but in case it does
     // not, the following line forces it to be.
     // we make the display_len = 0 here so we don't have to perform the BLANK or SKIP
     // check any further up the chain at CM.
#ifndef FEATURE_MSG_PACK_UNIT_TEST
     ((RVTYPE *) rec_ptr)->display_len = 0;
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */
     rec_ptr += FENDPOS(RVTYPE, display_len);
   }


 } /* end while */

 /* Now update the pointer to the output message */
 *message_ptr = rec_ptr;

 #undef RTYPE 

 #undef RVTYPE 
 #undef FTYPE 
 #undef V1TYPE 
 #undef V2TYPE 

 return ( status );

}  /* xlate_ext_ext_disp_rec */


#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_MC_EXT_DISP_REC

DESCRIPTION
  This function translates the Multi-character Extended Display information
  record appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Updates the msg_ptr to point to the first byte past the translated
  message.

===========================================================================*/
word xlate_ext_mc_ext_disp_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte **message_ptr,
    /* Pointer to pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos;
    /* Position of record inside the message */
  word end_pos;
    /* Temporary storage for the end point of the msg */
  word len;
    /* Length of information record in bytes */
  byte *msg_ptr;
    /* temp storage for message pointer */
  byte *int_buf_ptr;
    /* Pointer to the buffer item to be used for storage */
  byte i, j;
    /* Loop indexes */
  byte num_displays;
    /* Number pf display records */
  caii_mc_ext_disp_rec_type *disp_ptr;
  caii_mc_ext_disp_rec_info_type *recs_ptr;
  len = rec_len / 8;

  if ((len * 8) < rec_len)
  {
    len++;
  }

  if ((len - 1) > CAII_MC_EXT_DISP_BUF_SIZ)
  {
    MSG_ERROR("Buf is too small for this MC_EXT_DISP", 0, 0, 0);
    return CAIX_INV_LEN_S;
  }

  msg_ptr = *message_ptr;
  msg_pos = *msg_pos_ptr;
  end_pos = rec_len + msg_pos;     /* End Position of this record */

  ((caii_mc_ext_disp_type *) msg_ptr)->mc_ext_display_ind = b_unpackb(buf_ptr,
                                                                      msg_pos, FSIZ(cai_mc_ext_disp_fix_type, mc_ext_display_ind));
  msg_pos += FSIZ(cai_mc_ext_disp_fix_type, mc_ext_display_ind);

  ((caii_mc_ext_disp_type *) msg_ptr)->display_type = b_unpackb(buf_ptr, 
                                                                msg_pos, FSIZ(cai_mc_ext_disp_fix_type, display_type));
  msg_pos += FSIZ(cai_mc_ext_disp_fix_type, display_type);

  /* -----------------------------------------
  ** Initialize number of display records to 0
  ** ----------------------------------------- */
  num_displays = 0;

  /* --------------------------------------
  ** Initialize first record pointer to buf
  ** -------------------------------------- */
  int_buf_ptr = (byte *)((caii_mc_ext_disp_type *) msg_ptr)->buf; 

  while (end_pos > msg_pos)
  {
    int_buf_ptr = (byte *)ALIGN_DWORD((dword) int_buf_ptr);

    disp_ptr = ((caii_mc_ext_disp_type *) msg_ptr)->displays[num_displays] = 
               (caii_mc_ext_disp_rec_type *) int_buf_ptr;

    num_displays += 1;

    disp_ptr->display_tag = b_unpackb(buf_ptr, msg_pos,
                                      FSIZ(cai_mc_ext_disp_var1_type, display_tag));
    msg_pos += FSIZ(cai_mc_ext_disp_var1_type, display_tag);

    disp_ptr->num_record = b_unpackb(buf_ptr, msg_pos,
                                     FSIZ(cai_mc_ext_disp_var1_type, num_record));
    msg_pos += FSIZ(cai_mc_ext_disp_var1_type, num_record);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
    int_buf_ptr += FPOS(caii_mc_ext_disp_rec_type, recs[disp_ptr->num_record]);
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    for (i=0; i<disp_ptr->num_record; i++)
    {
      int_buf_ptr = (byte *)ALIGN_DWORD((dword) int_buf_ptr);

      recs_ptr = (caii_mc_ext_disp_rec_info_type*)int_buf_ptr;

#ifndef FEATURE_MSG_PACK_UNIT_TEST
      ((caii_mc_ext_disp_rec_type*)disp_ptr)->recs[i] = recs_ptr;
#endif

      /* We only support 8 bit characters for now, not 16 bit */
      recs_ptr->display_encoding = b_unpackb(buf_ptr, msg_pos,
                                             FSIZ(cai_mc_ext_disp_var2_type, display_encoding));
      msg_pos += FSIZ(cai_mc_ext_disp_var2_type, display_encoding);

      recs_ptr->num_fields = b_unpackb(buf_ptr, msg_pos,
                                       FSIZ(cai_mc_ext_disp_var2_type, num_fields));
      msg_pos += FSIZ(cai_mc_ext_disp_var2_type, num_fields);

      for (j=0; j<recs_ptr->num_fields; j++)
      {
        recs_ptr->chari[j] = b_unpackb(buf_ptr, msg_pos, 
                                       FSIZ(cai_mc_ext_disp_var3_type, chari));
        msg_pos += FSIZ(cai_mc_ext_disp_var3_type, chari);

      }

      int_buf_ptr += FPOS(caii_mc_ext_disp_rec_info_type, chari[recs_ptr->num_fields]);
    }
  } 

  ((caii_mc_ext_disp_type *) msg_ptr)->num_displays = num_displays;

  /* Add the reserved bits to msg_pos */
  msg_pos = end_pos;

  /* Update the pointer position inside the message which is
     being parsed */
  *msg_pos_ptr = msg_pos;

  /* now update the pointer to the output message */
  *message_ptr = int_buf_ptr;

  return status;
}
#endif /* FEATURE_IS2000_REL_A */


#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_EXT_ENH_MC_EXT_DISP_REC

DESCRIPTION
  This function translates the Enhanced Multi-character Extended Display information
  record appended to the Feature Notification Message on the Paging Channel, or
  the Alert with Information or Flash with Information Messages on the
  Forward Traffic Channels from the external to internal format.

DEPENDENCIES
  Assumes that the buffer pointer received as an input to the
  procedure points to the first bit of the subaddress record and the
  internal message pointer points to the record.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Updates the msg_ptr to point to the first byte past the translated
  message.

===========================================================================*/
word xlate_ext_enh_mc_ext_disp_rec
(
  word rec_len,
    /* Length in bits of the information record to be parsed */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  byte **message_ptr,
    /* Pointer to pointer to position inside the internal message type */
  word *msg_pos_ptr
    /* Pointer to position of record inside message */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos, start_msg_pos;
    /* Position of record inside the message */
  word len;
    /* Length of information record in bytes */
  byte *int_buf_ptr;
    /* Pointer to the buffer item to be used for storage */
  byte i, j, k;
    /* Loop indexes */
  caii_enh_mc_ext_disp_rec_type *disp_ptr;
  caii_enh_mc_ext_disp_rec_info_type *recs_ptr;
  byte record_length;
  word rec_start_pos;

  len = rec_len / 8;

  if ((len * 8) < rec_len)
  {
    len++;
  }

  if ((len - 1) > CAII_ENH_MC_EXT_DISP_BUF_SIZ)
  {
    MSG_ERROR("Buf is too small for this ENH_MC_EXT_DISP", 0, 0, 0);
    return CAIX_INV_LEN_S;
  }

  msg_pos = *msg_pos_ptr;
  start_msg_pos = msg_pos;

  ((caii_enh_mc_ext_disp_type*)*message_ptr)->display_type = b_unpackb(buf_ptr, 
                                                                       msg_pos, FSIZ(cai_enh_mc_ext_disp_fix_type, display_type));
  msg_pos += FSIZ(cai_enh_mc_ext_disp_fix_type, display_type);

  ((caii_enh_mc_ext_disp_type*)*message_ptr)->num_displays = b_unpackb(buf_ptr,
                                                                       msg_pos, FSIZ(cai_enh_mc_ext_disp_fix_type, num_displays));
  msg_pos += FSIZ(cai_enh_mc_ext_disp_fix_type, num_displays);

  /* --------------------------------------
  ** Initialize first record pointer to buf
  ** -------------------------------------- */
  int_buf_ptr = (byte *)(((caii_enh_mc_ext_disp_type*)*message_ptr)->buf); 

  for (i=0; i<(((caii_enh_mc_ext_disp_type*)*message_ptr)->num_displays + 1); i++)
  {
    int_buf_ptr = (byte *)ALIGN_DWORD((dword) int_buf_ptr);

    disp_ptr = ((caii_enh_mc_ext_disp_type*)*message_ptr)->displays[i] = (caii_enh_mc_ext_disp_rec_type *)int_buf_ptr;

    disp_ptr->display_tag = b_unpackb(buf_ptr, msg_pos,
                                      FSIZ(cai_enh_mc_ext_disp_var1_type, display_tag));
    msg_pos += FSIZ(cai_enh_mc_ext_disp_var1_type, display_tag);

    disp_ptr->num_record = b_unpackb(buf_ptr, msg_pos,
                                     FSIZ(cai_enh_mc_ext_disp_var1_type, num_record));
    msg_pos += FSIZ(cai_enh_mc_ext_disp_var1_type, num_record);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
    int_buf_ptr += FPOS(caii_enh_mc_ext_disp_rec_type, recs[disp_ptr->num_record]);
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    if ((disp_ptr->display_tag != CAI_EXT_DISP_BLANK) && 
        (disp_ptr->display_tag != CAI_EXT_DISP_SKIP))
    {

      for (j=0; j<disp_ptr->num_record; j++)
      {
        int_buf_ptr = (byte *)ALIGN_DWORD((dword) int_buf_ptr);

        recs_ptr = (caii_enh_mc_ext_disp_rec_info_type*)int_buf_ptr;

#ifndef FEATURE_MSG_PACK_UNIT_TEST
        ((caii_enh_mc_ext_disp_rec_type*)disp_ptr)->recs[j] = recs_ptr;
#endif

        rec_start_pos = msg_pos;
        record_length = b_unpackb(buf_ptr, msg_pos, 
                                  FSIZ(cai_enh_mc_ext_disp_var2_type, record_length));
        msg_pos += FSIZ(cai_enh_mc_ext_disp_var2_type, record_length);

        /* We only support 8 bit characters for now, not 16 bit */
        recs_ptr->display_encoding = b_unpackb(buf_ptr, msg_pos,
                                               FSIZ(cai_enh_mc_ext_disp_var2_type, display_encoding));
        msg_pos += FSIZ(cai_enh_mc_ext_disp_var2_type, display_encoding);

        recs_ptr->num_fields = b_unpackb(buf_ptr, msg_pos,
                                         FSIZ(cai_enh_mc_ext_disp_var2_type, num_fields));
        msg_pos += FSIZ(cai_enh_mc_ext_disp_var2_type, num_fields);

        for (k=0; k<recs_ptr->num_fields; k++)
        {
          recs_ptr->chari[k] = b_unpackb(buf_ptr, msg_pos, 
                                         FSIZ(cai_enh_mc_ext_disp_var3_type, chari));
          msg_pos += FSIZ(cai_enh_mc_ext_disp_var3_type, chari);
        }

        int_buf_ptr += FPOS(caii_enh_mc_ext_disp_rec_info_type, chari[recs_ptr->num_fields]);


        msg_pos = rec_start_pos + record_length*8;
      }

    }

  } 

  /* Add the reserve bits to msg_pos */
  msg_pos += (rec_len - msg_pos + start_msg_pos);

  /* Update the pointer position inside the message which is
     being parsed */
  *msg_pos_ptr = msg_pos;

  /* now update the pointer to the output message */
  *message_ptr = int_buf_ptr;

  return status;
}
#endif /* FEATURE_IS2000_REL_C */

/*===========================================================================

FUNCTION XLATE_EXT_INFO

DESCRIPTION
  This function translates a Traffic Channel Alert With Information
  or Flash With Information Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Alert With Information or Flash With
  Information message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_info
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  byte i;
    /* Index */
  word msg_pos;
    /* Position of record in message */
  byte *msg_ptr;
    /* Pointer to position inside internal message type */
  byte rec_type;
    /* Temporary storage for record type */
  word rec_len;
    /* Temporary storage for record length */
  word min_len;

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
  
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_alert_fix_type )
#ifdef FEATURE_IS2000_REL_A
            - FSIZ( cai_tc_hdr_ext_enc_type, sdu_encrypt_mode )
            - FSIZ( cai_tc_hdr_ext_enc_type, enc_seq )
#endif /* FEATURE_IS2000_REL_A */
     )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> Convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->alert.hdr );

    msg_pos = FENDPOS( cai_alert_fix_type, hdr.encryption );

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED, 
         &msg_pos, buf_ptr, 
         &int_ptr->alert.hdr.msg_int,int_ptr->alert.msg_type,
         int_ptr->alert.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->alert.hdr, int_ptr->alert.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        /* Initialize number of records to 0 */
        int_ptr->alert.num_recs = 0;
        msg_ptr = (byte*)ALIGN_DWORD((dword)(&int_ptr->alert.recs[0]));
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
        
        min_len = FSIZ(cai_rec_hdr_type, record_type) + 
                  FSIZ(cai_rec_hdr_type, record_len);

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->alert.hdr.msg_int.maci_incl)
        {
          min_len += FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        while ((len > msg_pos) && ((len - msg_pos) >= min_len) &&
               (status == CAIX_DONE_S))
        {
          word start_msg_pos;

          /* ------------------------------
          ** Unpack message type and length
          ** ------------------------------ */
          ((caii_rec_hdr_type *) msg_ptr)->record_type = rec_type =
            b_unpackb( buf_ptr, msg_pos, FSIZ(cai_rec_hdr_type, record_type));
          msg_pos += FSIZ(cai_rec_hdr_type, record_type);

          /* -------------------------
          ** Get record length in bits
          ** ------------------------- */
          rec_len = b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_rec_hdr_type, record_len)) * 8;
          msg_pos += FSIZ(cai_rec_hdr_type, record_len);
        
          start_msg_pos = msg_pos;

          if ((rec_len + msg_pos) > len)
          {
            /* ---------------------
            ** Record length invalid
            ** --------------------- */
            status = CAIX_INV_LEN_S;
            break;
          }

          else
          {
            /* --------------------------------------
            ** Attempt to parse information record(s)
            ** -------------------------------------- */
            switch (rec_type)
            {
              case CAI_DISPLAY_REC:
                /* --------------------------
                ** Display Information Record
                ** -------------------------- */
                ((caii_display_rec_type *) msg_ptr)->fix.num_char =
                   (byte) (rec_len / sizeof(cai_display_rec_var_type));

                for (i=0; i < ((caii_display_rec_type *) msg_ptr)->fix.num_char;
                     i++)
                {
                  ((caii_display_rec_type *) msg_ptr)->var[i] =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_display_rec_var_type, chari));
                  start_msg_pos += FSIZ(cai_display_rec_var_type, chari);
                }

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_display_rec_type,
                  var[((caii_display_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_CALLED_REC:
                /* --------------------------------------
                ** Called Party Number Information Record
                ** -------------------------------------- */
                ((caii_called_rec_type *) msg_ptr)->fix.number_type =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_called_fix_type, number_type));
                start_msg_pos += FSIZ(cai_called_fix_type, number_type);

                ((caii_called_rec_type *) msg_ptr)->fix.number_plan =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_called_fix_type, number_plan));
                start_msg_pos += FSIZ(cai_called_fix_type, number_plan);

                ((caii_called_rec_type *) msg_ptr)->fix.num_char =
                  (byte) ((rec_len - sizeof(cai_called_fix_type)) /
                  sizeof(cai_called_var_type));

                for (i=0; i < ((caii_called_rec_type *) msg_ptr)->fix.num_char;
                     i++)
                {
                  ((caii_called_rec_type *) msg_ptr)->var[i] =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_called_var_type, chari));
                  start_msg_pos += FSIZ(cai_called_var_type, chari);
                }

                /* ----------------------------------------------------------
                ** Increment internal message pointer to point to next record
                ** ---------------------------------------------------------- */
                msg_ptr += FENDPOS(caii_called_rec_type,
                  var[((caii_called_rec_type *) msg_ptr)->fix.num_char - 1] );

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_CALLING_REC:
              case CAI_CONNECT_REC:
                /* -----------------------------------------------------------
                ** Calling Party Number or Connected Number Information Record
                ** ----------------------------------------------------------- */
                ((caii_calling_rec_type *) msg_ptr)->fix.number_type =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_calling_fix_type, number_type));
                start_msg_pos += FSIZ(cai_calling_fix_type, number_type);

                ((caii_calling_rec_type *) msg_ptr)->fix.number_plan =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_calling_fix_type, number_plan));
                start_msg_pos += FSIZ(cai_calling_fix_type, number_plan);

                ((caii_calling_rec_type *) msg_ptr)->fix.pi =
                  b_unpackb(buf_ptr, start_msg_pos, FSIZ(cai_calling_fix_type, pi));
                start_msg_pos += FSIZ(cai_calling_fix_type, pi);

                ((caii_calling_rec_type *) msg_ptr)->fix.si =
                  b_unpackb(buf_ptr, start_msg_pos, FSIZ(cai_calling_fix_type, si));
                start_msg_pos += FSIZ(cai_calling_fix_type, si);

                ((caii_calling_rec_type *) msg_ptr)->fix.num_char =
                  (byte) ((rec_len - sizeof(cai_calling_fix_type)) /
                  sizeof(cai_calling_var_type));

                for (i=0; i < ((caii_calling_rec_type *) msg_ptr)->fix.num_char; i++)
                {
                  ((caii_calling_rec_type *) msg_ptr)->var[i] =
                    b_unpackb(buf_ptr, start_msg_pos,
                            FSIZ(cai_calling_var_type, chari));
                  start_msg_pos += FSIZ(cai_calling_var_type, chari);
                }

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += FENDPOS(caii_calling_rec_type,
                  var[((caii_calling_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_SIGNAL_REC:
                /* -------------------------
                ** Signal Information Record
                ** ------------------------- */
                ((caii_signal_rec_type *) msg_ptr)->signal_type =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_signal_rec_type, signal_type));
                start_msg_pos += FSIZ(cai_signal_rec_type, signal_type);

                ((caii_signal_rec_type *) msg_ptr)->alert_pitch =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_signal_rec_type, alert_pitch));
                start_msg_pos += FSIZ(cai_signal_rec_type, alert_pitch);

                ((caii_signal_rec_type *) msg_ptr)->signal =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_signal_rec_type, signal));
                start_msg_pos += FSIZ(cai_signal_rec_type, signal) +
                  FSIZ(cai_signal_rec_type, reserved);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_signal_rec_type);

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_MSG_WAITING_REC:
                /* ----------------------------------
                ** Message Waiting Information Record
                ** ---------------------------------- */
                ((caii_msg_waiting_rec_type *) msg_ptr)->msg_count =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_msg_waiting_rec_type, msg_count));
                start_msg_pos += FSIZ(cai_msg_waiting_rec_type, msg_count);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_msg_waiting_rec_type);

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_CALLED_SUB_REC:
              case CAI_CALLING_SUB_REC:
              case CAI_REDIR_SUB_REC:
              case CAI_CONNECT_SUB_REC:
                /* --------------------------------------------------------
                ** Calling Party Subaddress or Called Party Subaddress
                ** or Redirecting Subaddress or Connected Subaddress info
                ** record
                ** -------------------------------------------------------- */
                /* Unpack Information Record */
                status = xlate_ext_sub_rec(rec_len, buf_ptr, msg_ptr,
                  &start_msg_pos);

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_subaddr_rec_type,
                  var[((caii_subaddr_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_REDIR_NUM_REC:
                /* --------------------------------------------------------
                ** Redirecting Number Information Record
                ** -------------------------------------------------------- */
                /* Unpack Information Record */
                status = xlate_ext_redir_num_rec(rec_len, buf_ptr, msg_ptr,
                  &start_msg_pos);

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_redir_rec_type,
                  var[((caii_redir_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_EXT_DISPLAY_REC:
                /* ------------------------------
                ** Extended Display Info Record
                ** ------------------------------ */
                status = xlate_ext_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
                  &start_msg_pos);

                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_METER_PULSES_REC:
                /* --------------------------------
                ** Meter Pulses Information Record
                ** -------------------------------- */
                ((caii_meter_pulses_rec_type *) msg_ptr)->pulse_freq =
                  b_unpackw(buf_ptr, start_msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, pulse_freq));
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, pulse_freq);

                ((caii_meter_pulses_rec_type *) msg_ptr)->on_time =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, on_time));
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, on_time);

                ((caii_meter_pulses_rec_type *) msg_ptr)->off_time =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, off_time));
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, off_time);

                ((caii_meter_pulses_rec_type *) msg_ptr)->pulse_cnt =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, pulse_cnt));
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, pulse_cnt);

                /* Increment past reserved bit at end */
                start_msg_pos += FSIZ(cai_meter_pulses_rec_type, reserved);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
                msg_ptr += sizeof(caii_meter_pulses_rec_type); /*lint !e662 */
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_PARA_ALERT_REC:
                /* --------------------------------------
                ** Parametric Alerting Information Record
                ** -------------------------------------- */
                status = xlate_ext_para_alert_rec(rec_len, buf_ptr, msg_ptr,
                  &start_msg_pos);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
#if defined(FEATURE_IS2000_REL_A) && defined(FEATURE_MSG_PACK_UNIT_TEST)
#error code not present
#else
                if (((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups == 0)
                {
                  msg_ptr += FENDPOS(caii_para_alert_rec_type,fix);
                }
                else
                {
                  msg_ptr += FENDPOS( caii_para_alert_rec_type,
                   var[((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups - 1] );
                }
#endif /* FEATURE_IS2000_REL_A && FEATURE_MSG_PACK_UNIT_TEST */

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_LINE_CTRL_REC:
                /* -------------------------------------
                ** Line Control Information Record
                ** ------------------------------------- */
                ((caii_line_ctrl_rec_type *) msg_ptr)->pol_inc =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_line_ctrl_rec_type, pol_inc));
                start_msg_pos += FSIZ(cai_line_ctrl_rec_type, pol_inc);

                if (((caii_line_ctrl_rec_type *) msg_ptr)->pol_inc)
                {
                  ((caii_line_ctrl_rec_type *) msg_ptr)->tgl_mod =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, tgl_mod));
                  start_msg_pos += FSIZ(cai_line_ctrl_rec_type, tgl_mod);

                  ((caii_line_ctrl_rec_type *) msg_ptr)->rev_pol =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, rev_pol));
                  start_msg_pos += FSIZ(cai_line_ctrl_rec_type, rev_pol);

                  ((caii_line_ctrl_rec_type *) msg_ptr)->pow_dtm =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, pow_dtm));
                  start_msg_pos += FSIZ( cai_line_ctrl_rec_type, pow_dtm);
                }
                else
                {
                  ((caii_line_ctrl_rec_type *) msg_ptr)->pow_dtm =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, pow_dtm));
                  start_msg_pos += FSIZ(cai_line_ctrl_rec_type, pow_dtm);
                }

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_line_ctrl_rec_type); /*lint !e662 */

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_USER_ZONE_UPDATE_REC:
                ((caii_user_zone_update_type *) msg_ptr)->uzid =
                  b_unpackw(buf_ptr, start_msg_pos,
                  FSIZ(cai_user_zone_update_type, uzid));
                start_msg_pos += FSIZ(cai_user_zone_update_type, uzid);

                msg_ptr += FENDPOS( caii_user_zone_update_type,uzid );

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_USER_ZONE_REJECT_REC:
                ((caii_user_zone_reject_type *) msg_ptr)->reject_uzid =
                  b_unpackw(buf_ptr, start_msg_pos,
                  FSIZ(cai_user_zone_reject_type, reject_uzid));
                start_msg_pos += FSIZ(cai_user_zone_reject_type, reject_uzid);

                ((caii_user_zone_reject_type *) msg_ptr)->reject_action_indi =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_user_zone_reject_type, reject_action_indi));
                start_msg_pos += FSIZ(cai_user_zone_reject_type, reject_action_indi);

                ((caii_user_zone_reject_type *) msg_ptr)->uzid_assign_incl =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_user_zone_reject_type, uzid_assign_incl));
                start_msg_pos += FSIZ(cai_user_zone_reject_type, uzid_assign_incl);

                if (((caii_user_zone_reject_type *) msg_ptr)->uzid_assign_incl)
                {
                  ((caii_user_zone_reject_type *) msg_ptr)->assign_uzid =
                    b_unpackw(buf_ptr, start_msg_pos,
                    FSIZ(cai_user_zone_reject_type, assign_uzid));
                  start_msg_pos += FSIZ(cai_user_zone_reject_type, assign_uzid);
                  msg_ptr += FENDPOS( caii_user_zone_reject_type, assign_uzid );
                }
                else
                {
                  msg_ptr += FENDPOS(caii_user_zone_reject_type,
                    uzid_assign_incl );
                }

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

#ifdef FEATURE_IS2000_REL_A
              case CAI_MC_EXT_DISP_REC:
                /* ---------------------------------------------
                ** Multi-character Extended Display Info Record
                ** --------------------------------------------- */
                status = xlate_ext_mc_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
                  &start_msg_pos);

                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;

              case CAI_CALL_WAIT_IND_REC:
                /* ----------------------------------
                ** Call Waiting Indicator Record
                ** ---------------------------------- */
                ((caii_call_waiting_ind_type *) msg_ptr)->call_waiting_ind =
                  b_unpackb(buf_ptr, start_msg_pos,
                  FSIZ(cai_call_wait_type, call_waiting_ind));
                start_msg_pos += (FSIZ(cai_call_wait_type, call_waiting_ind) +
                  FSIZ(cai_call_wait_type, reserved));

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_call_waiting_ind_type);

                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
              case CAI_ENH_MC_EXT_DISP_REC:
                /* ---------------------------------------------
                ** Enhanced Multi-character Extended Display Info Record
                ** --------------------------------------------- */
                status = xlate_ext_enh_mc_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
                  &start_msg_pos);

                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                msg_pos += rec_len; 
                int_ptr->alert.num_recs++;
                break;
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_PASSPORT_MODE
              case CAI_NTL_SUP_SVC_REC:
              /* If JCDMA is not defined in the passport mode then treat
               * as if this code is not present. So slip into default case */
              if (mcc_passport_mode_is_jcdma())
              {
                /* ------------------------------------------
                ** Record for National Supplementary Services
                ** ------------------------------------------ */

                /* Determine the country-specific record type */

                ((caii_ntl_sup_svc_type *) msg_ptr)->mcc =
                   b_unpackw( buf_ptr, start_msg_pos,
                   FSIZ(cai_ntl_sup_svc_type, mcc));

                ((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype =
                  b_unpackb(buf_ptr, start_msg_pos + FSIZ(cai_ntl_sup_svc_type, mcc),
                  FSIZ(cai_ntl_sup_svc_type, record_subtype));

                if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc == CAI_T53_COUNTRY_CODE) &&
                    (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype == CAI_CLIR_REC))
                {
                  /* -----------------------
                  ** CLIR Information Record
                  ** ----------------------- */
                  start_msg_pos += FSIZ(cai_ntl_sup_svc_type, mcc) +
                    FSIZ(cai_ntl_sup_svc_type, record_subtype);

                  ((caii_clir_sup_svc_type *) msg_ptr)->cause =
                    b_unpackb(buf_ptr, start_msg_pos, 
                    FSIZ(cai_clir_sup_svc_type, cause));
                  start_msg_pos += FSIZ( cai_clir_sup_svc_type, cause);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_clir_sup_svc_type);

                  msg_pos += rec_len; 
                  int_ptr->alert.num_recs++;
                }
                else if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc ==
                          CAI_T53_COUNTRY_CODE) &&
                        (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype ==
                          CAI_RELEASE_REC))
                {
                  /* --------------------------
                  ** Release Information Record
                  ** -------------------------- */
                  start_msg_pos += FSIZ(cai_release_sup_svc_type, mcc) +
                    FSIZ(cai_release_sup_svc_type, record_subtype);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_release_sup_svc_type);

                  msg_pos += rec_len; 
                  int_ptr->alert.num_recs++;
                }
                else if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc ==
                          CAI_T53_COUNTRY_CODE) &&
                        (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype ==
                          CAI_AUDIO_CONTROL_REC))
                {
                  /* --------------------------------
                  ** Audio Control Information Record
                  ** -------------------------------- */
                  start_msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, mcc) +
                    FSIZ(cai_audio_ctl_sup_svc_type, record_subtype);

                  ((caii_audio_ctl_sup_svc_type *) msg_ptr)->up_link =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_audio_ctl_sup_svc_type, up_link));
                  start_msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, up_link);

                  ((caii_audio_ctl_sup_svc_type *) msg_ptr)->down_link =
                    b_unpackb(buf_ptr, start_msg_pos,
                    FSIZ(cai_audio_ctl_sup_svc_type, down_link));
                  start_msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, down_link) +
                    FSIZ(cai_audio_ctl_sup_svc_type, reserved);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_audio_ctl_sup_svc_type);

                  msg_pos += rec_len; 
                  int_ptr->alert.num_recs++;
                }
                else
                {
                  /* ------------------------------------
                  ** Unknown country-specific record type
                  ** ------------------------------------ */
                  msg_ptr += sizeof( caii_ntl_sup_svc_type );
                  msg_pos += rec_len;
                  int_ptr->alert.num_recs++;
                }
                break;
              }
#endif /* FEATURE_PASSPORT_MODE */
              /* This is an intentional fall through. If feature is not defined
                 or if the mode is not JCDMA the code will fall through into
                 default */
              /*lint -fallthrough */
              default:
                /* -------------------
                ** Unknown record type
                ** ------------------- */
                msg_ptr += sizeof( caii_rec_hdr_type );
                msg_pos += rec_len;
                int_ptr->alert.num_recs++;
            } /* end switch (rec_type) */

            msg_ptr = (byte*)ALIGN_DWORD(((dword) msg_ptr));
          } /* end if ((rec_len + msg_pos) > len) */

        } /* end of while */
      }
    }
  } /* else */

  return (status);

} /* xlate_ext_info */

/*===========================================================================

FUNCTION XLATE_EXT_TC_TMSI

DESCRIPTION
  This function translates a Forward Traffic Channel TMSI Assignment Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the TMSI Assignment message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_tmsi
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos = 0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_ftc_tmsi_asgn_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < CAI_FTC_TMSI_MIN)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_tmsi.hdr);

    msg_pos = FENDPOS(cai_ftc_tmsi_asgn_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED, 
         &msg_pos, buf_ptr, &int_ptr->tc_tmsi.hdr.msg_int,
         int_ptr->tc_tmsi.msg_type,
         int_ptr->tc_tmsi.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->tc_tmsi.hdr, int_ptr->tc_tmsi.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->tc_tmsi.data.zone_len = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, tmsi_zone_len));
        msg_pos += FSIZ(MTYPE, tmsi_zone_len);

        qw_set(int_ptr->tc_tmsi.data.info.tmsi_zone, 0L, 0L);
        b_unpackq(buf_ptr, msg_pos, (int_ptr->tc_tmsi.data.zone_len << 3),
          int_ptr->tc_tmsi.data.info.tmsi_zone);
        msg_pos += (int_ptr->tc_tmsi.data.zone_len << 3);

        int_ptr->tc_tmsi.data.info.tmsi_code =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, tmsi_code));
        msg_pos += FSIZ( MTYPE, tmsi_code);

        int_ptr->tc_tmsi.data.exp_time  =
          b_unpackd(buf_ptr, msg_pos, FSIZ( MTYPE, tmsi_exp_time));
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_tmsi */

/*===========================================================================

FUNCTION XLATE_EXT_TC_BURST

DESCRIPTION
  This function translates a Forward Traffic Channel Data Burst Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Data Burst message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_burst
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through characters */
  word msg_pos = 0;
  /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_fwd_tc_burst_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_burst_tc_fix_type ))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_burst.hdr);

    msg_pos = FENDPOS(cai_burst_tc_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, 
                                                CAIX_TC, 
                                                0, 
                                                CAIX_MACI_REQUIRED, 
                                                &msg_pos, 
                                                buf_ptr, 
                                                &int_ptr->tc_burst.hdr.msg_int,
                                                int_ptr->tc_burst.msg_type,
                                                int_ptr->tc_burst.hdr.ack_req
                                                )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->tc_burst.hdr, int_ptr->tc_burst.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->tc_burst.msg_number = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fix.msg_number));
        msg_pos += FSIZ(MTYPE, fix.msg_number);

        int_ptr->tc_burst.burst_type = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fix.burst_type));
        msg_pos += FSIZ(MTYPE, fix.burst_type);

        int_ptr->tc_burst.num_msgs = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fix.num_msgs));
        msg_pos += FSIZ(MTYPE, fix.num_msgs);

        int_ptr->tc_burst.num_fields = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fix.num_fields));
        msg_pos += FSIZ(MTYPE, fix.num_fields);

        if (int_ptr->tc_burst.num_fields > CAI_FWD_TC_BURST_MAX)
        {
          int_ptr->tc_burst.num_fields = (byte)CAI_FWD_TC_BURST_MAX;
        }

        for (i=0; i < int_ptr->tc_burst.num_fields; i++)
        {
          int_ptr->tc_burst.chari[i] = b_unpackb(buf_ptr, msg_pos,
            FSIZ(MTYPE, var[i]));
          msg_pos += FSIZ(MTYPE, var[i]);
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_burst */

/*===========================================================================

FUNCTION XLATE_EXT_FM_HO

DESCRIPTION
  This function translates a Traffic Channel Analog Handoff Direction
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Analog Handoff Direction type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_fm_ho
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos = 0;
  /* Position in message relative to start of buf_ptr */
  word min_len;

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
  
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_fm_ho_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (sizeof(cai_fm_ho_type) -
               FSIZ(cai_fm_ho_type, an_chan_type) -
               FSIZ(cai_fm_ho_type, dscc_msb) -
               FSIZ(cai_fm_ho_type, band_class))
#ifdef FEATURE_IS2000_REL_A
             - FSIZ(MTYPE, con_ref_incl) - FSIZ(MTYPE, con_ref)
#endif /* FEATURE_IS2000_REL_A */
     )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->fm_ho.hdr );

    msg_pos = FENDPOS(cai_fm_ho_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED, 
         &msg_pos, buf_ptr, &int_ptr->fm_ho.hdr.msg_int, 
         int_ptr->fm_ho.msg_type,
         int_ptr->fm_ho.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->fm_ho.hdr, int_ptr->fm_ho.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->fm_ho.use_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        int_ptr->fm_ho.action_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
        msg_pos += FSIZ(MTYPE, action_time);

        int_ptr->fm_ho.sid = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, sid));
        msg_pos += FSIZ(MTYPE, sid);

        int_ptr->fm_ho.vmac = b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, vmac));
        msg_pos += FSIZ(MTYPE, vmac);

        int_ptr->fm_ho.analog_chan =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, analog_chan));
        msg_pos += FSIZ(MTYPE, analog_chan);

        int_ptr->fm_ho.scc = b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, scc));
        msg_pos += FSIZ(MTYPE, scc);

        int_ptr->fm_ho.mem = b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, mem));
        msg_pos += FSIZ(MTYPE, mem);

        min_len = FSIZ(MTYPE, an_chan_type) + FSIZ(MTYPE, dscc_msb) +
                  FSIZ(MTYPE, band_class);

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->fm_ho.hdr.msg_int.maci_incl)
        {
          min_len += FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        if ((len - msg_pos) >= min_len)
        {
          int_ptr->fm_ho.an_chan_type =
            b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, an_chan_type));
          msg_pos += FSIZ(MTYPE, an_chan_type);

          int_ptr->fm_ho.dscc_msb =
            b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, dscc_msb));
          msg_pos += FSIZ(MTYPE, dscc_msb);

          int_ptr->fm_ho.band_class =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, band_class));
          msg_pos += FSIZ(MTYPE, band_class);

#ifdef FEATURE_PASSPORT_MODE
          if(mcc_passport_mode_is_jcdma())
          {
            int_ptr->fm_ho.dtx          = b_unpackb( PARAMS( dtx ));
          }
#endif /* FEATURE_PASSPORT_MODE */
        }

#ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
        {
          int_ptr->fm_ho.con_ref_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ( MTYPE, con_ref_incl));
          msg_pos += FSIZ(MTYPE, con_ref_incl);

          if (int_ptr->fm_ho.con_ref_incl)
          {
            int_ptr->fm_ho.con_ref =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
            msg_pos += FSIZ(MTYPE, con_ref);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_fm_ho */

/*===========================================================================

FUNCTION XLATE_EXT_TC_SYS_PARM

DESCRIPTION
  This function translates a Traffic Channel In-Traffic System Parameter
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the In-Traffic System Parameter type.

RETURN VALUE
  Errors that were encountered while translating the message.
  p_rev field will be set to zero to indicate an pre IS-95B format.
  A non-zero p_rev indicates an IS-95B and newer format.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_sys_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word buf_pos;
    /* Location of next bit in buffer to be processed */

  #ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
  #endif /* FEATURE_IS2000_REL_C_AKA */
    
  #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
  #endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_tc_sysparm_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** ( for IS-95B format, reserved bits are 4 )
  ** -------------------------------------------- */
  if (len < FENDPOS(MTYPE, nghbr_max_age ) + 4)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */

    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_sys.hdr);

    buf_pos = FENDPOS(cai_tc_sysparm_type, hdr.encryption);

    #ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED, 
         &buf_pos, buf_ptr, &int_ptr->tc_sys.hdr.msg_int,
         int_ptr->tc_sys.msg_type,
         int_ptr->tc_sys.hdr.ack_req                  
         )) != CAIX_DONE_S)
    {
      return status;
    }

    #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
    #endif /* FEATURE_MSG_PACK_UNIT_TEST */

    #endif /* FEATURE_IS2000_REL_C */

    #ifdef FEATURE_IS2000_REL_A
    if ((status = xlate_ext_ext_enc_tc(&len, &buf_pos, buf_ptr, 
               &int_ptr->tc_sys.hdr, int_ptr->tc_sys.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
    #endif /* FEATURE_IS2000_REL_A */
    
    int_ptr->tc_sys.sid = b_unpackw(buf_ptr, buf_pos, FSIZ(MTYPE, sid));
    buf_pos += FSIZ(MTYPE, sid);
    
    int_ptr->tc_sys.nid = b_unpackw(buf_ptr, buf_pos, FSIZ( MTYPE, nid));
    buf_pos += FSIZ(MTYPE, nid);
    
    int_ptr->tc_sys.srch_win_a = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, srch_win_a));
    buf_pos += FSIZ(MTYPE, srch_win_a);
    
    int_ptr->tc_sys.srch_win_n = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, srch_win_n));
    buf_pos += FSIZ(MTYPE, srch_win_n);
    
    int_ptr->tc_sys.srch_win_r = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, srch_win_r));
    buf_pos += FSIZ(MTYPE, srch_win_r);
    
    int_ptr->tc_sys.t_add = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_add));
    buf_pos += FSIZ(MTYPE, t_add);
    
    int_ptr->tc_sys.t_drop = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_drop));
    buf_pos += FSIZ(MTYPE, t_drop);
    
    int_ptr->tc_sys.t_comp = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_comp));
    buf_pos += FSIZ(MTYPE, t_comp);
    
    int_ptr->tc_sys.t_tdrop = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_tdrop));
    buf_pos += FSIZ(MTYPE, t_tdrop);
    
    int_ptr->tc_sys.nghbr_max_age = b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, nghbr_max_age));
    buf_pos += FSIZ(MTYPE, nghbr_max_age);
    
    /* 95b functionality is already supported in rel a */
    if (len-buf_pos < FSIZ(cai_tc_sysparm_type, p_rev) +
        FSIZ(cai_tc_sysparm_type, soft_slope)+
        FSIZ(cai_tc_sysparm_type, add_intercept)+
        FSIZ(cai_tc_sysparm_type, drop_intercept)+
        FSIZ(cai_tc_sysparm_type, packet_zone_id)+
        FSIZ(cai_tc_sysparm_type, extension))
    {
      int_ptr->tc_sys.p_rev = CAIX_P_REV_UNKNOWN;
    }
    else
    {
      #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
      #endif

      int_ptr->tc_sys.p_rev = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, p_rev ));
      buf_pos += FSIZ( MTYPE, p_rev );
      
      int_ptr->tc_sys.soft_slope = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, soft_slope ));
      buf_pos += FSIZ( MTYPE, soft_slope );
      
      int_ptr->tc_sys.add_intercept = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, add_intercept ));
      buf_pos += FSIZ( MTYPE, add_intercept );
      
      int_ptr->tc_sys.drop_intercept = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, drop_intercept ));
      buf_pos += FSIZ( MTYPE, drop_intercept );
      
      int_ptr->tc_sys.packet_zone_id = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, packet_zone_id ));
      buf_pos += FSIZ( MTYPE, packet_zone_id );
      
      int_ptr->tc_sys.extension = b_unpackb( buf_ptr, buf_pos, FSIZ( MTYPE, extension ));
      buf_pos += FSIZ( MTYPE, extension );
      
      if (int_ptr->tc_sys.extension)
      {
        int_ptr->tc_sys.t_mulchan =
          b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, t_mulchan));
        buf_pos += FSIZ(MTYPE, t_mulchan);
  
        int_ptr->tc_sys.begin_preamble =
          b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, begin_preamble));
        buf_pos += FSIZ(MTYPE, begin_preamble);
  
        int_ptr->tc_sys.resume_preamble =
          b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, resume_preamble));
        buf_pos += FSIZ(MTYPE, resume_preamble);
      }
      
      #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
      #else
      if (int_ptr->tc_sys.p_rev >= CAIX_P_REV_IS2000)
      #endif /* FEATURE_MSG_PACK_UNIT_TEST */
      {
        int_ptr->tc_sys.t_slotted_incl = b_unpackb(buf_ptr, buf_pos,
               FSIZ(cai_tc_sysparm_is2000_type, t_slotted_incl));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_type, t_slotted_incl);
  
        if (int_ptr->tc_sys.t_slotted_incl)
        {
          int_ptr->tc_sys.t_slotted = b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_tc_sysparm_is2000_type, t_slotted));
          buf_pos += FSIZ(cai_tc_sysparm_is2000_type, t_slotted);
        }
      }
    }
    
    #ifdef FEATURE_IS2000_REL_A

    #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
    #else
    if (int_ptr->tc_sys.p_rev >= CAIX_P_REV_IS2000_REL_A)
    #endif /* FEATURE_MSG_PACK_UNIT_TEST */

    {
      /* rel a enc fields */
      int_ptr->tc_sys.enc_supported = b_unpackb(buf_ptr, buf_pos,
            FSIZ(cai_tc_sysparm_is2000_Rel_A_type, enc_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_A_type, enc_supported);
      
      if (int_ptr->tc_sys.enc_supported)
      {
        int_ptr->tc_sys.sig_encrypt_sup = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_tc_sysparm_is2000_Rel_A_type, sig_encrypt_sup));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_A_type, sig_encrypt_sup);
  
        int_ptr->tc_sys.ui_encrypt_sup = b_unpackb(buf_ptr, buf_pos,
               FSIZ(cai_tc_sysparm_is2000_Rel_A_type, ui_encrypt_sup));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_A_type, ui_encrypt_sup);
      }
      
      int_ptr->tc_sys.cs_supported = b_unpackb(buf_ptr, buf_pos,
                 FSIZ(cai_tc_sysparm_is2000_Rel_A_type, cs_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_A_type,cs_supported);
    }

    #endif /* FEATURE_IS2000_REL_A */
    
    #ifdef FEATURE_IS2000_REL_C

    #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
    #else
    if (int_ptr->tc_sys.p_rev >= CAIX_P_REV_IS2000_REL_C)
    #endif /* FEATURE_MSG_PACK_UNIT_TEST */

    {
      int_ptr->tc_sys.chm_supported = 
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, chm_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, chm_supported);

      int_ptr->tc_sys.cdma_off_time_rep_sup_ind = 
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_sup_ind));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_sup_ind);
      
      if (int_ptr->tc_sys.cdma_off_time_rep_sup_ind)
      {
        int_ptr->tc_sys.cdma_off_time_rep_threshold_unit = 
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_threshold_unit));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_threshold_unit);
  
        int_ptr->tc_sys.cdma_off_time_rep_threshold = 
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_threshold));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, cdma_off_time_rep_threshold);
      }      

      int_ptr->tc_sys.t_tdrop_range_incl = 
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, t_tdrop_range_incl));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, t_tdrop_range_incl);
      
      if (int_ptr->tc_sys.t_tdrop_range_incl)
      {
        int_ptr->tc_sys.t_tdrop_range = 
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, t_tdrop_range));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, t_tdrop_range);
      }

      int_ptr->tc_sys.for_pdch_supported = 
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, for_pdch_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, for_pdch_supported);

      if (int_ptr->tc_sys.for_pdch_supported)
      {
        int_ptr->tc_sys.pdch_chm_supported = 
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, pdch_chm_supported));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, pdch_chm_supported);
      } 

      int_ptr->tc_sys.sdb_supported = 
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, sdb_supported));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, sdb_supported);

      if (int_ptr->tc_sys.cs_supported)
      {
        int_ptr->tc_sys.mob_qos = 
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, mob_qos));
        buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, mob_qos);
      }

      int_ptr->tc_sys.ms_init_pos_loc_sup_ind = 
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_tc_sysparm_is2000_Rel_C_type, ms_init_pos_loc_sup_ind));
      buf_pos += FSIZ(cai_tc_sysparm_is2000_Rel_C_type, ms_init_pos_loc_sup_ind);

    } /* if (int_ptr->tc_sys.p_rev >= CAIX_P_REV_IS2000_REL_C) */

    #endif /* FEATURE_IS2000_REL_C */

    #ifdef FEATURE_IS2000_REL_D
#error code not present
    #endif /* FEATURE_IS2000_REL_D */

    #ifndef FEATURE_MSG_PACK_UNIT_TEST
    /* There is an error if we parsed beyond the length */
    if (buf_pos > len)
    {
      status = CAIX_INV_LEN_S;
    }
    #endif /* !FEATURE_MSG_PACK_UNIT_TEST */
  }
  
  #undef MTYPE

  return (status);

} /* xlate_ext_tc_sys_parm */

/*===========================================================================

FUNCTION XLATE_EXT_NLU

DESCRIPTION
  This function translates a Traffic Channel Neighbor List Update
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Neighbor List Update message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_nlu
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  word var_len;

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_nlu_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_nlu_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->nlu.hdr );

    msg_pos = FENDPOS(cai_nlu_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED, 
         &msg_pos, buf_ptr, &int_ptr->nlu.hdr.msg_int,
         int_ptr->nlu.msg_type,
         int_ptr->nlu.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->nlu.hdr, int_ptr->nlu.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->nlu.pilot_inc =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix.pilot_inc));
        msg_pos += FSIZ(MTYPE, fix.pilot_inc);

        var_len = len - msg_pos; 

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->nlu.hdr.msg_int.maci_incl)
        {
          var_len -= FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        int_ptr->nlu.num_nghbr = var_len / FSIZ(cai_nlu_var_type, nghbr_pn);

        for (i=0; i < int_ptr->nlu.num_nghbr; i++)
        {
          int_ptr->nlu.nghbr[i].nghbr_pn =
            b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, var[i].nghbr_pn));
          msg_pos += FSIZ(MTYPE, var[i].nghbr_pn);
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_nlu */

/*===========================================================================

FUNCTION XLATE_EXT_SEND_BURST

DESCRIPTION
  This function translates a Traffic Channel Send Burst DTMF Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Send Burst DTMF message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_send_burst
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through digits */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_sbdtmf_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_sbdtmf_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->sbdtmf.hdr);

    msg_pos = FENDPOS(cai_sbdtmf_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->sbdtmf.hdr.msg_int, 
         int_ptr->sbdtmf.msg_type,
         int_ptr->sbdtmf.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->sbdtmf.hdr, int_ptr->sbdtmf.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->sbdtmf.num_digits =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix.num_digits ));
        msg_pos += FSIZ(MTYPE, fix.num_digits);

        int_ptr->sbdtmf.dtmf_on_length =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix.dtmf_on_length));
        msg_pos += FSIZ(MTYPE, fix.dtmf_on_length);

        int_ptr->sbdtmf.dtmf_off_length =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix.dtmf_off_length));
        msg_pos += FSIZ(MTYPE, fix.dtmf_off_length );

        for (i=0; i < int_ptr->sbdtmf.num_digits; i++)
        {
          int_ptr->sbdtmf.digit[i] = b_unpackb(buf_ptr, msg_pos,
            FSIZ(MTYPE, var[i]));
          msg_pos += FSIZ(MTYPE, var[i]);
        }

#ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
        {
          int_ptr->sbdtmf.con_ref_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix2.con_ref_incl));
          msg_pos += FSIZ(MTYPE, fix2.con_ref_incl);

          if (int_ptr->sbdtmf.con_ref_incl)
          {
            int_ptr->sbdtmf.con_ref =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fix2.con_ref));
            msg_pos += FSIZ(MTYPE, fix2.con_ref);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_send_burst */

/*===========================================================================

FUNCTION XLATE_EXT_PWR_CTL

DESCRIPTION
  This function translates a Traffic Channel Power Control Parameters
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Power Control Parameters message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pwr_ctl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
 
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_pwr_ctl_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_pwr_ctl_type))
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->pwr_ctl.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->pwr_ctl.hdr.msg_int,
         int_ptr->pwr_ctl.msg_type,
         int_ptr->pwr_ctl.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->pwr_ctl.hdr, int_ptr->pwr_ctl.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->pwr_ctl.pwr_rep_thresh =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_rep_thresh));
        msg_pos += FSIZ(MTYPE, pwr_rep_thresh);

        int_ptr->pwr_ctl.pwr_rep_frames =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_rep_frames));
        msg_pos += FSIZ(MTYPE, pwr_rep_frames );

        int_ptr->pwr_ctl.pwr_thresh_enable =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_thresh_enable));
        msg_pos += FSIZ(MTYPE, pwr_thresh_enable);

        int_ptr->pwr_ctl.pwr_period_enable =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_period_enable));
        msg_pos += FSIZ(MTYPE, pwr_period_enable );

        int_ptr->pwr_ctl.pwr_rep_delay =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pwr_rep_delay));
        msg_pos += FSIZ(MTYPE, pwr_rep_delay);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_pwr_ctl */

/*===========================================================================

FUNCTION XLATE_EXT_RET_PARMS

DESCRIPTION
  This function translates a Traffic Channel Retrieve Parameters
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Retrieve Parameters message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None.

===========================================================================*/

word xlate_ext_ret_parms
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index through parameter ids */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  word var_len;

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
    
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_ret_parms_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_ret_parms_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->ret.hdr);

    msg_pos = FENDPOS(cai_ret_parms_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->ret.hdr.msg_int,
         int_ptr->ret.msg_type,
         int_ptr->ret.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->ret.hdr, int_ptr->ret.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        var_len = len - msg_pos;

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->ret.hdr.msg_int.maci_incl)
        {
          var_len -= FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        int_ptr->ret.num_parms = var_len / FSIZ(cai_ret_parms_var_type, parameter_id);

        for (i=0; i < int_ptr->ret.num_parms; i++)
        {
          int_ptr->ret.parameter_id[i] =
            b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, var[i]));
          msg_pos += FSIZ(MTYPE, var[i]);
        }
      }
    }
  }

  #undef MTYPE
  return (status);

} /* xlate_ext_ret_parms */

/*===========================================================================

FUNCTION XLATE_EXT_SET_PARM

DESCRIPTION
  This function translates a Traffic Channel Set Parameters Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Set Parameters message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_set_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word buf_pos;
    /* Location of next bit in buffer to be processed */
  word i;
    /* Index through parameters */
  word rec_min_len;

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
      
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_set_parm_type

  /* -----------------------
  ** Initialize status to ok
  ** ----------------------- */
  status = CAIX_DONE_S;

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( cai_set_parm_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* --------------
    ** Unpack message
    ** -------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->set.hdr);

    buf_pos = FENDPOS(MTYPE, fix.hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &buf_pos, buf_ptr, &int_ptr->set.hdr.msg_int, 
         int_ptr->set.msg_type,
         int_ptr->set.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &buf_pos, buf_ptr, 
          &int_ptr->set.hdr, int_ptr->set.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->set.num_parms = 0;

        rec_min_len = FSIZ(MTYPE, var.parameter_id) +
          FSIZ(MTYPE, var.parameter_len);

#ifdef FEATURE_IS2000_REL_C
        if (int_ptr->set.hdr.msg_int.maci)
        {
          rec_min_len += FSIZ(cai_msg_int_type, maci);
        }
#endif /* FEATURE_IS2000_REL_C */

        /* -------------------------------------
        ** Loop through bits until reserved bits
        ** ------------------------------------- */
        while ((len > buf_pos)  && ((len - buf_pos) >= rec_min_len))
        {
          /* -----------------------------------------
          ** Unpack parameter id and parameter_len and
          ** increment buf_pos accordingly
          ** ----------------------------------------- */
          i = int_ptr->set.num_parms;  /* Set parameter index */

          int_ptr->set.parms[i].parameter_id =
            b_unpackw(buf_ptr, buf_pos, FSIZ(MTYPE, var.parameter_id));
          buf_pos += FSIZ(MTYPE, var.parameter_id);

          int_ptr->set.parms[i].parameter_len =
            b_unpackw(buf_ptr, buf_pos, FSIZ(MTYPE, var.parameter_len));
          buf_pos += FSIZ(MTYPE, var.parameter_len);

          if ((len - buf_pos) >= int_ptr->set.parms[i].parameter_len)
          {
            /* ---------------------------------------------------------
            ** There is enough room left in the buffer for the parameter
            ** --------------------------------------------------------- */
            if (int_ptr->set.parms[i].parameter_len > 31)
            {
              b_unpackq(buf_ptr, buf_pos,
                        int_ptr->set.parms[i].parameter_len + 1,
                        int_ptr->set.parms[i].parameter.parm_q);
            }
            else if (int_ptr->set.parms[i].parameter_len > 15)
            {
              int_ptr->set.parms[i].parameter.parm_d =
                b_unpackd(buf_ptr, buf_pos,
                          int_ptr->set.parms[i].parameter_len + 1);
            }
            else if (int_ptr->set.parms[i].parameter_len > 7)
            {
              int_ptr->set.parms[i].parameter.parm_w =
                b_unpackw(buf_ptr, buf_pos,
                          int_ptr->set.parms[i].parameter_len + 1);
            }
            else
            {
              int_ptr->set.parms[i].parameter.parm_b =
                b_unpackb(buf_ptr, buf_pos,
                          int_ptr->set.parms[i].parameter_len + 1);
            }

            /* -------------------------
            ** Increment buffer position
            ** ------------------------- */
            buf_pos += int_ptr->set.parms[i].parameter_len + 1;

            /* ------------------------------
            ** Increment number of parameters
            ** ------------------------------ */
            int_ptr->set.num_parms++;
          }
          else
          {
            /* --------------------------------------------------------
            ** There is an error in the message -> stop message parsing
            ** -------------------------------------------------------- */
            break;
          }
        } /* while */
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_set_parm */

/*===========================================================================

FUNCTION XLATE_EXT_SSD_UP

DESCRIPTION
  This function translates a Traffic Channel SSD Update Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the SSD Update message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ssd_up
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */

  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
      
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_ssd_up_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_ssd_up_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->ssd_up.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED, 
         &msg_pos, buf_ptr, &int_ptr->ssd_up.hdr.msg_int,
         int_ptr->ssd_up.msg_type,
         int_ptr->ssd_up.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->ssd_up.hdr, int_ptr->ssd_up.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE,  randssd),
                  int_ptr->ssd_up.randssd);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_ssd_up */

/*===========================================================================

FUNCTION XLATE_EXT_MOB_REG

DESCRIPTION
  This function translates a Traffic Channel Mobile Station Registered
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Mobile Station Registered message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_mob_reg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
         
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_registered_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_registered_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->reg.hdr);

    msg_pos = FENDPOS(cai_registered_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED, 
         &msg_pos, buf_ptr, &int_ptr->reg.hdr.msg_int,
         int_ptr->reg.msg_type,
         int_ptr->reg.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->reg.hdr, int_ptr->reg.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->reg.sid =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, sid));
        msg_pos += FSIZ(MTYPE, sid);

        int_ptr->reg.nid =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, nid));
        msg_pos += FSIZ(cai_registered_type, nid);

        int_ptr->reg.reg_zone =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, reg_zone));
        msg_pos += FSIZ(MTYPE, reg_zone);

        int_ptr->reg.total_zones =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, total_zones));
        msg_pos += FSIZ(MTYPE, total_zones);

        int_ptr->reg.zone_timer =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, zone_timer));
        msg_pos += FSIZ(MTYPE, zone_timer);

        int_ptr->reg.mult_sids =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, mult_sids));
        msg_pos += FSIZ(MTYPE, mult_sids);

        int_ptr->reg.mult_nids =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, mult_nids));
        msg_pos += FSIZ(MTYPE, mult_nids);

        int_ptr->reg.base_lat =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, base_lat));
        msg_pos += FSIZ(MTYPE, base_lat);

        int_ptr->reg.base_long =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, base_long));
        msg_pos += FSIZ(MTYPE, base_long);

        int_ptr->reg.reg_dist =
          b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, reg_dist));
        msg_pos += FSIZ(MTYPE, reg_dist);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_mob_reg */

/*===========================================================================

FUNCTION XLATE_EXT_TC_STREQ

DESCRIPTION
  This function translates a Forward Traffic Channel Status Request Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Status Request message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_streq
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  caii_tc_streq_type  *i_ptr = &int_ptr->tc_streq;
    /* Pointer to Status Request internal message */
  word i;
    /* Index for looping through info record types */
  byte qual_len;
    /* For receiving length of qualfication information */
  word msg_pos;
    /* For keeping track of bit offset into message */
  word status;
  /* Status returned to calling procedure */
    
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
      
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_tc_streq_fix_type
  /* Set up MTYPE for PARAMS macro */

  status = CAIX_DONE_S;

  if (len < sizeof(MTYPE))
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &i_ptr->hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED, 
         &msg_pos, buf_ptr, &i_ptr->hdr.msg_int, i_ptr->msg_type,
         i_ptr->hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, &i_ptr->hdr,
                                         i_ptr->msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        i_ptr->qual = b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, qual_typ));
        msg_pos += FSIZ(MTYPE, qual_typ);

        qual_len = (byte)(b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, qual_len)) * 8);
        msg_pos += FSIZ(MTYPE, qual_len);

        if (sizeof(MTYPE) + qual_len > len) /* Messge big enough? */
        {
          status =  CAIX_INV_LEN_S;
          return ( status ); /* Message too small for qual len to fit */
        }

        if (i_ptr->qual == CAI_NO_QUAL) /* If no qual info specified */
        {
          i_ptr->band = CAI_BAND_CLASS0;         /* Assume cellular band */

          i_ptr->op_mode = CAI_IS95_CDMA_OP_MODE; /* And CDMA mode */

          msg_pos += qual_len; /* Skip over qual info */
        }
        else if (i_ptr->qual == CAI_BAND_QUAL) /* Band qualification specified */
        {
          if (sizeof(cai_qual_info1_type) > qual_len) /* Will it fit? */
          {
            status =  CAIX_INV_LEN_S ;
            return (status); /* Message too small for band qual info */
          }
          else
          {
            i_ptr->band =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_qual_info1_type, band));
            /* Translate specified band qualfication */

            i_ptr->op_mode = CAI_IS95_CDMA_OP_MODE; /* Assume CDMA mode */

            msg_pos += qual_len; /* Skip over qual info field */
          }
        }
        else if (i_ptr->qual == CAI_BAND_OP_MODE_QUAL) /* Band and mode qual */
        {
          if (sizeof(cai_qual_info2_type) > qual_len) /* Will qual info fit? */
          {
            status = CAIX_INV_LEN_S ;
            return (status); /* Message too small for band and mode */
          }
          else
          {
            i_ptr->band =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_qual_info2_type, band));
            /* Translate band qual info */

            i_ptr->op_mode =
              b_unpackb(buf_ptr, msg_pos + FSIZ(cai_qual_info2_type, band),
                        FSIZ(cai_qual_info2_type, op_mode));
            /* Translate mode qual info */
            msg_pos += qual_len; /* Skip over qual info field */
          }
        }
        else
        {
          status = CAIX_INV_MSG_S;
          return (status);  /* Unknown qualification type */
        }

        i_ptr->num_fields =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_fields));
        /* Translate number of info rec requests. */
        msg_pos += FSIZ(MTYPE, num_fields);

        if (msg_pos + (i_ptr->num_fields * sizeof(cai_streq_var_type)) > len )
        {
          status = CAIX_INV_LEN_S ;
          return (status); /* Message too small */
        }

        /* Translate info rec requests */
        for (i = 0; i < i_ptr->num_fields; i++)
        {
          i_ptr->rec_typ[i] =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_streq_var_type, rec_typ));
          msg_pos += FSIZ(cai_streq_var_type, rec_typ);
        }
      }
    }
  }

  #undef MTYPE  /* Deactivate MTYPE definition */

  return ( status );

} /* xlate_ext_tc_streq */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_CFG

DESCRIPTION
  This function translates a Service Configuration Record from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_cfg
(
  word len,
    /* Length, in bits, of message fragment containing the service
       configuration record. */

  byte *buf_ptr,
    /* Pointer to received message containing the service
       configuration record. */

  word buf_pos,
    /* Offset in message at which service configuration record
       begins. */

  caii_srv_cfg_type *int_ptr,
    /* Pointer to where translated service configuration record
       should be placed. */

  boolean full_cfg
    /* Is this a full config msg? */
    /* (does it have the for and rev multi_frame_offset fields?) */
)
{
  word  status;
    /* Status returned to calling procedure. */

  word  rec_len;
    /* For keeping track of the number of bits remaining to translate
       in the service configuration record. */

  word  con_len;
    /* For keeping track of the number of bits in the service option
       connection record being translated. */

  word temp_buf_pos;
  word sch_rec_len;

  word  i;
    /* For indexing through the service option connection records. */

  if (len < sizeof(cai_rec_hdr_type))
    /* Is there enough room for an info rec header? */
  {
    status = CAIX_INV_LEN_S;    /* Message too short */
  }

  else if (b_unpackb(REC_P(record_type)) != CAI_FTC_SRV_CFG_REC)
  {
    status = CAIX_INV_MSG_S;  /* Wrong record type */
  }

  else if ((rec_len = b_unpackw(REC_P(record_len)) * 8) <
            sizeof(cai_srv_cfg_hdr_type) )
  {
    status = CAIX_INV_LEN_S;
      /* There isn't enough room even to hold a service configuration
         record with zero service option connections. */
  }

  else if (len <sizeof(cai_rec_hdr_type) + rec_len)
  {
    status = CAIX_INV_LEN_S;
      /* There isn't enough room to hold a service configuration record
         of the size specified in the information record header. */
  }

  else
  {
    buf_pos += sizeof(cai_rec_hdr_type); /* Skip over info rec header */

    global_buf_pos = buf_pos + rec_len;

    /* Unpack fields of service config record header */
    int_ptr->fwd_mux   = b_unpackw(HDR_P(fwd_mux));
    int_ptr->rev_mux   = b_unpackw(HDR_P(rev_mux));
    int_ptr->fwd_rates = b_unpackb(HDR_P(fwd_rates));
    int_ptr->rev_rates = b_unpackb(HDR_P(rev_rates));
    int_ptr->num_con   = b_unpackb(HDR_P(num_con));
      /* Note that the num_con field will be set to the number of
         service option connection records specified in the received
         service configuration record, but the actual number of service
         option configuration records translated is limited to
         CAII_SRV_CON_MAX. */

    rec_len -= sizeof(cai_srv_cfg_hdr_type);
      /* Adjust remaining record size */

    buf_pos += sizeof(cai_srv_cfg_hdr_type);
      /* Advance over record header */

    status = CAIX_DONE_S;
      /* Set good status. This may get changed in the
         following for loop. */

    for (i = 0; i<int_ptr->num_con && i<CAII_SRV_CON_MAX; i++)
      /* Translate each service option connection record contained in
         the service configuration record. Stop when either the specified
         number of records are translated, or when the maximum number of
         records supported by the internal type is reached. */
    {
      /* Now we know we can at least look at the record length field */

      if (rec_len < (con_len = b_unpackw(CON_P(rec_len))*8))
      /* Is there room for a service option connection record of the
         actual length specified in the record? */
      {
        status = CAIX_INV_LEN_S;  /* Not enough room */
        break;
      }

      else
      {
        word cur;

        /* Translate the fields of the service option connection rec */
        int_ptr->con[i].con_ref  = b_unpackb(CON_P(con_ref));
        int_ptr->con[i].so       = b_unpackw(CON_P(so));
        int_ptr->con[i].fwd_traf = b_unpackb(CON_P(fwd_traf));
        int_ptr->con[i].rev_traf = b_unpackb(CON_P(rev_traf));

        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        {
          int_ptr->con[i].ui_encrypt_mode = b_unpackb(CON_P(ui_encrypt_mode));
          int_ptr->con[i].sr_id           = b_unpackb(CON_P(sr_id));
          int_ptr->con[i].rlp_info_incl   = b_unpackb( CON_P(rlp_info_incl));
          temp_buf_pos = buf_pos + sizeof(cai_srv_cfg_con_type);

          if (int_ptr->con[i].rlp_info_incl)
          {
            #define VTYPE cai_srv_cfg_con_var_type

            int_ptr->con[i].rlp_blob_len = b_unpackb(buf_ptr, temp_buf_pos,
              FSIZ(VTYPE, rlp_blob_len));
            temp_buf_pos += FSIZ(VTYPE, rlp_blob_len);

            for (cur=0;cur<int_ptr->con[i].rlp_blob_len;cur++)
            {
              int_ptr->con[i].rlp_blob[cur] = b_unpackb(buf_ptr, temp_buf_pos,
                FSIZ(VTYPE, rlp_blob));
              temp_buf_pos += FSIZ(VTYPE, rlp_blob);
            }

            #undef VTYPE
          }

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            #define FTYPE cai_srv_cfg_con_is2000_rel_a_fix_type

            int_ptr->con[i].qos_parms_incl = b_unpackb(buf_ptr, temp_buf_pos,
              FSIZ(FTYPE, qos_parms_incl));
            temp_buf_pos += FSIZ(FTYPE, qos_parms_incl);

            if (int_ptr->con[i].qos_parms_incl)
            {
              #define VTYPE cai_srv_cfg_con_is2000_rel_a_var_type

              int_ptr->con[i].qos_parms_len = b_unpackb(buf_ptr, temp_buf_pos,
                FSIZ(VTYPE, qos_parms_len));
              temp_buf_pos += FSIZ(VTYPE, qos_parms_len);

              for (cur=0; cur<int_ptr->con[i].qos_parms_len; cur++)
              {
                int_ptr->con[i].qos_parms[cur] = b_unpackb(buf_ptr,
                  temp_buf_pos, FSIZ(VTYPE, qos_parms));
                temp_buf_pos += FSIZ(VTYPE, qos_parms);
              }

              #undef VTYPE
            }

            #undef FTYPE
          } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) */
#endif /* FEATURE_IS2000_REL_A */

        } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000) */
        rec_len -= con_len;    /* Adjust remaining record length */
        buf_pos += con_len;  /* Move ptr to start of next rec */
      }
    } /* end for */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      #define FTYPE cai_srv_cfg_is2000_type

      int_ptr->fch_cc_incl = b_unpackb(buf_ptr, buf_pos, FSIZ(FTYPE, fch_cc_incl));
      buf_pos += FSIZ(FTYPE, fch_cc_incl);

      if (int_ptr->fch_cc_incl)
      {
        int_ptr->fch_frame_size = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, fch_frame_size));
        buf_pos += FSIZ(FTYPE, fch_frame_size);

        int_ptr->for_fch_rc = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, for_fch_rc));
        buf_pos += FSIZ(FTYPE, for_fch_rc);

        int_ptr->rev_fch_rc = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, rev_fch_rc));
        buf_pos += FSIZ(FTYPE, rev_fch_rc);
      }

      int_ptr->dcch_cc_incl = b_unpackb(buf_ptr, buf_pos,
        FSIZ(FTYPE, dcch_cc_incl));
      buf_pos += FSIZ(FTYPE, dcch_cc_incl);

      if (int_ptr->dcch_cc_incl)
      {
        int_ptr->dcch_frame_size = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, dcch_frame_size));
        buf_pos += FSIZ(FTYPE, dcch_frame_size);

        int_ptr->for_dcch_rc = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, for_dcch_rc));
        buf_pos += FSIZ(FTYPE, for_dcch_rc);

        int_ptr->rev_dcch_rc = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, rev_dcch_rc));
        buf_pos += FSIZ(FTYPE, rev_dcch_rc);
      }

      int_ptr->for_sch_cc_incl = b_unpackb(buf_ptr,buf_pos,
        FSIZ(FTYPE, for_sch_cc_incl));
      buf_pos += FSIZ(FTYPE, for_sch_cc_incl);

      if (int_ptr->for_sch_cc_incl)
      {
        int_ptr->num_for_sch = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, num_for_sch));
        buf_pos += FSIZ(FTYPE, num_for_sch);

        #define VTYPE1 cai_for_sch_type
        #define VTYPE2 cai_sch_chn_cfg_type

        for (i=0; i<int_ptr->num_for_sch; i++)
        {
          int_ptr->for_sch[i].for_sch_id = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE1, for_sch_id));
          buf_pos += FSIZ(VTYPE1, for_sch_id);

          int_ptr->for_sch[i].for_sch_mux = b_unpackw(buf_ptr, buf_pos,
            FSIZ(VTYPE1, for_sch_mux));
          buf_pos += FSIZ(VTYPE1, for_sch_mux);

          temp_buf_pos = buf_pos;

          sch_rec_len = b_unpackb(buf_ptr, buf_pos, FSIZ(VTYPE2, sch_rec_len));
          buf_pos += FSIZ(VTYPE2, sch_rec_len);

          int_ptr->for_sch[i].sch_chn_cfg.sch_rc = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE2, sch_rc));
          buf_pos += FSIZ(VTYPE2, sch_rc);

          int_ptr->for_sch[i].sch_chn_cfg.coding = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE2, coding));
          buf_pos += FSIZ(VTYPE2, coding);

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            int_ptr->for_sch[i].sch_chn_cfg.frame_40_used = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, frame_40_used));
            buf_pos += FSIZ(VTYPE2, frame_40_used);

            int_ptr->for_sch[i].sch_chn_cfg.frame_80_used = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, frame_80_used));
            buf_pos += FSIZ(VTYPE2, frame_80_used);

            int_ptr->for_sch[i].sch_chn_cfg.max_rate = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, max_rate));
            buf_pos += FSIZ(VTYPE2, max_rate);
          }
#endif /* FEATURE_IS2000_REL_A */

          buf_pos = temp_buf_pos + sch_rec_len*8;
        } /* end for */

        #undef VTYPE1
        #undef VTYPE2

      } /* end if (for_sch_cc_incl) */

      int_ptr->rev_sch_cc_incl = b_unpackb(buf_ptr, buf_pos,
        FSIZ(FTYPE, rev_sch_cc_incl));
      buf_pos += FSIZ(FTYPE, rev_sch_cc_incl);

      if (int_ptr->rev_sch_cc_incl)
      {
        int_ptr->num_rev_sch = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, num_rev_sch));
        buf_pos += FSIZ(FTYPE, num_rev_sch);

        #define VTYPE1 cai_rev_sch_type
        #define VTYPE2 cai_sch_chn_cfg_type

        for (i=0; i<int_ptr->num_rev_sch; i++)
        {
          int_ptr->rev_sch[i].rev_sch_id = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE1, rev_sch_id));
          buf_pos += FSIZ(VTYPE1, rev_sch_id);

          int_ptr->rev_sch[i].rev_sch_mux = b_unpackw(buf_ptr, buf_pos,
            FSIZ(VTYPE1, rev_sch_mux));
          buf_pos += FSIZ(VTYPE1, rev_sch_mux);

          temp_buf_pos = buf_pos;

          sch_rec_len = b_unpackb(buf_ptr, buf_pos, FSIZ(VTYPE2, sch_rec_len));
          buf_pos += FSIZ(VTYPE2, sch_rec_len);

          int_ptr->rev_sch[i].sch_chn_cfg.sch_rc = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE2, sch_rc));
          buf_pos += FSIZ(VTYPE2, sch_rc);

          int_ptr->rev_sch[i].sch_chn_cfg.coding = b_unpackb(buf_ptr, buf_pos,
            FSIZ(VTYPE2, coding));
          buf_pos += FSIZ(VTYPE2, coding);

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            int_ptr->rev_sch[i].sch_chn_cfg.frame_40_used = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, frame_40_used));
            buf_pos += FSIZ(VTYPE2, frame_40_used);

            int_ptr->rev_sch[i].sch_chn_cfg.frame_80_used = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, frame_80_used));
            buf_pos += FSIZ(VTYPE2, frame_80_used);

            int_ptr->rev_sch[i].sch_chn_cfg.max_rate = b_unpackb(buf_ptr,
              buf_pos, FSIZ(VTYPE2, max_rate));
            buf_pos += FSIZ(VTYPE2, max_rate);
          }
#endif /* FEATURE_IS2000_REL_A */

          buf_pos = temp_buf_pos + sch_rec_len * 8;
        } /* end for */

        #undef VTYPE1
        #undef VTYPE2

      } /* end if (rev_sch_cc_incl) */

      #undef FTYPE

#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        #define FTYPE cai_srv_cfg_is2000_rel_b_type

        int_ptr->fch_dcch_mux_option_ind = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, fch_dcch_mux_option_ind));
        buf_pos += FSIZ(FTYPE, fch_dcch_mux_option_ind);

        if (int_ptr->fch_dcch_mux_option_ind ==
            CAI_MUX_OPTION_DIFF_FOR_FCH_AND_DCCH)
        {
          int_ptr->for_dcch_mux = b_unpackw(buf_ptr, buf_pos,
            FSIZ(FTYPE, for_dcch_mux));
          buf_pos += FSIZ(FTYPE, for_dcch_mux);

          int_ptr->rev_dcch_mux = b_unpackw(buf_ptr, buf_pos,
            FSIZ(FTYPE, rev_dcch_mux));
          buf_pos += FSIZ(FTYPE, rev_dcch_mux);
        }

        #undef FTYPE
      } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) */
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        #define FTYPE cai_srv_cfg_is2000_rel_c_fix_type
        #define VTYPE cai_srv_cfg_is2000_rel_c_var_type

        int_ptr->for_pdch_cc_incl = b_unpackb(buf_ptr, buf_pos,
          FSIZ(FTYPE, for_pdch_cc_incl));
        buf_pos += FSIZ(FTYPE, for_pdch_cc_incl);

        if (int_ptr->for_pdch_cc_incl)
        {
          int_ptr->for_pdch_mux_option = b_unpackw(buf_ptr, buf_pos,
            FSIZ(VTYPE, for_pdch_mux_option));
          buf_pos += FSIZ(VTYPE, for_pdch_mux_option);

          int_ptr->for_pdch_rc = b_unpackw(buf_ptr, buf_pos,
            FSIZ(VTYPE, for_pdch_rc));
          buf_pos += FSIZ(VTYPE, for_pdch_rc);
        }

        #undef VTYPE
        #undef FTYPE

      } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) */
#endif /* FEATURE_IS2000_REL_C */


#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000) */

    if (buf_pos > global_buf_pos)
    {
      status = CAIX_INV_LEN_S;
      MSG_ERROR("Gone past len of SCR %d %d", buf_pos, global_buf_pos, 0);
    }

  } /* else */

  return ( status );

} /* xlate_ext_srv_cfg */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_REQ

DESCRIPTION
  This function translates a Service Request Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_req
(
  word len,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to received message to be translated */

  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
    
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ftc_srv_req_fix_type

  /* Set up MTYPE for PARAMS macro */

  if (len < sizeof(MTYPE))
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->srv_req.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->srv_req.hdr.msg_int,
         int_ptr->srv_req.msg_type,
         int_ptr->srv_req.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->srv_req.hdr, int_ptr->srv_req.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->srv_req.req_seq =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, req_seq));
        msg_pos += FSIZ(MTYPE, req_seq);

        int_ptr->srv_req.purp = b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, purp));
        msg_pos += FSIZ(MTYPE, purp);

        if ( int_ptr->srv_req.purp == CAI_SRV_PRO_PURP )
        {
          /* Translate service configuration record */
          status = xlate_ext_srv_cfg(len - sizeof(MTYPE), buf_ptr, msg_pos,
                                     &int_ptr->srv_req.cfg ,0);
        }
      }
    }
  } /* else */

  #undef MTYPE  /* Deactivate MTYPE definition */

  return (status);

} /* xlate_ext_srv_req */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_RSP

DESCRIPTION
  This function translates a Service Response Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_rsp
(
  word len,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to received message to be translated */

  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ftc_srv_rsp_fix_type
  /* Set up MTYPE for PARAMS macro */

  if ( len < sizeof( MTYPE ) )
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->srv_rsp.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->srv_rsp.hdr.msg_int,
         int_ptr->srv_rsp.msg_type,
         int_ptr->srv_rsp.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->srv_rsp.hdr, int_ptr->srv_rsp.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->srv_rsp.req_seq =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, req_seq));
        msg_pos += FSIZ(MTYPE, req_seq);

        int_ptr->srv_rsp.purp = b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, purp));
        msg_pos += FSIZ(MTYPE, purp);

        if (int_ptr->srv_rsp.purp == CAI_SRV_PRO_PURP)
        {
          /* Translate service configuration record */
          status = xlate_ext_srv_cfg(len - sizeof(MTYPE), buf_ptr, msg_pos,
                                     &int_ptr->srv_rsp.cfg ,0);
        }
      }
    }
  } /* else */

  #undef MTYPE  /* Deactivate MTYPE definition */

  return (status);

} /* xlate_ext_srv_rsp */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_CON

DESCRIPTION
  This function translates a Service Connect Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_con
(
  word len,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to received message to be translated */

  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word local_len;
#ifdef FEATURE_IS2000_REL_A
  word i;
#endif /* FEATURE_IS2000_REL_A */

  word buf_pos = 0;

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
    
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_srv_con_fix_type

  /* Set up MTYPE for PARAMS macro */

  if ( len < sizeof(MTYPE) )
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->srv_con.hdr);

    buf_pos = FENDPOS(cai_srv_con_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &buf_pos, buf_ptr, &int_ptr->srv_con.hdr.msg_int,
         int_ptr->srv_con.msg_type,
         int_ptr->srv_con.hdr.ack_req         
         )) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
    if ((status = xlate_ext_ext_enc_tc(&len, &buf_pos, buf_ptr, 
        &int_ptr->srv_con.hdr, int_ptr->srv_con.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */

    int_ptr->srv_con.use_time =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, use_time));
    buf_pos += FSIZ(MTYPE, use_time);
    
    int_ptr->srv_con.action_time =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, action_time));
    buf_pos += FSIZ(MTYPE, action_time);
    
    int_ptr->srv_con.con_seq =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, con_seq));
    buf_pos += FSIZ(MTYPE, con_seq);

#ifndef FEATURE_IS2000_REL_A
    buf_pos = sizeof(MTYPE);
    local_len = 0;
#else
    buf_pos += FSIZ(MTYPE,reserved);
    
    int_ptr->srv_con.use_old_srv_cfg =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, use_old_serv_config));
    buf_pos += FSIZ(MTYPE, use_old_serv_config);

#ifdef FEATURE_IS2000_REL_C
    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) && 
        (int_ptr->srv_con.use_old_srv_cfg == CAI_USE_OLD_SRV_CFG_WITH_GIVEN_SR_ID))
    {
      int_ptr->srv_con.sr_id =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_srv_con_rel_c_type, sr_id));
      buf_pos += FSIZ(cai_srv_con_rel_c_type, sr_id);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
    }
#endif /* FEATURE_IS2000_REL_C */


    int_ptr->srv_con.sync_id_incl =
      b_unpackb(buf_ptr, buf_pos, FSIZ(MTYPE, sync_id_incl));
    buf_pos += FSIZ(MTYPE, sync_id_incl);
    
    /* we do this to be able to calculate the length of the
       sync_id related fields in the message */
    local_len = buf_pos;
    
    /* sync_id processing */
    if (int_ptr->srv_con.sync_id_incl)
    {
      int_ptr->srv_con.sync_id_len =
        b_unpackb(buf_ptr, buf_pos,
      FSIZ(cai_srv_cfg_sync_id_type, sync_id_len));
      buf_pos += FSIZ(cai_srv_cfg_sync_id_type, sync_id_len);
      
      for (i=0; i<int_ptr->srv_con.sync_id_len; i++)
      {
        int_ptr->srv_con.sync_id[i] =
          b_unpackb(buf_ptr, buf_pos, FSIZ(cai_srv_cfg_sync_id_type, sync_id));
        buf_pos += FSIZ(cai_srv_cfg_sync_id_type, sync_id);
      }
    } /* if (int_ptr->srv_con.sync_id_incl) */
    
    /* calculate the length of the sync_id related fields for use below.*/
    local_len = buf_pos - local_len;
    /* Translate service configuration record */
    if ((int_ptr->srv_con.use_old_srv_cfg == CAI_USE_SRV_CFG_IN_MSG) ||
        (int_ptr->srv_con.use_old_srv_cfg == CAI_USE_OLD_SRV_CFG_WITH_CFG_IN_MSG)
       )
#endif /* FEATURE_IS2000_REL_A */
    {
      status = xlate_ext_srv_cfg(len - sizeof(MTYPE) - local_len,
         buf_ptr, buf_pos, &int_ptr->srv_con.cfg ,1);

      if (status != CAIX_DONE_S)
      {
        return status;
      }

      buf_pos = global_buf_pos;
    }
    
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
#ifdef FEATURE_IS2000_REL_A
      if ((int_ptr->srv_con.use_old_srv_cfg == CAI_USE_SRV_CFG_IN_MSG) ||
          (int_ptr->srv_con.use_old_srv_cfg == CAI_USE_OLD_SRV_CFG_WITH_CFG_IN_MSG)
         )
#endif /* FEATURE_IS2000_REL_A */
      {
        xlate_int_non_neg_srv_cfg(buf_ptr, &buf_pos,
                                  &(int_ptr->srv_con.non_neg_cfg));
      }
    }
    
#ifdef FEATURE_IS2000_REL_A
    int_ptr->srv_con.cc.cc_info_incl = 0;
    
    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) &&
        (int_ptr->srv_con.use_old_srv_cfg == CAI_USE_SRV_CFG_IN_MSG))
    {
      int_ptr->srv_con.cc.cc_info_incl =  b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_cc_info_fix_type, cc_info_incl));
      buf_pos += FSIZ(cai_cc_info_fix_type, cc_info_incl);
      
      if (int_ptr->srv_con.cc.cc_info_incl)
      {
        int_ptr->srv_con.cc.num_calls_assign =  b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_cc_info_fix_type, num_calls_assign));
        buf_pos += FSIZ(cai_cc_info_fix_type, num_calls_assign);
  
        for (i=0; i<int_ptr->srv_con.cc.num_calls_assign && i<CAI_SCM_MAX_NUM_CALLS_ASSIGN; i++ )
        {
          int_ptr->srv_con.cc.conn[i].con_ref =
            b_unpackb(buf_ptr, buf_pos, FSIZ(cai_cc_info_type, con_ref));
          buf_pos += FSIZ(cai_cc_info_type, con_ref);
    
          int_ptr->srv_con.cc.conn[i].response_ind =
            b_unpackb(buf_ptr, buf_pos, FSIZ(cai_cc_info_type, response_ind));
          buf_pos += FSIZ(cai_cc_info_type, response_ind);
    
          if (int_ptr->srv_con.cc.conn[i].response_ind)
          {
            int_ptr->srv_con.cc.conn[i].tag =
              b_unpackb(buf_ptr, buf_pos, FSIZ(cai_cc_info_type, tag));
            buf_pos += FSIZ(cai_cc_info_type, tag);
          }
          else
          {
            int_ptr->srv_con.cc.conn[i].bypass_alert_answer =
              b_unpackb(buf_ptr, buf_pos,
            FSIZ(cai_cc_info_type, bypass_alert_answer));
            buf_pos += FSIZ(cai_cc_info_type, bypass_alert_answer);
          }
        } // for (..)
      }
    } // if ( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      int_ptr->srv_con.use_type0_plcm =
        b_unpackb(buf_ptr, buf_pos, FSIZ(cai_srv_con_rel_c_type, use_type0_plcm));
      buf_pos += FSIZ(cai_srv_con_rel_c_type, use_type0_plcm);
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    /* Make sure the message contained all the fields advertised by the p-rev */
    if (buf_pos > len)
    {
      status = CAIX_INV_LEN_S;
    }

  } /* else length check failed*/

  #undef MTYPE  /* Deactivate MTYPE definition */

  return (status);

} /* xlate_ext_srv_con */

/*===========================================================================

FUNCTION XLATE_EXT_SRV_CTL

DESCRIPTION
  This function translates a Service Option Control Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srv_ctl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* For indexing through type specific bytes */
  word msg_pos;
    /* Position of record in message */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
      
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ftc_srv_ctl_fix_type
  /* Set up MTYPE for PARAMS macro */

  if ( len < sizeof(MTYPE) )
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->srv_ctl.hdr);

    msg_pos = FENDPOS(cai_ftc_srv_ctl_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->srv_ctl.hdr.msg_int,
         int_ptr->srv_ctl.msg_type,
         int_ptr->srv_ctl.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->srv_ctl.hdr, int_ptr->srv_ctl.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->srv_ctl.use_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos +=  FSIZ(MTYPE, use_time);

        int_ptr->srv_ctl.action_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
        msg_pos +=  FSIZ(MTYPE, action_time) ;

        int_ptr->srv_ctl.con_ref =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
        msg_pos +=  FSIZ(MTYPE, con_ref);

        int_ptr->srv_ctl.so = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, so));
        msg_pos += FSIZ(MTYPE, so);

        int_ptr->srv_ctl.tsf_len =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, tsf_len));
        msg_pos +=  FSIZ(MTYPE, tsf_len);

        len -= sizeof(MTYPE);   /* Adjust len for remainder of msg */

        #undef MTYPE
        /* Done with this def for MTYPE */

        #define MTYPE cai_ftc_srv_ctl_var_type
        /* Set up MTYPE for PARAMS macro for variable part of msg */

        if (len < int_ptr->srv_ctl.tsf_len * sizeof(MTYPE))
          /* Is the remainder of the message long enough to include the
             number of type specific bytes specified? */
        {
          status = CAIX_INV_LEN_S;  /* Message too short */
        }
        else
        {
          /* Translate the type specific bytes */
          for (i = 0; i < int_ptr->srv_ctl.tsf_len; i++)
          {
            int_ptr->srv_ctl.tsf[i] =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, tsf));

            /* Advance pointer to next byte */
            msg_pos += sizeof(MTYPE);
          } /* for */
        } /* else */
      }
    }
  } /* else */

  #undef MTYPE
  /* Deactivate MTYPE def */

  return (status);

} /* xlate_ext_srv_ctl */

/*===========================================================================

FUNCTION XLATE_EXT_TC_SRV_REDIR

DESCRIPTION
  This function translates a Service Redirection Message from external to
  internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_srv_redir
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* For indexing through type specific bytes */
  word msg_pos;
    /* Position of record in message */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
      
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ftc_srv_redir_fix_type
  /* Set up MTYPE for PARAMS macro */

  if (len < sizeof(MTYPE))
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }

  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tc_srv_redir.hdr);

    msg_pos = FENDPOS(cai_ftc_srv_redir_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tc_srv_redir.hdr.msg_int,
         int_ptr->tc_srv_redir.msg_type, 
         int_ptr->tc_srv_redir.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->tc_srv_redir.hdr, int_ptr->tc_srv_redir.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->tc_srv_redir.return_if_fail =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, return_if_fail));
        msg_pos += FSIZ(MTYPE, return_if_fail);

        int_ptr->tc_srv_redir.delete_tmsi =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, delete_tmsi));
        msg_pos += FSIZ(MTYPE, delete_tmsi);

        int_ptr->tc_srv_redir.redirect_type =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, redirect_type));
        msg_pos += FSIZ(MTYPE, redirect_type);

        int_ptr->tc_srv_redir.record_type =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, record_type));
        msg_pos += FSIZ(MTYPE, record_type);

        int_ptr->tc_srv_redir.record_len =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, record_len));
        msg_pos += FSIZ(MTYPE, record_len);

        #undef MTYPE
        /* Done with this def for MTYPE */

        /* ---------------------
        ** Switch on record type
        ** --------------------- */
        switch (int_ptr->tc_srv_redir.record_type)
        {
          case CAI_NDSS_OFF_INDICATION:
            /* IS-95B, NDSS off, no type specific fields included */
            break;

          case CAI_ANALOG_REDIRECTION_REC:
            int_ptr->tc_srv_redir.redir.rec1.expected_sid =
              b_unpackw(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec1_type, expected_sid));
            msg_pos += FSIZ(cai_redirect_rec1_type, expected_sid);

            int_ptr->tc_srv_redir.redir.rec1.ignore_cdma =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec1_type, ignore_cdma));
            msg_pos += FSIZ(cai_redirect_rec1_type, ignore_cdma);

            int_ptr->tc_srv_redir.redir.rec1.sys_ordering =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec1_type, sys_ordering));
            msg_pos += FSIZ(cai_redirect_rec1_type, sys_ordering);
            int_ptr->tc_srv_redir.redir.rec1.max_redirect_delay = 0;
            break;

          case CAI_CDMA_REDIRECTION_REC:

            #define RTYPE cai_redirect_rec2_type

            int_ptr->tc_srv_redir.redir.rec2.band_class =
              b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, band_class));
            msg_pos += FSIZ(RTYPE, band_class);

            int_ptr->tc_srv_redir.redir.rec2.expected_sid =
              b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_sid));
            msg_pos += FSIZ(RTYPE, expected_sid);

            int_ptr->tc_srv_redir.redir.rec2.expected_nid =
              b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_nid));
            msg_pos += FSIZ(RTYPE, expected_nid);

            msg_pos += FSIZ(RTYPE, reserved);

            int_ptr->tc_srv_redir.redir.rec2.num_chans =
              b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, num_chans));
            msg_pos += FSIZ(RTYPE, num_chans);

            if ((len - msg_pos) >=
                (int_ptr->tc_srv_redir.redir.rec2.num_chans * FSIZ(RTYPE, cdma_chan)))
            {
              for (i=0; i < int_ptr->tc_srv_redir.redir.rec2.num_chans; i++)
              {
                int_ptr->tc_srv_redir.redir.rec2.cdma_chan[i] =
                  b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, cdma_chan));
                msg_pos += FSIZ(RTYPE, cdma_chan);
              }
            }
            else
            {
              status = CAIX_INV_MSG_S;
            }

            #undef RTYPE

            break;

          case CAI_JTACS_REDIRECTION_REC:
            int_ptr->tc_srv_redir.redir.rec4.expected_aid =
              b_unpackw(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec4_type, expected_aid));
            msg_pos += FSIZ(cai_redirect_rec4_type, expected_aid);

            int_ptr->tc_srv_redir.redir.rec4.ignore_cdma =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_redirect_rec4_type, ignore_cdma));
            msg_pos += FSIZ(cai_redirect_rec4_type, ignore_cdma);
            break;

          default:
            MSG_MED("Invalid rec type %d",
              int_ptr->tc_srv_redir.record_type,0,0);
            status = CAIX_INV_MSG_S;
            break;
        } /* end of switch */
      }
    }
  }

  return (status);

} /* xlate_ext_tc_srv_redir */

/*===========================================================================

FUNCTION XLATE_EXT_SCAM

DESCRIPTION
  This function translates a Supplemental Channel Assignment Message from
  external to internal format.

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_scam
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word pi, ch;
    /* For indexing through type specific bytes */
  word msg_pos;
    /* Position of record in message */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_scam_fix1_type
  /* Set up MTYPE for PARAMS macro */

  status = CAIX_DONE_S;

  if (len < sizeof(MTYPE) - 7)
    /* Is message at least long enough to contain the fixed portion? */
  {
    status = CAIX_INV_LEN_S;  /* Message too short */
  }
  else
  {
    /* Translate fixed portion of message */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->scam.fix.hdr);

    msg_pos = FENDPOS(cai_scam_fix1_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->scam.fix.hdr.msg_int,
         int_ptr->scam.fix.msg_type,
         int_ptr->scam.fix.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->scam.fix.hdr, int_ptr->scam.fix.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->scam.fix.use_retry_delay =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, use_retry_delay));
        msg_pos +=  FSIZ(MTYPE, use_retry_delay);

        if (int_ptr->scam.fix.use_retry_delay)
        {
          int_ptr->scam.fix.retry_delay =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, retry_delay));
          msg_pos += FSIZ(MTYPE, retry_delay);
        }

        int_ptr->scam.fix.rev_included =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_included));
        msg_pos += FSIZ(MTYPE, rev_included);

        #undef MTYPE
        /* Done with this def for MTYPE */

        if (int_ptr->scam.fix.rev_included )
        {
          int_ptr->scam.fix.rev_dtx_duration =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, rev_dtx_duration));
          msg_pos += FSIZ(cai_scam_var1_type, rev_dtx_duration);

          int_ptr->scam.fix.expl_rev_start_tm =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, expl_rev_start_tm));
          msg_pos += FSIZ(cai_scam_var1_type, expl_rev_start_tm);

          if (int_ptr->scam.fix.expl_rev_start_tm)
          {
            int_ptr->scam.fix.rev_start_tm =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, rev_start_tm));
            msg_pos += FSIZ(cai_scam_var1_type, rev_start_tm);
          }

          int_ptr->scam.fix.use_rev_dur =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var1_type, use_rev_dur));
          msg_pos += FSIZ(cai_scam_var1_type, use_rev_dur);

          if (int_ptr->scam.fix.use_rev_dur)
          {
            int_ptr->scam.fix.rev_dur =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var1_type, rev_dur));
            msg_pos += FSIZ(cai_scam_var1_type, rev_dur);
          }

          int_ptr->scam.fix.use_rev_hdm_seq =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, use_rev_hdm_seq));
          msg_pos += FSIZ(cai_scam_var1_type, use_rev_hdm_seq);

          if (int_ptr->scam.fix.use_rev_hdm_seq)
          {
            int_ptr->scam.fix.rev_hdm_seq =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, rev_hdm_seq));
            msg_pos += FSIZ(cai_scam_var1_type, rev_hdm_seq);
          }

          int_ptr->scam.fix.num_rev_codes =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, num_rev_codes));
          msg_pos += FSIZ(cai_scam_var1_type, num_rev_codes);

          int_ptr->scam.fix.use_t_add_abt =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, use_t_add_abt));
          msg_pos += FSIZ(cai_scam_var1_type, use_t_add_abt);

          int_ptr->scam.fix.use_scrm_seq =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var1_type, use_scrm_seq));
          msg_pos += FSIZ(cai_scam_var1_type, use_scrm_seq);

          if (int_ptr->scam.fix.use_scrm_seq)
          {
            int_ptr->scam.fix.scrm_seq_num =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, scrm_seq_num));
            msg_pos += FSIZ(cai_scam_var1_type, scrm_seq_num);
          }

          int_ptr->scam.fix.rev_parms_inc =
            b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, rev_parms_inc));
          msg_pos += FSIZ(cai_scam_var1_type, rev_parms_inc);

          if (int_ptr->scam.fix.rev_parms_inc)
          {
            int_ptr->scam.fix.t_mulchan =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, t_mulchan));
            msg_pos += FSIZ(cai_scam_var1_type, t_mulchan);

            int_ptr->scam.fix.begin_pre =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, begin_pre));
            msg_pos += FSIZ(cai_scam_var1_type, begin_pre);

            int_ptr->scam.fix.resume_pre =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var1_type, resume_pre));
            msg_pos += FSIZ(cai_scam_var1_type, resume_pre);
          }
        }

        int_ptr->scam.fix.for_inc =
          b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_fix2_type, for_inc));
        msg_pos += FSIZ(cai_scam_fix2_type, for_inc);

        if (int_ptr->scam.fix.for_inc)
        {
          int_ptr->scam.fix.for_sup_config =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_scam_var2_type, for_sup_config));
          msg_pos += FSIZ(cai_scam_var2_type, for_sup_config);

          /* The following two fields are included if FOR_SUP_CONFIG==1or3,
          ** if the mobile is to start processing the channels.            */
          if ((int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_START) ||
              (int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_SPEC_START))
          {
            int_ptr->scam.fix.expl_for_start_tm = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var2_type, expl_for_start_tm));
            msg_pos += FSIZ(cai_scam_var2_type, expl_for_start_tm);

            if (int_ptr->scam.fix.expl_for_start_tm)
            {
              int_ptr->scam.fix.for_start_tm =
                b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var2_type, for_start_tm));
              msg_pos += FSIZ(cai_scam_var2_type, for_start_tm);
            }
          }

          int_ptr->scam.fix.use_for_dur =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var2_type, use_for_dur));
          msg_pos += FSIZ(cai_scam_var2_type, use_for_dur);

          if (int_ptr->scam.fix.use_for_dur)
          {
            int_ptr->scam.fix.for_dur =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var2_type, for_dur));
            msg_pos += FSIZ(cai_scam_var2_type, for_dur);
          }

          /* The following two fields are included if FOR_SUP_CONFIG==1or3,
          ** if the mobile is to start processing the channels.             */
          if ((int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_START) ||
              (int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_SPEC_START))
          {
            int_ptr->scam.fix.use_for_hdm_seq =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var2_type, use_for_hdm_seq));
            msg_pos += FSIZ(cai_scam_var2_type, use_for_hdm_seq);

            if( int_ptr->scam.fix.use_for_hdm_seq )
            {
              int_ptr->scam.fix.for_hdm_seq = b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_scam_var2_type, for_hdm_seq));
              msg_pos += FSIZ(cai_scam_var2_type, for_hdm_seq);
            }
          }

          if ((int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_SPEC_STOP)||
              (int_ptr->scam.fix.for_sup_config == CAI_FOR_SUP_SPEC_START))
          {
            int_ptr->scam.fix.num_sup_plt = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_scam_var3_type, num_sup_plt));
            msg_pos += FSIZ(cai_scam_var3_type, num_sup_plt);

            int_ptr->scam.fix.num_sup =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_scam_var3_type, num_sup));
            msg_pos += FSIZ(cai_scam_var3_type, num_sup);

            for (pi=0; pi < int_ptr->scam.fix.num_sup_plt; pi++)
            {
              int_ptr->scam.var[pi].plt_pn =
                b_unpackw(buf_ptr, msg_pos, FSIZ(cai_scam_var4_type, plt_pn));
              msg_pos += FSIZ(cai_scam_var4_type, plt_pn);

              int_ptr->scam.var[pi].expl_code_chan = b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_scam_var4_type, expl_code_chan));
              msg_pos += FSIZ(cai_scam_var4_type, expl_code_chan);

              if (int_ptr->scam.var[pi].expl_code_chan)
              {
                for (ch=0; ch<int_ptr->scam.fix.num_sup; ch++)
                {
                  int_ptr->scam.var[pi].chan_lst.sup_code_chan[ch] =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_scam_var5_type, sup_code_chan));
                  msg_pos += FSIZ(cai_scam_var5_type, sup_code_chan);
                }
              }
              else
              {
                int_ptr->scam.var[pi].chan_lst.base_code_chan =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_scam_var6_type, base_code_chan));
                msg_pos += FSIZ(cai_scam_var6_type, base_code_chan);
              }
            } /* for each pilot */
          } /* if FOR_SUP_CONFIG */
        } /* if FOR_INCLUDED */
      }
    }
  }

  return (status);

} /* xlate_ext_scam */

/*===========================================================================

FUNCTION XLATE_EXT_TC_PWR_CTRL

DESCRIPTION
  This function translates a Traffic Channel Power Control
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Mobile Station Registered message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_pwr_ctrl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */

  word buf_pos = 0;

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
                
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_pwr_ctrl_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof( MTYPE))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->pwr_ctrl.hdr);

    buf_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &buf_pos, buf_ptr, &int_ptr->pwr_ctrl.hdr.msg_int,
         int_ptr->pwr_ctrl.msg_type,
         int_ptr->pwr_ctrl.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &buf_pos, buf_ptr,
          &int_ptr->pwr_ctrl.hdr, int_ptr->pwr_ctrl.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->pwr_ctrl.pwr_cntl_step =
          b_unpackd(buf_ptr, buf_pos, FSIZ(MTYPE, pwr_cntl_step));
        buf_pos += FSIZ(MTYPE, pwr_cntl_step);

        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        {
          word i;

          int_ptr->pwr_ctrl.use_time = b_unpackb(buf_ptr, buf_pos,
            FSIZ(cai_pwr_ctrl_is2000_type, use_time));
          buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, use_time);

          if (int_ptr->pwr_ctrl.use_time)
          {
            int_ptr->pwr_ctrl.action_time = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, action_time));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, action_time);
          }

          int_ptr->pwr_ctrl.fpc_incl = b_unpackb(buf_ptr,buf_pos,
            FSIZ(cai_pwr_ctrl_is2000_type, fpc_incl));
          buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_incl);

          if (int_ptr->pwr_ctrl.fpc_incl)
          {
            int_ptr->pwr_ctrl.fpc_mode = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_mode));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_mode);

            int_ptr->pwr_ctrl.fpc_pri_chan = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_pri_chan));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_pri_chan);

            int_ptr->pwr_ctrl.fpc_olpc_fch_incl = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_olpc_fch_incl));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_olpc_fch_incl);

            if (int_ptr->pwr_ctrl.fpc_olpc_fch_incl)
            {
              int_ptr->pwr_ctrl.fpc_fch_fer = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_fer));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_fer);

              int_ptr->pwr_ctrl.fpc_fch_min_setpt = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_min_setpt));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_min_setpt);

              int_ptr->pwr_ctrl.fpc_fch_max_setpt = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_max_setpt));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_fch_max_setpt);
            }

            int_ptr->pwr_ctrl.fpc_olpc_dcch_incl = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_olpc_dcch_incl));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_olpc_dcch_incl);

            if (int_ptr->pwr_ctrl.fpc_olpc_dcch_incl)
            {
              int_ptr->pwr_ctrl.fpc_dcch_fer = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_fer));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_fer);

              int_ptr->pwr_ctrl.fpc_dcch_min_setpt = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_min_setpt));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_min_setpt);

              int_ptr->pwr_ctrl.fpc_dcch_max_setpt = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_max_setpt));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_dcch_max_setpt);
            }

            if ((int_ptr->pwr_ctrl.fpc_mode == 1) ||
                (int_ptr->pwr_ctrl.fpc_mode == 2))
            {
              int_ptr->pwr_ctrl.fpc_sec_chan = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_sec_chan));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_sec_chan);
            }

            int_ptr->pwr_ctrl.num_sup = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, num_sup));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, num_sup);

            for (i=0; i<int_ptr->pwr_ctrl.num_sup && i<CAI_MAX_NUM_FOR_SCH; i++)
            {
              int_ptr->pwr_ctrl.sup_chns[i].sch_id =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_fpc_sup_chn_type, sch_id));
              buf_pos += FSIZ(cai_fpc_sup_chn_type, sch_id);

              int_ptr->pwr_ctrl.sup_chns[i].fpc_sch_fer =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_fpc_sup_chn_type, fpc_sch_fer));
              buf_pos += FSIZ(cai_fpc_sup_chn_type, fpc_sch_fer);

              int_ptr->pwr_ctrl.sup_chns[i].fpc_sch_min_setpt =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_fpc_sup_chn_type, fpc_sch_min_setpt));
              buf_pos += FSIZ(cai_fpc_sup_chn_type, fpc_sch_min_setpt);

              int_ptr->pwr_ctrl.sup_chns[i].fpc_sch_max_setpt =
                b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_fpc_sup_chn_type, fpc_sch_max_setpt));
              buf_pos += FSIZ(cai_fpc_sup_chn_type, fpc_sch_max_setpt);
            }

            int_ptr->pwr_ctrl.fpc_thresh_incl =
              b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_thresh_incl));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_thresh_incl);

            if (int_ptr->pwr_ctrl.fpc_thresh_incl)
            {
              int_ptr->pwr_ctrl.fpc_setpt_thresh =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_setpt_thresh));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_setpt_thresh);
            }

            int_ptr->pwr_ctrl.fpc_thresh_sch_incl =
              b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, fpc_thresh_sch_incl));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_thresh_sch_incl);

            if (int_ptr->pwr_ctrl.fpc_thresh_sch_incl)
            {
              int_ptr->pwr_ctrl.fpc_setpt_thresh_sch =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_pwr_ctrl_is2000_type, fpc_setpt_thresh_sch));
              buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, fpc_setpt_thresh_sch);
            }
          }

          int_ptr->pwr_ctrl.rpc_incl = b_unpackb(buf_ptr, buf_pos,
            FSIZ(cai_pwr_ctrl_is2000_type, rpc_incl));
          buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, rpc_incl);

          if (int_ptr->pwr_ctrl.rpc_incl)
          {
            word record_len;
            word start_pos;

            int_ptr->pwr_ctrl.rpc_num_rec = b_unpackb(buf_ptr, buf_pos,
              FSIZ(cai_pwr_ctrl_is2000_type, rpc_num_rec));
            buf_pos += FSIZ(cai_pwr_ctrl_is2000_type, rpc_num_rec);

            for (i=0; i<int_ptr->pwr_ctrl.rpc_num_rec &&
                      i<CAI_MAX_NUM_RPC_RECS; i++)
            {
              int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type =
                b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_rpc_type, rpc_adj_rec_type));
              buf_pos += FSIZ(cai_rpc_type, rpc_adj_rec_type);

              record_len = b_unpackb(buf_ptr, buf_pos,
                FSIZ(cai_rpc_type, rpc_adj_rec_len));
              buf_pos += FSIZ(cai_rpc_type, rpc_adj_rec_len);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

              start_pos = buf_pos;
              if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type == CAI_CHAN_ADJ_GAIN)
              {
                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.fch_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj0_type, fch_incl));
                buf_pos += FSIZ(cai_rpc_adj0_type, fch_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.fch_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.fch_chan_adj_gain =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, fch_chan_adj_gain));
                  buf_pos += FSIZ(cai_rpc_adj0_type, fch_chan_adj_gain);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.dcch_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj0_type, dcch_incl));
                buf_pos += FSIZ(cai_rpc_adj0_type, dcch_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.dcch_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.dcch_chan_adj_gain =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, dcch_chan_adj_gain));
                  buf_pos += FSIZ(cai_rpc_adj0_type, dcch_chan_adj_gain);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch0_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj0_type, sch0_incl));
                buf_pos += FSIZ(cai_rpc_adj0_type, sch0_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch0_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch0_chan_adj_gain =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, sch0_chan_adj_gain));
                  buf_pos += FSIZ(cai_rpc_adj0_type, sch0_chan_adj_gain);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch1_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj0_type, sch1_incl));
                buf_pos += FSIZ(cai_rpc_adj0_type, sch1_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch1_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.sch1_chan_adj_gain =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, sch1_chan_adj_gain));
                  buf_pos += FSIZ(cai_rpc_adj0_type, sch1_chan_adj_gain);
                }

#ifdef FEATURE_IS2000_REL_C
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_ackch_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, rev_ackch_incl));
                  buf_pos += FSIZ(cai_rpc_adj0_type, rev_ackch_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_ackch_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_ackch_chan_adj_gain =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj0_type, rev_ackch_chan_adj_gain));
                    buf_pos += FSIZ(cai_rpc_adj0_type, rev_ackch_chan_adj_gain);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_cqich_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj0_type, rev_cqich_incl));
                  buf_pos += FSIZ(cai_rpc_adj0_type, rev_cqich_incl);
      
                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_cqich_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj0.rev_cqich_chan_adj_gain =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj0_type, rev_cqich_chan_adj_gain));
                    buf_pos += FSIZ(cai_rpc_adj0_type, rev_cqich_chan_adj_gain);
                  }
                }
#endif /* FEATURE_IS2000_REL_C */

              } /* if rpc_adj_rec_type == 0 */
              else if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type == CAI_BASIC_RATE_ADJ_GAIN)
              {
                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_type =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_type));
                buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_type);

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_20ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj1_type, rc3_rc5_20ms_incl));
                buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc5_20ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_20ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1500 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1500));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1500);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_2700 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2700));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2700);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_4800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_9600 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc4_rc6_20ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj1_type, rc4_rc6_20ms_incl));
                buf_pos += FSIZ(cai_rpc_adj1_type, rc4_rc6_20ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc4_rc6_20ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_3600 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_7200 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_14400 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.five_ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj1_type, five_ms_incl));
                buf_pos += FSIZ(cai_rpc_adj1_type, five_ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.five_ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.norm_att_gain_9600_5ms =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, norm_att_gain_9600_5ms));
                  buf_pos += FSIZ(cai_rpc_adj1_type, norm_att_gain_9600_5ms);
                }

#ifdef FEATURE_IS2000_REL_A
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_40ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rc3_rc5_40ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc5_40ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_40ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1350_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1350_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1350_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_2400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2400_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_4800_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_9600_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600_40ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc6_40ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rc3_rc6_40ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc6_40ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc6_40ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1800_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_3600_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_7200_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_14400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400_40ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_80ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rc3_rc5_80ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc5_80ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc5_80ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1200_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_2400_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2400_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_2400_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_4800_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_4800_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_9600_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_9600_80ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc6_80ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj1_type, rc3_rc6_80ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj1_type, rc3_rc6_80ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rc3_rc6_80ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_1800_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_1800_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_3600_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_3600_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_7200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_7200_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj1.rl_att_adj_gain_14400_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400_80ms));
                    buf_pos += FSIZ(cai_rpc_adj1_type, rl_att_adj_gain_14400_80ms);
                  }
                } //if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
#endif /* FEATURE_IS2000_REL_A */

              } /* if rpc_adj_rec_type == 1 */
              else if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type == CAI_HIGH_RATE_ADJ_GAIN)
              {
                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.code_type =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj2_type, code_type));
                buf_pos += FSIZ(cai_rpc_adj2_type, code_type);

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_type =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_type));
                buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_type);

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_20ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj2_type, rc3_rc5_20ms_incl));
                buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc5_20ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_20ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_19200 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_38400 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400));
                  buf_pos += FSIZ(cai_rpc_adj2_type,rl_att_adj_gain_38400);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_76800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_153600 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_307200 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_307200));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_307200);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_614400 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_614400));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_614400);
                }

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc4_rc6_20ms_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj2_type, rc4_rc6_20ms_incl));
                buf_pos += FSIZ(cai_rpc_adj2_type, rc4_rc6_20ms_incl);

                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc4_rc6_20ms_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_28800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_57600 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_115200 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_230400 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_230400));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_230400);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_460800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_460800));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_460800);

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_1036800 =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_1036800));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_1036800);
                }

#ifdef FEATURE_IS2000_REL_A
                if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_40ms_incl =
                    b_unpackb(buf_ptr,buf_pos,
                    FSIZ(cai_rpc_adj2_type, rc3_rc5_40ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc5_40ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_40ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_19200_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_38400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_76800_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_153600_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_307200_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                               FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_307200_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_307200_40ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc6_40ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rc3_rc6_40ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc6_40ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc6_40ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_28800_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_57600_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_115200_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_230400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_230400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_230400_40ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_518400_40ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_518400_40ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_518400_40ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_80ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rc3_rc5_80ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc5_80ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc5_80ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_19200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_19200_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_38400_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_38400_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_76800_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_76800_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_153600_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_153600_80ms);
                  }

                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc6_80ms_incl =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj2_type, rc3_rc6_80ms_incl));
                  buf_pos += FSIZ(cai_rpc_adj2_type, rc3_rc6_80ms_incl);

                  if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rc3_rc6_80ms_incl)
                  {
                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_28800_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_28800_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_57600_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_57600_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_115200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_115200_80ms);

                    int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj2.rl_att_adj_gain_259200_80ms =
                      b_unpackb(buf_ptr, buf_pos,
                      FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_259200_80ms));
                    buf_pos += FSIZ(cai_rpc_adj2_type, rl_att_adj_gain_259200_80ms);
                  }
                } //if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
#endif /* FEATURE_IS2000_REL_A */

              } /* if rpc_adj_rec_type == 2 */

#ifdef FEATURE_IS2000_REL_C
              else if ((int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj_rec_type == CAI_RCQICH_ADJ_GAIN)
                      && (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C))
               {
                 int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_type =
                   b_unpackb(buf_ptr, buf_pos,
                   FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_type));
                 buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_type); 

                 int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_high_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_high_incl));
                 buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_high_incl); 

                 if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_high_incl)
                 {
                   int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_high =
                     b_unpackb(buf_ptr, buf_pos,
                     FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_high));
                   buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_high);
                 } 

                int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_low_incl =
                  b_unpackb(buf_ptr, buf_pos,
                  FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_low_incl));
                buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_low_incl);
    
                if (int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_low_incl)
                {
                  int_ptr->pwr_ctrl.rpc_recs[i].rpc_adj.adj3.rl_cqich_att_adj_gain_low =
                    b_unpackb(buf_ptr, buf_pos,
                    FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_low));
                  buf_pos += FSIZ(cai_rpc_adj3_type, rl_cqich_att_adj_gain_low);
                }
              } /* if p-rev >= 9 and rpc_adj_rec_type == 3 */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

              buf_pos = start_pos + 8*record_len;
            } /* for each rpc_num_rec */
          } /* if rpc_incl */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

        } /* if p_rev_in_use >= 6 */

        /* There is an error if we parsed beyond the length */
        if (buf_pos > len)
        {
          status = CAIX_INV_LEN_S;
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_pwr_ctrl */

/*===========================================================================

FUNCTION XLATE_ADD_PILOT_REC

DESCRIPTION
  This function translates a pilot record from external to internal
formats.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the caii_add_pilot_rec_type message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

void xlate_add_pilot_rec
(
  byte type,
    /* type of the pilot: 000 - 1X Common Pilot w/ TD
                          001 - 1X Aux Pilot
                          010 - 1x Aux Pilot w/ TD
                          011 - 3X Common Pilot
                          100 - 3x Aux Pilot */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  word pos,
    /* current position in the buffer */
  caii_add_pilot_rec_type *int_ptr
    /* Pointer to the destination pilot record */
)
{
  word ext_msg_pos = pos;

  switch(type)
  {
    case CAI_PILOT_REC_1X_COM_TD:

      UNPACKB_PG(rec0.td_power_level, cai_add_pilot_rec0_type, td_power_level);
      UNPACKB_PG(rec0.td_mode, cai_add_pilot_rec0_type, td_mode);
      break;

#ifdef FEATURE_IS2000_REL_A
    case CAI_PILOT_REC_1X_AUX:
      UNPACKB_PG(rec1.qof, cai_add_pilot_rec1_type, qof);
      UNPACKB_PG(rec1.walsh_length, cai_add_pilot_rec1_type, walsh_length);

      int_ptr->rec1.aux_pilot_walsh = b_unpackw(buf_ptr, ext_msg_pos,
        FSIZ(cai_add_pilot_rec1_type, aux_pilot_walsh) + int_ptr->rec1.walsh_length);
      ext_msg_pos += FSIZ(cai_add_pilot_rec1_type, aux_pilot_walsh) +
        int_ptr->rec1.walsh_length;
      break;

    case CAI_PILOT_REC_1X_AUX_TD:
      UNPACKB_PG(rec2.qof, cai_add_pilot_rec2_type, qof);
      UNPACKB_PG(rec2.walsh_length, cai_add_pilot_rec2_type, walsh_length);

      int_ptr->rec2.aux_walsh = b_unpackw(buf_ptr, ext_msg_pos,
        FSIZ(cai_add_pilot_rec2_type, aux_walsh) + int_ptr->rec2.walsh_length);
      ext_msg_pos += FSIZ(cai_add_pilot_rec2_type, aux_walsh) +
        int_ptr->rec2.walsh_length;

      UNPACKB_PG(rec2.aux_td_power_level, cai_add_pilot_rec2_type, aux_td_power_level);
      UNPACKB_PG(rec2.td_mode, cai_add_pilot_rec2_type, td_mode);
      break;

    case CAI_PILOT_REC_3X_COM:
      UNPACKB_PG(rec3.sr3_primary_pilot, cai_add_pilot_rec3_type, sr3_primary_pilot);
      UNPACKB_PG(rec3.sr3_pilot_power1, cai_add_pilot_rec3_type, sr3_pilot_power1);
      UNPACKB_PG(rec3.sr3_pilot_power2, cai_add_pilot_rec3_type, sr3_pilot_power2);
      break;

    case CAI_PILOT_REC_3X_AUX:
      UNPACKB_PG(rec4.sr3_primary_pilot, cai_add_pilot_rec4_type, sr3_primary_pilot);
      UNPACKB_PG(rec4.sr3_pilot_power1, cai_add_pilot_rec4_type, sr3_pilot_power1);
      UNPACKB_PG(rec4.sr3_pilot_power2, cai_add_pilot_rec4_type, sr3_pilot_power2);
      UNPACKB_PG(rec4.qof, cai_add_pilot_rec4_type, qof);
      UNPACKB_PG(rec4.walsh_length, cai_add_pilot_rec4_type, walsh_length);

      int_ptr->rec4.aux_pilot_walsh = b_unpackw(buf_ptr, ext_msg_pos,
        FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh) + int_ptr->rec4.walsh_length);
      ext_msg_pos += FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh) +
        int_ptr->rec4.walsh_length;

      UNPACKB_PG(rec4.add_info_incl1, cai_add_pilot_rec4_type, add_info_incl1);
      if (int_ptr->rec4.add_info_incl1)
      {
        UNPACKB_PG(rec4.qof1, cai_add_pilot_rec4_type, qof1);
        UNPACKB_PG(rec4.walsh_length1, cai_add_pilot_rec4_type, walsh_length1);

        int_ptr->rec4.aux_pilot_walsh1 = b_unpackw(buf_ptr, ext_msg_pos,
          FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh1) +
          int_ptr->rec4.walsh_length1);
        ext_msg_pos += FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh1) +
          int_ptr->rec4.walsh_length1;
      }

      UNPACKB_PG(rec4.add_info_incl2, cai_add_pilot_rec4_type, add_info_incl2);
      if (int_ptr->rec4.add_info_incl2)
      {
        UNPACKB_PG(rec4.qof2, cai_add_pilot_rec4_type, qof2);
        UNPACKB_PG(rec4.walsh_length2, cai_add_pilot_rec4_type, walsh_length2);

        int_ptr->rec4.aux_pilot_walsh2 = b_unpackw(buf_ptr, ext_msg_pos,
          FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh2) + int_ptr->rec4.walsh_length2);
        ext_msg_pos += FSIZ(cai_add_pilot_rec4_type, aux_pilot_walsh2) +
          int_ptr->rec4.walsh_length2;
      }

      break;
#endif /* FEATURE_IS2000_REL_A */

    } /*lint !e744: Switch statement has not default */

}

/*===========================================================================

FUNCTION XLATE_EXT_ADD_PILOT_REC

DESCRIPTION
  This function translates a pilot record from internal to external
formats.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_add_pilot_rec
(
  byte type,
  /* type of the pilot: 000 - 1X Common Pilot w/ TD
                        001 - 1X Aux Pilot
                        010 - 1x Aux Pilot w/ TD
                        011 - 3X Common Pilot
                        100 - 3x Aux Pilot */
  caii_add_pilot_rec_type *rec_ptr,
    /* Pointer to the source pilot record */
  word *len_ptr,
  /* Pointer to length of the pilot record header in bits */
  byte *buf_ptr
  /* Pointer to where packed pilot record type should be placed */
)
{
#ifdef FEATURE_IS2000_REL_A
    byte reserve_bits;
#endif /* FEATURE_IS2000_REL_A */

    switch (type)
    {
      case 0: /* 000 - 1X Common Pilot with TD */
        b_packb( rec_ptr->rec0.td_power_level,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec0_type,td_power_level));
        *len_ptr += FSIZ( cai_add_pilot_rec0_type,td_power_level );

        b_packb( rec_ptr->rec0.td_mode,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec0_type,td_mode));
        *len_ptr += FSIZ( cai_add_pilot_rec0_type,td_mode );

        b_packb( 0,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec0_type,reserved));
        *len_ptr += FSIZ( cai_add_pilot_rec0_type,reserved );

        break;

#ifdef FEATURE_IS2000_REL_A
      case 1: /* 001 - 1X Auxiliary Pilot */
        b_packb( rec_ptr->rec1.qof,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec1_type,qof));
        *len_ptr += FSIZ( cai_add_pilot_rec1_type,qof );

        b_packb( rec_ptr->rec1.walsh_length,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec1_type,walsh_length));
        *len_ptr += FSIZ( cai_add_pilot_rec1_type,walsh_length );

        /* if the aux walsh is less than 3, pack a byte */
        b_packw( rec_ptr->rec1.aux_pilot_walsh, buf_ptr,
                   *len_ptr,
                   rec_ptr->rec1.walsh_length  + 6);

        *len_ptr += rec_ptr->rec1.walsh_length  + 6;

        /* Calculate the length of reserved bits */
        reserve_bits = (sizeof(cai_add_pilot_rec1_type) +
                            rec_ptr->rec1.walsh_length)
                           %8;

        if( reserve_bits != 0 )
        {
          reserve_bits = 8 - reserve_bits;

          /* Pack reserved bits */
          b_packb( 0, buf_ptr, *len_ptr, reserve_bits );
          *len_ptr += reserve_bits;
        }

        break;

      case 2: /* 010 - 1 Auxiliary Pilot with Transmit Diversity */

        b_packb( rec_ptr->rec2.qof,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec2_type,qof));
        *len_ptr += FSIZ( cai_add_pilot_rec2_type,qof );

        b_packb( rec_ptr->rec2.walsh_length,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec2_type,walsh_length));
        *len_ptr += FSIZ( cai_add_pilot_rec2_type,walsh_length );

        b_packw( rec_ptr->rec2.aux_walsh,
            buf_ptr, *len_ptr, rec_ptr->rec2.walsh_length + 6);
        *len_ptr += rec_ptr->rec2.walsh_length + 6;

        b_packb( rec_ptr->rec2.aux_td_power_level,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec2_type,aux_td_power_level));
        *len_ptr += FSIZ( cai_add_pilot_rec2_type,aux_td_power_level );

        b_packw( rec_ptr->rec2.td_mode,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec2_type,td_mode));
        *len_ptr += FSIZ( cai_add_pilot_rec2_type,td_mode );

        reserve_bits = (sizeof(cai_add_pilot_rec2_type) +
                            rec_ptr->rec2.walsh_length)
                           %8;

        if( reserve_bits != 0 )
        {
          reserve_bits = 8 - reserve_bits;

          /* Pack reserved bits */
          b_packb( 0, buf_ptr, *len_ptr, reserve_bits );
          *len_ptr += reserve_bits;
        }

        break;

      case 3: /* 011 - 3X Common Pilot */

        b_packb( rec_ptr->rec3.sr3_primary_pilot,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec3_type,sr3_primary_pilot));
        *len_ptr += FSIZ( cai_add_pilot_rec3_type,sr3_primary_pilot );

        b_packb( rec_ptr->rec3.sr3_pilot_power1,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec3_type,sr3_pilot_power1));
        *len_ptr += FSIZ( cai_add_pilot_rec3_type,sr3_pilot_power1 );

        b_packb( rec_ptr->rec3.sr3_pilot_power2,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec3_type,sr3_pilot_power2));
        *len_ptr += FSIZ( cai_add_pilot_rec3_type,sr3_pilot_power2 );

        break;

      case 4: /* 100 - 3X Auxiliary Pilot */

        b_packb( rec_ptr->rec4.sr3_primary_pilot,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,sr3_primary_pilot));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,sr3_primary_pilot );

        b_packb( rec_ptr->rec4.sr3_pilot_power1,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,sr3_pilot_power1));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,sr3_pilot_power1 );

        b_packb( rec_ptr->rec4.sr3_pilot_power2,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,sr3_pilot_power2));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,sr3_pilot_power2 );

        b_packb( rec_ptr->rec4.qof,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,qof));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,qof );

        b_packb( rec_ptr->rec4.walsh_length,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,walsh_length));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,walsh_length );

        /* if the aux walsh is less than 3, pack a byte */
        b_packw( rec_ptr->rec4.aux_pilot_walsh, buf_ptr,
                 *len_ptr,
                 rec_ptr->rec4.walsh_length  + 6);
        *len_ptr += rec_ptr->rec4.walsh_length  + 6;

        b_packb( rec_ptr->rec4.add_info_incl1,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,add_info_incl1));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,add_info_incl1 );

        if (rec_ptr->rec4.add_info_incl1)
        {
          b_packb( rec_ptr->rec4.qof1,
             buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,qof1));
          *len_ptr += FSIZ( cai_add_pilot_rec4_type,qof1 );

          b_packb( rec_ptr->rec4.walsh_length1,
            buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,walsh_length1));
          *len_ptr += FSIZ( cai_add_pilot_rec4_type,walsh_length1 );

          b_packw( rec_ptr->rec4.aux_pilot_walsh1, buf_ptr,
                   *len_ptr,
                   rec_ptr->rec4.walsh_length1 + 6);
          *len_ptr += rec_ptr->rec4.walsh_length1 + 6;
        }

        b_packb( rec_ptr->rec4.add_info_incl2,
          buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,add_info_incl2));
        *len_ptr += FSIZ( cai_add_pilot_rec4_type,add_info_incl2 );

        if (rec_ptr->rec4.add_info_incl2)
        {
          b_packb( rec_ptr->rec4.qof2,
            buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,qof2));
          *len_ptr += FSIZ( cai_add_pilot_rec4_type,qof2 );

          b_packb( rec_ptr->rec4.walsh_length2,
            buf_ptr, *len_ptr, FSIZ( cai_add_pilot_rec4_type,walsh_length2));
          *len_ptr += FSIZ( cai_add_pilot_rec4_type,walsh_length2 );

          b_packw( rec_ptr->rec4.aux_pilot_walsh2, buf_ptr,
                     *len_ptr,
                     rec_ptr->rec4.walsh_length2 + 6);

          *len_ptr += rec_ptr->rec4.aux_pilot_walsh2 + 6;

          /* Calculate the length of reserved bits */
          reserve_bits = (sizeof(cai_add_pilot_rec4_type) +
                              rec_ptr->rec4.walsh_length +
                              rec_ptr->rec4.walsh_length1 +
                              rec_ptr->rec4.walsh_length2 )
                             %8;

          if( reserve_bits != 0 )
          {
            reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
            b_packb( 0, buf_ptr, *len_ptr, reserve_bits );
            *len_ptr += reserve_bits;
          }

        }
        break;
#endif /* FEATURE_IS2000_REL_A */

    } /*lint !e744: Switch statement has not default */
    return TRUE;
}

/*===========================================================================

FUNCTION XLATE_EXT_EXT_NLU

DESCRIPTION
  This function translates a Traffic Channel Extended Neighbor List Update
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Neighbor List Update message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ext_nlu
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */
  word msg_pos = 0;
    /* Position of record in message */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
             
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_ext_nlu_fix_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length, size of fixed type,
  ** without dependent fields.
  ** -------------------------------------------- */
  if (len < (sizeof(MTYPE)
             - FSIZ(MTYPE, global_timing_incl)
             - FSIZ(MTYPE, global_tx_duration)
             - FSIZ(MTYPE, global_tx_period)))
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->ext_nlu.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->ext_nlu.hdr.msg_int,
         int_ptr->ext_nlu.msg_type,
         int_ptr->ext_nlu.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->ext_nlu.hdr, int_ptr->ext_nlu.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->ext_nlu.pilot_inc =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, pilot_inc));
        msg_pos += FSIZ(MTYPE, pilot_inc);

        int_ptr->ext_nlu.nghbr_srch_mode =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, nghbr_srch_mode));
        msg_pos += FSIZ(MTYPE, nghbr_srch_mode);

        int_ptr->ext_nlu.srch_win_n =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, srch_win_n));
        msg_pos += FSIZ(MTYPE, srch_win_n);

        int_ptr->ext_nlu.use_timing =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, use_timing));
        msg_pos += FSIZ(MTYPE, use_timing);


        /* Begin unpacking dependent fields */
        if (int_ptr->ext_nlu.use_timing)
        {
          int_ptr->ext_nlu.global_timing_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, global_timing_incl));
          msg_pos += FSIZ(MTYPE, global_timing_incl);

          if (int_ptr->ext_nlu.global_timing_incl)
          {
            int_ptr->ext_nlu.global_tx_duration =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, global_tx_duration));
            msg_pos += FSIZ(MTYPE, global_tx_duration);

            int_ptr->ext_nlu.global_tx_period =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, global_tx_period));
            msg_pos += FSIZ(MTYPE, global_tx_period);
          }
        }

        int_ptr->ext_nlu.num_nghbr =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_nghbr));
        msg_pos += FSIZ(MTYPE, num_nghbr);

        for (i=0; (i < int_ptr->ext_nlu.num_nghbr) &&
                  (i < CAI_EXT_NLU_MAX); i++)
        {
          int_ptr->ext_nlu.nghbr[i].nghbr_pn =
            b_unpackw(buf_ptr, msg_pos,
            FSIZ(cai_ext_nlu_var_type, nghbr_pn));
          msg_pos += FSIZ(cai_ext_nlu_var_type, nghbr_pn);

          if (int_ptr->ext_nlu.nghbr_srch_mode == SRCH_PRI_AND_WIN ||
              int_ptr->ext_nlu.nghbr_srch_mode == SRCH_PRI_ONLY)
          {
            int_ptr->ext_nlu.nghbr[i].search_pri =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_var_type, search_pri));
            msg_pos += FSIZ(cai_ext_nlu_var_type, search_pri);
          }

          if (int_ptr->ext_nlu.nghbr_srch_mode == SRCH_PRI_AND_WIN ||
              int_ptr->ext_nlu.nghbr_srch_mode == SRCH_WIN_ONLY)
          {
            int_ptr->ext_nlu.nghbr[i].srch_win_nghbr =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_var_type, srch_win_nghbr));
            msg_pos += FSIZ(cai_ext_nlu_var_type, srch_win_nghbr);
          }

          if (int_ptr->ext_nlu.use_timing)
          {
            int_ptr->ext_nlu.nghbr[i].timing_incl =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_var_type, timing_incl));
            msg_pos += FSIZ(cai_ext_nlu_var_type, timing_incl);

            if (int_ptr->ext_nlu.nghbr[i].timing_incl)
            {
              int_ptr->ext_nlu.nghbr[i].nghbr_tx_offset =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_type, nghbr_tx_offset));
              msg_pos += FSIZ(cai_ext_nlu_var_type, nghbr_tx_offset);

              /* Parse the following if GLOBAL_TIMING_INCL is zero. */
              if (!(int_ptr->ext_nlu.global_timing_incl))
              {
                int_ptr->ext_nlu.nghbr[i].nghbr_tx_duration =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_ext_nlu_var_type, nghbr_tx_duration));
                msg_pos += FSIZ(cai_ext_nlu_var_type, nghbr_tx_duration);

                int_ptr->ext_nlu.nghbr[i].nghbr_tx_period =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_ext_nlu_var_type, nghbr_tx_period));
                msg_pos += FSIZ(cai_ext_nlu_var_type, nghbr_tx_period);
              }
            }
          }
        }

        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        {
          int_ptr->ext_nlu.srch_offset_incl =
            b_unpackb(buf_ptr, msg_pos,
            FSIZ(cai_ext_nlu_fix_is2000_type, srch_offset_incl));
          msg_pos += FSIZ(cai_ext_nlu_fix_is2000_type, srch_offset_incl);

          for (i=0; (i < int_ptr->ext_nlu.num_nghbr) &&
                    (i < CAI_EXT_NLU_MAX); i++)
          {
            int_ptr->ext_nlu.add_nghbr[i].add_pilot_rec_incl =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_ext_nlu_var_is2000_type, add_pilot_rec_incl));
            msg_pos += FSIZ(cai_ext_nlu_var_is2000_type, add_pilot_rec_incl);

            if (int_ptr->ext_nlu.add_nghbr[i].add_pilot_rec_incl)
            {
              word record_len = 0;
              word record_start_pos = 0;

              int_ptr->ext_nlu.add_nghbr[i].nghbr_pilot_rec_type =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_is2000_type, nghbr_pilot_rec_type));
              msg_pos += FSIZ(cai_ext_nlu_var_is2000_type, nghbr_pilot_rec_type);

              record_len = b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_is2000_type, record_len));
              msg_pos += FSIZ(cai_ext_nlu_var_is2000_type, record_len);

              record_start_pos = msg_pos;

              xlate_add_pilot_rec(int_ptr->ext_nlu.add_nghbr[i].nghbr_pilot_rec_type,
                                  buf_ptr, msg_pos,
                                  &(int_ptr->ext_nlu.add_nghbr[i].add_pilot_rec));
              msg_pos = record_start_pos + record_len * 8;
            }

            if ((int_ptr->ext_nlu.srch_offset_incl) &&
                (int_ptr->ext_nlu.nghbr_srch_mode == SRCH_PRI_AND_WIN ||
                 int_ptr->ext_nlu.nghbr_srch_mode == SRCH_WIN_ONLY))
            {
              int_ptr->ext_nlu.add_nghbr[i].srch_offset_nghbr =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_is2000_type, srch_offset_nghbr));
              msg_pos += FSIZ(cai_ext_nlu_var_is2000_type,srch_offset_nghbr);
            }
          }
        } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000) */

#ifdef FEATURE_IS2000_REL_B
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
        {
          int_ptr->ext_nlu.resq_enabled =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_ext_nlu_fix_rel_b_type, resq_enabled));
          msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_enabled);

          if (int_ptr->ext_nlu.resq_enabled)
          {
            int_ptr->ext_nlu.resq_delay_time = b_unpackb(buf_ptr, msg_pos,
             FSIZ(cai_ext_nlu_fix_rel_b_type, resq_delay_time));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_delay_time);

            int_ptr->ext_nlu.resq_allowed_time = b_unpackb(buf_ptr, msg_pos,
             FSIZ(cai_ext_nlu_fix_rel_b_type, resq_allowed_time));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_allowed_time);

            int_ptr->ext_nlu.resq_attempt_time = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_attempt_time ));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_attempt_time);

            int_ptr->ext_nlu.resq_code_chan = b_unpackw(buf_ptr, msg_pos,
             FSIZ(cai_ext_nlu_fix_rel_b_type, resq_code_chan));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_code_chan);

            int_ptr->ext_nlu.resq_qof = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_qof));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_qof);

            int_ptr->ext_nlu.resq_min_period_incl = b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_min_period_incl ));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_min_period_incl);

            if (int_ptr->ext_nlu.resq_min_period_incl)
            {
              int_ptr->ext_nlu.resq_min_period = b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_fix_rel_b_type, resq_min_period));
              msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_min_period);
            }

            int_ptr->ext_nlu.resq_num_tot_trans_incl =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_incl));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_incl);

            if (int_ptr->ext_nlu.resq_num_tot_trans_incl)
            {
              int_ptr->ext_nlu.resq_num_tot_trans_20ms =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_20ms));
              msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_20ms);

              int_ptr->ext_nlu.resq_num_tot_trans_5ms =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_5ms ));
              msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_tot_trans_5ms);
            }

            int_ptr->ext_nlu.resq_num_preamble =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_preamble));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_num_preamble);
  
            int_ptr->ext_nlu.resq_power_delta =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_ext_nlu_fix_rel_b_type, resq_power_delta));
            msg_pos += FSIZ(cai_ext_nlu_fix_rel_b_type, resq_power_delta);
  
            for ( i=0; (i < int_ptr->ext_nlu.num_nghbr) && (i < CAI_EXT_NLU_MAX); i++)
            {
              int_ptr->ext_nlu.resq[i].nghbr_resq_configured =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_ext_nlu_var_rel_b_type, nghbr_resq_configured));
              msg_pos += FSIZ(cai_ext_nlu_var_rel_b_type, nghbr_resq_configured);
            }
          } /* if (int_ptr->ext_nlu.resq_enabled) */
        } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) */
#endif /* FEATURE_IS2000_REL_B */

      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_ext_nlu */

/*===========================================================================

FUNCTION XLATE_EXT_TC_CFS_REQ

DESCRIPTION
  This function translates a Traffic Channel Candidate Frequency Search Request
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Candidate Frequency Search Request
  message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_cfs_req
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */
  word msg_pos;
    /* Position of record in message */

  word fix_len;

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
          
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_cfs_req_fix_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(MTYPE ) + sizeof(cai_cfs_mod1_fix_type))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {

    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->cfs_req.fix.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->cfs_req.fix.hdr.msg_int,
         int_ptr->cfs_req.fix.msg_type,
         int_ptr->cfs_req.fix.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
          &int_ptr->cfs_req.fix.hdr, int_ptr->cfs_req.fix.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->cfs_req.fix.pre_proc_done = FALSE;

        int_ptr->cfs_req.fix.use_time =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        int_ptr->cfs_req.fix.action_time =
          b_unpackb(buf_ptr, msg_pos,FSIZ(MTYPE, action_time));
        msg_pos += FSIZ(MTYPE, action_time );

        /* skip over reserved bits */
        msg_pos += FSIZ(MTYPE, reserved);

        int_ptr->cfs_req.fix.cfsrm_seq =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, cfsrm_seq));
        msg_pos += FSIZ(MTYPE, cfsrm_seq);

        int_ptr->cfs_req.fix.srch_type =
          b_unpackb(buf_ptr, msg_pos,FSIZ(MTYPE, srch_type));
        msg_pos += FSIZ(MTYPE, srch_type);

        int_ptr->cfs_req.fix.srch_period =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, srch_period));
        msg_pos += FSIZ(MTYPE, srch_period);

        int_ptr->cfs_req.fix.srch_mode =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, srch_mode));
        msg_pos += FSIZ(MTYPE, srch_mode);

        int_ptr->cfs_req.fix.mod_sp_len =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, mod_sp_len));
        msg_pos += FSIZ( cai_cfs_req_fix_type, mod_sp_len);

        fix_len = msg_pos;

        if (len - msg_pos < int_ptr->cfs_req.fix.mod_sp_len)
        {
          status = CAIX_INV_LEN_S;
        }
        else
        {
          /* Mode-Specific Fields */
          switch (int_ptr->cfs_req.fix.srch_mode)
          {
            case CAI_CF_SRCH_TYPE_CDMA:
              int_ptr->cfs_req.var.mod0.band_class =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, band_class));
              msg_pos += FSIZ( cai_cfs_mod0_fix_type, band_class);

              int_ptr->cfs_req.var.mod0.cdma_freq =
                b_unpackw(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, cdma_freq));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, cdma_freq);

              int_ptr->cfs_req.var.mod0.sf_total_ec_thresh =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, sf_total_ec_thresh));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, sf_total_ec_thresh);

              int_ptr->cfs_req.var.mod0.sf_total_ec_io_thresh =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, sf_total_ec_io_thresh));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, sf_total_ec_io_thresh);

              int_ptr->cfs_req.var.mod0.diff_rx_pwr_thresh =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, diff_rx_pwr_thresh));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, diff_rx_pwr_thresh);

              int_ptr->cfs_req.var.mod0.min_total_pilot_ecio =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, min_total_pilot_ecio));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, min_total_pilot_ecio);

              int_ptr->cfs_req.var.mod0.cf_t_add =
                b_unpackb(buf_ptr, msg_pos,
                       FSIZ(cai_cfs_mod0_fix_type, cf_t_add));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, cf_t_add);

              int_ptr->cfs_req.var.mod0.tf_wait_time =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, tf_wait_time));
              msg_pos += FSIZ( cai_cfs_mod0_fix_type, tf_wait_time);

              int_ptr->cfs_req.var.mod0.cf_pilot_inc =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, cf_pilot_inc));
              msg_pos += FSIZ( cai_cfs_mod0_fix_type, cf_pilot_inc);

              int_ptr->cfs_req.var.mod0.cf_srch_win_n =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, cf_srch_win_n));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, cf_srch_win_n);

              int_ptr->cfs_req.var.mod0.cf_srch_win_r =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, cf_srch_win_r));
              msg_pos += FSIZ( cai_cfs_mod0_fix_type, cf_srch_win_r);

              msg_pos += FSIZ( cai_cfs_mod0_fix_type, reserved );

              int_ptr->cfs_req.var.mod0.pilot_update =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_mod0_fix_type, pilot_update));
              msg_pos += FSIZ(cai_cfs_mod0_fix_type, pilot_update);

              if (int_ptr->cfs_req.var.mod0.pilot_update)
              {
                int_ptr->cfs_req.var.mod0.num_pilot =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_cfs_mod0_fix_type, num_pilot));
                msg_pos += FSIZ(cai_cfs_mod0_fix_type, num_pilot);

                int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_cfs_mod0_fix_type, cf_nghbr_srch_mode));
                msg_pos += FSIZ(cai_cfs_mod0_fix_type, cf_nghbr_srch_mode);

                if (int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode <=
                    SRCH_PRI_AND_WIN)
                {
                  for (i=0; (i<int_ptr->cfs_req.var.mod0.num_pilot)
                            && (i<CAI_CFSREQ_REC_MAX) ; i++)
                  {
                    int_ptr->cfs_req.var.mod0.pilot_update_rec[i].nghbr_pn =
                      b_unpackw(buf_ptr, msg_pos,
                      FSIZ(cai_cfs_mod0_var_type, nghbr_pn));
                    msg_pos += FSIZ(cai_cfs_mod0_var_type, nghbr_pn);

                    int_ptr->cfs_req.var.mod0.pilot_update_rec[i].search_set =
                      b_unpackw(buf_ptr, msg_pos,
                      FSIZ(cai_cfs_mod0_var_type, search_set));
                    msg_pos += FSIZ(cai_cfs_mod0_var_type, search_set);

                    if (int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode ==
                        SRCH_PRI_AND_WIN ||
                        int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode ==
                        SRCH_PRI_ONLY)
                    {
                      int_ptr->cfs_req.var.mod0.pilot_update_rec[i].search_priority =
                        b_unpackw(buf_ptr, msg_pos,
                        FSIZ(cai_cfs_mod0_var_type, search_priority));
                      msg_pos += FSIZ(cai_cfs_mod0_var_type, search_priority);
                    }

                    if (int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode ==
                        SRCH_PRI_AND_WIN ||
                        int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode ==
                        SRCH_WIN_ONLY)
                    {
                      int_ptr->cfs_req.var.mod0.pilot_update_rec[i].srch_win_nghbr =
                        b_unpackw(buf_ptr, msg_pos,
                        FSIZ(cai_cfs_mod0_var_type, srch_win_nghbr));
                      msg_pos += FSIZ(cai_cfs_mod0_var_type, srch_win_nghbr);
                    }
                  }
                }
              } /* check for Pilot Update is 1 */

             #define VTYPE cai_cfs_req_is2000_rec_var_type
             if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
             {
               word j;

               int_ptr->cfs_req.var.mod0.cf_srch_offset_incl =
                 b_unpackb(buf_ptr, msg_pos,
                 FSIZ(cai_cfs_req_is2000_type, cf_srch_offset_incl));
               msg_pos += FSIZ(cai_cfs_req_is2000_type, cf_srch_offset_incl);

               if (int_ptr->cfs_req.var.mod0.pilot_update )
               {
                 for (j=0; j<int_ptr->cfs_req.var.mod0.num_pilot && j<CAI_CFSREQ_REC_MAX; j++)
                 {
                   int_ptr->cfs_req.var.mod0.add_nghbr[j].add_pilot_rec_incl =
                     b_unpackb(buf_ptr, msg_pos,
                     FSIZ(cai_cfs_req_is2000_rec_fix_type, add_pilot_rec_incl));
                   msg_pos += FSIZ(cai_cfs_req_is2000_rec_fix_type, add_pilot_rec_incl);

                   if (int_ptr->cfs_req.var.mod0.add_nghbr[j].add_pilot_rec_incl)
                   {

                     word record_len = 0;
                     word record_start_pos = 0;

                     int_ptr->cfs_req.var.mod0.add_nghbr[j].nghbr_pilot_rec_type =
                       b_unpackb(buf_ptr, msg_pos,
                       FSIZ(VTYPE, nghbr_pilot_rec_type));
                     msg_pos += FSIZ(VTYPE, nghbr_pilot_rec_type);

                     record_len = b_unpackb(buf_ptr, msg_pos,
                       FSIZ(VTYPE,record_len));
                     msg_pos += FSIZ(VTYPE, record_len);

                     record_start_pos = msg_pos;

                     xlate_add_pilot_rec(int_ptr->cfs_req.var.mod0.add_nghbr[j].nghbr_pilot_rec_type,
                                         buf_ptr, msg_pos,
                                         &(int_ptr->cfs_req.var.mod0.add_nghbr[j].add_pilot_rec));

                     msg_pos = record_start_pos + record_len * 8;
                   }

                   if ((int_ptr->cfs_req.var.mod0.cf_srch_offset_incl) &&
                       ((int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode == SRCH_PRI_AND_WIN) ||
                        (int_ptr->cfs_req.var.mod0.cf_nghbr_srch_mode == SRCH_WIN_ONLY)))
                   {
                     int_ptr->cfs_req.var.mod0.add_nghbr[j].srch_offset_nghbr =
                       b_unpackb(buf_ptr, msg_pos, FSIZ(VTYPE, srch_offset_nghbr));
                     msg_pos += FSIZ(VTYPE, srch_offset_nghbr);
                   }
                 }
               } /* Checking for Pilot_Update = 1 */
             } /* If CAIX_P_REV_IS2000 checking */

             #undef VTYPE

             break;

           case CAI_CF_SRCH_TYPE_ANALOG:
             int_ptr->cfs_req.var.mod1.band_class =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_cfs_mod1_fix_type, band_class));
             msg_pos += FSIZ(cai_cfs_mod1_fix_type, band_class);

             int_ptr->cfs_req.var.mod1.sf_total_ec_thresh =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_cfs_mod1_fix_type, sf_total_ec_thresh));
             msg_pos += FSIZ(cai_cfs_mod1_fix_type, sf_total_ec_thresh);

             int_ptr->cfs_req.var.mod1.sf_total_ec_io_thresh =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_cfs_mod1_fix_type, sf_total_ec_io_thresh));
             msg_pos += FSIZ(cai_cfs_mod1_fix_type, sf_total_ec_io_thresh);

             msg_pos += FSIZ(cai_cfs_mod1_fix_type, reserved );

             int_ptr->cfs_req.var.mod1.num_analog_freqs =
               b_unpackb(buf_ptr, msg_pos,
               FSIZ(cai_cfs_mod1_fix_type, num_analog_freqs));
             msg_pos += FSIZ(cai_cfs_mod1_fix_type, num_analog_freqs);

             for (i=0; (i<int_ptr->cfs_req.var.mod1.num_analog_freqs)
                       && (i<CAI_CFS_ANALOG_MAX); i++)
             {
               int_ptr->cfs_req.var.mod1.analog_freq[i] =
                 b_unpackw(buf_ptr, msg_pos,
                 FSIZ(cai_cfs_mod1_var_type, analog_freq));
               msg_pos += FSIZ( cai_cfs_mod1_var_type, analog_freq);
             }
             break;

           default:
             MSG_MED("Invalid srch mode %d", int_ptr->cfs_req.fix.srch_mode,0,0);
             status = CAIX_INV_MSG_S;
             break;
          } /* switch*/

          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            // Append the Length with necessary Reserved.
            msg_pos = fix_len + int_ptr->cfs_req.fix.mod_sp_len * 8;

            int_ptr->cfs_req.align_timing =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_cfs_req_type, align_timing));
            msg_pos += FSIZ(cai_cfs_req_type,align_timing);

            if (int_ptr->cfs_req.align_timing)
            {
              int_ptr->cfs_req.search_offset =
                b_unpackb(buf_ptr, msg_pos,
                FSIZ(cai_cfs_req_type, search_offset));
              msg_pos += FSIZ(cai_cfs_req_type,search_offset);
            }
          }
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_cfs_req */

/*===========================================================================

FUNCTION XLATE_EXT_TC_CFS_CTRL

DESCRIPTION
  This function translates a Traffic Channel Candidate Frequency Control
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Candidate Frequency Control
  message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_cfs_ctrl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_cfs_ctrl_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(MTYPE))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->cfs_ctrl.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->cfs_ctrl.hdr.msg_int,
         int_ptr->cfs_ctrl.msg_type,
         int_ptr->cfs_ctrl.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->cfs_ctrl.hdr, int_ptr->cfs_ctrl.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->cfs_ctrl.use_time =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        int_ptr->cfs_ctrl.action_time =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
        msg_pos += FSIZ(MTYPE, action_time);

        int_ptr->cfs_ctrl.cfscm_seq =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, cfscm_seq));
        msg_pos += FSIZ(MTYPE, cfscm_seq);

        int_ptr->cfs_ctrl.srch_type =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, srch_type));
        msg_pos += FSIZ(MTYPE, srch_type);

        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        {
          int_ptr->cfs_ctrl.align_timing =
            b_unpackd( buf_ptr, msg_pos, FSIZ(MTYPE, align_timing));
          msg_pos += FSIZ(MTYPE, align_timing);
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_cfs_ctrl */

/*===========================================================================

FUNCTION XLATE_EXT_TC_PUF

DESCRIPTION
  This function translates a Power Up Function
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Power Up Function
  message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_puf
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position of record in message */
      
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_puf_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < FENDPOS( MTYPE, puf_freq_incl))
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->puf.hdr);

    msg_pos = FENDPOS(cai_puf_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->puf.hdr.msg_int,
         int_ptr->puf.msg_type,
         int_ptr->puf.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->puf.hdr, int_ptr->puf.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->puf.use_time =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, use_time));
        msg_pos += FSIZ(cai_puf_type, use_time);

        int_ptr->puf.action_time =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, action_time));
        msg_pos += FSIZ(cai_puf_type, action_time);

        int_ptr->puf.act_tm_frm =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, act_tm_frm));
        msg_pos += FSIZ(cai_puf_type, act_tm_frm);

        int_ptr->puf.puf_setup_sz =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_setup_sz));
        msg_pos += FSIZ(cai_puf_type, puf_setup_sz);

        int_ptr->puf.puf_pulse_sz =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_pulse_sz));
        msg_pos += FSIZ(cai_puf_type, puf_pulse_sz);

        int_ptr->puf.puf_interval =
          b_unpackw(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_interval));
        msg_pos += FSIZ(cai_puf_type, puf_interval);

        int_ptr->puf.puf_init_pwr =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_init_pwr));
        msg_pos += FSIZ(cai_puf_type, puf_init_pwr);

        int_ptr->puf.puf_pwr_step =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_pwr_step));
        msg_pos += FSIZ( cai_puf_type, puf_pwr_step);

        int_ptr->puf.tot_puf_prob =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, tot_puf_prob));
        msg_pos += FSIZ(cai_puf_type, tot_puf_prob);

        int_ptr->puf.max_pwr_puf =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, max_pwr_puf));
        msg_pos += FSIZ(cai_puf_type, max_pwr_puf);

        int_ptr->puf.puf_freq_incl =
          b_unpackd(buf_ptr, msg_pos, FSIZ(cai_puf_type, puf_freq_incl));
        msg_pos += FSIZ(cai_puf_type, puf_freq_incl);

        if ( int_ptr->puf.puf_freq_incl )
        {
          int_ptr->puf.band_class =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_puf_type, band_class));
          msg_pos += FSIZ(cai_puf_type, band_class);

          int_ptr->puf.cdma_freq =
            b_unpackw(buf_ptr, msg_pos, FSIZ(cai_puf_type, cdma_freq));
          msg_pos += FSIZ( cai_puf_type, cdma_freq );
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_puf */

/*===========================================================================

FUNCTION XLATE_EXT_TC_PUF_CMP

DESCRIPTION
  This function translates a Power Up Function Completion
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Power Up Function Completion
  message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_puf_cmp
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position of record in message */
       
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_puf_comp_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < FENDPOS( MTYPE, loc_ind))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->puf_comp.hdr);

    msg_pos = FENDPOS(cai_puf_comp_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->puf_comp.hdr.msg_int,
         int_ptr->puf_comp.msg_type,
         int_ptr->puf_comp.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->puf_comp.hdr, int_ptr->puf_comp.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        msg_pos += FSIZ(MTYPE, reserved);
        int_ptr->puf_comp.loc_ind =
          b_unpackd(buf_ptr, msg_pos, FSIZ(MTYPE, loc_ind));
        msg_pos += FSIZ(MTYPE, loc_ind);

        if (int_ptr->puf_comp.loc_ind)
        {
          msg_pos += FSIZ(MTYPE, reserved1);
          int_ptr->puf_comp.ms_lat = b_unpackd(buf_ptr, msg_pos,
            FSIZ(MTYPE, ms_lat));
          msg_pos += FSIZ(MTYPE, ms_lat);

          int_ptr->puf_comp.ms_long = b_unpackd( buf_ptr, msg_pos,
            FSIZ(MTYPE, ms_long));
          msg_pos += FSIZ(MTYPE, ms_long);

          int_ptr->puf_comp.tm_stamp = b_unpackd( buf_ptr, msg_pos,
            FSIZ(MTYPE, tm_stamp));
          msg_pos += FSIZ(MTYPE, tm_stamp);
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_puf_cmp */

/*===========================================================================

FUNCTION XLATE_EXT_HO_SRCH_PARMS

DESCRIPTION
  This function translates the searh parameters of a Generic Traffic Channel
  Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_srch_parms
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to srch parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.srch.srch_win_a, cai_ho_srch_type, srch_win_a);

  if ((int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
      || (int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
     )
  {
    /* GHDM, UHDM and MEID UHDM contain SRCH_WIN_N and SRCH_WIN_R. */
    UNPACKB_PG_DRF(ho.srch.srch_win_n, cai_ho_srch_type, srch_win_n);
    UNPACKB_PG_DRF(ho.srch.srch_win_r, cai_ho_srch_type, srch_win_r);
  }

  UNPACKB_PG_DRF(ho.srch.t_add, cai_ho_srch_type, t_add);
  UNPACKB_PG_DRF(ho.srch.t_drop, cai_ho_srch_type, t_drop);
  UNPACKB_PG_DRF(ho.srch.t_comp, cai_ho_srch_type, t_comp);
  UNPACKB_PG_DRF(ho.srch.t_tdrop, cai_ho_srch_type, t_tdrop);

  if ((int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
      || (int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
     )
  {
    /* GHDM, UHDM and MEID UHDM have soft handoff improvement fields. */
    UNPACKB_PG_DRF(ho.srch.soft_slope, cai_ho_srch_type, soft_slope);
    UNPACKB_PG_DRF(ho.srch.add_intercept, cai_ho_srch_type, add_intercept);
    UNPACKB_PG_DRF(ho.srch.drop_intercept, cai_ho_srch_type, drop_intercept);
  }

  return (status);

} /* xlate_ext_ho_srch_parms */

/*===========================================================================

FUNCTION XLATE_EXT_HO_EXTRA_PARMS

DESCRIPTION
  This function translates the "extra" parameters of a Generic Traffic
  Channel Handoff Direction Message from external to internal format.
  The "extra" parameters include hard handoff plus service configuration
  parameters plus some search parameters

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_extra_parms
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
      /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to extra parms */
)
{
  word status;
    /* Status returned to calling procedure */

  word len;
    /* Temporary length variable */


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  if (int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
  {
    /* Only the GHDM contains P_REV and PACKET_ZONE_ID right here.
       The EHDM may contain a P_REV field later in the message (95-B). */

    UNPACKB_PG_DRF(ho.extra.p_rev, cai_ho_extra_type, p_rev);
    UNPACKB_PG_DRF(ho.extra.packet_zone_id,
                   cai_ho_extra_type, packet_zone_id);
  }

  if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG) 
#ifdef FEATURE_MEID_SUPPORT
      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
     )
  {
    UNPACKB_PG_DRF(ho.extra.packet_zone_id,
                   cai_ho_extra_type, packet_zone_id);
  }

  UNPACKB_PG_DRF(ho.extra.frame_offset, cai_ho_extra_type, frame_offset);
  UNPACKB_PG_DRF(ho.extra.private_lcm, cai_ho_extra_type, private_lcm);
  UNPACKB_PG_DRF(ho.extra.reset_l2, cai_ho_extra_type, reset_l2);

  if (int_ptr->ho.msg_type != CAI_HO_DIR_MSG)
  {
    /* HDM does not contain these fields. */

    UNPACKB_PG_DRF(ho.extra.reset_fpc, cai_ho_extra_type, reset_fpc);

    /* The inclusion of SERV_NEG_TYPE in the EHDM depends on P_REV.  If it
       is not included, this is a reserved field.  We will parse it here
       as SERV_NEG_TYPE, and let MC decide what to do with it. */

    if ((int_ptr->ho.msg_type != CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
        && (int_ptr->ho.msg_type != CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
       )
    {
      UNPACKB_PG_DRF(ho.extra.serv_neg_type, cai_ho_extra_type, serv_neg_type);
    }
  }

  UNPACKB_PG_DRF(ho.extra.encrypt_mode, cai_ho_extra_type, encrypt_mode);

  if (int_ptr->ho.msg_type != CAI_HO_DIR_MSG)
  {
    /* HDM does not contain these fields. */

    /* NOM_PWR_EXT is not in the EHDM from IS-95A, but it is included
       in J-STD-008 and beyond.  In IS-95A, there is a reserved field of
       the same size here, so we will parse it as NOM_PWR_EXT. */

    UNPACKB_PG_DRF(ho.extra.nom_pwr_ext, cai_ho_extra_type, nom_pwr_ext);
    UNPACKB_PG_DRF(ho.extra.nom_pwr, cai_ho_extra_type, nom_pwr);

    if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
       )
    {
      UNPACKB_PG_DRF(ho.extra.rlgain_traffic_pilot, cai_ho_msg_is2000_type,
                     rlgain_traffic_pilot);
      UNPACKB_PG_DRF(ho.extra.default_rlag, cai_ho_msg_is2000_type,
                     default_rlag);
    }

    UNPACKB_PG_DRF(ho.extra.num_preamble, cai_ho_extra_type, num_preamble);
    UNPACKB_PG_DRF(ho.extra.band_class, cai_ho_extra_type, band_class);
  }

  if (int_ptr->ho.msg_type == CAI_HO_DIR_MSG)
  {
    /* FREQ_INCL is only included in the HDM.  In the HDM, CDMA_FREQ is
       included only if FREQ_INCL == 1. */

    UNPACKB_PG_DRF(ho.extra.freq_incl, cai_ho_freq_inc_type, freq_incl);
  }

  if ((int_ptr->ho.msg_type != CAI_HO_DIR_MSG) ||
      int_ptr->ho.extra.freq_incl)
  {
    UNPACKW_PG_DRF(ho.extra.cdma_freq, cai_ho_extra_type, cdma_freq);
  }

  if ((int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
      || (int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
     )
  {
    /* GHDM, UHDM and MEID UHDM contain these fields. */

    UNPACKB_PG_DRF(ho.extra.return_if_ho_fail,
                   cai_ho_extra_type, return_if_ho_fail);

    if (int_ptr->ho.extra.return_if_ho_fail)
    {
      /* Include complete search flag if return_if_ho_fail is set */

      UNPACKB_PG_DRF(ho.extra.complete_srch,
                     cai_ho_comp_srch_type, complete_srch);
    }

    UNPACKB_PG_DRF(ho.extra.periodic_srch, cai_ho_extra_type, periodic_srch);
    UNPACKB_PG_DRF(ho.extra.scr_included,
                   cai_ho_extra_type, scr_included);

    if (int_ptr->ho.extra.scr_included)
    {
      /* Service configuration is included */

      UNPACKB_PG_DRF(ho.extra.serv_con_seq,
                     cai_ho_svc_inc_type, serv_con_seq);

      /* Cheat and look ahead to get length, so we can use existing
         xlate_ext_srv_cfg routine.  RECORD_LEN is in bytes, so convert
         to bits then add size of header, as xlate function expects it. */

      len = 8*b_unpackb(buf_ptr,
                        *ext_msg_pos + (word)FPOS(cai_rec_hdr_type, record_len),
                        FSIZ(cai_rec_hdr_type, record_len))
            + sizeof(cai_rec_hdr_type);

      /* Translate service configuration record */
      status = xlate_ext_srv_cfg(len, buf_ptr, *ext_msg_pos,
                                 &int_ptr->ho.extra.cfg,
                                 1
                                 );
      *ext_msg_pos += len;
    }  // scr_included
  }  // GHDM


  return (status);

} /* xlate_ext_ho_extra_parms */

/*===========================================================================

FUNCTION XLATE_EXT_HO_FOR_INC

DESCRIPTION
  This function translates the included forward parameters of a Generic
  Traffic Channel Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/


word xlate_ext_ho_for_inc
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.sup.for_sup_config, cai_ho_sup_for_type, for_sup_config);

  if ((int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_STOP) ||
      (int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_START))
  {
    UNPACKB_PG_DRF(ho.sup.num_for_sup, cai_ho_for_sup_cfg_type, num_for_sup);

    if (int_ptr->ho.sup.num_for_sup > CAI_MAX_NUM_SUP)
    {
      /* We would write past the end of th array */

      return (status = CAIX_INV_LEN_S);
    }
  }

  if ((int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_START) ||
      (int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_START))
  {
    UNPACKB_PG_DRF(ho.sup.use_for_dur,
                  cai_ho_for_sup_cfg_type, use_for_duration);

    if (int_ptr->ho.sup.use_for_dur)
    {
      /* Get forward duration field too */

      UNPACKB_PG_DRF(ho.sup.for_dur, cai_ho_sup_for_dur_type, for_duration);
    }
  }
  else
  {
    int_ptr->ho.sup.use_for_dur = FALSE;
  }

  return (status);

} /* xlate_ext_ho_for_inc */

/*===========================================================================

FUNCTION XLATE_EXT_HO_REV_INC

DESCRIPTION
  This function translates the included reverse parameters of a Generic
  Traffic Channel Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/


word xlate_ext_ho_rev_inc
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.sup.rev_dtx_duration,
                 cai_ho_sup_rev_type, rev_dtx_duration);
  UNPACKB_PG_DRF(ho.sup.clear_retry_delay,
                 cai_ho_sup_rev_type, clr_retry_dly);
  UNPACKB_PG_DRF(ho.sup.use_rev_dur, cai_ho_sup_rev_type, use_rev_duration);

  if (int_ptr->ho.sup.use_rev_dur)
  {
    /* Decode the reverse duration value */

    UNPACKB_PG_DRF(ho.sup.rev_dur, cai_ho_sup_rev_dur_type, rev_duration);
  }

  UNPACKB_PG_DRF(ho.sup.num_rev_codes, cai_ho_sup_rev_type, num_rev_codes);
  UNPACKB_PG_DRF(ho.sup.use_t_add_abt, cai_ho_sup_rev_type, use_t_add_abort);

  return (status);

} /* xlate_ext_ho_rev_inc */

/*===========================================================================

FUNCTION XLATE_EXT_HO_REV_PARMS

DESCRIPTION
  This function translates the included reverse parameters of a Generic
  Traffic Channel Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_rev_parms
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.sup.t_mulchan, cai_ho_sup_rev_parm_type, t_mulchan);
  UNPACKB_PG_DRF(ho.sup.begin_pre, cai_ho_sup_rev_parm_type, begin_preamble);
  UNPACKB_PG_DRF(ho.sup.resume_pre,
                 cai_ho_sup_rev_parm_type, resume_preamble);

  return (status);

} /* xlate_ext_ho_rev_parms */

/*===========================================================================

FUNCTION XLATE_EXT_HO_SUP_PARMS

DESCRIPTION
  This function translates the supplemental parameters of a Generic Traffic
  Channel Handoff Direction Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_sup_parms
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  UNPACKB_PG_DRF(ho.sup.for_included,
                cai_ho_sup_chan_parms_type, for_included);

  if (int_ptr->ho.sup.for_included)
  {
    /* Forward supplemental assignment information is included */

    status = xlate_ext_ho_for_inc(buf_ptr, int_ptr, ext_msg_pos);

    if (status != CAIX_DONE_S)
    {
      return (status);
    }
  }

  UNPACKB_PG_DRF(ho.sup.rev_included,
                 cai_ho_sup_chan_parms_type, rev_included);

  if (int_ptr->ho.sup.rev_included)
  {
    /* Reverse supplemental assignment information is included */

    status = xlate_ext_ho_rev_inc(buf_ptr, int_ptr, ext_msg_pos);

    if (status != CAIX_DONE_S)
    {
      return (status);
    }
  }

  UNPACKB_PG_DRF(ho.sup.rev_parms_inc,
                 cai_ho_sup_chan_parms_type, rev_parms_inc);

  if (int_ptr->ho.sup.rev_parms_inc)
  {
    /* Reverse supplemental parameters are included */

    status = xlate_ext_ho_rev_parms(buf_ptr, int_ptr, ext_msg_pos);
  }

  return (status);

} /* xlate_ext_ho_sup_parms */

/*===========================================================================

FUNCTION XLATE_EXT_HO_CHAN

DESCRIPTION
  This function translates the pilot and supplemental code channel
  information array of a Generic Traffic Channel Handoff Direction Message
  from external to internal format.

DEPENDENCIES
  The fields SUP_CAHN_PARMS_INC, FOR_INCLUDED, FOR_SUP_CONFIG, NUM_PILOTS
  and NUM_FOR_SUP must have already been parsed and put into int_ptr.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Changes the value at the offset pointer (ext_msg_pos) corresponding to the
  parms that were decoded.  Puts parsed fields in location pointed to by
  int_ptr.

===========================================================================*/

word xlate_ext_ho_chan
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
  word status;
    /* Status returned to calling procedure */
  byte pilot;
    /* Loop variable and array index for pilot array */

  byte chan;
    /* Loop variable and array index for supplemental channel array */

  boolean check_sup;
    /* Indicator to check for supplemental channels */
  byte num_for_sup;
    /* Temp variable to hold number of supplemental code channels */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ((int_ptr->ho.num_pilots == 0 ||
       int_ptr->ho.num_pilots > CAI_HO_MSG_MAX_PILOTS))
  {
    /* Message must have at least one pilot to be valid, but also
       do not want to write past end of array with too many pilots. */

    status = CAIX_INV_LEN_S;
    return (status);
  }

  status = CAIX_DONE_S;

  /* Check to see if key fields have valid info, and assign temp
     variables accordingly to help create channel array. */

  if (int_ptr->ho.sup_chan_parms_inc  &&
      int_ptr->ho.sup.for_included    &&
      ((int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_STOP) ||
       (int_ptr->ho.sup.for_sup_config == CAI_FOR_SUP_SPEC_START)))
  {
    /* Check for forward supplemental channels */

    check_sup = TRUE;
    num_for_sup = int_ptr->ho.sup.num_for_sup;
  }
  else
  {
    /* No supplemental info is included. */

    check_sup = FALSE;
    num_for_sup = 0;
  }


  for (pilot = 0; pilot < int_ptr->ho.num_pilots; pilot++)
  {
    UNPACKW_PG_DRF(ho.pilot[pilot].pilot_pn,
                   cai_ho_msg_pilot_type, pilot_pn);
    UNPACKB_PG_DRF(ho.pilot[pilot].pwr_comb_ind,
                  cai_ho_msg_pilot_type, pwr_comb_ind);
#if (defined(FEATURE_MSG_PACK_UNIT_TEST))
#error code not present
#else
    UNPACKB_PG_DRF(ho.pilot[pilot].code_chan_fch,
                  cai_ho_msg_pilot_type, code_chan);
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    if (check_sup)
    {
      /* for_sup_included is included */

      UNPACKB_PG_DRF(ho.pilot[pilot].for_sup_inc,
                     cai_ho_for_sup_cfg_sup_type, for_sup_inc);

      if (int_ptr->ho.pilot[pilot].for_sup_inc)
      {
        /* Forward supplemental channel record is included */

        UNPACKB_PG_DRF(ho.pilot[pilot].expl_code_chan,
                       cai_ho_for_sup_ch_rec_type, expl_code_chan);

        if (int_ptr->ho.pilot[pilot].expl_code_chan)
        {
          /* forward supplemental code channels are explicitly listed */

          for (chan = 0; chan < num_for_sup; chan++)
          {
            UNPACKB_PG_DRF(ho.pilot[pilot].chan_rec.sup_code_chan[chan],
                           cai_ho_for_sup_chan_type, sup_code_chan);
          }
        }
        else
        {
          /* only base code channel is explicitly listed */

          UNPACKB_PG_DRF(ho.pilot[pilot].chan_rec.base_code_chan,
                         cai_ho_for_sup_base_type, base_code_chan);
        }
      } /* if (for_sup_included) */
    } /* if (check_sup) */


  } /* for (pilots) */

  return (status);

} /* xlate_ext_ho_chan */

#if defined(FEATURE_IS2000_REL_A) || defined(FEATURE_MEID_SUPPORT)
/*===========================================================================

FUNCTION XLATE_HO_ENC_CC

DESCRIPTION
  This function translates cc info, sync_id and enc information for the GHDM & UHDM

DEPENDENCIES

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS

===========================================================================*/

void xlate_ho_enc_cc
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word *ext_msg_pos_ptr
    /* Pointer to offset from buf_ptr to get to supplemental parms */
)
{
    int i;
    word ext_msg_pos = *ext_msg_pos_ptr;

    if (int_ptr->ho.extra_parms)
    {
       /* unpack encrypt info */
       if (int_ptr->ho.extra.encrypt_mode == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
       {
         int_ptr->ho.d_sig_encrypt_mode =  b_unpackb( buf_ptr, ext_msg_pos,
                        FSIZ(cai_ho_msg_sig_enc_type,d_sig_encrypt_mode));
         ext_msg_pos += FSIZ(cai_ho_msg_sig_enc_type,d_sig_encrypt_mode);
       }

       if ((int_ptr->ho.extra.encrypt_mode == CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG) ||
           (int_ptr->ho.extra.encrypt_mode == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
       {
         /* key_size included */
         int_ptr->ho.key_size =  b_unpackb( buf_ptr, ext_msg_pos,
                          FSIZ(cai_ho_msg_sig_enc_type,key_size));
         ext_msg_pos += FSIZ(cai_ho_msg_sig_enc_type,key_size);
       }

    } // if (int_ptr->ho.extra_parms)

    // 3X fields only in UHDM and MEID UHDM
    if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
       )
    {
       int_ptr->ho.threexfl_1xrl_incl =  b_unpackb( buf_ptr, ext_msg_pos,
                     FSIZ(cai_ho_msg_1xrl_type,threexfl_1xrl_incl));
       ext_msg_pos += FSIZ(cai_ho_msg_1xrl_type,threexfl_1xrl_incl);

       if (int_ptr->ho.threexfl_1xrl_incl)
       {
         int_ptr->ho.onexrl_freq_offset =  b_unpackb( buf_ptr, ext_msg_pos,
                     FSIZ(cai_ho_msg_1xrl_type,onexrl_freq_offset));
         ext_msg_pos += FSIZ(cai_ho_msg_1xrl_type,onexrl_freq_offset);
       }
    }

    if (int_ptr->ho.extra_parms)
    {

      /* sync ID */
       if (int_ptr->ho.extra.scr_included || int_ptr->ho.extra.nnscr_included)
       {
         int_ptr->ho.sync_id_incl = b_unpackb( buf_ptr, ext_msg_pos,
                     FSIZ(cai_srv_con_fix_type, sync_id_incl));
         ext_msg_pos += FSIZ(cai_srv_con_fix_type, sync_id_incl);

         if (int_ptr->ho.sync_id_incl)
         {
           int_ptr->ho.sync_id_len = b_unpackb( buf_ptr, ext_msg_pos,
                       FSIZ(cai_srv_cfg_sync_id_type, sync_id_len));
           ext_msg_pos += FSIZ(cai_srv_cfg_sync_id_type, sync_id_len);

           for (i=0; i<int_ptr->ho.sync_id_len; i++)
           {
             int_ptr->ho.sync_id[i] = b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ(cai_srv_cfg_sync_id_type, sync_id));
             ext_msg_pos += FSIZ(cai_srv_cfg_sync_id_type, sync_id);
           }
         }

       } /* if (int_ptr->ho.extra.scr_included ..) */

       if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
           || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
          )
       {
         /* cc info */
         if (int_ptr->ho.extra.scr_included)
         {
           int_ptr->ho.cc.cc_info_incl =  b_unpackb( buf_ptr, ext_msg_pos,
                    FSIZ(cai_cc_info_fix_type,cc_info_incl));
           ext_msg_pos += FSIZ(cai_cc_info_fix_type,cc_info_incl);

           /* CC Info is UHDM specific only */
           if (int_ptr->ho.cc.cc_info_incl)
           {
             int_ptr->ho.cc.num_calls_assign =  b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ(cai_cc_info_fix_type, num_calls_assign));
             ext_msg_pos += FSIZ(cai_cc_info_fix_type, num_calls_assign);

             for (i=0; i<int_ptr->ho.cc.num_calls_assign ; i++ )
             {
               int_ptr->ho.cc.conn[i].con_ref =
                 b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ(cai_cc_info_type, con_ref));
               ext_msg_pos += FSIZ(cai_cc_info_type, con_ref);

               int_ptr->ho.cc.conn[i].response_ind =
                 b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ(cai_cc_info_type, response_ind));
               ext_msg_pos += FSIZ(cai_cc_info_type, response_ind);

               if (int_ptr->ho.cc.conn[i].response_ind)
               {
                 int_ptr->ho.cc.conn[i].tag =
                   b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ(cai_cc_info_type, tag));
                 ext_msg_pos += FSIZ(cai_cc_info_type, tag);
               }
               else
               {
                 int_ptr->ho.cc.conn[i].bypass_alert_answer =
                   b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ(cai_cc_info_type, bypass_alert_answer));
                 ext_msg_pos += FSIZ(cai_cc_info_type, bypass_alert_answer);
               }
             } /* for */
           } /* if (int_ptr->ho.cc.cc_info_incl) */
         }
         else
         {
           /* If SCR not included, set CC_INFO_INCL to 0 */
           int_ptr->ho.cc.cc_info_incl = 0;
         } /* if (int_ptr->ho.extra.scr_included) */
       } /* if UHDM */
       else
       {
         /* If not UHDM, set CC_INFO_INCL to 0 */
         int_ptr->ho.cc.cc_info_incl = 0;
       }
    } // if (int_ptr->ho.extra_parms)

    *ext_msg_pos_ptr = ext_msg_pos;

}
#endif /* FEATURE_IS2000_REL_A || FEATURE_MEID_SUPPORT */

/*===========================================================================

FUNCTION XLATE_EXT_HO_MSG

DESCRIPTION
  This function translates a Generic Traffic Channel Handoff Direction
  Message (HDM, EHDM, GHDM, UHDM, MEID UHDM) from external to internal format.

DEPENDENCIES
  Assumes that the internal message type field received as an input to the
  function already includes the Handoff Direction Message type.  Also
  assumes that the message buffer is pointing to the field after the
  message type field.  Note:  Since this is a sort of like a union of all of
  the handoff direction messages, generally one CANNOT use sizeof on the
  cai.h structures, as they may contain extra fields.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  Puts parsed message in location pointed to by int_ptr.

===========================================================================*/

word xlate_ext_ho_msg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of variable part of message */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (len < CAI_HO_MSG_MIN_LENGTH)
  {
    return CAIX_INV_LEN_S;
  }

  /* -----------------------------------------------------------------
  ** Length is OK --> convert message from external to internal format
  ** starting with the first field after message_type
  ** -------------------------------------------------------------- */

  /* Tell pre-processor that it hasn't looked at this message yet */
  int_ptr->ho.pre_proc_done = FALSE;

    /* buf_ptr points to first field (msg_type), so
       position ext_msg_pos right after to point to TC header. */
    ext_msg_pos = (word)FENDPOS(cai_ho_msg_fix_type, msg_type);

    xlate_ext_tc_hdr(buf_ptr, &int_ptr->ho.hdr);
    ext_msg_pos = FENDPOS(cai_ho_msg_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED, &ext_msg_pos, buf_ptr, 
         &int_ptr->ho.hdr.msg_int, int_ptr->ho.msg_type,
         int_ptr->ho.hdr.ack_req)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
    if ((status = xlate_ext_ext_enc_tc(&len, &ext_msg_pos, buf_ptr,
         &int_ptr->ho.hdr, int_ptr->ho.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */

  UNPACKB_PG(ho.use_time, cai_ho_msg_fix_type, use_time);

  if (int_ptr->ho.use_time ||
      ((int_ptr->ho.msg_type != CAI_GEN_HO_DIR_MSG) &&
       (int_ptr->ho.msg_type != CAI_UNIV_HO_DIR_MSG) 
#ifdef FEATURE_MEID_SUPPORT
       && (int_ptr->ho.msg_type != CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
      ))
  {
    /* In the GHDM, UHDM and MEID UHDM, action_time is absent
       if use_time == 0 */
    UNPACKB_PG(ho.action_time, cai_ho_action_time_type, action_time);
  }

  UNPACKB_PG(ho.hdm_seq, cai_ho_msg_fix_type, hdm_seq);

  if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
     )
  {
    UNPACKB_PG(ho.parms_incl, cai_ho_msg_is2000_type, parms_incl);
    if (int_ptr->ho.parms_incl)
    {
      UNPACKB_PG(ho.extra.p_rev, cai_ho_extra_type, p_rev);
      UNPACKB_PG(ho.extra.serv_neg_type, cai_ho_extra_type, serv_neg_type);
    }
  }

  if (int_ptr->ho.msg_type != CAI_HO_DIR_MSG)
  {
    UNPACKB_PG(ho.srch_inc, cai_ho_msg_fix_type, srch_inc);
  }
  else
  {
    /* There is no SRCH_INC field in the HDM, but SRCH parms are there. */
    int_ptr->ho.srch_inc = TRUE;
  }

  if (int_ptr->ho.srch_inc)
  {
    /* The search parameters are included for this message. */
    status = xlate_ext_ho_srch_parms(buf_ptr, int_ptr, &ext_msg_pos);

    if (status != CAIX_DONE_S)
    {
      return (status);
    }
  }

  if (int_ptr->ho.msg_type != CAI_HO_DIR_MSG)
  {
    /* This is the same bit as HARD_INCLUDED in the EHDM, and it serves
       roughly the same function, so parse it as EXTRA_PARMS. */

    UNPACKB_PG(ho.extra_parms, cai_ho_msg_fix_type, extra_parms);
  }
  else
  {
    /* There is no EXTRA_PARMS field in the HDM, but some of the
       subfields are there. */
    int_ptr->ho.extra_parms = TRUE;
  }

  if (int_ptr->ho.extra_parms)
  {
    /* The "extra" parameters include hard handoff plus service
       configuration parameters plus some search parameters. */

    status = xlate_ext_ho_extra_parms(buf_ptr, int_ptr, &ext_msg_pos);

    if (status != CAIX_DONE_S)
    {
      return (status);
    }

    if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
       )
    {
      int_ptr->ho.extra.nnscr_included =
        b_unpackb(buf_ptr,ext_msg_pos,
              FSIZ(cai_ho_msg_is2000_type,nnscr_included));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type,nnscr_included);
      if (int_ptr->ho.extra.nnscr_included)
      {
        xlate_int_non_neg_srv_cfg(buf_ptr,&ext_msg_pos,
                                  &(int_ptr->ho.extra.non_neg_cfg));
      }
    }
  }

  if (int_ptr->ho.msg_type == CAI_EXT_HO_DIR_MSG)
  {
    /* Only the EDHM has ADD_LENGTH field which may indicate that the
       message contains P_REV information (IS-95B and beyond).  At least
       in theory, P_REV could be included while HARD_INC == 0, so we
       parse it outside of the EXTRA_PARMS parser. */

    UNPACKB_PG(ho.add.add_length, cai_ho_add_length_type, add_length );

    if ((int_ptr->ho.add.add_length) != 0)
    {
      int_ptr->ho.add.ext_ho_p_rev = b_unpackb(
        buf_ptr, ext_msg_pos, FSIZ(cai_ho_add_length_type, ext_ho_p_rev));
    }

    ext_msg_pos += int_ptr->ho.add.add_length * 8;
  }

  if (int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
  {
    /* Only the GHDM contains supplemental channel information
             and PWR_CNTL_STEP. */

    UNPACKB_PG(ho.sup_chan_parms_inc, cai_ho_msg_fix_type, sup_chan_parms_inc);

    if (int_ptr->ho.sup_chan_parms_inc)
    {
      /* The Supplemental Channel Parameters are included. */

      status = xlate_ext_ho_sup_parms(buf_ptr, int_ptr, &ext_msg_pos);

      if (status != CAIX_DONE_S)
      {
        return (status);
      }
    }

    UNPACKB_PG(ho.use_pwr_cntl_step, cai_ho_msg_fix_type, use_pwr_cntl_step);

    if (int_ptr->ho.use_pwr_cntl_step)
    {
      /* Power control step size is included. */

      UNPACKB_PG(ho.pwr_cntl_step, cai_ho_pwr_cntl_type, pwr_cntl_step);
    }
  }
  else
  {
    /* There is no supplemental channel info or PWR_CNTL_STEP
       in the HDM or EHDM. */
    int_ptr->ho.sup_chan_parms_inc = FALSE;
    int_ptr->ho.use_pwr_cntl_step = FALSE;
  }

  if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
     )
  {
    UNPACKB_PG(ho.use_pwr_cntl_step,
               cai_ho_msg_fix_type, use_pwr_cntl_step);

    if (int_ptr->ho.use_pwr_cntl_step)
    {
      /* Power control step size is included. */
      UNPACKB_PG(ho.pwr_cntl_step, cai_ho_pwr_cntl_type, pwr_cntl_step);
    }

    UNPACKB_PG(ho.clear_retry_delay,
               cai_ho_msg_is2000_type, clear_retry_delay);
  }


  if ((int_ptr->ho.msg_type != CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
      && (int_ptr->ho.msg_type != CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
     )
  {
    if (int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG)
    {
      /* The GHDM tells us how many pilot records there are. */
      UNPACKB_PG(ho.num_pilots, cai_ho_msg_fix_type, num_pilots);
    }
    else
    {
      /* Note: This section is also part of the else from above
               (inside the #ifdef). */

      /* HDM and EHDM do not have a NUM_PILOTS field, so calculate it.  The
         calculation assumes that the pilot array is at the very end of the
         message (except for the RESERVED field).  This is true for the HDM
         and EHDM.  The integer division takes care of the RESERVED field
         which is always smaller than cai_ho_msg_pilot_type. */

      /* Since length is: ext_msg_pos (length of preceding fields)
                          + NUM_PILOTS*sizeof(cai_ho_msg_pilot_type)
                          + RESERVED

         then: (length - ext_msg_pos)/sizeof(cai_ho_msg_pilot_type)
         is:   NUM_PILOTS + RESERVED/sizeof(cai_ho_msg_pilot_type)
         now:  RESERVED/sizeof(cai_ho_msg_pilot_type) == 0 for integer math
         so: NUM_PILOTS == (length - ext_msg_pos)/sizeof(cai_ho_msg_pilot_type)
      */

      int temp_len = len - ext_msg_pos;
      
#ifdef FEATURE_IS2000_REL_C
      if (int_ptr->ho.hdr.msg_int.maci_incl)
      {
        /* Exclude MACI bits */
        temp_len -= FSIZ(cai_msg_int_type, maci);
      }
#endif /* FEATURE_IS2000_REL_C */

      if (temp_len > 0)
      {
        int_ptr->ho.num_pilots =
          (byte)temp_len/sizeof(cai_ho_msg_pilot_type);
      }
      else
      {
        return (status = CAIX_INV_LEN_S);
      }
    }

    status = xlate_ext_ho_chan(buf_ptr, int_ptr, &ext_msg_pos); /*lint !e725*/
  }

  /**********************************************************
                UHDM, MEID UHDM Specific parsing
  ***********************************************************/

  if ((int_ptr->ho.msg_type == CAI_UNIV_HO_DIR_MSG)
#ifdef FEATURE_MEID_SUPPORT
      || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
     )
  {
    word i,j;
    word record_len;
    word start_record_pos;

#ifdef FEATURE_IS2000_REL_A
    boolean thx_info_included_in_msg;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    boolean parse_rev_fch_gating_mode;
#endif /* FEATURE_IS2000_REL_C */

    UNPACKB_PG(ho.sch_incl, cai_ho_msg_is2000_type, sch_incl);

    if (int_ptr->ho.sch_incl)
    {
      UNPACKB_PG(ho.num_for_assign, cai_ho_msg_is2000_type, num_for_assign);
      for (i=0;i<int_ptr->ho.num_for_assign && i<CAI_MAX_NUM_FOR_SCH;i++)
      {
        UNPACKB_PG(ho.for_assign[i].for_sch_id,cai_ho_msg_is2000_type,
                   for_sch_id);
        UNPACKB_PG(ho.for_assign[i].for_sch_duration,
                   cai_ho_msg_is2000_type,for_sch_duration);
        UNPACKB_PG(ho.for_assign[i].for_sch_start_time_incl,
                   cai_ho_msg_is2000_type,for_sch_start_time_incl);
        if (int_ptr->ho.for_assign[i].for_sch_start_time_incl)
        {
          UNPACKB_PG(ho.for_assign[i].for_sch_start_time,
                     cai_ho_msg_is2000_type,for_sch_start_time);
        }
        UNPACKB_PG(ho.for_assign[i].sccl_index,
                   cai_ho_msg_is2000_type,sccl_index);
      }

      UNPACKB_PG(ho.num_rev_assign, cai_ho_msg_is2000_type, num_rev_assign);
      for (i=0;i<int_ptr->ho.num_rev_assign && i<CAI_MAX_NUM_REV_SCH;i++)
      {
        UNPACKB_PG(ho.rev_assign[i].rev_sch_id,cai_ho_msg_is2000_type,
                   rev_sch_id);
        UNPACKB_PG(ho.rev_assign[i].rev_sch_duration,
                   cai_ho_msg_is2000_type,rev_sch_duration);
        UNPACKB_PG(ho.rev_assign[i].rev_sch_start_time_incl,
                   cai_ho_msg_is2000_type,rev_sch_start_time_incl);
        if (int_ptr->ho.rev_assign[i].rev_sch_start_time_incl)
        {
          UNPACKB_PG(ho.rev_assign[i].rev_sch_start_time,
                     cai_ho_msg_is2000_type,rev_sch_start_time);
        }
        UNPACKB_PG(ho.rev_assign[i].rev_sch_rate,
                   cai_ho_msg_is2000_type,rev_sch_rate);
      }
    }

    UNPACKB_PG(ho.fpc_subchan_gain,cai_ho_msg_is2000_type,fpc_subchan_gain);
    UNPACKB_PG(ho.use_pc_time,cai_ho_msg_is2000_type,use_pc_time);
    if (int_ptr->ho.use_pc_time)
    {
      UNPACKB_PG(ho.pc_action_time,cai_ho_msg_is2000_type,pc_action_time);
    }
    UNPACKB_PG(ho.ch_ind,cai_ho_msg_is2000_type,ch_ind);

    record_len = b_unpackb(buf_ptr,ext_msg_pos,
                           FSIZ(cai_ho_msg_is2000_type,active_set_rec_len));
    ext_msg_pos += FSIZ(cai_ho_msg_is2000_type,active_set_rec_len);
    start_record_pos = ext_msg_pos;

    if ((int_ptr->ho.ch_ind == CAI_DED_CTL) ||
        (int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT) ||
        (int_ptr->ho.ch_ind == CAI_DED_CTL_CONT_REV_PLT) ||
        (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
    {
      if (int_ptr->ho.sch_incl)
      {
        UNPACKB_PG(ho.sch_cfg.num_for_sch,cai_sch_cfg_type,num_for_sch);
        for (i=0; i<int_ptr->ho.sch_cfg.num_for_sch &&
                  i<CAI_MAX_NUM_FOR_SCH_CFG; i++)
        {
          UNPACKB_PG(ho.sch_cfg.for_sch_cfg[i].for_sch_id,
                     cai_sch_cfg_type,for_sch_id);
          UNPACKB_PG(ho.sch_cfg.for_sch_cfg[i].sccl_index,
                     cai_sch_cfg_type,sccl_index);
          UNPACKB_PG(ho.sch_cfg.for_sch_cfg[i].for_sch_rate,
                     cai_sch_cfg_type,for_sch_rate);
        }

        UNPACKB_PG(ho.sch_cfg.num_rev_sch,cai_sch_cfg_type,num_rev_sch);

        for (i=0; i<int_ptr->ho.sch_cfg.num_rev_sch &&
                  i<CAI_MAX_NUM_REV_SCH_CFG; i++)
        {
          UNPACKB_PG(ho.sch_cfg.rev_sch_cfg[i].rev_sch_id,
                     cai_sch_cfg_type,rev_sch_id);
          UNPACKB_PG(ho.sch_cfg.rev_sch_cfg[i].rev_walsh_id,
                     cai_sch_cfg_type,rev_walsh_id);
          UNPACKB_PG(ho.sch_cfg.rev_sch_cfg[i].rev_sch_rate,
                     cai_sch_cfg_type,rev_sch_rate);
        }
      }

      UNPACKB_PG(ho.num_pilots,cai_ho_msg_fix_type,num_pilots);

      UNPACKB_PG(ho.srch_offset_incl,cai_ho_msg_is2000_type,srch_offset_incl);

      for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++)
      {
        UNPACKW_PG(ho.pilot[i].pilot_pn,cai_ho_msg_pilot_type,pilot_pn);
        if (int_ptr->ho.srch_offset_incl)
        {
          UNPACKB_PG(ho.pilot[i].srch_offset,
                     cai_ho_msg_pilot_is2000_type,srch_offset);
        }
        else
        {
          int_ptr->ho.pilot[i].srch_offset = 0;
        }

        UNPACKB_PG(ho.pilot[i].add_pilot_rec_incl,
                   cai_ho_msg_pilot_is2000_type,add_pilot_rec_incl);

        if (int_ptr->ho.pilot[i].add_pilot_rec_incl)
        {
          word tmp_record_len = 0;
          word record_start_pos = 0;

          /* xlate_add_pilot_rec */
          UNPACKB_PG(ho.pilot[i].pilot_rec_type,
                     cai_ho_msg_pilot_is2000_type,pilot_rec_type);
          tmp_record_len = b_unpackb(buf_ptr,ext_msg_pos,
                           FSIZ(cai_ho_msg_pilot_is2000_type,record_len));
          ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type,record_len);

          record_start_pos = ext_msg_pos;

          xlate_add_pilot_rec(int_ptr->ho.pilot[i].pilot_rec_type,
                              buf_ptr, ext_msg_pos,
                              &(int_ptr->ho.pilot[i].add_pilot_rec));

          ext_msg_pos = record_start_pos + tmp_record_len*8;
        }

        UNPACKB_PG(ho.pilot[i].pwr_comb_ind,cai_ho_msg_pilot_type,
                   pwr_comb_ind);

        if ((int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT) ||
            (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
        {
          UNPACKW_PG(ho.pilot[i].code_chan_fch,
                     cai_ho_msg_pilot_is2000_type,code_chan_fch);
          UNPACKB_PG(ho.pilot[i].qof_mask_id_fch,
                     cai_ho_msg_pilot_is2000_type,qof_mask_id_fch);
        }

        if ((int_ptr->ho.ch_ind == CAI_DED_CTL) ||
            (int_ptr->ho.ch_ind == CAI_DED_CTL_CONT_REV_PLT) ||
            (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
        {
          UNPACKW_PG(ho.pilot[i].code_chan_dcch,
                     cai_ho_msg_pilot_is2000_type,code_chan_dcch);
          UNPACKB_PG(ho.pilot[i].qof_mask_id_dcch,
                     cai_ho_msg_pilot_is2000_type,qof_mask_id_dcch);
        }

        if (int_ptr->ho.sch_incl)
        {
          UNPACKB_PG(ho.pilot[i].num_sch,
                     cai_ho_msg_pilot_is2000_type,num_sch);

          for (j=0; j<int_ptr->ho.pilot[i].num_sch &&
                    j<CAI_MAX_NUM_SCH_CHAN; j++)
          {
            if (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT)
            {
              UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].for_sch_id,
                         cai_sch_chan_rec_type,for_sch_id_111);
            }
            else
            {
              UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].for_sch_id,
                         cai_sch_chan_rec_type,for_sch_id);
            }

            UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].sccl_index,
                       cai_sch_chan_rec_type,sccl_index);
            UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl,
                       cai_sch_chan_rec_type,pilot_incl);

            if (int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl)
            {
              UNPACKW_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].code_chan_sch,
                         cai_sch_chan_rec_type,code_chan_sch);
              UNPACKB_PG(ho.pilot[i].chan_rec.sch_chan_rec[j].qof_mask_id_sch,
                         cai_sch_chan_rec_type,qof_mask_id_sch);
            }
          }
        }
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        thx_info_included_in_msg = FALSE;
        /* 3x fields can be fch only, dcch only or may exist for both */

        /* Get fch_info_incl, if present */
        if ((int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT ) ||
            (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
        {
          UNPACKB_PG(ho.thx_and_ccsh_info.thx_fch_info_incl,
                     cai_ho_msg_3xfch_fix_type, thx_fch_info_incl);

          if (int_ptr->ho.thx_and_ccsh_info.thx_fch_info_incl)
          {
             // this will be used later to figure out if SCH 3X info is present
             thx_info_included_in_msg = TRUE;
           }
         }

        /* get dcch_info_incl, if present */
        if ((int_ptr->ho.ch_ind == CAI_DED_CTL) ||
            (int_ptr->ho.ch_ind == CAI_DED_CTL_CONT_REV_PLT) ||
            (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))
        {
          UNPACKB_PG(ho.thx_and_ccsh_info.thx_dcch_info_incl,
                     cai_ho_msg_3xdcch_fix_type, thx_dcch_info_incl);

          if (int_ptr->ho.thx_and_ccsh_info.thx_dcch_info_incl)
          {
             thx_info_included_in_msg = TRUE;
          }
        }

        for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++)
        {
          if (((int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT) ||
               (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT))  &&
                int_ptr->ho.thx_and_ccsh_info.thx_fch_info_incl)
          {
            UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_fch_low_incl,
                        cai_ho_msg_3xfch_type, thx_fch_low_incl);

            if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_fch_low_incl)
            {
              UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].qof_mask_id_fch_low,
                          cai_ho_msg_3xfch_type, qof_mask_id_fch_low);
              UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].code_chan_fch_low,
                          cai_ho_msg_3xfch_type, code_chan_fch_low);
            }

            UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_fch_high_incl,
                       cai_ho_msg_3xfch_type, thx_fch_high_incl);

            if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_fch_high_incl)
            {
              UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].qof_mask_id_fch_high,
                         cai_ho_msg_3xfch_type, qof_mask_id_fch_high);
              UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].code_chan_fch_high,
                         cai_ho_msg_3xfch_type, code_chan_fch_high);
            }
          } // if

          if (((int_ptr->ho.ch_ind == CAI_DED_CTL) ||
                (int_ptr->ho.ch_ind == CAI_DED_CTL_CONT_REV_PLT) ||
                (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT)) &&
               int_ptr->ho.thx_and_ccsh_info.thx_dcch_info_incl)
          {
             UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_dcch_low_incl,
                        cai_ho_msg_3xdcch_type, thx_dcch_low_incl);

             if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_dcch_low_incl)
             {
               UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].qof_mask_id_dcch_low,
                          cai_ho_msg_3xdcch_type, qof_mask_id_dcch_low);
               UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].code_chan_dcch_low,
                          cai_ho_msg_3xdcch_type, code_chan_dcch_low);
             }

             UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_dcch_high_incl,
                        cai_ho_msg_3xdcch_type, thx_dcch_high_incl);

             if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_dcch_high_incl)
             {
               UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].qof_mask_id_dcch_high,
                          cai_ho_msg_3xdcch_type, qof_mask_id_dcch_high);
               UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].code_chan_dcch_high,
                          cai_ho_msg_3xdcch_type, code_chan_dcch_high);
             }
          } // if

          /* Now unpack 3x sch fields, if present */
         if (thx_info_included_in_msg && int_ptr->ho.sch_incl)
         {
             UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].thx_sch_info_incl,
                        cai_sch_chan_rec_type, thx_sch_info_incl);

             if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].thx_sch_info_incl)
             {
               for (j=0; j<int_ptr->ho.pilot[i].num_sch &&
                         j<CAI_MAX_NUM_SCH_CHAN; j++)
               {
                 UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].for_sch_id,
                            cai_sch_chan_rec_type, for_sch_id);
                 UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].thx_sch_low_incl,
                            cai_sch_chan_rec_type, thx_sch_low_incl);

                 if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].thx_sch_low_incl)
                 {
                   UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].qof_mask_id_sch_low,
                              cai_sch_chan_rec_type, qof_mask_id_sch_low);
                   UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].code_chan_sch_low,
                              cai_sch_chan_rec_type, code_chan_sch_low);
                 }

                 UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].thx_sch_high_incl,
                            cai_sch_chan_rec_type, thx_sch_high_incl);

                 if (int_ptr->ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].thx_sch_high_incl)
                 {
                   UNPACKB_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].qof_mask_id_sch_high,
                              cai_sch_chan_rec_type, qof_mask_id_sch_high);
                   UNPACKW_PG(ho.thx_and_ccsh_info.pilot_threex[i].sch_chan_rec_threex[j].code_chan_sch_high,
                   cai_sch_chan_rec_type, code_chan_sch_high);
                 }
               } // for (j = ..)
             }
         } // if (int_ptr->ho.sch_incl)
        } // for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++)
      } // if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A))
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        UNPACKB_PG(ho.thx_and_ccsh_info.ccsh_included, cai_ho_msg_ccsh_type,
                   ccsh_included);

        if (int_ptr->ho.thx_and_ccsh_info.ccsh_included)
        {
          UNPACKB_PG(ho.thx_and_ccsh_info.use_ccsh_encoder_time,
            cai_ho_msg_ccsh_type, use_ccsh_encoder_time);

          if (int_ptr->ho.thx_and_ccsh_info.use_ccsh_encoder_time)
          {
            UNPACKB_PG(ho.thx_and_ccsh_info.ccsh_encoder_action_time,
                cai_ho_msg_ccsh_type, ccsh_encoder_action_time);
          }

          if (int_ptr->ho.sch_incl)
          {
            for (i=0; i<int_ptr->ho.num_pilots &&
                     i<CAI_HO_MSG_MAX_PILOTS; i++)
            {
              for (j=0; j<int_ptr->ho.pilot[i].num_sch &&
                       j<CAI_MAX_NUM_SCH_CHAN; j++)
              {
                if (int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl)
                {
                  UNPACKB_PG(ho.thx_and_ccsh_info.pilot[i].sch[j].ccsh_encoder_type,
                     cai_ho_msg_ccsh_type, ccsh_encoder_type);
                }
              }
            }
          }
        } /* if ccsh_included */
      }  /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) */
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    } // if ((int_ptr->ho.ch_ind == CAI_DED_CTL) || ...

#ifdef FEATURE_IS2000_REL_C
    else if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) && (int_ptr->ho.ch_ind == CAI_REFER_TO_EXT_CH_IND))
    {
      int_ptr->ho.ext_ch_ind = 
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, ext_ch_ind));
      ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, ext_ch_ind);

      ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, reserved);

#ifndef FEATURE_IS2000_REL_D
      if ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_F) || 
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_D) || 
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_F) || 
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PD_D) || 
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_FD) || 
          (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PFD_FD))
#endif /* FEATURE_IS2000_REL_D */
        
      {
        int_ptr->ho.pdch_control_hold = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_control_hold));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_control_hold);
        
        int_ptr->ho.full_ci_feedback_ind = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, full_ci_feedback_ind));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, full_ci_feedback_ind);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

        int_ptr->ho.rev_cqich_frame_offset = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_frame_offset));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_frame_offset);
        
        int_ptr->ho.rev_cqich_reps = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_reps));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_reps);

        int_ptr->ho.rev_ackch_reps = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rev_ackch_reps));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rev_ackch_reps);

        if (int_ptr->ho.sch_incl &&
            (int_ptr->ho.ext_ch_ind != CAI_EXT_CHIND_PC_F) &&
            (int_ptr->ho.ext_ch_ind != CAI_EXT_CHIND_PC_D))
        {       
          int_ptr->ho.sch_cfg.num_for_sch = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, num_for_sch));
          ext_msg_pos += FSIZ(cai_sch_cfg_type, num_for_sch);
          
          for (i=0; i<int_ptr->ho.sch_cfg.num_for_sch &&
                 i<CAI_MAX_NUM_FOR_SCH_CFG; i++)
          {
            int_ptr->ho.sch_cfg.for_sch_cfg[i].for_sch_id = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, for_sch_id));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, for_sch_id);
        
            int_ptr->ho.sch_cfg.for_sch_cfg[i].sccl_index = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, sccl_index));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, sccl_index);
        
            int_ptr->ho.sch_cfg.for_sch_cfg[i].for_sch_rate = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, for_sch_rate));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, for_sch_rate);
          }
        }

        if (int_ptr->ho.sch_incl)
        {
          int_ptr->ho.sch_cfg.num_rev_sch = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, num_rev_sch));
          ext_msg_pos += FSIZ(cai_sch_cfg_type, num_rev_sch);
            
          for (i=0; i<int_ptr->ho.sch_cfg.num_rev_sch &&
                 i<CAI_MAX_NUM_REV_SCH_CFG; i++)
          {
            int_ptr->ho.sch_cfg.rev_sch_cfg[i].rev_sch_id = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, rev_sch_id));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, rev_sch_id);
              
            int_ptr->ho.sch_cfg.rev_sch_cfg[i].rev_walsh_id = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, rev_walsh_id));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, rev_walsh_id);
              
            int_ptr->ho.sch_cfg.rev_sch_cfg[i].rev_sch_rate = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_cfg_type, rev_sch_rate));
            ext_msg_pos += FSIZ(cai_sch_cfg_type, rev_sch_rate);
          }
        }

        int_ptr->ho.num_pilots = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_fix_type, num_pilots));
        ext_msg_pos += FSIZ(cai_ho_msg_fix_type, num_pilots);

        int_ptr->ho.srch_offset_incl = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_is2000_type, srch_offset_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, srch_offset_incl);

        int_ptr->ho.pdch_group_ind_incl = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_group_ind_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_group_ind_incl);

        int_ptr->ho.for_pdch_parms_incl = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_parms_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_parms_incl);

        if (int_ptr->ho.for_pdch_parms_incl)
        {
          int_ptr->ho.for_pdch_params.for_pdch_rlgain_incl = 
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_rlgain_incl));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_rlgain_incl);

          if (int_ptr->ho.for_pdch_params.for_pdch_rlgain_incl)
          {
            int_ptr->ho.for_pdch_params.rlgain_ackch_pilot = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rlgain_ackch_pilot));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rlgain_ackch_pilot);

            int_ptr->ho.for_pdch_params.rlgain_cqich_pilot = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rlgain_cqich_pilot));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rlgain_cqich_pilot);
          }

          int_ptr->ho.for_pdch_params.num_soft_switching_frames = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_frames));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_frames);
        
          int_ptr->ho.for_pdch_params.num_softer_switching_frames = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_frames));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_frames);
        
          int_ptr->ho.for_pdch_params.num_soft_switching_slots = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_slots));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_slots);
        
          int_ptr->ho.for_pdch_params.num_softer_switching_slots = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_slots));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_slots);
        
          int_ptr->ho.for_pdch_params.chm_switching_params_incl = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, chm_switching_params_incl));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, chm_switching_params_incl);

          if (int_ptr->ho.for_pdch_params.chm_switching_params_incl)
          {
            int_ptr->ho.for_pdch_params.num_soft_switching_frames_chm = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_frames_chm));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_frames_chm);
        
            int_ptr->ho.for_pdch_params.num_softer_switching_frames_chm = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_frames_chm));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_frames_chm);
        
            int_ptr->ho.for_pdch_params.num_soft_switching_slots_chm = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_slots_chm));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_soft_switching_slots_chm);
        
            int_ptr->ho.for_pdch_params.num_softer_switching_slots_chm = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_slots_chm));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_softer_switching_slots_chm);
          }  /* if chm_switching_params_incl */
              
          int_ptr->ho.for_pdch_params.pdch_soft_switching_delay = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_soft_switching_delay));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_soft_switching_delay);
        
          int_ptr->ho.for_pdch_params.pdch_softer_switching_delay = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_softer_switching_delay));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_softer_switching_delay);
            
          int_ptr->ho.for_pdch_common_parms = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_common_parms));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_common_parms);
        
          if (int_ptr->ho.for_pdch_common_parms)
          {
            int_ptr->ho.walsh_table_id = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, walsh_table_id));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, walsh_table_id);
            
            int_ptr->ho.num_pdcch = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_pdcch));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_pdcch);
  
            for (i=0; i<int_ptr->ho.num_pdcch + 1; i++)     
            {
              int_ptr->ho.for_pdcch_walsh[i] = 
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdcch_walsh));
              ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdcch_walsh);
            } /* for */
          }  /* if for_pdch_common_parms */
        }  /* if for_pdch_parms_incl */
      
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
        
        for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++)
        {
          int_ptr->ho.pilot[i].pilot_pn = 
            b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_type, pilot_pn));
          ext_msg_pos += FSIZ(cai_ho_msg_pilot_type, pilot_pn);
        
          if (int_ptr->ho.srch_offset_incl)
          {
            int_ptr->ho.pilot[i].srch_offset = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, srch_offset));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, srch_offset);
          }
          else
          {
            int_ptr->ho.pilot[i].srch_offset = 0;
          }
        
          int_ptr->ho.pilot[i].add_pilot_rec_incl = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, add_pilot_rec_incl));
          ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, add_pilot_rec_incl);  
        
          if (int_ptr->ho.pilot[i].add_pilot_rec_incl)
          {
            word tmp_record_len = 0;
            word record_start_pos = 0;
              
            int_ptr->ho.pilot[i].pilot_rec_type = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, pilot_rec_type));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, pilot_rec_type);  
        
            tmp_record_len = b_unpackb(buf_ptr,ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type,record_len));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type,record_len);
        
            record_start_pos = ext_msg_pos;
            xlate_add_pilot_rec(int_ptr->ho.pilot[i].pilot_rec_type,
              buf_ptr, ext_msg_pos,
              &(int_ptr->ho.pilot[i].add_pilot_rec));
            ext_msg_pos = record_start_pos + tmp_record_len*8;
          }  /* if add_pilot_rec_incl */

          int_ptr->ho.pilot[i].for_pdch_incl = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_incl));
          ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdch_incl);
        
          if (int_ptr->ho.pilot[i].for_pdch_incl &&
              !int_ptr->ho.for_pdch_common_parms)
          {
            int_ptr->ho.pilot[i].walsh_table_id = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, walsh_table_id));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, walsh_table_id);
        
            int_ptr->ho.pilot[i].num_pdcch = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, num_pdcch));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, num_pdcch);
        
            for (j=0; j<int_ptr->ho.pilot[i].num_pdcch + 1; j++)     
            {
              int_ptr->ho.pilot[i].for_pdcch_walsh[j] = 
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, for_pdcch_walsh));
              ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, for_pdcch_walsh);
            }
          }
        
          if (int_ptr->ho.pilot[i].for_pdch_incl)
          {
            int_ptr->ho.pilot[i].mac_id = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, mac_id));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, mac_id);
        
            int_ptr->ho.pilot[i].rev_cqich_cover = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_cover));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, rev_cqich_cover);
          }
        
          if (int_ptr->ho.pilot[i].for_pdch_incl &&
              ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_F) 
               || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_D) 
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
                     ))
          {
            UNPACKB_PG(ho.pilot[i].for_cpcch_walsh, cai_ho_msg_ch_ind_0_type, for_cpcch_walsh);
          }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          if (int_ptr->ho.pilot[i].for_pdch_incl &&
              ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_F) 
               || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_D) 
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
               ))
          {
            UNPACKB_PG(ho.pilot[i].for_cpcsch, cai_ho_msg_ch_ind_0_type, for_cpcsch);
          }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
        
          int_ptr->ho.pilot[i].pwr_comb_ind = 
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_type, pwr_comb_ind));
          ext_msg_pos += FSIZ(cai_ho_msg_pilot_type, pwr_comb_ind);
        
          if (int_ptr->ho.pdch_group_ind_incl)
          {
            int_ptr->ho.pilot[i].pdch_group_ind = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ch_ind_0_type, pdch_group_ind));
            ext_msg_pos += FSIZ(cai_ho_msg_ch_ind_0_type, pdch_group_ind);
          }
        
          if ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_F) 
              || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_FD) 
              || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PFD_FD) 
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            int_ptr->ho.pilot[i].code_chan_fch = 
              b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, code_chan_fch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, code_chan_fch);
        
            int_ptr->ho.pilot[i].qof_mask_id_fch = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, qof_mask_id_fch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, qof_mask_id_fch);
          }
        
          if ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PD_D) 
              || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            int_ptr->ho.pilot[i].code_chan_dcch = 
              b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, code_chan_dcch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, code_chan_dcch);
        
            int_ptr->ho.pilot[i].qof_mask_id_dcch = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, qof_mask_id_dcch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, qof_mask_id_dcch);
          }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
        
          if (int_ptr->ho.sch_incl)
          {
            int_ptr->ho.pilot[i].num_sch = 
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_pilot_is2000_type, num_sch));
            ext_msg_pos += FSIZ(cai_ho_msg_pilot_is2000_type, num_sch);
        
            for (j=0;j<int_ptr->ho.pilot[i].num_sch && j<CAI_MAX_NUM_SCH_CHAN;j++)
            {
              int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].for_sch_id = 
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, for_sch_id));
              ext_msg_pos += FSIZ(cai_sch_chan_rec_type, for_sch_id);
  
              int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].sccl_index = 
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, sccl_index));
              ext_msg_pos += FSIZ(cai_sch_chan_rec_type, sccl_index);
        
              int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl = 
                b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, pilot_incl));
              ext_msg_pos += FSIZ(cai_sch_chan_rec_type, pilot_incl);
        
              if ( int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl)
              {
                int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].code_chan_sch = 
                  b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, code_chan_sch));
                ext_msg_pos += FSIZ(cai_sch_chan_rec_type, code_chan_sch);
        
                int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].qof_mask_id_sch = 
                  b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sch_chan_rec_type, qof_mask_id_sch));
                ext_msg_pos += FSIZ(cai_sch_chan_rec_type, qof_mask_id_sch);
              }
            } /* for (j=0;j<int_ptr->ho.pilot[i].num_sch && j<CAI_MAX_NUM_SCH_CHAN;j++) */
          }  /* if sch_incl */
        } /*  for (i=0;i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS;i++) */


        int_ptr->ho.thx_and_ccsh_info.ccsh_included =
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ccsh_type, ccsh_included));
        ext_msg_pos += FSIZ(cai_ho_msg_ccsh_type, ccsh_included);

        if (int_ptr->ho.thx_and_ccsh_info.ccsh_included)
        {
          int_ptr->ho.thx_and_ccsh_info.use_ccsh_encoder_time =
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ccsh_type, use_ccsh_encoder_time));
          ext_msg_pos += FSIZ(cai_ho_msg_ccsh_type, use_ccsh_encoder_time);
    
          if (int_ptr->ho.thx_and_ccsh_info.use_ccsh_encoder_time)
          {
            int_ptr->ho.thx_and_ccsh_info.ccsh_encoder_action_time =
              b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ccsh_type, ccsh_encoder_action_time));
            ext_msg_pos += FSIZ(cai_ho_msg_ccsh_type, ccsh_encoder_action_time);
          }

          if (int_ptr->ho.sch_incl)
          {
            for (i=0; i<int_ptr->ho.num_pilots && i<CAI_HO_MSG_MAX_PILOTS; i++)
            {
              for (j=0; j<int_ptr->ho.pilot[i].num_sch &&
                        j<CAI_MAX_NUM_SCH_CHAN; j++)
              {
                if (int_ptr->ho.pilot[i].chan_rec.sch_chan_rec[j].pilot_incl)
                {
                  int_ptr->ho.thx_and_ccsh_info.pilot[i].sch[j].ccsh_encoder_type =
                  b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_ccsh_type, ccsh_encoder_type));
                  ext_msg_pos += FSIZ(cai_ho_msg_ccsh_type, ccsh_encoder_type);
                }
              }
            }
          }
        } /* if ccsh_included */


#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      }
    }  /* if p-rev >= 9 and ch_ind == 0 */
#endif /* FEATURE_IS2000_REL_C */
    
    /* This should work for ch_ind 0 as well as ch_ind 2, 5, 6 and 7 -- 
       since the length of ch_ind 0 is active_set_rec_len x 8 */
    ext_msg_pos = start_record_pos + record_len*8;

#ifdef FEATURE_IS2000_REL_C
    /* Rev_fch_gating_mode and its dependents became conditional in
       Release C.  Hence, if Release C is not defined, or the p-rev-in-use
       is less than 9, parse them unconditionally.  If the p-rev-in-use
       is 9 or greater, the field will be ommitted if:
       + ch_ind is 2 or 6
       + ch_ind is 0 and ext_ch_ind is 2 or 4
    */

    parse_rev_fch_gating_mode = FALSE;

    if (caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C)
    {
      parse_rev_fch_gating_mode = TRUE;
    }
    else
    {
      if (int_ptr->ho.ch_ind == CAI_REFER_TO_EXT_CH_IND)
      {
        if ((int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PC_F) 
            || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_F) 
            || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PF_FD)
            || (int_ptr->ho.ext_ch_ind == CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
           )
        {
          parse_rev_fch_gating_mode = TRUE;
        }
      }
      else if ((int_ptr->ho.ch_ind == CAI_FUND_CONT_REV_PLT) || 
         (int_ptr->ho.ch_ind == CAI_FUND_DED_CTL_CONT_REV_PLT)) 
      {
        parse_rev_fch_gating_mode = TRUE;
      }
    }
    
    if (parse_rev_fch_gating_mode)
#endif /* FEATURE_IS2000_REL_C */
    {
      int_ptr->ho.rev_fch_gating_mode = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, rev_fch_gating_mode));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_fch_gating_mode);
      
      if (int_ptr->ho.rev_fch_gating_mode)
      {
        int_ptr->ho.rev_pwr_cntl_delay_incl = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay_incl);
        
        if (int_ptr->ho.rev_pwr_cntl_delay_incl)
        {
          int_ptr->ho.rev_pwr_cntl_delay = b_unpackb(buf_ptr, ext_msg_pos,
           FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay));
          ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay);
        }
      }
    }

#if defined(FEATURE_IS2000_REL_A) || defined(FEATURE_MEID_SUPPORT)
    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) 
#ifdef FEATURE_MEID_SUPPORT
        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
       )
    {
      xlate_ho_enc_cc(buf_ptr, int_ptr, &ext_msg_pos);
      int_ptr->ho.cs_supported =  b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_cs_type, cs_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_cs_type, cs_supported);
    }  // PREV 7
#endif /* FEATURE_IS2000_REL_A || FEATURE_MEID_SUPPORT */

#if defined(FEATURE_IS2000_REL_C) || defined(FEATURE_MEID_SUPPORT)
    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
#ifdef FEATURE_MEID_SUPPORT
        || (int_ptr->ho.msg_type == CAI_MEID_UNIV_HO_DIR_MSG)
#endif /* FEATURE_MEID_SUPPORT */
       )
    {
      int_ptr->ho.chm_supported =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, chm_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, chm_supported);

      int_ptr->ho.cdma_off_time_rep_sup_ind =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_sup_ind));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_sup_ind);

      if (int_ptr->ho.cdma_off_time_rep_sup_ind)
      {
        int_ptr->ho.cdma_off_time_rep_threshold_unit =  
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_threshold_unit));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_threshold_unit);
        
        int_ptr->ho.cdma_off_time_rep_threshold =  
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_threshold));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, cdma_off_time_rep_threshold);
      }
      
      int_ptr->ho.release_to_idle_ind =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, release_to_idle_ind));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, release_to_idle_ind);

      int_ptr->ho.msg_integrity_sup =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, msg_integrity_sup));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, msg_integrity_sup);

      int_ptr->ho.gen_2g_key =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, gen_2g_key));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, gen_2g_key);

      int_ptr->ho.register_in_idle =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, register_in_idle));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, register_in_idle);
      int_ptr->ho.plcm_type_incl =  
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_plcm_info_type, plcm_type_incl));
      ext_msg_pos += FSIZ(cai_plcm_info_type, plcm_type_incl);

      if (int_ptr->ho.plcm_type_incl)
      {
        int_ptr->ho.plcm_type =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_plcm_info_type, plcm_type));
        ext_msg_pos += FSIZ(cai_plcm_info_type, plcm_type);

        if (int_ptr->ho.plcm_type == CAI_PLCM_TYPE_BS_SPEC)
        {
          b_unpackq(buf_ptr, ext_msg_pos, FSIZ(cai_plcm_info_type, plcm_39), int_ptr->ho.plcm_39);
          ext_msg_pos += FSIZ(cai_plcm_info_type, plcm_39);
        }
      }
    }
#endif /* FEATURE_IS2000_REL_C || FEATURE_MEID_SUPPORT */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      if (int_ptr->ho.srch_inc)
      {
        int_ptr->ho.t_tdrop_range_incl =  
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, t_tdrop_range_incl));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, t_tdrop_range_incl);
        
        if (int_ptr->ho.t_tdrop_range_incl)
        {
          int_ptr->ho.t_tdrop_range =  
            b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, t_tdrop_range));
          ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, t_tdrop_range);
        }
      }

      int_ptr->ho.for_pdch_supported =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, for_pdch_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, for_pdch_supported);

      if (int_ptr->ho.for_pdch_supported)
      {
        int_ptr->ho.pdch_chm_supported =  
          b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, pdch_chm_supported));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, pdch_chm_supported);

      }

      int_ptr->ho.pilot_info_req_supported =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, pilot_info_req_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, pilot_info_req_supported);

      int_ptr->ho.enc_supported =  
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, enc_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, enc_supported);

      if (int_ptr->ho.enc_supported)
      {
        int_ptr->ho.sig_encrypt_sup.cmea =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sig_encrypt_sup_type, cmea));
        ext_msg_pos += FSIZ(cai_sig_encrypt_sup_type, cmea);

        int_ptr->ho.sig_encrypt_sup.ecmea =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sig_encrypt_sup_type, ecmea));
        ext_msg_pos += FSIZ(cai_sig_encrypt_sup_type, ecmea);

        int_ptr->ho.sig_encrypt_sup.rea =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_sig_encrypt_sup_type, rea));
        ext_msg_pos += FSIZ(cai_sig_encrypt_sup_type, rea);

        ext_msg_pos += FSIZ(cai_sig_encrypt_sup_type, reserved);

        int_ptr->ho.ui_encrypt_sup.oryx =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ui_encrypt_sup_type, oryx));
        ext_msg_pos += FSIZ(cai_ui_encrypt_sup_type, oryx);

        int_ptr->ho.ui_encrypt_sup.rea =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ui_encrypt_sup_type, rea));
        ext_msg_pos += FSIZ(cai_ui_encrypt_sup_type, rea);

        ext_msg_pos += FSIZ(cai_ui_encrypt_sup_type, reserved);
      }

      int_ptr->ho.use_sync_id =  
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, use_sync_id));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, use_sync_id);

      int_ptr->ho.sid_incl =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, sid_incl));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, sid_incl);

      if (int_ptr->ho.sid_incl)
      {
        int_ptr->ho.sid =  
          b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, sid));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, sid);
      }

      int_ptr->ho.nid_incl =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, nid_incl));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, nid_incl);

      if (int_ptr->ho.nid_incl)
      {
        int_ptr->ho.nid =  
          b_unpackw(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, nid));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, nid);
      }

      int_ptr->ho.sdb_supported =  
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, sdb_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, sdb_supported);

      if (int_ptr->ho.cs_supported)
      {
        int_ptr->ho.mob_qos =  
        b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, mob_qos));
        ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, mob_qos);
      }

      int_ptr->ho.ms_init_pos_loc_sup_ind =  
      b_unpackb(buf_ptr, ext_msg_pos, FSIZ(cai_ho_msg_rel_c_type, ms_init_pos_loc_sup_ind));
      ext_msg_pos += FSIZ(cai_ho_msg_rel_c_type, ms_init_pos_loc_sup_ind);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    }
#endif /* FEATURE_IS2000_REL_C */

  } // if (UHDM specific parsing)

  /**********************************************************

              GHDM Specific parsing

  ***********************************************************/
  if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000) &&
      (int_ptr->ho.msg_type == CAI_GEN_HO_DIR_MSG))
  {
    int_ptr->ho.fpc_subchan_gain = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(cai_ho_msg_is2000_type, fpc_subchan_gain));
    ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, fpc_subchan_gain);

    int_ptr->ho.use_pc_time = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(cai_ho_msg_is2000_type, use_pc_time));
    ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, use_pc_time);

    if (int_ptr->ho.use_pc_time)
    {
      int_ptr->ho.pc_action_time = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, pc_action_time));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, pc_action_time);
    }

    if (int_ptr->ho.extra_parms)
    {
      int_ptr->ho.extra.rlgain_traffic_pilot = b_unpackb(buf_ptr,
        ext_msg_pos, FSIZ(cai_ho_msg_is2000_type, rlgain_traffic_pilot));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rlgain_traffic_pilot);

      int_ptr->ho.extra.default_rlag = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, default_rlag));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, default_rlag);

      int_ptr->ho.extra.nnscr_included = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, nnscr_included));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, nnscr_included);

      if (int_ptr->ho.extra.nnscr_included)
      {
        xlate_int_non_neg_srv_cfg(buf_ptr,&ext_msg_pos,
                                  &(int_ptr->ho.extra.non_neg_cfg));
      }
    }

    int_ptr->ho.rev_fch_gating_mode = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(cai_ho_msg_is2000_type, rev_fch_gating_mode));
    ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_fch_gating_mode);

    if (int_ptr->ho.rev_fch_gating_mode)
    {
      int_ptr->ho.rev_pwr_cntl_delay_incl = b_unpackb( buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay_incl));
      ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay_incl);

      if (int_ptr->ho.rev_pwr_cntl_delay_incl)
      {
        int_ptr->ho.rev_pwr_cntl_delay = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay));
        ext_msg_pos += FSIZ(cai_ho_msg_is2000_type, rev_pwr_cntl_delay);
      }
    }

#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      xlate_ho_enc_cc(buf_ptr, int_ptr, &ext_msg_pos);

      int_ptr->ho.cs_supported = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ho_msg_cs_type, cs_supported));
      ext_msg_pos += FSIZ(cai_ho_msg_cs_type, cs_supported);
    }  // PREV 7
#endif /* FEATURE_IS2000_REL_A */

  } // if (GHDM specific parsing)


  /* If status okay so far, check processed length vs. len parameter
     including possible reserved bits (ext_msg_pos <= len <= ext_msg_pos+7) */
  if ((status == CAIX_DONE_S) && (ext_msg_pos > len))
  {
    /* If we go pass the end of the message, that's an error. */
    status = CAIX_INV_LEN_S;
  }

  return (status);

} /* xlate_ext_ho_msg */

#ifdef FEATURE_IS2000_SCH
/*===========================================================================

FUNCTION XLATE_EXT_TC_ESCAM

DESCRIPTION
  This function translates a Extended Supplemental Channel Assignment
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Supplemental Channel Assignment
  Message.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_escam
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position of record in message */
  word i, k;
    /* Loop Counters */
#ifdef FEATURE_IS2000_REL_A
  word j;
    /* Loop Counters */
  word num_sup_sho = 0;
    /* Num_sup_sho of the current 3X record */
  boolean found_num_sup_sho;
    /* Found num_sup_sho of the current 3X record */
#endif /* FEATURE_IS2000_REL_A */
#ifdef FEATURE_IS2000_REL_B
  word start_sch_rec_pos;
    /* Indicates beginning of sch record */
  word sch_rec_len;
    /* Length of sch record */
#endif /* FEATURE_IS2000_REL_B */
         
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_escam_type

  msg_pos = 0;

  xlate_ext_tc_hdr(buf_ptr, &int_ptr->escam.hdr);

  msg_pos = FENDPOS(cai_escam_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
       CAIX_MACI_REQUIRED,
       &msg_pos, buf_ptr, &int_ptr->escam.hdr.msg_int,
       int_ptr->escam.msg_type,
       int_ptr->escam.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
  {
#ifdef FEATURE_IS2000_REL_A
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
        &int_ptr->escam.hdr, int_ptr->escam.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
    {
      int_ptr->escam.start_time_unit = b_unpackb(buf_ptr, msg_pos,
  FSIZ(MTYPE, start_time_unit));
      msg_pos += FSIZ(MTYPE, start_time_unit);

      int_ptr->escam.rev_sch_dtx_duration = b_unpackb(buf_ptr, msg_pos,
  FSIZ(MTYPE, rev_sch_dtx_duration));
      msg_pos += FSIZ(MTYPE, rev_sch_dtx_duration);

      int_ptr->escam.use_t_add_abort = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, use_t_add_abort));
      msg_pos += FSIZ(MTYPE, use_t_add_abort);

      int_ptr->escam.use_scrm_seq_num = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, use_scrm_seq_num));
      msg_pos += FSIZ(MTYPE, use_scrm_seq_num);

      if (int_ptr->escam.use_scrm_seq_num)
      {
        int_ptr->escam.scrm_seq_num = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, scrm_seq_num));
        msg_pos += FSIZ(MTYPE, scrm_seq_num);
      }

      int_ptr->escam.add_info_incl = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, add_info_incl));
      msg_pos += FSIZ(MTYPE, add_info_incl);

      if (int_ptr->escam.add_info_incl)
      {
        int_ptr->escam.fpc_pri_chan = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, fpc_pri_chan));
        msg_pos += FSIZ(MTYPE, fpc_pri_chan);
      }

      int_ptr->escam.rev_cfg_included = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, rev_cfg_included));
      msg_pos += FSIZ(MTYPE, rev_cfg_included);

      if (int_ptr->escam.rev_cfg_included)
      {
        int_ptr->escam.num_rev_cfg_recs = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, num_rev_cfg_recs));
        msg_pos += FSIZ(MTYPE, num_rev_cfg_recs);

        if ((int_ptr->escam.num_rev_cfg_recs+1) > CAI_ESCAM_MAX_REV_CFG)
        {
          return CAIX_INV_LEN_S;
        }

        for (i=0; i<(int_ptr->escam.num_rev_cfg_recs+1); i++)
        {
          int_ptr->escam.rev_cfg[i].rev_sch_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_id));
          msg_pos += FSIZ(MTYPE, rev_sch_id);

          int_ptr->escam.rev_cfg[i].rev_walsh_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_walsh_id));
          msg_pos += FSIZ(MTYPE, rev_walsh_id);

          int_ptr->escam.rev_cfg[i].rev_sch_rate =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_rate));
          msg_pos += FSIZ(MTYPE, rev_sch_rate);
        }
      }

      int_ptr->escam.num_rev_sch = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, num_rev_sch));
      msg_pos += FSIZ(MTYPE, num_rev_sch);

      if ((int_ptr->escam.num_rev_sch) > CAI_ESCAM_MAX_REV_SCH)
      {
        return CAIX_INV_LEN_S;
      }

      for (i=0; i<int_ptr->escam.num_rev_sch; i++)
      {
        int_ptr->escam.rev_sch[i].rev_sch_id = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, rev_sch_id_2));
        msg_pos += FSIZ(MTYPE, rev_sch_id_2);

        int_ptr->escam.rev_sch[i].rev_sch_duration =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_duration));
        msg_pos += FSIZ(MTYPE, rev_sch_duration);

        int_ptr->escam.rev_sch[i].rev_sch_start_time_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_start_time_incl));
        msg_pos += FSIZ(MTYPE, rev_sch_start_time_incl);

        if (int_ptr->escam.rev_sch[i].rev_sch_start_time_incl)
        {
          int_ptr->escam.rev_sch[i].rev_sch_start_time =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_start_time));
          msg_pos += FSIZ(MTYPE, rev_sch_start_time);
        }

        int_ptr->escam.rev_sch[i].rev_sch_rate =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_rate_2));
        msg_pos += FSIZ(MTYPE, rev_sch_rate_2);
      }

      int_ptr->escam.for_cfg_included = b_unpackb(buf_ptr, msg_pos,
        FSIZ(MTYPE, for_cfg_included));
      msg_pos += FSIZ(MTYPE, for_cfg_included);

      if (int_ptr->escam.for_cfg_included)
      {
        int_ptr->escam.for_sch_fer_rep = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, for_sch_fer_rep));
        msg_pos += FSIZ(MTYPE, for_sch_fer_rep);

        int_ptr->escam.num_for_cfg_recs = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, num_for_cfg_recs));
        msg_pos += FSIZ(MTYPE, num_for_cfg_recs);

        if ((int_ptr->escam.num_for_cfg_recs + 1) > CAI_ESCAM_MAX_FOR_CFG)
        {
          return CAIX_INV_LEN_S;
        }

        for (i=0; i<int_ptr->escam.num_for_cfg_recs+1; i++)
        {
          int_ptr->escam.for_cfg[i].for_sch_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_id));
          msg_pos += FSIZ(MTYPE, for_sch_id);

          int_ptr->escam.for_cfg[i].sccl_index =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sccl_index));
          msg_pos += FSIZ(MTYPE, sccl_index);

          int_ptr->escam.for_cfg[i].for_sch_rate =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_rate));
          msg_pos += FSIZ(MTYPE, for_sch_rate);

          int_ptr->escam.for_cfg[i].num_sup_sho =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_sup_sho));
          msg_pos += FSIZ(MTYPE, num_sup_sho);

          if ((int_ptr->escam.for_cfg[i].num_sup_sho+1) > CAI_ESCAM_MAX_SUP_SHO)
          {
            return CAIX_INV_LEN_S;
          }

          for (k=0; k<(int_ptr->escam.for_cfg[i].num_sup_sho+1); k++)
          {
            int_ptr->escam.for_cfg[i].sup_sho[k].pilot_pn =
              b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, pilot_pn));
            msg_pos += FSIZ(MTYPE, pilot_pn);

            int_ptr->escam.for_cfg[i].sup_sho[k].add_pilot_rec_incl =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, add_pilot_rec_incl));
            msg_pos += FSIZ(MTYPE, add_pilot_rec_incl);

            if (int_ptr->escam.for_cfg[i].sup_sho[k].add_pilot_rec_incl)
            {
              word record_len = 0;
              word record_start_pos = 0;

              int_ptr->escam.for_cfg[i].sup_sho[k].active_pilot_rec_type =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, active_pilot_rec_type));
              msg_pos += FSIZ(MTYPE, active_pilot_rec_type);

              record_len = b_unpackb(buf_ptr, msg_pos,
                FSIZ(MTYPE, record_len)); msg_pos += FSIZ(MTYPE, record_len);

              record_start_pos = msg_pos;

              xlate_add_pilot_rec(
                int_ptr->escam.for_cfg[i].sup_sho[k].active_pilot_rec_type,
                buf_ptr, msg_pos,
                &(int_ptr->escam.for_cfg[i].sup_sho[k].add_pilot_rec));

              msg_pos = record_start_pos + record_len*8;
            }

            int_ptr->escam.for_cfg[i].sup_sho[k].for_sch_cc_index =
              b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_cc_index));
            msg_pos += FSIZ(MTYPE, for_sch_cc_index);

            int_ptr->escam.for_cfg[i].sup_sho[k].qof_mask_id_sch =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, qof_mask_id_sch));
            msg_pos += FSIZ(MTYPE, qof_mask_id_sch);
          } /* end for */
        } /* end for */
      } /* end if (int_ptr->escam.for_cfg_included) */

      int_ptr->escam.num_for_sch =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_for_sch));
      msg_pos += FSIZ(MTYPE, num_for_sch);

      if ((int_ptr->escam.num_for_sch) > CAI_ESCAM_MAX_FOR_SCH)
      {
        return CAIX_INV_LEN_S;
      }

      for (i=0; i<int_ptr->escam.num_for_sch; i++)
      {
        int_ptr->escam.for_sch[i].for_sch_id =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_id_2));
        msg_pos += FSIZ(MTYPE, for_sch_id_2);

        int_ptr->escam.for_sch[i].for_sch_duration =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_duration));
        msg_pos += FSIZ(MTYPE, for_sch_duration);

        int_ptr->escam.for_sch[i].for_sch_start_time_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_start_time_incl));
        msg_pos += FSIZ(MTYPE, for_sch_start_time_incl);

        if (int_ptr->escam.for_sch[i].for_sch_start_time_incl)
        {
          int_ptr->escam.for_sch[i].for_sch_start_time =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_start_time));
          msg_pos += FSIZ(MTYPE, for_sch_start_time);
        }

        int_ptr->escam.for_sch[i].sccl_index =
          b_unpackb(buf_ptr,msg_pos, FSIZ(MTYPE,sccl_index_2));
        msg_pos += FSIZ(MTYPE,sccl_index_2);
      } /* end for */

      int_ptr->escam.fpc_incl =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_incl));
      msg_pos += FSIZ(MTYPE, fpc_incl);

      if (int_ptr->escam.fpc_incl)
      {
        int_ptr->escam.fpc_mode_sch =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_mode_sch));
        msg_pos += FSIZ(MTYPE, fpc_mode_sch);

        int_ptr->escam.fpc_sch_init_setpt_op =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_init_setpt_op));
        msg_pos += FSIZ(MTYPE, fpc_sch_init_setpt_op);

        if ((int_ptr->escam.fpc_mode_sch == 1) ||
            (int_ptr->escam.fpc_mode_sch == 2))
        {
          int_ptr->escam.fpc_sec_chan =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sec_chan));
          msg_pos += FSIZ(MTYPE, fpc_sec_chan);
        }

        int_ptr->escam.num_sup =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_sup));
        msg_pos += FSIZ(MTYPE, num_sup);

        if ((int_ptr->escam.num_sup) > CAI_ESCAM_MAX_SUP)
        {
          return CAIX_INV_LEN_S;
        }

        for (i=0; i<int_ptr->escam.num_sup; i++)
        {
          int_ptr->escam.sup[i].sch_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sch_id));
          msg_pos += FSIZ(MTYPE, sch_id);

          int_ptr->escam.sup[i].fpc_sch_fer =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_fer));
          msg_pos += FSIZ(MTYPE, fpc_sch_fer);

          int_ptr->escam.sup[i].fpc_sch_init_setpt =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_init_setpt));
          msg_pos += FSIZ(MTYPE, fpc_sch_init_setpt);

          int_ptr->escam.sup[i].fpc_sch_min_setpt =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_min_setpt));
          msg_pos += FSIZ(MTYPE, fpc_sch_min_setpt);

          int_ptr->escam.sup[i].fpc_sch_max_setpt =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_sch_max_setpt));
          msg_pos += FSIZ(MTYPE, fpc_sch_max_setpt);
        } /* end for */

        int_ptr->escam.fpc_thresh_sch_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_thresh_sch_incl));
        msg_pos += FSIZ(MTYPE, fpc_thresh_sch_incl);

        if (int_ptr->escam.fpc_thresh_sch_incl)
        {
          int_ptr->escam.fpc_setpt_thresh_sch =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_setpt_thresh_sch));
          msg_pos += FSIZ(MTYPE, fpc_setpt_thresh_sch);
        }
      } /* end if (int_ptr->escam.fpc_incl) */

      int_ptr->escam.rpc_incl =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rpc_incl));
      msg_pos += FSIZ(MTYPE, rpc_incl);

      if (int_ptr->escam.rpc_incl)
      {
        int_ptr->escam.rpc_num_sup =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rpc_num_sup));
        msg_pos += FSIZ(MTYPE, rpc_num_sup);

        for (i=0; i<int_ptr->escam.rpc_num_sup+1; i++)
        {
          int_ptr->escam.rpc_sup[i].sch_id =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sch_id));
          msg_pos += FSIZ(MTYPE, sch_id);

          int_ptr->escam.rpc_sup[i].rlgain_sch_pilot =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rlgain_sch_pilot));
          msg_pos += FSIZ(MTYPE, rlgain_sch_pilot);
        }
      } /* end if (int_ptr->escam.rpc_incl) */

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        int_ptr->escam.threex_sch_info_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threex_sch_info_incl));
        msg_pos += FSIZ(MTYPE, threex_sch_info_incl);

        if (int_ptr->escam.threex_sch_info_incl)
        {
          if (!int_ptr->escam.for_cfg_included)
          {
            MSG_ERROR("Invalid ESCAM 3X SCH info", 0,0,0);
            return CAIX_INV_LEN_S;
          }

          int_ptr->escam.num_threex_cfg =
      b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_threex_cfg));
          msg_pos += FSIZ(MTYPE, num_threex_cfg);

          for (i=0; i < int_ptr->escam.num_threex_cfg; i++)
          {
            int_ptr->escam.threex_cfg[i].for_sch_id =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threex_for_sch_id));
            msg_pos += FSIZ(MTYPE, threex_for_sch_id);

            int_ptr->escam.threex_cfg[i].num_threex_rec =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_threex_rec));
            msg_pos += FSIZ(MTYPE, num_threex_rec);

            for (j=0; j < (int_ptr->escam.threex_cfg[i].num_threex_rec + 1);
                 j++)
            {
              int_ptr->escam.threex_cfg[i].rec[j].sccl_index =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threex_sccl_index));
              msg_pos += FSIZ(MTYPE, threex_sccl_index);

              found_num_sup_sho = FALSE;

              /* Retrieve corresponding NUM_SUP_SHO using FOR_SCH_ID and
                 SCCL_INDEX */
              for (k=0; k < (int_ptr->escam.num_for_cfg_recs + 1); k++)
              {
                if ((int_ptr->escam.for_cfg[k].for_sch_id ==
                     int_ptr->escam.threex_cfg[i].for_sch_id) &&
                (int_ptr->escam.for_cfg[k].sccl_index ==
                     int_ptr->escam.threex_cfg[i].rec[j].sccl_index))
                {
                  num_sup_sho = int_ptr->escam.for_cfg[k].num_sup_sho;
                  found_num_sup_sho = TRUE;
            /* If doing SILK testing, pick the last one if there are
                     duplicates */
#ifndef FEATURE_MSG_PACK_UNIT_TEST
                  break;
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
                }
              }

              if (!found_num_sup_sho)
              {
                MSG_ERROR("ESCAM: No 1X record matches 3X info", 0,0,0);
                return CAIX_INV_LEN_S;
              }

              for (k=0; k < (num_sup_sho + 1); k++)
              {
                int_ptr->escam.threex_cfg[i].rec[j].sup[k].threex_sch_low_incl =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(MTYPE, threex_sch_low_incl));
                msg_pos += FSIZ(MTYPE, threex_sch_low_incl);

                if (int_ptr->escam.threex_cfg[i].rec[j].sup[k].threex_sch_low_incl)
                {
                  int_ptr->escam.threex_cfg[i].rec[j].sup[k].qof_mask_id_sch_low =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(MTYPE, threex_qof_mask_id_sch_low));
                  msg_pos += FSIZ(MTYPE, threex_qof_mask_id_sch_low);

                  int_ptr->escam.threex_cfg[i].rec[j].sup[k].code_chan_sch_low =
                    b_unpackw(buf_ptr, msg_pos,
                    FSIZ(MTYPE, threex_code_chan_sch_low));
                  msg_pos += FSIZ(MTYPE, threex_code_chan_sch_low);
                }

                int_ptr->escam.threex_cfg[i].rec[j].sup[k].threex_sch_high_incl =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threex_sch_high_incl));
                msg_pos += FSIZ(MTYPE, threex_sch_high_incl);

                if (int_ptr->escam.threex_cfg[i].rec[j].sup[k].threex_sch_high_incl)
                {
                  int_ptr->escam.threex_cfg[i].rec[j].sup[k].qof_mask_id_sch_high =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(MTYPE, threex_qof_mask_id_sch_high));
                  msg_pos += FSIZ(MTYPE, threex_qof_mask_id_sch_high);

                  int_ptr->escam.threex_cfg[i].rec[j].sup[k].code_chan_sch_high =
                    b_unpackw(buf_ptr, msg_pos,
                    FSIZ(MTYPE, threex_code_chan_sch_high));
                  msg_pos += FSIZ(MTYPE, threex_code_chan_sch_high);
                }
              } /* for (k=0; k < (num_sup_sho + 1); k++) */
            } /* for (j=0; j < (int_ptr->escam.threex_cfg[i].num_threex_rec + 1); j++) */
          } /* for (i=0; i < int_ptr->escam.num_threex_cfg; i++)  */
        } /* if (int_ptr->escam.threex_sch_info_incl) */
      } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        int_ptr->escam.ccsh_included =
          b_unpackb(buf_ptr,msg_pos,FSIZ(MTYPE,ccsh_included));
        msg_pos += FSIZ(MTYPE,ccsh_included);

        if (int_ptr->escam.ccsh_included)
        {
          if (!int_ptr->escam.for_cfg_included)
          {
            MSG_ERROR("Invalid ESCAM CCSH info", 0,0,0);
            return CAIX_INV_LEN_S;
          }

          for (i=0; i < (int_ptr->escam.num_for_cfg_recs + 1); i++)
          {
          for (j=0; j < (int_ptr->escam.for_cfg[i].num_sup_sho + 1); j++)
            {
              int_ptr->escam.ccsh_cfg[i].sup[j].ccsh_encoder_type =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ccsh_encoder_type));
              msg_pos += FSIZ(MTYPE, ccsh_encoder_type);
            }
          }
        }

        int_ptr->escam.for_sch_cc_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, for_sch_cc_incl));
        msg_pos += FSIZ(MTYPE, for_sch_cc_incl);

        if (int_ptr->escam.for_sch_cc_incl)
        {
          for (i=0; i < int_ptr->escam.num_for_sch; i++)
          {
            int_ptr->escam.for_sch_cc[i].for_sch_id =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_for_sch_type, for_sch_id));
            msg_pos += FSIZ(cai_for_sch_type, for_sch_id);

            int_ptr->escam.for_sch_cc[i].for_sch_mux =
              b_unpackw(buf_ptr, msg_pos, FSIZ(cai_for_sch_type, for_sch_mux));
            msg_pos += FSIZ(cai_for_sch_type, for_sch_mux);

            /* SCH_REC_LEN includes its own length */
            start_sch_rec_pos = msg_pos;

            sch_rec_len =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, sch_rec_len));
            msg_pos += FSIZ(cai_sch_chn_cfg_type,sch_rec_len);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.sch_rc =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, sch_rc));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, sch_rc);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.coding =
              b_unpackb(buf_ptr,msg_pos,FSIZ(cai_sch_chn_cfg_type, coding));
                msg_pos += FSIZ(cai_sch_chn_cfg_type, coding);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.frame_40_used =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_sch_chn_cfg_type, frame_40_used));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, frame_40_used);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.frame_80_used =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_sch_chn_cfg_type, frame_80_used));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, frame_80_used);

            int_ptr->escam.for_sch_cc[i].sch_chn_cfg.max_rate =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, max_rate));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, max_rate);

            msg_pos = start_sch_rec_pos + 8*sch_rec_len;

          }
        } /* if (int_ptr->escam.for_sch_cc_incl) */

        int_ptr->escam.rev_sch_cc_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_sch_cc_incl));
        msg_pos += FSIZ(MTYPE, rev_sch_cc_incl);

        if (int_ptr->escam.rev_sch_cc_incl)
        {
          for (i=0; i < int_ptr->escam.num_rev_sch; i++)
          {
            int_ptr->escam.rev_sch_cc[i].rev_sch_id =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rev_sch_type, rev_sch_id));
            msg_pos += FSIZ(cai_rev_sch_type, rev_sch_id);

            int_ptr->escam.rev_sch_cc[i].rev_sch_mux =
              b_unpackw(buf_ptr, msg_pos, FSIZ(cai_rev_sch_type, rev_sch_mux));
            msg_pos += FSIZ(cai_rev_sch_type, rev_sch_mux);

            /* SCH_REC_LEN includes its own length */
            start_sch_rec_pos = msg_pos;

            sch_rec_len =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, sch_rec_len));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, sch_rec_len);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.sch_rc =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, sch_rc));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, sch_rc);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.coding =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, coding));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, coding);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.frame_40_used =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, frame_40_used));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, frame_40_used);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.frame_80_used =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, frame_80_used));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, frame_80_used);

            int_ptr->escam.rev_sch_cc[i].sch_chn_cfg.max_rate =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_sch_chn_cfg_type, max_rate));
            msg_pos += FSIZ(cai_sch_chn_cfg_type, max_rate);

            msg_pos = start_sch_rec_pos + 8*sch_rec_len;
          }
        } /* if (int_ptr->escam.rev_sch_cc_incl) */
      } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) */
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    }
  }
  /* There is an error if we parsed beyond the length */
  if (msg_pos > len)
  {
    status = CAIX_INV_LEN_S;
  }

 #undef MTYPE

 return (status);

} /* xlate_ext_tc_escam */

#endif

#if defined(FEATURE_IS2000_REL_A)||defined(FEATURE_IS2000_CHS)
/*===========================================================================

FUNCTION XLATE_EXT_TC_RAM

DESCRIPTION
  This function translates a Traffic Channel Resource Allocation
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_ram
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
           
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ram_type
  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < ( sizeof(cai_ram_type) - FSIZ(MTYPE, action_time)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->ram.hdr );
    msg_pos = FENDPOS( cai_ram_type, hdr.encryption );

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->ram.hdr.msg_int,
         int_ptr->ram.msg_type,
         int_ptr->ram.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->ram.hdr, int_ptr->ram.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->ram.use_time = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        if (int_ptr->ram.use_time)
        {
          int_ptr->ram.action_time =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
          msg_pos += FSIZ(MTYPE, action_time);
        }

        int_ptr->ram.fpc_pri_chan =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, fpc_pri_chan));
        msg_pos += FSIZ(MTYPE, fpc_pri_chan);
      }
    }
  }

  #undef MTYPE

  return (status);
} /* xlate_ext_tc_ram */

/*===========================================================================

FUNCTION XLATE_EXT_TC_ERM

DESCRIPTION
  This function translates a Traffic Channel Extended Release
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_erm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
#ifdef FEATURE_IS2000_REL_C
  int i;
    /* Loop counter */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_erm_type
  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (FSIZ(MTYPE, msg_type) + FSIZ(MTYPE, hdr) + FSIZ(MTYPE, use_time)
       + FSIZ(MTYPE, ch_ind) + FSIZ(MTYPE, gating_rate_incl)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->erm.hdr);

    msg_pos = FENDPOS(cai_erm_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->erm.hdr.msg_int,
         int_ptr->erm.msg_type,
         int_ptr->erm.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->erm.hdr, int_ptr->erm.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->erm.use_time =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
        msg_pos += FSIZ(MTYPE, use_time);

        if (int_ptr->erm.use_time)
        {
          int_ptr->erm.action_time =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
          msg_pos += FSIZ(MTYPE,action_time);
        }

        int_ptr->erm.ch_ind =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ch_ind));
        msg_pos += FSIZ(MTYPE, ch_ind);

        int_ptr->erm.gating_rate_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, gating_rate_incl));
        msg_pos += FSIZ(MTYPE, gating_rate_incl);

        if (int_ptr->erm.gating_rate_incl)
        {
          int_ptr->erm.pilot_gating_rate =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pilot_gating_rate));
          msg_pos += FSIZ(MTYPE, pilot_gating_rate);
        }

#ifdef FEATURE_IS2000_REL_C
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
        {
          int_ptr->erm.use_ext_ch_ind =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_ext_ch_ind));
          msg_pos += FSIZ(MTYPE, use_ext_ch_ind); 
    
          if (int_ptr->erm.use_ext_ch_ind)
          {
            int_ptr->erm.ext_ch_ind =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ext_ch_ind));
            msg_pos += FSIZ(MTYPE, ext_ch_ind); 
      
            int_ptr->erm.pdch_control_hold =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, pdch_control_hold));
            msg_pos += FSIZ(MTYPE, pdch_control_hold);  

            if (int_ptr->erm.gating_rate_incl)
            {
              int_ptr->erm.switching_parms_incl =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, switching_parms_incl));
              msg_pos += FSIZ(MTYPE, switching_parms_incl);
  
              if (int_ptr->erm.switching_parms_incl)
              {
                int_ptr->erm.num_soft_switching_frames_chm =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_soft_switching_frames_chm));
                msg_pos += FSIZ(MTYPE, num_soft_switching_frames_chm);
    
                int_ptr->erm.num_softer_switching_frames_chm =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_softer_switching_frames_chm));
                msg_pos += FSIZ(MTYPE, num_softer_switching_frames_chm);
              }
            }
          }   /* if (int_ptr->erm.use_ext_ch_ind) */

          int_ptr->erm.direct_to_idle_info_incl =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, direct_to_idle_info_incl));
          msg_pos += FSIZ(MTYPE, direct_to_idle_info_incl);
    
          if (int_ptr->erm.direct_to_idle_info_incl)
          {
            int_ptr->erm.release_type =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, release_type));
            msg_pos += FSIZ(MTYPE, release_type);

            if (int_ptr->erm.release_type != CAI_RELEASE_TO_SYS_DETERMINATION)
            {
              int_ptr->erm.sid = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, sid));
              msg_pos += FSIZ(MTYPE, sid);
            
              int_ptr->erm.nid = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, nid));
              msg_pos += FSIZ(MTYPE, nid);
      
              int_ptr->erm.freq_incl =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, freq_incl));
              msg_pos += FSIZ(MTYPE, freq_incl);

              if (int_ptr->erm.freq_incl)
              {
                int_ptr->erm.cdma_freq = 
                  b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, cdma_freq));
                msg_pos += FSIZ(MTYPE, cdma_freq);
  
                int_ptr->erm.band_class =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, band_class));
                msg_pos += FSIZ(MTYPE, band_class);
              }
            }  /* if (int_ptr->erm.release_type != CAI_RELEASE_TO_SYS_DETERMINATION) */

            if (int_ptr->erm.release_type == CAI_RELEASE_TO_IDLE_ON_PCH)
            {
              int_ptr->erm.page_ch =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, page_ch));
              msg_pos += FSIZ(MTYPE, page_ch);
    
              int_ptr->erm.prat =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, prat));
              msg_pos += FSIZ(MTYPE, prat);
            }

            if (int_ptr->erm.release_type == CAI_RELEASE_TO_IDLE_ON_BCCH)
            {
              int_ptr->erm.sr1_bcch_code_chan_non_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_bcch_code_chan_non_td));
              msg_pos += FSIZ(MTYPE, sr1_bcch_code_chan_non_td);
          
              int_ptr->erm.sr1_crat_non_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_crat_non_td));
              msg_pos += FSIZ(MTYPE, sr1_crat_non_td);
  
              int_ptr->erm.sr1_brat_non_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_brat_non_td));
              msg_pos += FSIZ(MTYPE, sr1_brat_non_td);
            }

            if (int_ptr->erm.release_type == CAI_RELEASE_TO_IDLE_ON_BCCH_TD)
            {
              int_ptr->erm.sr1_td_mode =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_td_mode));
              msg_pos += FSIZ(MTYPE, sr1_td_mode);

              int_ptr->erm.sr1_bcch_code_chan_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_bcch_code_chan_td));
              msg_pos += FSIZ(MTYPE, sr1_bcch_code_chan_td);

              int_ptr->erm.sr1_crat_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_crat_td));
              msg_pos += FSIZ(MTYPE, sr1_crat_td);
        
              int_ptr->erm.sr1_brat_td =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_brat_td));
              msg_pos += FSIZ(MTYPE, sr1_brat_td);

              int_ptr->erm.sr1_td_power_level =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr1_td_power_level));
              msg_pos += FSIZ(MTYPE, sr1_td_power_level);
            }

            if (int_ptr->erm.release_type != CAI_RELEASE_TO_SYS_DETERMINATION)
            {
              int_ptr->erm.num_pilots_d2i_incl =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_pilots_d2i_incl));
              msg_pos += FSIZ(MTYPE, num_pilots_d2i_incl);
  
              if (int_ptr->erm.num_pilots_d2i_incl)
              {
                int_ptr->erm.num_pilots_d2i =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_pilots_d2i));
                msg_pos += FSIZ(MTYPE, num_pilots_d2i);
    
                for (i=0; i < int_ptr->erm.num_pilots_d2i; i++)
                {
                  int_ptr->erm.pilot_pn[i] =
                    b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, pilot_pn));
                  msg_pos += FSIZ(MTYPE, pilot_pn);
                }
              }
            }
          }  /* if (int_ptr->erm.direct_to_idle_info_incl) */
        } /* if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) */
#endif /* FEATURE_IS2000_REL_C */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

        /* There is an error if we parsed beyond the length */
        if (msg_pos > len)
        {
          status = CAIX_INV_LEN_S;
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_erm */

#endif /* FEATURE_IS2000_REL_A || FEATURE_IS2000_CHS */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_TC_MABOM

DESCRIPTION
  This function translates a Traffic Channel Mobile Assisted Burst
  Operation Parameters Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_mabom
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
             
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_mabop_type

  xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcmabop.hdr);

  msg_pos = FENDPOS(cai_mabop_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
       CAIX_MACI_REQUIRED,
       &msg_pos, buf_ptr, &int_ptr->tcmabop.hdr.msg_int,
       int_ptr->tcmabop.msg_type,
       int_ptr->tcmabop.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
  {
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr,
        &int_ptr->tcmabop.hdr, int_ptr->tcmabop.msg_type, 0, 0)) == CAIX_DONE_S)
    {
      int_ptr->tcmabop.order_flag = b_unpackb(buf_ptr, msg_pos, 
        FSIZ(MTYPE, order_flag));
      msg_pos += FSIZ(MTYPE, order_flag);

      if (int_ptr->tcmabop.order_flag)
      {
        int_ptr->tcmabop.psmin_delta =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, psmin_delta));
        msg_pos += FSIZ(MTYPE, psmin_delta);

        int_ptr->tcmabop.order_interval =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, order_interval));
        msg_pos += FSIZ(MTYPE, order_interval);
      }

      int_ptr->tcmabop.periodic_flag =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, periodic_flag));
      msg_pos += FSIZ(MTYPE, periodic_flag);

      if (int_ptr->tcmabop.periodic_flag)
      {
        int_ptr->tcmabop.num_pilots =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_pilots));
        msg_pos += FSIZ(MTYPE, num_pilots);

        int_ptr->tcmabop.periodic_interval =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, periodic_interval));
        msg_pos += FSIZ(MTYPE, periodic_interval);
      }

      int_ptr->tcmabop.threshold_flag =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threshold_flag));
      msg_pos += FSIZ(MTYPE, threshold_flag);

      if (int_ptr->tcmabop.threshold_flag)
      {
        int_ptr->tcmabop.ps_floor_high =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ps_floor_high));
        msg_pos += FSIZ(MTYPE, ps_floor_high);

        int_ptr->tcmabop.ps_floor_low =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ps_floor_low));
        msg_pos += FSIZ(MTYPE, ps_floor_low);

        int_ptr->tcmabop.ps_ceiling_high =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ps_ceiling_high));
        msg_pos += FSIZ(MTYPE, ps_ceiling_high);

        int_ptr->tcmabop.ps_ceiling_low =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ps_ceiling_low));
        msg_pos += FSIZ(MTYPE, ps_ceiling_low);

        int_ptr->tcmabop.threshold_interval =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, threshold_interval));
        msg_pos += FSIZ(MTYPE, threshold_interval);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_mabom */

/*===========================================================================

FUNCTION XLATE_EXT_TC_UZRM
DESCRIPTION
  This function translates a Traffic Channel User Zone Reject
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_uzrm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
         
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_user_zone_rej_type

  xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcuzrm.hdr);

  msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
       CAIX_MACI_REQUIRED,
       &msg_pos, buf_ptr, &int_ptr->tcuzrm.hdr.msg_int,
       int_ptr->tcuzrm.msg_type,
       int_ptr->tcuzrm.hdr.ack_req         
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
  {
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
        &int_ptr->tcuzrm.hdr, int_ptr->tcuzrm.msg_type, 0, 0)) == CAIX_DONE_S)
    {
      int_ptr->tcuzrm.reject_uzid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, reject_uzid));
      msg_pos += FSIZ(MTYPE, reject_uzid);

      int_ptr->tcuzrm.reject_action_indi =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, reject_action_indi));
      msg_pos += FSIZ(MTYPE, reject_action_indi);

      int_ptr->tcuzrm.user_assign_included =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, user_assign_included));
      msg_pos += FSIZ(MTYPE, user_assign_included);

      if (int_ptr->tcuzrm.user_assign_included)
      {
        int_ptr->tcuzrm.assign_id =
          b_unpackw( buf_ptr, msg_pos, FSIZ(MTYPE, assign_id));
        msg_pos += FSIZ(MTYPE, assign_id);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_uzrm */

/*===========================================================================

FUNCTION XLATE_EXT_TC_UZUM
DESCRIPTION
  This function translates a Traffic Channel User Zone Update
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_uzum
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_user_zone_upd_type

  xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcuzum.hdr);

  msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
       CAIX_MACI_REQUIRED,
       &msg_pos, buf_ptr, &int_ptr->tcuzum.hdr.msg_int,
       int_ptr->tcuzum.msg_type,
       int_ptr->tcuzum.hdr.ack_req         
       )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
  {
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
        &int_ptr->tcuzum.hdr, int_ptr->tcuzum.msg_type, 0, 0)) == CAIX_DONE_S)
    {
      int_ptr->tcuzum.uz_id =
        b_unpackw(buf_ptr, msg_pos, FSIZ( MTYPE, uz_id));
      msg_pos += FSIZ(MTYPE,uz_id);
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_uzum */

/*===========================================================================

FUNCTION xlate_ext_tc_clam
DESCRIPTION
  This function translates a Traffic Channel Call Assignement
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_clam
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  
  #ifdef FEATURE_IS2000_REL_D
#error code not present
  #endif /* FEATURE_IS2000_REL_D */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_call_assignment_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (FSIZ(MTYPE, msg_type) + FSIZ(MTYPE, hdr) + FSIZ(MTYPE, response_ind)
       + FSIZ(MTYPE, bypass_alert_answer) + FSIZ(MTYPE, so_incl) + 
       FSIZ(MTYPE, con_ref_incl)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tccam.hdr);
    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tccam.hdr.msg_int, 
         int_ptr->tccam.msg_type,
         int_ptr->tccam.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->tccam.hdr, int_ptr->tccam.msg_type, 0, 0)) == CAIX_DONE_S)
      {
        int_ptr->tccam.response_ind =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, response_ind));
        msg_pos += FSIZ(MTYPE, response_ind);

        if (int_ptr->tccam.response_ind)
        {
          int_ptr->tccam.tag =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, tag));
          msg_pos += FSIZ(MTYPE, tag);

          int_ptr->tccam.accept_ind =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, accept_ind));
          msg_pos += FSIZ(MTYPE, accept_ind);

          if (!int_ptr->tccam.accept_ind)
          {
            int_ptr->tccam.reject_pktdata_ind =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, reject_pktdata_ind));
            msg_pos += FSIZ(MTYPE, reject_pktdata_ind);
          }
        }
        else /* response_ind */
          /* bypass_alert_answer is included if CLAM is a response,
             hence response_ind is 1 */
        {
          int_ptr->tccam.bypass_alert_answer =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, bypass_alert_answer));
          msg_pos += FSIZ(MTYPE, bypass_alert_answer);
        }

        int_ptr->tccam.so_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, so_incl));
        msg_pos += FSIZ(MTYPE, so_incl);

        if (int_ptr->tccam.so_incl)
        {
          int_ptr->tccam.so =
            b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, so));
          msg_pos += FSIZ(MTYPE, so);
        }

        int_ptr->tccam.con_ref_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref_incl));
        msg_pos += FSIZ(MTYPE, con_ref_incl);

        if (int_ptr->tccam.con_ref_incl)
        {
          int_ptr->tccam.con_ref =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
          msg_pos += FSIZ(MTYPE, con_ref);
        }

#ifdef FEATURE_IS2000_REL_C
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
        {
          /* This field is included if either accept_ind is not included, or
             if it is included and set to 1.  Accept_ind is not included
             if response_ind is 0. */
          if (!int_ptr->tccam.response_ind || (int_ptr->tccam.response_ind && int_ptr->tccam.accept_ind))
          {
            int_ptr->tccam.use_old_serv_config =
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_old_serv_config));
            msg_pos += FSIZ(MTYPE, use_old_serv_config);

            #ifdef FEATURE_IS2000_REL_D
#error code not present
            #endif /* FEATURE_IS2000_REL_D */
  
            if (int_ptr->tccam.use_old_serv_config)
            {
              int_ptr->tccam.sr_id =
                b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, sr_id));
              msg_pos += FSIZ(MTYPE, sr_id);

              #ifdef FEATURE_IS2000_REL_D
#error code not present
              #endif /* FEATURE_IS2000_REL_D */
            }
          }
        }
#endif /* FEATURE_IS2000_REL_C */ 

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  /* There is an error if we parsed beyond the length */
        if (msg_pos > len)
        {
          status = CAIX_INV_LEN_S;
        }
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_clam */

/*===========================================================================

FUNCTION XLATE_EXT_TC_EAWIM  (also used for Extended Flash)
DESCRIPTION
  This function translates a Traffic Channel Extended Alert with Info
  Message and Extended Flash with Info from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_eawim
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  byte *msg_ptr;
   /* Pointer to position inside internal message type */
  byte rec_type;
   /* Temporary storage for record type */
  word rec_len;
   /* Temporary storage for record length */
  word i, j;
  /* counter */
             
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_extended_alert_w_info_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < sizeof(cai_extended_alert_w_info_type) -
            FSIZ(MTYPE, con_ref))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tceawim.hdr);

    msg_pos = FENDPOS(MTYPE, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tceawim.hdr.msg_int,
         int_ptr->tceawim.msg_type,
         int_ptr->tceawim.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->tceawim.hdr, int_ptr->tceawim.msg_type, 0, 0)) == CAIX_DONE_S)
      {
        int_ptr->tceawim.con_ref_incl =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref_incl));
        msg_pos += FSIZ(MTYPE, con_ref_incl);

        if (int_ptr->tceawim.con_ref_incl)
        {
          int_ptr->tceawim.con_ref =
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
          msg_pos += FSIZ(MTYPE, con_ref);
        }

        int_ptr->tceawim.num_recs =
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_recs));
        msg_pos += FSIZ(MTYPE, num_recs);

        /* point to the start */
        msg_ptr = (byte*)&int_ptr->tceawim.recs[0];
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

        /* unpack records */
        for ( i=0; i < int_ptr->tceawim.num_recs; i++)
        {
          /* ------------------------------
          ** Unpack message type and length
          ** ------------------------------ */
          ((caii_rec_hdr_type *) msg_ptr)->record_type = rec_type =
            b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rec_hdr_type, record_type));
          msg_pos += FSIZ(cai_rec_hdr_type, record_type);

          /* -------------------------
          ** Get record length in bits
          ** ------------------------- */
          rec_len = b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_rec_hdr_type, record_len)) * 8;
          msg_pos += FSIZ(cai_rec_hdr_type, record_len);

          if ((rec_len + msg_pos) > len)
          {
            status = CAIX_INV_LEN_S;
            break;
          }
          else
          {
            switch (rec_type)
            {
              case CAI_DISPLAY_REC:
                /* --------------------------
                ** Display Information Record
                ** -------------------------- */
                ((caii_display_rec_type *) msg_ptr)->fix.num_char =
                  (byte) (rec_len / sizeof(cai_display_rec_var_type));

                for (j=0;
                     j < ((caii_display_rec_type *) msg_ptr)->fix.num_char; j++)
                {
                  ((caii_display_rec_type *) msg_ptr)->var[j] =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_display_rec_var_type, chari));
                  msg_pos += FSIZ(cai_display_rec_var_type, chari);
                }

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_display_rec_type,
                           var[((caii_display_rec_type *) msg_ptr)->fix.num_char - 1]);
                break;

              case CAI_CALLED_REC:
                /* --------------------------------------
                ** Called Party Number Information Record
                ** -------------------------------------- */
                ((caii_called_rec_type *) msg_ptr)->fix.number_type =
                   b_unpackb(buf_ptr, msg_pos,
                   FSIZ(cai_called_fix_type, number_type));
                msg_pos += FSIZ(cai_called_fix_type, number_type);

                ((caii_called_rec_type *) msg_ptr)->fix.number_plan =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_called_fix_type, number_plan));
                msg_pos += FSIZ(cai_called_fix_type, number_plan);

                ((caii_called_rec_type *) msg_ptr)->fix.num_char =
                  (byte)((rec_len - sizeof( cai_called_fix_type )) /
                         sizeof( cai_called_var_type));

                for (j=0;
                     j < ((caii_called_rec_type *) msg_ptr)->fix.num_char; j++)
                {
                  ((caii_called_rec_type *) msg_ptr)->var[j] =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_called_var_type, chari));
                  msg_pos += FSIZ(cai_called_var_type, chari);
                }

                /* ----------------------------------------------------------
                ** Increment internal message pointer to point to next record
                ** ---------------------------------------------------------- */
                msg_ptr += FENDPOS(caii_called_rec_type,
                  var[((caii_called_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += 1;  /* Increment past reserved bit at end */
                break;

              case CAI_CALLING_REC:
              case CAI_CONNECT_REC:
                /* -----------------------------------------------------------
                ** Calling Party Number or Connected Number Information Record
                ** ----------------------------------------------------------- */
                ((caii_calling_rec_type *) msg_ptr)->fix.number_type =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_calling_fix_type, number_type));
                msg_pos += FSIZ(cai_calling_fix_type, number_type);

                ((caii_calling_rec_type *) msg_ptr)->fix.number_plan =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_calling_fix_type, number_plan));
                msg_pos += FSIZ(cai_calling_fix_type, number_plan);

                ((caii_calling_rec_type *) msg_ptr)->fix.pi =
                   b_unpackb(buf_ptr, msg_pos,
                   FSIZ(cai_calling_fix_type, pi));
                msg_pos += FSIZ(cai_calling_fix_type, pi);

                ((caii_calling_rec_type *) msg_ptr)->fix.si =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_calling_fix_type, si));
                msg_pos += FSIZ(cai_calling_fix_type, si);

                ((caii_calling_rec_type *) msg_ptr)->fix.num_char =
                  (byte) ((rec_len - sizeof(cai_calling_fix_type)) /
                          sizeof(cai_calling_var_type));

                for (j=0;
                     j < ((caii_calling_rec_type *) msg_ptr)->fix.num_char; j++)
                {
                  ((caii_calling_rec_type *) msg_ptr)->var[j] =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_calling_var_type, chari));
                  msg_pos += FSIZ(cai_calling_var_type, chari);
                }

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += FENDPOS(caii_calling_rec_type,
                  var[((caii_calling_rec_type *) msg_ptr)->fix.num_char - 1]);

                msg_pos += 5;  /* Increment past reserved bits at end */
                break;

              case CAI_SIGNAL_REC:
                /* -------------------------
                ** Signal Information Record
                ** ------------------------- */
                ((caii_signal_rec_type *) msg_ptr)->signal_type =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_signal_rec_type, signal_type));
                msg_pos += FSIZ( cai_signal_rec_type, signal_type);

                ((caii_signal_rec_type *) msg_ptr)->alert_pitch =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_signal_rec_type, alert_pitch));
                msg_pos += FSIZ( cai_signal_rec_type, alert_pitch);

                ((caii_signal_rec_type *) msg_ptr)->signal =
                  b_unpackb(buf_ptr, msg_pos,
                          FSIZ(cai_signal_rec_type, signal));
                msg_pos += FSIZ(cai_signal_rec_type, signal) +
                           FSIZ(cai_signal_rec_type, reserved);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_signal_rec_type);
                break;

              case CAI_MSG_WAITING_REC:
                /* ----------------------------------
                ** Message Waiting Information Record
                ** ---------------------------------- */
                ((caii_msg_waiting_rec_type *) msg_ptr)->msg_count =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_msg_waiting_rec_type, msg_count));
                msg_pos += FSIZ(cai_msg_waiting_rec_type, msg_count);

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_msg_waiting_rec_type);
                break;

              case CAI_CALLED_SUB_REC:
              case CAI_CALLING_SUB_REC:
              case CAI_REDIR_SUB_REC:
              case CAI_CONNECT_SUB_REC:
                /* --------------------------------------------------------
                ** Calling Party Subaddress or Called Party Subaddress
                ** or Redirecting Subaddress or Connected Subaddress info
                ** record
                ** -------------------------------------------------------- */
                /* Unpack Information Record */
                status = xlate_ext_sub_rec(rec_len, buf_ptr, msg_ptr, &msg_pos);

                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_subaddr_rec_type,
                  var[((caii_subaddr_rec_type *) msg_ptr)->fix.num_char - 1]);
                break;

              case CAI_REDIR_NUM_REC:
                /* --------------------------------------------------------
                ** Redirecting Number Information Record
                ** -------------------------------------------------------- */
                /* Unpack Information Record */

                status = xlate_ext_redir_num_rec(rec_len, buf_ptr,
                         msg_ptr, &msg_pos);
                /* -------------------------------------------------
                ** Increment internal message pointer to next record
                ** ------------------------------------------------- */
                msg_ptr += FENDPOS(caii_redir_rec_type,
                  var[((caii_redir_rec_type *) msg_ptr)->fix.num_char - 1]);
                break;

              case CAI_EXT_DISPLAY_REC:
                /* ------------------------------
                ** Extended Display Info Record
                ** ------------------------------ */
                status = xlate_ext_ext_disp_rec(rec_len, buf_ptr, &msg_ptr, 
                  &msg_pos);
                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                break;

              case CAI_METER_PULSES_REC:
                /* --------------------------------
                ** Meter Pulses Information Record
                ** -------------------------------- */
                ((caii_meter_pulses_rec_type *) msg_ptr)->pulse_freq =
                  b_unpackw(buf_ptr, msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, pulse_freq));
                msg_pos += FSIZ(cai_meter_pulses_rec_type, pulse_freq);

                ((caii_meter_pulses_rec_type *) msg_ptr)->on_time =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, on_time));
                msg_pos += FSIZ(cai_meter_pulses_rec_type, on_time);

                ((caii_meter_pulses_rec_type *) msg_ptr)->off_time =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, off_time));
                msg_pos += FSIZ(cai_meter_pulses_rec_type, off_time);

                ((caii_meter_pulses_rec_type *) msg_ptr)->pulse_cnt =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_meter_pulses_rec_type, pulse_cnt));
                msg_pos += FSIZ(cai_meter_pulses_rec_type, pulse_cnt);

                msg_pos += FSIZ(cai_meter_pulses_rec_type, reserved);     /* Increment past reserved bit at end */

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
                msg_ptr += sizeof(caii_meter_pulses_rec_type); /*lint !e662 */
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
                break;

              case CAI_PARA_ALERT_REC:
                /* --------------------------------------
                ** Parametric Alerting Information Record
                ** -------------------------------------- */
                status = xlate_ext_para_alert_rec(rec_len, buf_ptr,
                         msg_ptr, &msg_pos);
                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
#if defined(FEATURE_IS2000_REL_A) && defined(FEATURE_MSG_PACK_UNIT_TEST)
#error code not present
#else
                if (((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups == 0)
                {
                  msg_ptr += FENDPOS(caii_para_alert_rec_type,fix);
                }
                else
                {
                  msg_ptr += FENDPOS(caii_para_alert_rec_type,
                    var[((caii_para_alert_rec_type *) msg_ptr)->fix.num_groups - 1]);
                }
#endif /* FEATURE_IS2000_REL_A && FEATURE_MSG_PACK_UNIT_TEST */
                break;

              case CAI_LINE_CTRL_REC:
                /* -------------------------------------
                ** Line Control Information Record
                ** ------------------------------------- */
                ((caii_line_ctrl_rec_type *) msg_ptr)->pol_inc =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_line_ctrl_rec_type, pol_inc));
                msg_pos += FSIZ(cai_line_ctrl_rec_type, pol_inc);

                if (((caii_line_ctrl_rec_type *) msg_ptr)->pol_inc)
                {
                  ((caii_line_ctrl_rec_type *) msg_ptr)->tgl_mod =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, tgl_mod));
                  msg_pos += FSIZ(cai_line_ctrl_rec_type, tgl_mod);

                  ((caii_line_ctrl_rec_type *) msg_ptr)->rev_pol =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, rev_pol));
                  msg_pos += FSIZ(cai_line_ctrl_rec_type, rev_pol);

                  ((caii_line_ctrl_rec_type *) msg_ptr)->pow_dtm =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, pow_dtm));
                  msg_pos += FSIZ(cai_line_ctrl_rec_type, pow_dtm);

                  msg_pos += 5;     /* Increment past reserved bit at end */
                }
                else
                {
                  ((caii_line_ctrl_rec_type *) msg_ptr)->pow_dtm =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_line_ctrl_rec_type, pow_dtm));
                  msg_pos += FSIZ(cai_line_ctrl_rec_type, pow_dtm);

                  msg_pos += 7;     /* Increment past reserved bit at end */
                }

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof(caii_line_ctrl_rec_type); /*lint !e662 */
                break;

              case CAI_USER_ZONE_UPDATE_REC:
                ((caii_user_zone_update_type *) msg_ptr)->uzid =
                  b_unpackw(buf_ptr, msg_pos,
                  FSIZ(cai_user_zone_update_type, uzid));
                msg_pos += FSIZ(cai_user_zone_update_type, uzid);
                msg_ptr += FENDPOS(caii_user_zone_update_type,uzid);
                break;

              case CAI_USER_ZONE_REJECT_REC:
                ((caii_user_zone_reject_type *) msg_ptr)->reject_uzid =
                  b_unpackw(buf_ptr, msg_pos,
                  FSIZ(cai_user_zone_reject_type, reject_uzid));
                msg_pos += FSIZ( cai_user_zone_reject_type, reject_uzid);

                ((caii_user_zone_reject_type *) msg_ptr)->reject_action_indi =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_user_zone_reject_type, reject_action_indi));
                msg_pos += FSIZ(cai_user_zone_reject_type, reject_action_indi);

                ((caii_user_zone_reject_type *) msg_ptr)->uzid_assign_incl =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_user_zone_reject_type, uzid_assign_incl));
                msg_pos += FSIZ(cai_user_zone_reject_type, uzid_assign_incl);

                if (((caii_user_zone_reject_type *) msg_ptr)->uzid_assign_incl)
                {
                  ((caii_user_zone_reject_type *) msg_ptr)->assign_uzid =
                    b_unpackw(buf_ptr, msg_pos,
                    FSIZ(cai_user_zone_reject_type, assign_uzid));
                  msg_pos += FSIZ(cai_user_zone_reject_type, assign_uzid);

                  msg_ptr += FENDPOS(caii_user_zone_reject_type,assign_uzid);
                }
                else
                {
                  msg_ptr += FENDPOS(caii_user_zone_reject_type,uzid_assign_incl );
                }
                msg_pos += 4; /* reserved */
                break;

#ifdef FEATURE_IS2000_REL_A
              case CAI_MC_EXT_DISP_REC:
                /* ---------------------------------------------
                ** Multi-character Extended Display Info Record
                ** --------------------------------------------- */
                status = xlate_ext_mc_ext_disp_rec(rec_len, buf_ptr,
                         &msg_ptr, &msg_pos);
                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                break;

              case CAI_CALL_WAIT_IND_REC:
                /* ----------------------------------
                ** Call Waiting Indicator Record
                ** ---------------------------------- */
                ((caii_call_waiting_ind_type *) msg_ptr)->call_waiting_ind =
                  b_unpackb(buf_ptr, msg_pos,
                  FSIZ(cai_call_wait_type, call_waiting_ind));
                msg_pos += (FSIZ( cai_call_wait_type, call_waiting_ind) +
                            FSIZ(cai_call_wait_type, reserved));

                /* -------------------------------
                ** Update internal message pointer
                ** ------------------------------- */
                msg_ptr += sizeof( caii_call_waiting_ind_type );
                break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
              case CAI_ENH_MC_EXT_DISP_REC:
                /* ---------------------------------------------
                ** Enhanced Multi-character Extended Display Info Record
                ** --------------------------------------------- */
                status = xlate_ext_enh_mc_ext_disp_rec(rec_len, buf_ptr,
                         &msg_ptr, &msg_pos);
                /* -------------------------------
                ** xlate function already updated
                ** internal message pointer
                ** ------------------------------- */
                break;
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_PASSPORT_MODE
              case CAI_NTL_SUP_SVC_REC:
              /* If JCDMA is not defined in the passport mode then treat
               * as if this code is not present. So slip into default case */
              if (mcc_passport_mode_is_jcdma())
              {
                /* ------------------------------------------
                ** Record for National Supplementary Services
                ** ------------------------------------------ */

                /* Determine the country-specific record type */

                ((caii_ntl_sup_svc_type *) msg_ptr)->mcc =
                   b_unpackw( buf_ptr, msg_pos,
                   FSIZ(cai_ntl_sup_svc_type, mcc));

                ((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype =
                  b_unpackb(buf_ptr, msg_pos + FSIZ(cai_ntl_sup_svc_type, mcc),
                  FSIZ(cai_ntl_sup_svc_type, record_subtype));

                if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc == CAI_T53_COUNTRY_CODE) &&
                    (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype == CAI_CLIR_REC))
                {
                  /* -----------------------
                  ** CLIR Information Record
                  ** ----------------------- */
                  msg_pos += FSIZ(cai_ntl_sup_svc_type, mcc) +
                    FSIZ(cai_ntl_sup_svc_type, record_subtype);

                  ((caii_clir_sup_svc_type *) msg_ptr)->cause =
                    b_unpackb(buf_ptr, msg_pos, 
                    FSIZ(cai_clir_sup_svc_type, cause));
                  msg_pos += FSIZ( cai_clir_sup_svc_type, cause);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_clir_sup_svc_type);

                }
                else if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc ==
                          CAI_T53_COUNTRY_CODE) &&
                        (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype ==
                          CAI_RELEASE_REC))
                {
                  /* --------------------------
                  ** Release Information Record
                  ** -------------------------- */
                  msg_pos += FSIZ(cai_release_sup_svc_type, mcc) +
                    FSIZ(cai_release_sup_svc_type, record_subtype);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_release_sup_svc_type);

                }
                else if ((((caii_ntl_sup_svc_type *) msg_ptr)->mcc ==
                          CAI_T53_COUNTRY_CODE) &&
                        (((caii_ntl_sup_svc_type *) msg_ptr)->record_subtype ==
                          CAI_AUDIO_CONTROL_REC))
                {
                  /* --------------------------------
                  ** Audio Control Information Record
                  ** -------------------------------- */
                  msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, mcc) +
                    FSIZ(cai_audio_ctl_sup_svc_type, record_subtype);

                  ((caii_audio_ctl_sup_svc_type *) msg_ptr)->up_link =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_audio_ctl_sup_svc_type, up_link));
                  msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, up_link);

                  ((caii_audio_ctl_sup_svc_type *) msg_ptr)->down_link =
                    b_unpackb(buf_ptr, msg_pos,
                    FSIZ(cai_audio_ctl_sup_svc_type, down_link));
                  msg_pos += FSIZ(cai_audio_ctl_sup_svc_type, down_link) +
                    FSIZ(cai_audio_ctl_sup_svc_type, reserved);

                  /* -------------------------------
                  ** Update internal message pointer
                  ** ------------------------------- */
                  msg_ptr += sizeof(caii_audio_ctl_sup_svc_type);

                }
                else
                {
                  /* ------------------------------------
                  ** Unknown country-specific record type
                  ** ------------------------------------ */
                  msg_ptr += sizeof( caii_ntl_sup_svc_type );
                  msg_pos += rec_len;
                }
                break;
              }
#endif /* FEATURE_T53 */
              /* This is an intentional fall through. If feature is not defined
                 or if the mode is not JCDMA the code will fall through into
                 default */
              /*lint -fallthrough */
              default:
                /* -------------------
                ** Unknown record type
                ** ------------------- */
                msg_ptr += sizeof(caii_rec_hdr_type);
                msg_pos += rec_len;
            } /* end switch (rec_type) */

            msg_ptr = (byte*)ALIGN_DWORD(((dword) msg_ptr));

          }
        }
      }
    }
  } /* if length is ok */

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_eawim */

/*===========================================================================

FUNCTION XLATE_EXT_TC_SMCM
DESCRIPTION
  This function translates a Traffic Channel Security Mode Command
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_smcm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  word i;
    /* counter */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
      
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_security_mode_cmd_fix_type
  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (sizeof(cai_security_mode_cmd_fix_type ) +
             FSIZ(cai_security_mode_cmd_var2_type, c_sig_encrypt_mode_incl) -
       FSIZ(cai_security_mode_cmd_fix_type, action_time))
     )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcsmcm.hdr);
    msg_pos = FENDPOS(cai_security_mode_cmd_fix_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tcsmcm.hdr.msg_int, 
         int_ptr->tcsmcm.msg_type,
         int_ptr->tcsmcm.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */

    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
               &int_ptr->tcsmcm.hdr, int_ptr->tcsmcm.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }

    int_ptr->tcsmcm.use_time =
      b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, use_time));
    msg_pos += FSIZ(MTYPE, use_time);
    
    if (int_ptr->tcsmcm.use_time)
    {
      int_ptr->tcsmcm.action_time =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, action_time));
      msg_pos += FSIZ(MTYPE, action_time);
    }
    
    int_ptr->tcsmcm.d_sig_encrypt_mode =
      b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, d_sig_encrypt_mode));
    msg_pos += FSIZ(MTYPE, d_sig_encrypt_mode);
    
    int_ptr->tcsmcm.num_recs =
      b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_recs));
    msg_pos += FSIZ(MTYPE, num_recs);
    
#undef MTYPE
    
#define MTYPE cai_security_mode_cmd_var_type
    
    for ( i=0; i < int_ptr->tcsmcm.num_recs; i++)
    {
      int_ptr->tcsmcm.recs[i].con_ref =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, con_ref));
      msg_pos += FSIZ(MTYPE, con_ref);
      
      int_ptr->tcsmcm.recs[i].ui_encrypt_mode =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, ui_encrypt_mode));
      msg_pos += FSIZ(MTYPE, ui_encrypt_mode);
    }
    
#undef MTYPE
    
#define MTYPE cai_security_mode_cmd_var2_type
    
    if ((int_ptr->tcsmcm.d_sig_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
        (int_ptr->tcsmcm.d_sig_encrypt_mode == CAI_ENC_MODE_REA))
    {
      int_ptr->tcsmcm.key_size =
        b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, key_size));
      msg_pos += FSIZ(MTYPE,key_size);
    }
    
    int_ptr->tcsmcm.c_sig_encrypt_mode_incl =
      b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, c_sig_encrypt_mode_incl));
    msg_pos += FSIZ(MTYPE, c_sig_encrypt_mode_incl);
    
    if (int_ptr->tcsmcm.c_sig_encrypt_mode_incl)
    {
      int_ptr->tcsmcm.c_sig_encrypt_mode =
        b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, c_sig_encrypt_mode));
      msg_pos += FSIZ(MTYPE, c_sig_encrypt_mode);
    }

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      int_ptr->tcsmcm.msg_int_info_incl =
        b_unpackb( buf_ptr, msg_pos, FSIZ(cai_security_mode_cmd_rel_c_type, msg_int_info_incl));
      msg_pos += FSIZ(cai_security_mode_cmd_rel_c_type, msg_int_info_incl);
      
      if (int_ptr->tcsmcm.msg_int_info_incl)
      {
        int_ptr->tcsmcm.change_keys =
          b_unpackb( buf_ptr, msg_pos, FSIZ(cai_security_mode_cmd_rel_c_type, change_keys));
        msg_pos += FSIZ(cai_security_mode_cmd_rel_c_type, change_keys);
  
        int_ptr->tcsmcm.use_uak =
          b_unpackb( buf_ptr, msg_pos, FSIZ(cai_security_mode_cmd_rel_c_type, use_uak));
        msg_pos += FSIZ(cai_security_mode_cmd_rel_c_type, use_uak);
      }
    }
#endif /* FEATURE_IS2000_REL_C */

    /* Make sure the message contained all the fields advertised by the p-rev */
    if (msg_pos > len)
    {
      status = CAIX_INV_LEN_S;
    }

  } /* else length check failed */

  #undef MTYPE

  return (status);

} /* xlate_ext_tc_smcm */

#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A_BSID
/*===========================================================================

FUNCTION XLATE_EXT_TC_BS_STATUS_RSP

DESCRIPTION
  This function translates a Forward Traffic Channel Base Station Status
  Response Message from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_bs_status_rsp
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i, j;
    /* Index for looping through characters */
  word msg_pos = 0;
  /* Position in message relative to start of buf_ptr */
  word record_pos, record_pos1;
  /* Position of the record */
  word reserved_bits, reserved_1_bits;
  /* Number of reserved bits, and reserved_1 bits. */
  word qual_info_len, record_length, record_len;
  /* Qualification Information Length, and Record Length */
         
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_bs_status_rsp_type

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < FSIZ(MTYPE, bss_fix))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Length is OK --> convert message from external to internal format
    ** starting with the first field after message_type
    ** ----------------------------------------------------------------- */
    xlate_ext_tc_hdr( buf_ptr, &int_ptr->bssrsp.hdr );

    msg_pos = FENDPOS(MTYPE, bss_fix.hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->bssrsp.hdr.msg_int,
         int_ptr->bssrsp.msg_type,
         int_ptr->bssrsp.hdr.ack_req
         )) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_C */
    {
#ifdef FEATURE_IS2000_REL_A
      if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
          &int_ptr->bssrsp.hdr, int_ptr->bssrsp.msg_type, 0, 0)) == CAIX_DONE_S)
#endif /* FEATURE_IS2000_REL_A */
      {
        int_ptr->bssrsp.qual = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, bss_fix.qual_info_type));
        msg_pos += FSIZ(MTYPE, bss_fix.qual_info_type);

        qual_info_len = b_unpackb(buf_ptr, msg_pos,
          FSIZ(MTYPE, bss_fix.qual_info_len));
        msg_pos += FSIZ(MTYPE, bss_fix.qual_info_len);

        switch (int_ptr->bssrsp.qual)
        {
          case CAI_NO_QUAL:
            if (qual_info_len != 0 )
            {
              MSG_ERROR(" BSSRSP: qual_info_len %d != 0", qual_info_len, 0, 0);
              status = CAIX_INV_MSG_S;
            }
            break;

          case CAI_BAND_QUAL:
            if (qual_info_len != (sizeof(cai_qual_info1_type)/8) )
            {
              MSG_ERROR(" BSSRSP: qual_info_len %d != 1", qual_info_len, 0, 0);
              status = CAIX_INV_MSG_S;
            }
            else
            {
              int_ptr->bssrsp.band =
                  b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, qi.qi1.band) );
              msg_pos += FSIZ(MTYPE, qi.qi1.band);
              msg_pos += FSIZ(MTYPE, qi.qi1.reserved);
            }
            break;

          case CAI_BAND_OP_MODE_QUAL:
            if (qual_info_len != (sizeof(cai_qual_info2_type)/8) )
            {
              MSG_ERROR(" BSSRSP: qual_info_len %d != 2", qual_info_len, 0, 0);
              status = CAIX_INV_MSG_S;
            }
            else
            {
              int_ptr->bssrsp.band =
                  b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, qi.qi2.band) );
              msg_pos += FSIZ(MTYPE, qi.qi2.band);
              int_ptr->bssrsp.op_mode =
                b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, qi.qi2.op_mode) );
              msg_pos += FSIZ(MTYPE, qi.qi2.op_mode);
              msg_pos += FSIZ(MTYPE, qi.qi2.reserved);
            }
            break;

          default:
            MSG_ERROR(" BSSRSP: qual_info_type %d not supported",
                        int_ptr->bssrsp.qual, 0, 0);
            status = CAIX_INV_MSG_S;
        }

        if (status == CAIX_DONE_S)
        {
          int_ptr->bssrsp.num_record = b_unpackb(buf_ptr, msg_pos,
            FSIZ(MTYPE, bss_fix.num_record));
          msg_pos += FSIZ(MTYPE, bss_fix.num_record);

          for (i = 0; (status == CAIX_DONE_S) &&
               (i < int_ptr->bssrsp.num_record); i++)
          {
            int_ptr->bssrsp.bss_rec[i].record_type =
              b_unpackb( buf_ptr, msg_pos, FSIZ(MTYPE, rec_fix.record_type));
            msg_pos += FSIZ(MTYPE, rec_fix.record_type);

            record_length = b_unpackb(buf_ptr, msg_pos,
              FSIZ(MTYPE, rec_fix.record_length));
            msg_pos += FSIZ(MTYPE, rec_fix.record_length);

            record_pos = msg_pos;

            switch (int_ptr->bssrsp.bss_rec[i].record_type)
            {
              case CAI_BSS_PILOT_INFO_RSP:
                int_ptr->bssrsp.bss_rec[i].pi.num_pilots = b_unpackb(buf_ptr,
                  msg_pos, FSIZ(MTYPE, rec0.fix.num_pilots));
                msg_pos += FSIZ(MTYPE, rec0.fix.num_pilots);

                int_ptr->bssrsp.bss_rec[i].pi.sid_nid_ind = b_unpackb(buf_ptr,
                  msg_pos, FSIZ(MTYPE, rec0.fix.sid_nid_ind));
                msg_pos += FSIZ(MTYPE, rec0.fix.sid_nid_ind);

                for (j = 0; (status == CAIX_DONE_S) &&
                     (j < int_ptr->bssrsp.bss_rec[i].pi.num_pilots); j++)
                {
                  /* Save the record position */
                  record_pos1 = msg_pos;

                  record_len = b_unpackb(buf_ptr, msg_pos,
                    FSIZ(MTYPE, rec0.var_fix.record_len));
                  msg_pos += FSIZ(MTYPE, rec0.var_fix.record_len);

                  int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].pilot_pn =
                    b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE,
                    rec0.var_fix.pilot_pn));
                  msg_pos += FSIZ(MTYPE, rec0.var_fix.pilot_pn);

                  int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_id =
                    b_unpackw(buf_ptr, msg_pos,
                    FSIZ(MTYPE, rec0.var_fix.base_id));
                  msg_pos += FSIZ(MTYPE, rec0.var_fix.base_id);

                  if (int_ptr->bssrsp.bss_rec[i].pi.sid_nid_ind != 0)
                  {
                    int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].sid_nid_incl =
                      b_unpackb(buf_ptr, msg_pos,
                      FSIZ(MTYPE, rec0.var_var.sid_nid_incl));
                    msg_pos += FSIZ(MTYPE, rec0.var_var.sid_nid_incl);

                    if (int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].sid_nid_incl !=
                        0 )
                    {
                      int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].sid =
                        b_unpackw( buf_ptr, msg_pos,
                        FSIZ(MTYPE, rec0.var_var.sid));
                      msg_pos += FSIZ(MTYPE, rec0.var_var.sid);

                      int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].nid =

                      b_unpackw( buf_ptr, msg_pos,
                      FSIZ(MTYPE, rec0.var_var.nid));
                      msg_pos += FSIZ(MTYPE, rec0.var_var.nid);
                    }
                  } /* end if sid_nid_ind != 0 */

#ifdef FEATURE_IS2000_REL_C
                  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
                  {
                    int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_lat_long_incl =
                      b_unpackb(buf_ptr, msg_pos,
                      FSIZ(MTYPE, rec0.var_var.base_lat_long_incl));
                    msg_pos += FSIZ(MTYPE, rec0.var_var.base_lat_long_incl);

                    if (int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_lat_long_incl)
                    {
                      int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_lat =
                        b_unpackd(buf_ptr, msg_pos,
                        FSIZ(MTYPE, rec0.var_var.base_lat));
                      msg_pos += FSIZ(MTYPE, rec0.var_var.base_lat);

                      int_ptr->bssrsp.bss_rec[i].pi.pi_rec[j].base_long =
                        b_unpackd(buf_ptr, msg_pos,
                        FSIZ(MTYPE, rec0.var_var.base_long));
                      msg_pos += FSIZ(MTYPE, rec0.var_var.base_long);
                    }
                  } /* prev_in_use >= 9 */
#endif /* FEATURE_IS2000_REL_C */

                  /* Reserved 1 */
                  reserved_1_bits = 8 - ((msg_pos - record_pos1) % 8);
                  if ( reserved_1_bits != 8 )
                  {
                    msg_pos += reserved_1_bits;
                  }

                  /* Check if the record_len is valid */
                  if ((msg_pos - record_pos1) != (record_len * 8))
                  {
                    MSG_ERROR("record_len %d is invalid", record_len, 0, 0);
                    status = CAIX_INV_MSG_S;
                  }
                } /* end for num_pilots */
                break; /* case 0 */

              default:
                MSG_ERROR(" BSSRSP: record_type %d not supported",
                          int_ptr->bssrsp.bss_rec[i].record_type, 0, 0);
                status = CAIX_INV_MSG_S;
                break;
            } /* switch of record_type */

            if (status == CAIX_DONE_S)
            {
              /* Reserved bits */
              reserved_bits = 8 - ((msg_pos - record_pos) % 8);
              if ( reserved_bits != 8 )
              {
                msg_pos += reserved_bits;
              }

              /* Check if the record_length is valid */
              if ((msg_pos - record_pos) != (record_length * 8))
              {
                MSG_ERROR("record_length %d is invalid", record_length, 0, 0);
                status = CAIX_INV_MSG_S;
              }
            }
          } /* end for num_records */
        } /* end if (status == CAIX_DONE_S) */
      }
    }
  } /* end if (len < FSIZ(MTYPE, bss_fix)) */

  #undef MTYPE

  return (status);

} /* xlate_ext_bs_status_rsp */
#endif /* FEATURE_IS2000_REL_A_BSID */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_EXT_TC_AUTH_REQ
DESCRIPTION
  This function translates a Traffic Channel Authentication Request
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_auth_req
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
          
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < (sizeof( cai_tc_auth_req_type ) + FSIZ(cai_msg_int_type, maci_incl)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->tcauthreq.hdr);
    msg_pos = FENDPOS(cai_tc_auth_req_type, hdr.encryption);

    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0,
         CAIX_MACI_NOT_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->tcauthreq.hdr.msg_int,
         int_ptr->tcauthreq.msg_type,
         int_ptr->tcauthreq.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }
    
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
               &int_ptr->tcauthreq.hdr, int_ptr->tcauthreq.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }

#define MTYPE cai_tc_auth_req_type

    b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE, randa)/2, int_ptr->tcauthreq.randa_hi);
    msg_pos += FSIZ(MTYPE, randa)/2;

    b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE, randa)/2, int_ptr->tcauthreq.randa_lo);
    msg_pos += FSIZ(MTYPE, randa)/2;
    
    b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE, con_sqn), int_ptr->tcauthreq.con_sqn);
    msg_pos += FSIZ(MTYPE, con_sqn);
    
    int_ptr->tcauthreq.amf = b_unpackw(buf_ptr, msg_pos, FSIZ(MTYPE, amf));
    msg_pos += FSIZ(MTYPE, amf);
    
    b_unpackq(buf_ptr, msg_pos, FSIZ(MTYPE, mac_a), int_ptr->tcauthreq.mac_a);
    msg_pos += FSIZ(MTYPE, mac_a);
    
#undef MTYPE
  }

  return (status);

} /* xlate_ext_tc_auth_req */

/*===========================================================================

FUNCTION XLATE_EXT_TC_RATE_CHANGE
DESCRIPTION
  This function translates a Traffic Channel Rate Change
  Message from external to internal format.

DEPENDENCIES
  None.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_rate_change
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos=0;
    /* Position in message relative to start of buf_ptr */
  word i;
    /* counter */
          
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length.
  ** -------------------------------------------- */
  if (len < (sizeof( cai_rate_change_fix_type ) + FSIZ(cai_msg_int_type, maci_incl)))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    xlate_ext_tc_hdr(buf_ptr, &int_ptr->rate_change.hdr);
    msg_pos = FENDPOS(cai_rate_change_fix_type, hdr.encryption);

    if ((status = xlate_ext_mi_and_validate_maci(len, CAIX_TC, 0, 
         CAIX_MACI_REQUIRED,
         &msg_pos, buf_ptr, &int_ptr->rate_change.hdr.msg_int,
         int_ptr->rate_change.msg_type,
         int_ptr->rate_change.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }
    if ((status = xlate_ext_ext_enc_tc(&len, &msg_pos, buf_ptr, 
               &int_ptr->rate_change.hdr, int_ptr->rate_change.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
     
#define MTYPE cai_rate_change_var_type
    
    int_ptr->rate_change.use_time =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rate_change_fix_type, use_time));
    msg_pos += FSIZ(cai_rate_change_fix_type, use_time);
    
    int_ptr->rate_change.action_time =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rate_change_fix_type, action_time));
    msg_pos += FSIZ(cai_rate_change_fix_type, action_time);
    
    int_ptr->rate_change.rev_cqich_rate_change_incl =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rate_change_fix_type, rev_cqich_rate_change_incl));
    msg_pos += FSIZ(cai_rate_change_fix_type, rev_cqich_rate_change_incl);
    
    if(int_ptr->rate_change.rev_cqich_rate_change_incl)
    {
      int_ptr->rate_change.full_ci_feedback_ind = 
  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, full_ci_feedback_ind));
      msg_pos += FSIZ(MTYPE, full_ci_feedback_ind);
      
      int_ptr->rate_change.rev_cqich_reps = 
  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_cqich_reps));
      msg_pos += FSIZ(MTYPE, rev_cqich_reps);
      
      int_ptr->rate_change.switching_parms_incl = 
  b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, switching_parms_incl));
      msg_pos += FSIZ(MTYPE, switching_parms_incl);
      
      if (int_ptr->rate_change.switching_parms_incl)
      {
        int_ptr->rate_change.num_soft_switching_frames = 
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_soft_switching_frames));
        msg_pos += FSIZ(MTYPE, num_soft_switching_frames);
  
        int_ptr->rate_change.num_softer_switching_frames = 
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_softer_switching_frames));
        msg_pos += FSIZ(MTYPE, num_softer_switching_frames);
  
        int_ptr->rate_change.chm_switching_parms_incl = 
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, chm_switching_parms_incl));
        msg_pos += FSIZ(MTYPE, chm_switching_parms_incl);
  
        if (int_ptr->rate_change.chm_switching_parms_incl)
        {
          int_ptr->rate_change.num_soft_switching_frames_chm = 
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_soft_switching_frames_chm));
          msg_pos += FSIZ(MTYPE, num_soft_switching_frames_chm);
    
          int_ptr->rate_change.num_softer_switching_frames_chm = 
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_softer_switching_frames_chm));
          msg_pos += FSIZ(MTYPE, num_softer_switching_frames_chm);
        }
      }  /* if (int_ptr->rate_change.switching_parms_incl) */

      int_ptr->rate_change.rl_cqich_att_adj_gain_incl = 
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_incl));
      msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_incl);      
      
      if (int_ptr->rate_change.rl_cqich_att_adj_gain_incl)
      {
        int_ptr->rate_change.num_recs = 
          b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, num_recs));
        msg_pos += FSIZ(MTYPE, num_recs);      
  
        for (i=0; i < int_ptr->rate_change.num_recs + 1; i++)
        {
          int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_type = 
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_type));
          msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_type);      
    
          int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_high_incl = 
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_high_incl));
          msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_high_incl);      
    
          if (int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_high_incl)
          {
            int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_high = 
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_high));
            msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_high);      
          }

          int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_low_incl = 
            b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_low_incl));
          msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_low_incl);      
  
          if (int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_low_incl)
          {
            int_ptr->rate_change.rl_cqich[i].rl_cqich_att_adj_gain_low = 
              b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rl_cqich_att_adj_gain_low));
            msg_pos += FSIZ(MTYPE, rl_cqich_att_adj_gain_low);      
          }

        }   /* for (i=0; i < int_ptr->rate_change.num_recs + 1; i++) */
      }   /*  if (int_ptr->rate_change.rl_cqich_att_adj_gain_incl) */
    }  /* if(int_ptr->rate_change.rev_cqich_rate_change_incl) */

    int_ptr->rate_change.rev_ackch_rate_change_incl =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rate_change_fix_type, rev_ackch_rate_change_incl));
    msg_pos += FSIZ(cai_rate_change_fix_type, rev_ackch_rate_change_incl);
    
    if (int_ptr->rate_change.rev_ackch_rate_change_incl)
    {
      int_ptr->rate_change.rev_ackch_reps =
        b_unpackb(buf_ptr, msg_pos, FSIZ(MTYPE, rev_ackch_reps));
      msg_pos += FSIZ(MTYPE, rev_ackch_reps);
    }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

#undef MTYPE

  }
  return (status);

} /* xlate_ext_tc_rate_change */

#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*===========================================================================

FUNCTION XLATE_EXT_TC_MSG

DESCRIPTION
  This function translates a received Traffic Channel Message from
  external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_tc_msg
(
  word len,
    /* Length of message in bits */
  byte *tc_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
#ifdef FEATURE_AUTH
  byte encryption;

  /* the message encrypt mode could be one of the following values:
   *  0 (CAI_ENC_MODE_DISABLED)      -- no encryption
   *  1 (CAI_ENCRYPT_CALL_CTL_MSGS)  -- CMEA encrypted. the message 
   *     will be decrypted by the function call of auth_decrypt_cdma
   *  2 (CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG) -- ECMEA. this mode is not
   *     supported
   *  3 (CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG  -- AES encrypted. later on
   *     in function xlate_ext_ext_enc_tc will handle the AES decryption.
   *     
   */
  if ((encryption = b_unpackb( tc_ptr, FPOS( cai_gen_tc_type, hdr.encryption ),
      FSIZ( cai_gen_tc_type, hdr.encryption ))) == CAI_ENCRYPT_CALL_CTL_MSGS)
  {
    if (!auth_decrypt_cdma( &len, tc_ptr ))
    {
      /* The decryption failed, and we can't risk processing the message */
      return (CAIX_INV_MSG_S);
    }
  }
  else if (encryption == CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG)
  {
    /* We don't support ECMEA */
    return (CAIX_INV_MSG_S);
  }
  else
  {
    /* Either no encryption - pass through
    ** or Extended Encryption - processed later
    */
  }
#endif /* FEATURE_AUTH */

  /* -------------------
  ** Decode message type
  ** ------------------- */
  switch ((int_ptr->gen_tc.msg_type =
             b_unpackb( tc_ptr, FPOS( cai_gen_type, msg_type ),
                                FSIZ( cai_gen_type, msg_type ))))
  {
    case CAI_TC_FWD_ORD_MSG:
      status = xlate_ext_tc_ord( len, tc_ptr, int_ptr );
      MSG_MED ( "RX order type 0x%x ack_seq %x msg_seq %x",
                int_ptr->tc_ord.gen.order,
                int_ptr->tc_ord.gen.hdr.ack_seq,
                int_ptr->tc_ord.gen.hdr.msg_seq );
      break;

    case CAI_TC_AUTH_MSG:
      status = xlate_ext_auth_ch( len, tc_ptr, int_ptr );
      MSG_MED ( "RX auth chal encrypt %x randu %x",
                int_ptr->auth_ch.hdr.encryption,
                int_ptr->auth_ch.randu, 0 );
      break;

    case CAI_ALERT_MSG:
      status = xlate_ext_info( len, tc_ptr, int_ptr );
      MSG_MED ( "RX alert w/info #recs %x",
                int_ptr->alert.num_recs, 0, 0 );
      break;

    case CAI_TC_FWD_BURST_MSG:
      status = xlate_ext_tc_burst( len, tc_ptr, int_ptr );
      MSG_MED ( "RX TC burst msg# %x type %x msgs %x",
                int_ptr->tc_burst.msg_number,
                int_ptr->tc_burst.burst_type,
                int_ptr->tc_burst.num_msgs );
      break;

    case CAI_HO_DIR_MSG:
    case CAI_EXT_HO_DIR_MSG:
    case CAI_GEN_HO_DIR_MSG:
    case CAI_UNIV_HO_DIR_MSG:
#ifdef FEATURE_MEID_SUPPORT
    case CAI_MEID_UNIV_HO_DIR_MSG:
#endif /* FEATURE_MEID_SUPPORT */

      /* Yes, these five cases fall through, because we want to use
         the generic handoff function for all handoff types. */

      status = xlate_ext_ho_msg( len, tc_ptr, int_ptr );
      MSG_MED ( "RX HO type %d, hdm_seq %d #pilots %d",
                int_ptr->gen_tc.msg_type,
                int_ptr->ho.hdm_seq,
                int_ptr->ho.num_pilots );
      break;

    case CAI_FM_HO_MSG:
      status = xlate_ext_fm_ho( len, tc_ptr, int_ptr );
      MSG_MED ( "RX FM HO vmac %x chan %x scc %x",
                int_ptr->fm_ho.vmac,
                int_ptr->fm_ho.analog_chan,
                int_ptr->fm_ho.scc );
      break;

    case CAI_TC_SYS_PARM_MSG:
      status = xlate_ext_tc_sys_parm( len, tc_ptr, int_ptr );
      MSG_MED ( "RX In Traffic SysParm", 0, 0, 0 );
      break;

    case CAI_TC_NLU_MSG:
      status = xlate_ext_nlu( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Nghbr List Update %x nghbrs ",
                int_ptr->nlu.num_nghbr, 0, 0 );
      break;

    case CAI_SEND_BURST_MSG:
      status = xlate_ext_send_burst( len, tc_ptr, int_ptr );
      MSG_MED ( "RX DTMF %x", int_ptr->sbdtmf.digit[0], 0, 0 );
      break;

    case CAI_PWR_CTL_MSG:
      status = xlate_ext_pwr_ctl( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Pwr Ctl thresh %x, frms %x, delay %x",
                int_ptr->pwr_ctl.pwr_rep_thresh,
                int_ptr->pwr_ctl.pwr_rep_frames,
                int_ptr->pwr_ctl.pwr_rep_delay   );
      break;

    case CAI_RET_PARMS_MSG:
      status = xlate_ext_ret_parms( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Ret Parms # %x, prm1 %x, prm2 %x",
                int_ptr->ret.num_parms,
                int_ptr->ret.parameter_id[0],
                int_ptr->ret.parameter_id[1] );
      break;

    case CAI_SET_PARMS_MSG:
      status = xlate_ext_set_parm( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Ret Parms # %x, prm1 %x, prm2 %x",
                int_ptr->set.num_parms,
                int_ptr->set.parms[0].parameter_id,
                int_ptr->set.parms[1].parameter_id );
      break;

    case CAI_TC_SSD_UP_MSG:
      status = xlate_ext_ssd_up( len, tc_ptr, int_ptr);
      MSG_MED ( "RX SSD up randu %lx%lx",
                qw_lo (int_ptr->ssd_up.randssd ),
                qw_hi (int_ptr->ssd_up.randssd ), 0 );
      break;

    case CAI_FWD_FLASH_MSG:
      status = xlate_ext_info( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Flash with %x records",
                int_ptr->alert.num_recs, 0, 0 );
      break;

    case CAI_MOB_REG_MSG:
      status = xlate_ext_mob_reg( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Mob Reg in SID %x NID %x",
              int_ptr->reg.sid, int_ptr->reg.nid, 0 );
      break;

    case CAI_TC_STREQ_MSG:
      status = xlate_ext_tc_streq( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Stat Req. num fields: %x",
                int_ptr->tc_streq.num_fields, 0, 0 );
      break;

    case CAI_FTC_SRV_REQ_MSG:
      status = xlate_ext_srv_req( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Srv Req. Purp: %x Num Rec: %x",
              int_ptr->srv_req.purp, int_ptr->srv_req.cfg.num_con, 0 );
      break;

    case CAI_FTC_SRV_RSP_MSG:
      status = xlate_ext_srv_rsp( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Srv Rsp. Purp: %x Num Rec: %x",
              int_ptr->srv_rsp.purp, int_ptr->srv_rsp.cfg.num_con, 0 );
      break;

    case CAI_SRV_CON_MSG:
      status = xlate_ext_srv_con( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Srv Con. Con Seq: %x Num Rec: %x",
              int_ptr->srv_con.con_seq, int_ptr->srv_con.cfg.num_con, 0 );
      break;

    case CAI_FTC_SRV_CTL_MSG:
      status = xlate_ext_srv_ctl( len, tc_ptr, int_ptr );
      MSG_MED ( "RX Srv Ctl. Con Ref: %x SO: %x",
              int_ptr->srv_ctl.con_ref, int_ptr->srv_ctl.so, 0 );
      break;

    case CAI_FTC_TMSI_ASGN_MSG:
      status = xlate_ext_tc_tmsi( len, tc_ptr, int_ptr );
      MSG_MED ( "RX FTC TMSI Assignment msg",   0, 0, 0 );
      break;

    case CAI_FTC_SRV_REDIR_MSG:
      status = xlate_ext_tc_srv_redir( len,tc_ptr, int_ptr );
      MSG_MED ( "RX FTC Srv Redir msg, redir_type %d",
                int_ptr->tc_srv_redir.redirect_type, 0, 0 );
      break;

    case CAI_SUP_CHN_ASN_MSG:
      status = xlate_ext_scam( len,tc_ptr, int_ptr );
      MSG_MED ( "", 0, 0, 0 );
      break;

    case CAI_FTC_PWR_CTRL_MSG:
      status = xlate_ext_tc_pwr_ctrl( len,tc_ptr, int_ptr );
      MSG_MED ( "", 0, 0, 0 );
      break;

    case CAI_EXT_NLU_MSG:
      status = xlate_ext_ext_nlu( len,tc_ptr, int_ptr );
      MSG_MED ( "", 0, 0, 0 );
      break;

    case CAI_CF_SRCH_REQ_MSG:
      status = xlate_ext_tc_cfs_req( len,tc_ptr, int_ptr );
      MSG_MED ( "", 0, 0, 0 );
      break;

    case CAI_CFS_CTRL_MSG:
      status = xlate_ext_tc_cfs_ctrl( len,tc_ptr, int_ptr );
      MSG_MED ( "", 0, 0, 0 );
      break;

    case CAI_PUF_MSG:
      status = xlate_ext_tc_puf( len,tc_ptr, int_ptr );
      MSG_MED ( "", 0, 0, 0 );
      break;

    case CAI_PUF_CMP_MSG:
      status = xlate_ext_tc_puf_cmp( len,tc_ptr, int_ptr );
      MSG_MED ( "", 0, 0, 0 );
      break;

    #ifdef FEATURE_IS2000_SCH
    case CAI_EXT_SUP_CHN_ASN_MSG:
      status = xlate_ext_tc_escam( len,tc_ptr,int_ptr );
      break;
    #endif /* FEATURE_IS2000_SCH */

#if defined( FEATURE_IS2000_CHS) || defined  (FEATURE_IS2000_REL_A)
    case CAI_RES_ALLOC_MSG:
      status = xlate_ext_tc_ram( len, tc_ptr, int_ptr );
      break;

    case CAI_EXT_RELEASE_MSG:
      status = xlate_ext_tc_erm( len, tc_ptr, int_ptr );
      break;
#endif /* FEATURE_IS2000_CHS || FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A
    case CAI_MOB_ASSIST_BURST_OP_MSG:
      status = xlate_ext_tc_mabom( len,tc_ptr,int_ptr );
      break;

    case CAI_USER_ZONE_REJ_MSG:
      status = xlate_ext_tc_uzrm( len,tc_ptr,int_ptr );
      break;

    case CAI_USER_ZONE_UPDATE_MSG:
      status = xlate_ext_tc_uzum( len,tc_ptr,int_ptr );
      break;

    case CAI_CALL_ASSIGN_MSG:
      status = xlate_ext_tc_clam( len,tc_ptr,int_ptr );
      break;

    case CAI_EXT_ALERT_W_INFO_MSG:
      status = xlate_ext_tc_eawim( len,tc_ptr,int_ptr );
      break;

    case CAI_EXT_FLASH_W_INFO_MSG:
      status = xlate_ext_tc_eawim( len,tc_ptr,int_ptr );
      break;

    case CAI_SECURITY_MODE_MSG:
      status = xlate_ext_tc_smcm( len,tc_ptr,int_ptr );
      break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A_BSID
    case CAI_BS_STATUS_RSP_MSG:
      status = xlate_ext_bs_status_rsp( len, tc_ptr, int_ptr );
      break;
#endif /* FEATURE_IS2000_REL_A_BSID */

#ifdef FEATURE_IS2000_REL_C
    case CAI_TC_AUTH_REQ_MSG:
      status = xlate_ext_tc_auth_req( len, tc_ptr, int_ptr );
      break;

    case CAI_RATE_CHANGE_MSG:
      status = xlate_ext_tc_rate_change( len, tc_ptr, int_ptr );
      break;
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_ext_tc_msg */

/*===========================================================================

FUNCTION XLATE_EXT_SYS_PARM

DESCRIPTION
  This function translates a Paging Channel System Parameter Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the System Parameter message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_sys_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* status returned to calling procedure */
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word min_len;
    /* Protocol dependent minimum length requirement */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_sysparm_msg_type

  /* ---------------------------------------
  ** Check length to make sure it is correct
  ** --------------------------------------- */
  if ( len < CAI_SYSPARM_MIN )
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* ----------------------------------------------------------------
    ** Length is ok - start translating message at field after msg_type
    ** ---------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(sysparm.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(sysparm.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKW_PG(sysparm.sid, MTYPE, sid);
    UNPACKW_PG(sysparm.nid, MTYPE, nid);
    UNPACKW_PG(sysparm.reg_zone, MTYPE, reg_zone);
    UNPACKB_PG(sysparm.total_zones, MTYPE, total_zones);
    UNPACKB_PG(sysparm.zone_timer, MTYPE, zone_timer);
    UNPACKB_PG(sysparm.mult_sids, MTYPE, mult_sids);
    UNPACKB_PG(sysparm.mult_nids, MTYPE, mult_nids);
    UNPACKW_PG(sysparm.base_id, MTYPE, base_id);
    UNPACKB_PG(sysparm.base_class, MTYPE, base_class);
    UNPACKB_PG(sysparm.page_chan, MTYPE, page_chan);
    UNPACKB_PG(sysparm.max_slot_cycle_index, MTYPE, max_slot_cycle_index);
    UNPACKB_PG(sysparm.home_reg, MTYPE, home_reg);
    UNPACKB_PG(sysparm.for_sid_reg, MTYPE, for_sid_reg);
    UNPACKB_PG(sysparm.for_nid_reg, MTYPE, for_nid_reg);
    UNPACKB_PG(sysparm.power_up_reg, MTYPE, power_up_reg);
    UNPACKB_PG(sysparm.power_down_reg, MTYPE, power_down_reg);
    UNPACKB_PG(sysparm.parameter_reg, MTYPE, parameter_reg);
    UNPACKB_PG(sysparm.reg_prd, MTYPE, reg_prd);
    UNPACKD_PG(sysparm.base_lat, MTYPE, base_lat);
    UNPACKD_PG(sysparm.base_long, MTYPE, base_long);
    UNPACKW_PG(sysparm.reg_dist, MTYPE, reg_dist);
    UNPACKB_PG(sysparm.srch_win_a, MTYPE, srch_win_a);
    UNPACKB_PG(sysparm.srch_win_n, MTYPE, srch_win_n);
    UNPACKB_PG(sysparm.srch_win_r, MTYPE, srch_win_r);
    UNPACKB_PG(sysparm.nghbr_max_age, MTYPE, nghbr_max_age);
    UNPACKB_PG(sysparm.pwr_rep_thresh, MTYPE, pwr_rep_thresh);
    UNPACKB_PG(sysparm.pwr_rep_frames, MTYPE, pwr_rep_frames);
    UNPACKB_PG(sysparm.pwr_thresh_enable, MTYPE, pwr_thresh_enable);
    UNPACKB_PG(sysparm.pwr_period_enable, MTYPE, pwr_period_enable);
    UNPACKB_PG(sysparm.pwr_rep_delay, MTYPE, pwr_rep_delay);
    UNPACKB_PG(sysparm.rescan, MTYPE, rescan);
    UNPACKB_PG(sysparm.t_add, MTYPE, t_add);
    UNPACKB_PG(sysparm.t_drop, MTYPE, t_drop);
    UNPACKB_PG(sysparm.t_comp, MTYPE, t_comp);
    UNPACKB_PG(sysparm.t_tdrop, MTYPE, t_tdrop);
    UNPACKB_PG(sysparm.ext_sys_parameter, MTYPE, ext_sys_parameter);
    UNPACKB_PG(sysparm.ext_nghbr_list, MTYPE, ext_nghbr_list);
    UNPACKB_PG(sysparm.gen_nghbr_list, MTYPE, gen_nghbr_list);

#ifdef FEATURE_DYNAMIC_P_REV
    if (cdma.mob_cai_rev < P_REV_IS95B)
    {
      int_ptr->sysparm.gen_nghbr_list = FALSE;
    }
#endif /* FEATURE_DYNAMIC_P_REV */

    UNPACKB_PG(sysparm.global_redirect, MTYPE, global_redirect);

#ifdef FEATURE_DYNAMIC_P_REV
    if (cdma.mob_cai_rev >= P_REV_IS2000)
#endif /* FEATURE_DYNAMIC_P_REV */
    {
      /* Length check on mandatory fields + minimum reserved bits */
      min_len = FENDPOS( MTYPE, ext_chan_list ) - FENDPOS( MTYPE, gen_nghbr_list );
      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
      }
 
      if ( ( len - ext_msg_pos ) >= min_len ) 
      {
        int_ptr->sysparm.is2000_incl = TRUE;
        UNPACKB_PG(sysparm.pri_nghbr_list, MTYPE, pri_nghbr_list);
        UNPACKB_PG(sysparm.user_zone_id, MTYPE, user_zone_id);
        UNPACKB_PG(sysparm.ext_global_redirect, MTYPE, ext_global_redirect);
        UNPACKB_PG(sysparm.ext_chan_list, MTYPE, ext_chan_list);

#ifdef FEATURE_IS2000_REL_C
#ifdef FEATURE_DYNAMIC_P_REV
        if (cdma.mob_cai_rev >= P_REV_IS2000_REL_C)
#endif /* FEATURE_DYNAMIC_P_REV */
        {
          /* Length check on mandatory fields + minimum reserved bits */
          min_len = FSIZ( MTYPE, t_tdrop_range_incl );
          min_len += 8 - ( FENDPOS( MTYPE, t_tdrop_range_incl ) + CAI_PC_CRC_SIZE ) % 8;
          
          if ( (len - ext_msg_pos ) >= min_len )
          {
            int_ptr->sysparm.is2000_rel_c_incl = TRUE;
            UNPACKB_PG(sysparm.t_tdrop_range_incl, MTYPE, t_tdrop_range_incl);
            if (int_ptr->sysparm.t_tdrop_range_incl)
            {
              UNPACKB_PG(sysparm.t_tdrop_range, MTYPE, t_tdrop_range);
            }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
     
          }
        }
#endif /* FEATURE_IS2000_REL_C */

      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_sys_parm */

/*===========================================================================

FUNCTION XLATE_EXT_ACC_PARM

DESCRIPTION
  This function translates a Paging Channel Access Parameters Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Access Parameter message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_acc_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */

  #ifdef FEATURE_IS2000_REL_A
  word min_len;
    /* Protocol dependent minimum length requirement */
  byte  i;        /* Loop counter */
#endif /* FEATURE_IS2000_REL_A */


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_accparm_msg_type

  /* ---------------------------------------
  ** Check length to make sure it is correct
  ** --------------------------------------- */
  if ( len < CAI_ACCPARM_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ----------------------------------------------------------------
    ** Length is ok - start translating message at field after msg_type
    ** ---------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(accparm.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(accparm.acc_msg_seq, MTYPE, acc_msg_seq);
    UNPACKB_PG(accparm.acc_chan, MTYPE, acc_chan);
    UNPACKB_PG(accparm.nom_pwr, MTYPE, nom_pwr);
    UNPACKB_PG(accparm.init_pwr, MTYPE, init_pwr);
    UNPACKB_PG(accparm.pwr_step, MTYPE, pwr_step);
    UNPACKB_PG(accparm.num_step, MTYPE, num_step);
    UNPACKB_PG(accparm.max_cap_sz, MTYPE, max_cap_sz);
    UNPACKB_PG(accparm.pam_sz, MTYPE, pam_sz);
    UNPACKB_PG(accparm.psist_0_9, MTYPE, psist_0_9);
    UNPACKB_PG(accparm.psist_10, MTYPE, psist_10);
    UNPACKB_PG(accparm.psist_11, MTYPE, psist_11);
    UNPACKB_PG(accparm.psist_12, MTYPE, psist_12);
    UNPACKB_PG(accparm.psist_13, MTYPE, psist_13);
    UNPACKB_PG(accparm.psist_14, MTYPE, psist_14);
    UNPACKB_PG(accparm.psist_15, MTYPE, psist_15);
    UNPACKB_PG(accparm.msg_psist, MTYPE, msg_psist);
    UNPACKB_PG(accparm.reg_psist, MTYPE, reg_psist);
    UNPACKB_PG(accparm.probe_pn_ran, MTYPE, probe_pn_ran);
    UNPACKB_PG(accparm.acc_tmo, MTYPE, acc_tmo);
    UNPACKB_PG(accparm.probe_bkoff, MTYPE, probe_bkoff);
    UNPACKB_PG(accparm.bkoff, MTYPE, bkoff);
    UNPACKB_PG(accparm.max_req_seq, MTYPE, max_req_seq);
    UNPACKB_PG(accparm.max_rsp_seq, MTYPE, max_rsp_seq);
    UNPACKB_PG(accparm.auth, MTYPE, auth);

    /* New IS-95A requirement */
    if ((int_ptr->accparm.auth != 0) && (int_ptr->accparm.auth != 1))
    {
      int_ptr->accparm.auth = TRUE;
    }

    if (int_ptr->accparm.auth)
    {
      UNPACKD_PG(accparm.rand, MTYPE, rand);
    }

    UNPACKB_PG(accparm.nom_pwr_ext, MTYPE, nom_pwr_ext);

#ifdef FEATURE_IS2000_REL_A
#ifdef FEATURE_DYNAMIC_P_REV
    if (cdma.mob_cai_rev >= P_REV_IS2000_REL_A)
#endif /* FEATURE_DYNAMIC_P_REV */
    {
      /* Length check on mandatory fields + minimum reserved bits */
      min_len = FSIZ( MTYPE, psist_emg_incl ) + FSIZ( MTYPE, acct_incl );
      min_len +=  8 - ( ext_msg_pos + min_len +  CAI_PC_CRC_SIZE ) % 8; 
      if ( ( len - ext_msg_pos ) >=  min_len )
      {
        UNPACKB_PG(accparm.psist_emg_incl, MTYPE, psist_emg_incl);

        if (int_ptr->accparm.psist_emg_incl)
        {
          UNPACKB_PG(accparm.psist_emg, MTYPE, psist_emg);
        }

        /* Support for ACCT fields */
        UNPACKB_PG(accparm.acct_incl, MTYPE, acct_incl);

        if (int_ptr->accparm.acct_incl)
        {
          UNPACKB_PG(accparm.acct_incl_emg, MTYPE, acct_incl_emg);
          UNPACKB_PG(accparm.acct_aoc_bitmap_incl, MTYPE, acct_aoc_bitmap_incl);
          UNPACKB_PG(accparm.acct_so_incl, MTYPE, acct_so_incl);

          if (int_ptr->accparm.acct_so_incl)
          {
            UNPACKB_PG(accparm.num_acct_so, MTYPE, num_acct_so);

            for (i=0; i<(int_ptr->accparm.num_acct_so+1); i++)
            {
              if (int_ptr->accparm.acct_aoc_bitmap_incl)
              {
                UNPACKB_PG(accparm.acct_so_info[i].acct_aoc_bitmap1, MTYPE, acct_aoc_bitmap1);
              }
              UNPACKW_PG(accparm.acct_so_info[i].acct_so, MTYPE, acct_so);
            }
          }

          UNPACKB_PG(accparm.acct_so_grp_incl, MTYPE, acct_so_grp_incl);

          if (int_ptr->accparm.acct_so_grp_incl)
          {
            UNPACKB_PG(accparm.num_acct_so_grp, MTYPE, num_acct_so_grp);
            for (i=0; i<(int_ptr->accparm.num_acct_so_grp+1); i++)
            {
              if (int_ptr->accparm.acct_aoc_bitmap_incl)
              {
                UNPACKB_PG(accparm.acct_so_grp_info[i].acct_aoc_bitmap2, MTYPE, acct_aoc_bitmap2);
              }
              UNPACKB_PG(accparm.acct_so_grp_info[i].acct_so_grp, MTYPE, acct_so_grp);
            }
          }
        }
      }
    }
    #endif /* FEATURE_IS2000_REL_A */
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_acc_parm */

/*===========================================================================

FUNCTION XLATE_EXT_EXT_NL

DESCRIPTION
  This function translates a Paging Channel Extended Neighbor List Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Neighbor List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ext_nl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_ext_nghbr_msg_type

  if ( len < CAI_EXT_NGHBR_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------------
    ** Length is ok - convert message from external to internal format
    ** starting with the first field after message_type
    ** --------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(ext_nghbr.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(ext_nghbr.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(ext_nghbr.pilot_inc, MTYPE, pilot_inc);

    /* Initialize number of neighbors */
    int_ptr->ext_nghbr.num_nghbrs = 0;

    for (i=0; ( ( ext_msg_pos + FENDPOS( MTYPE, freq_incl ) - 
                  FENDPOS( MTYPE, pilot_inc ) ) <= len ); i++)
    {
      UNPACKB_PG(ext_nghbr.nghbr[i].nghbr_config, MTYPE, nghbr_config);
      UNPACKW_PG(ext_nghbr.nghbr[i].nghbr_pn, MTYPE, nghbr_pn);
      UNPACKB_PG(ext_nghbr.nghbr[i].search_pri, MTYPE, search_pri);
      UNPACKB_PG(ext_nghbr.nghbr[i].freq_incl, MTYPE, freq_incl);

      /* Check if neighbor freq and band are included */
      /* for this set.                                */
      if (int_ptr->ext_nghbr.nghbr[i].freq_incl)
      {
        UNPACKB_PG(ext_nghbr.nghbr[i].nghbr_band, MTYPE, nghbr_band);
        UNPACKW_PG(ext_nghbr.nghbr[i].nghbr_freq, MTYPE, nghbr_freq);
      }

      /* ----------------------------------------------------
      ** If NGHBR_CONFIGr is equal to '000', '001', or '010',
      ** then NGHBR_CONFIGs = NGHBR_CONFIGr, otherwise,
      ** NGHBR_CONFIGs = '011'.
      ** ---------------------------------------------------- */
      if (int_ptr->ext_nghbr.nghbr[i].nghbr_config > 3)
      {
        int_ptr->ext_nghbr.nghbr[i].nghbr_config = 3;
      }

      /* Set number of neighbors */
      int_ptr->ext_nghbr.num_nghbrs++;
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_ext_nl */

/*===========================================================================

FUNCTION XLATE_EXT_NL

DESCRIPTION
  This function translates a Paging Channel Neighbor List Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Neigbor List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_nl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through neighbors */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_nghbr_msg_type

  if ( len < CAI_NGHBR_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------------
    ** Length is ok - convert message from external to internal format
    ** starting with the first field after message_type
    ** --------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(nghbr.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(nghbr.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(nghbr.pilot_inc, MTYPE, pilot_inc);

    /* -------------------------------------
    ** Translate variable portion of message
    ** ------------------------------------- */
    int_ptr->nghbr.num_nghbrs = ( len - FENDPOS(MTYPE, pilot_inc) ) / 
                                ( sizeof( MTYPE ) - FENDPOS( MTYPE, pilot_inc ) );

    for (i=0; i < int_ptr->nghbr.num_nghbrs; i++)
    {
      UNPACKB_PG(nghbr.nghbr[i].nghbr_config, MTYPE, nghbr_config);
      UNPACKW_PG(nghbr.nghbr[i].nghbr_pn, MTYPE, nghbr_pn);

      /* ----------------------------------------------------
      ** If NGHBR_CONFIGr is equal to '000', '001', or '010',
      ** then NGHBR_CONFIGs = NGHBR_CONFIGr, otherwise,
      ** NGHBR_CONFIGs = '011'.
      ** ---------------------------------------------------- */
      if (int_ptr->nghbr.nghbr[i].nghbr_config > 3) {
        int_ptr->nghbr.nghbr[i].nghbr_config = 3;
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_nl */

/*===========================================================================

FUNCTION XLATE_EXT_CL

DESCRIPTION
  This function translates a CDMA Channel List Message from external
  to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the CDMA Channel List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_cl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = 0;
    /* Position in message relative to start of buf_ptr */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through channels */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_chnlist_msg_type

  if ( len < CAI_CHNLIST_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(chnlist.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(chnlist.config_msg_seq, MTYPE, config_msg_seq);

    int_ptr->chnlist.num_freq = 
      ( len - FENDPOS( MTYPE, config_msg_seq ) ) /
      ( sizeof(MTYPE) - FENDPOS( MTYPE, config_msg_seq ) );

    for (i=0; i < int_ptr->chnlist.num_freq; i++)
    {
      UNPACKW_PG(chnlist.cdma_freq[i], MTYPE, cdma_freq);
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_cl */

/*===========================================================================

FUNCTION XLATE_EXT_SLT_PAGE

DESCRIPTION
  This function translates a Paging Channel Slotted Page Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Slotted Page message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_slt_page
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of page within page message */
  word num_pages;
    /* Number of pages in page array */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_slt_page_fix_type

  /* ------------------------------------------------------
  ** First determine if the message is of sufficient length
  ** ------------------------------------------------------ */
  if (len < sizeof( cai_slt_page_fix_type )) {
    status = CAIX_INV_LEN_S;
  }

  else {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    int_ptr->slt_page.config_msg_seq = b_unpackb( PARAMS( config_msg_seq ));
    int_ptr->slt_page.acc_msg_seq    = b_unpackb( PARAMS( acc_msg_seq ));
    int_ptr->slt_page.more_pages     = b_unpackb( PARAMS( more_pages ));

    num_pages = 0;
    ext_msg_pos = sizeof( cai_slt_page_fix_type );

    while (len >= (CAI_SLT_PAGE_MIN + ext_msg_pos)) {
      int_ptr->slt_page.pages[num_pages].msg_seq =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_slt_page_var_type, msg_seq ));
      ext_msg_pos += FSIZ( cai_slt_page_var_type, msg_seq );

      int_ptr->slt_page.pages[num_pages].ext_addr =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_slt_page_var_type, ext_addr ));
      ext_msg_pos += FSIZ( cai_slt_page_var_type, ext_addr );

      int_ptr->slt_page.pages[num_pages].min1 =
        b_unpackd( buf_ptr, ext_msg_pos,
                   FSIZ( cai_slt_page_var_type, min1 ));
      ext_msg_pos += FSIZ( cai_slt_page_var_type, min1 );

      if (int_ptr->slt_page.pages[num_pages].ext_addr) {
        int_ptr->slt_page.pages[num_pages].min2 =
          b_unpackw( buf_ptr, ext_msg_pos,
                     FSIZ( cai_slt_page_var_type, min2 ));
        ext_msg_pos += FSIZ( cai_slt_page_var_type, min2 );
      }

      int_ptr->slt_page.pages[num_pages].special_service =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_slt_page_var_type, special_service ));
      ext_msg_pos += FSIZ( cai_slt_page_var_type, special_service );

      if (int_ptr->slt_page.pages[num_pages].special_service) {
        int_ptr->slt_page.pages[num_pages].service_option =
          b_unpackw( buf_ptr, ext_msg_pos,
                     FSIZ( cai_slt_page_var_type, service_option ));
        ext_msg_pos += FSIZ( cai_slt_page_var_type, service_option );
      }

      num_pages++;
    } /* end of while */

    int_ptr->slt_page.num_pages = num_pages;

    status = CAIX_DONE_S;
  }

  #undef MTYPE
  return (status);

} /* xlate_ext_slt_page */

/* <EJECT> */
/*===========================================================================

FUNCTION XLATE_EXT_PAGE

DESCRIPTION
  This function translates a Paging Channel Page Message from external
  to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Page Message message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_page
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of page within page message */
  word num_pages;
    /* Number of pages in page array */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_page_fix_type

  /* ------------------------------------------------------
  ** First determine if the message is of sufficient length
  ** ------------------------------------------------------ */
  if (len < sizeof( cai_page_fix_type )) {
    status = CAIX_INV_LEN_S;
  }

  else {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    int_ptr->page.config_msg_seq = b_unpackb( PARAMS( config_msg_seq ));
    int_ptr->page.acc_msg_seq    = b_unpackb( PARAMS( acc_msg_seq ));

    num_pages  = 0;
    ext_msg_pos   = sizeof (cai_page_fix_type );

    while (len >= (ext_msg_pos + CAI_PAGE_MIN)) {
      int_ptr->page.pages[num_pages].msg_seq =
        b_unpackb( buf_ptr, ext_msg_pos, FSIZ( cai_page_var_type, msg_seq ));
      ext_msg_pos += FSIZ( cai_page_var_type, msg_seq );

      int_ptr->page.pages[num_pages].ext_addr =
        b_unpackb( buf_ptr, ext_msg_pos, FSIZ( cai_page_var_type, ext_addr ));
      ext_msg_pos += FSIZ( cai_page_var_type, ext_addr );

      int_ptr->page.pages[num_pages].min1 =
        b_unpackd( buf_ptr, ext_msg_pos, FSIZ( cai_page_var_type, min1 ));
      ext_msg_pos += FSIZ( cai_page_var_type, min1 );

      if (int_ptr->page.pages[num_pages].ext_addr) {
        int_ptr->page.pages[num_pages].min2 =
          b_unpackw( buf_ptr, ext_msg_pos, FSIZ( cai_page_var_type, min2 ));
        ext_msg_pos += FSIZ( cai_page_var_type, min2 );
      }

      int_ptr->page.pages[num_pages].special_service =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_page_var_type, special_service ));
      ext_msg_pos += FSIZ( cai_page_var_type, special_service );

      if (int_ptr->page.pages[num_pages].special_service) {
        int_ptr->page.pages[num_pages].service_option =
          b_unpackw( buf_ptr, ext_msg_pos,
                     FSIZ( cai_page_var_type, service_option ));
        ext_msg_pos += FSIZ( cai_page_var_type, service_option );
      }

      num_pages ++;
    } /* end of while */

    int_ptr->page.num_pages = num_pages;

    status = CAIX_DONE_S;
  }

  #undef MTYPE
  return (status);

} /* xlate_ext_page */

/*===========================================================================

FUNCTION XLATE_EXT_PC_HDR

DESCRIPTION

DEPENDENCIES
  None

RETURN VALUE
  status

SIDE EFFECTS
  None

===========================================================================*/

void xlate_ext_pc_hdr
(
  word *buf_pos,
    /* Position of header fields relative to start of buf_ptr */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_pc_hdr_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  byte i;
    /* Loop counter */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  int_ptr->ack_seq =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, ack_seq ));
  *buf_pos += FSIZ( cai_pc_hdr_type, ack_seq );

  int_ptr->msg_seq =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, msg_seq ));
  *buf_pos += FSIZ( cai_pc_hdr_type, msg_seq );

  int_ptr->ack_req =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, ack_req ));
  *buf_pos += FSIZ( cai_pc_hdr_type, ack_req );

  int_ptr->valid_ack =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, valid_ack ));
  *buf_pos += FSIZ( cai_pc_hdr_type, valid_ack );

  int_ptr->addr_type =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, addr_type ));
  *buf_pos += FSIZ( cai_pc_hdr_type, addr_type );

  int_ptr->addr_len =
    b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_pc_hdr_type, addr_len ));
  *buf_pos += FSIZ( cai_pc_hdr_type, addr_len );

  if (int_ptr->addr_type == CAI_MIN_ADDR_TYPE)   /* 0 */
  {
    int_ptr->addr.type0.min1 =
      b_unpackd( buf_ptr, *buf_pos, FSIZ( cai_addr0_type, min1 ));
    *buf_pos += FSIZ( cai_addr0_type, min1 );

    int_ptr->addr.type0.min2 =
      b_unpackw( buf_ptr, *buf_pos, FSIZ( cai_addr0_type, min2 ));
    *buf_pos += FSIZ( cai_addr0_type, min2 );

    *buf_pos += FSIZ( cai_addr0_type, reserved );
  }
  else if (int_ptr->addr_type == CAI_ESN_ADDR_TYPE)   /* 1 */
  {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
    b_unpackq( buf_ptr, *buf_pos,
               (int_ptr->addr_len * FSIZ( cai_addr1_type, esn )),
               int_ptr->addr.type1.esn );
    *buf_pos += (int_ptr->addr_len * FSIZ( cai_addr1_type, esn ));
  }
  else if (int_ptr->addr_type == CAI_IMSI_ADDR_TYPE)    /* 2 */
  {
    int_ptr->addr.type2.imsi.imsi_class =
      b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_addr2_type, imsi_class ));
    *buf_pos += FSIZ( cai_addr2_type, imsi_class );

    if (int_ptr->addr.type2.imsi.imsi_class == 0)
    {
      int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type =
        b_unpackb( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
      *buf_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

      if (int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type == 0)
      {
        *buf_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type0_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.zero.type.zero.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
      }
      else if (int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type == 1)
      {
        *buf_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

        int_ptr->addr.type2.imsi.class_type.zero.type.one.imsi_11_12 =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
        *buf_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type1_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.zero.type.one.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
      }
      else if (int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type == 2)
      {
        *buf_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

        int_ptr->addr.type2.imsi.class_type.zero.type.two.mcc =
          b_unpackw( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class0_type2_type, mcc ));
        *buf_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type2_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.zero.type.two.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
      }
      else /* (int_ptr->addr.type2.imsi.class_type.zero.imsi_class_0_type == 3) */
      {
        *buf_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

        int_ptr->addr.type2.imsi.class_type.zero.type.three.mcc =
          b_unpackw( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class0_type3_type, mcc ));
        *buf_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

        int_ptr->addr.type2.imsi.class_type.zero.type.three.imsi_11_12 =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
        *buf_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class0_type3_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.zero.type.three.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
      }
    }
    else /* (int_ptr->addr.type2.imsi.imsi_class == 1) */
    {
      int_ptr->addr.type2.imsi.class_type.one.imsi_class_1_type =
        b_unpackb( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
      *buf_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

      if (int_ptr->addr.type2.imsi.class_type.one.imsi_class_1_type == 0)
      {
        *buf_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

        int_ptr->addr.type2.imsi.class_type.one.type.zero.imsi_addr_num =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
        *buf_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

        int_ptr->addr.type2.imsi.class_type.one.type.zero.imsi_11_12 =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
        *buf_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class1_type0_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.one.type.zero.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
      }
      else /* (int_ptr->addr.type2.imsi.class_type.one.imsi_class_1_type == 1) */
      {
        int_ptr->addr.type2.imsi.class_type.one.type.one.imsi_addr_num =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
        *buf_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

        int_ptr->addr.type2.imsi.class_type.one.type.one.mcc =
          b_unpackw( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type1_type, mcc ));
        *buf_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

        int_ptr->addr.type2.imsi.class_type.one.type.one.imsi_11_12 =
          b_unpackb( buf_ptr, *buf_pos,
                     FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
        *buf_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

        b_unpackq( buf_ptr, *buf_pos,
                   FSIZ( cai_imsi_class1_type1_type, imsi_s ),
                   int_ptr->addr.type2.imsi.class_type.one.type.one.imsi_s );
        *buf_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
      }
    }
  }
  /* Process TMSI address for header */
  else if (int_ptr->addr_type == CAI_TMSI_ADDR_TYPE)     /* 3 */
  {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
    /* Initialize destination TMSI info to zero */
    /* before unpacking.                        */
    int_ptr->addr.type3.tmsi_code = 0;
    qw_set( int_ptr->addr.type3.tmsi_zone, 0L, 0L );

    /* Determine if address length is longer  */
    /* than the maximum sized TMSI code.  If  */
    /* so, then TMSI zone is present.  Unpack */
    /* TMSI zone.                             */
    if ( int_ptr->addr_len > MAX_TMSI_CODE_LEN )
    {
      b_unpackq( buf_ptr, *buf_pos,
                 (( int_ptr->addr_len - MAX_TMSI_CODE_LEN ) << 3 ), /*lint !e701*/
                 int_ptr->addr.type3.tmsi_zone );
      *buf_pos += ( int_ptr->addr_len - MAX_TMSI_CODE_LEN ) << 3; /*lint !e701*/

      int_ptr->addr.type3.tmsi_code =
        b_unpackd( buf_ptr, *buf_pos, FSIZ( cai_tmsi_type, tmsi_code ));
      *buf_pos += FSIZ( cai_tmsi_type, tmsi_code );
    }
    /* Only TMSI code was sent so use address length */
    /* to unpack variable sized TMSI code.           */
    else
    {
      int_ptr->addr.type3.tmsi_code =
        b_unpackd( buf_ptr, *buf_pos, ( int_ptr->addr_len << 3 ));
      *buf_pos += int_ptr->addr_len << 3;
    }
  }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif // FEATURE_IS2000_REL_D
  else if (int_ptr->addr_type == CAI_BCAST_ADDR_TYPE)    /* 5 */
  {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
    for (i=0; i < int_ptr->addr_len; i++)
    {
      int_ptr->addr.type5.bc_addr[i] =
        b_unpackb( buf_ptr, *buf_pos, FSIZ( cai_addr5_type, bc_addr ));
      *buf_pos += FSIZ( cai_addr5_type, bc_addr );
    }
  }
  else
  {
    /* -----------------------------------------------------------------
    ** Unknown ADDR_TYPE -> advance buffer pointer past ADDR_TYPE fields
    ** since we are unable to correctly parse them
    ** ----------------------------------------------------------------- */
    *buf_pos += (8 * int_ptr->addr_len);
  }

} /* end xlate_ext_pc_hdr() */


#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_EXT_ENC

DESCRIPTION
  This function translates the extended encryption fields and process them.

DEPENDENCIES
  The decryption function is defined in AUTH module.

RETURN VALUE
  CAIX_DONE_S - if everything is good.
  CAIX_INV_MSG_S - if anything wrong.


SIDE EFFECTS
  buf_pos updated. Extended encryption fields are put into the internal format
  just to preserve them. The message may be translated from crypto text into
  plain text.

===========================================================================*/

word xlate_ext_ext_enc
(
  word *len_ptr,
    /* Pointer to Length of message */
  word chn,
    /* Physical Channel this message is received on */
  byte pd,
    /* Protocol discriminator */
  word *buf_pos_ptr,
    /* Position of header fields relative to start of buf_ptr */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_pc_hdr_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  uint8 msg_type,  /* the message type */
  uint8 order,     /* the order type in case of an order message */
  uint8 ordq       /* the order qualification in case of an order message */
)
{
  word status = CAIX_DONE_S;

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  /* -----------------------------------------------------------------------
  ** If the received channel is FCCCH, then there is Extended Encryption
  ** fields. If received channel is PCH, and if PD is 1, there is Extended
  ** Encryption fields. Otherwise, no extended encryption fields.
  ** ----------------------------------------------------------------------- */
  if ((chn == CAIX_BCCH) || (chn == CAIX_FCCCH) || 
      ((chn == CAIX_PC) && (pd != 0)))
  {
    /* ----------------------------------------------------------------------
    ** Parse the Extended Encryption fields. Notice that Extended Encryption
    ** fields are not useful after this step. But we put it into the internal
    ** format anyway.
    ** ---------------------------------------------------------------------- */
    int_ptr->enc.enc_fields_incl =
      b_unpackb( buf_ptr, *buf_pos_ptr, FSIZ( cai_ext_enc_type, enc_fields_incl ));
    *buf_pos_ptr += FSIZ( cai_ext_enc_type, enc_fields_incl );

    if (int_ptr->enc.enc_fields_incl)
    {
      int_ptr->enc.sdu_encrypt_mode =
        b_unpackb( buf_ptr, *buf_pos_ptr, FSIZ( cai_ext_enc_type, sdu_encrypt_mode ));
      *buf_pos_ptr += FSIZ( cai_ext_enc_type, sdu_encrypt_mode );

      if (((int_ptr->enc.sdu_encrypt_mode == CAI_ENC_MODE_ECMEA)
           || (int_ptr->enc.sdu_encrypt_mode == CAI_ENC_MODE_REA))
#ifdef FEATURE_IS2000_REL_C
          && !int_ptr->msg_int.maci_incl
#endif /* FEATURE_IS2000_REL_C */
         )
      {
        int_ptr->enc.enc_seq =
          b_unpackb( buf_ptr, *buf_pos_ptr, FSIZ( cai_ext_enc_type, enc_seq ));
        *buf_pos_ptr += FSIZ( cai_ext_enc_type, enc_seq );
      }

#ifndef FEATURE_MSG_PACK_UNIT_TEST
      #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
      #endif /* FEATURE_IS2000_REL_A_AES */
#endif /* ! FEATURE_MSG_PACK_UNIT_TEST */
    } /* enc_fields_incl */
#ifndef FEATURE_MSG_PACK_UNIT_TEST
    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #else
    if ( int_ptr->enc.sdu_encrypt_mode != CAI_ENC_MODE_DISABLED )
    {
      return CAIX_INV_ENC_MODE_NOT_SUP_S;
    }
    #endif /* FEATURE_IS2000_REL_A_AES */
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */
  } /* pd != 0 */
  return status;
} /* xlate_ext_ext_enc */
#endif /* FEATURE_IS2000_REL_A*/

#ifdef FEATURE_IS2000_REL_D 
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*===========================================================================

FUNCTION XLATE_EXT_PC_ORD

DESCRIPTION
  This function translates a Paging Channel Order Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Order message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_ord
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word order_pos;
    /* Position of order relative to start of buf_ptr */
  byte add_record_len;
    /* Temporary storage for the add_record_len field */
  word num_recs;
    /* Number of orders contained in received Paging Channel Order Msg */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
  word rec_min_len;
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
         
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  order_pos = FSIZ(cai_pc_hdr_type, msg_type);

  /* ---------------------------------
  ** Initialize number of records to 0
  ** --------------------------------- */
  num_recs = 0;
  
  rec_min_len = CAI_PC_ORDER_MIN;

  while ((len > order_pos) && ((len - order_pos) >= rec_min_len))
  {
    xlate_ext_pc_hdr(&order_pos, buf_ptr,
      &int_ptr->pc_ord.ords[num_recs].gen.hdr);

#ifdef FEATURE_IS2000_REL_C
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Message Integrity fields and
    ** MACI field if there is one.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
         CAIX_MACI_REQUIRED, &order_pos,
         buf_ptr, &int_ptr->pc_ord.ords[num_recs].gen.hdr.msg_int,
         int_ptr->pc_ord.msg_type,
         int_ptr->pc_ord.ords[num_recs].gen.hdr.ack_req
         )) != CAIX_DONE_S)
    {
      return status;
    }

    if ((num_recs == 0) && 
        int_ptr->pc_ord.ords[num_recs].gen.hdr.msg_int.maci_incl)
    {
      rec_min_len += FSIZ(cai_msg_int_type,maci);
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Extended Encryption fields if
    ** there is one, and run the decryption algorithm.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_ext_enc(&len, chn, pd, &order_pos, buf_ptr,
                                    &int_ptr->pc_ord.ords[num_recs].gen.hdr, 
                                    int_ptr->pc_ord.msg_type,
                                    int_ptr->pc_ord.ords[num_recs].gen.order,
                                    int_ptr->pc_ord.ords[num_recs].ordq.ordq
                                   )
        ) != CAIX_DONE_S
       )
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */

    int_ptr->pc_ord.ords[num_recs].gen.order =
      b_unpackb(buf_ptr, order_pos, FSIZ(cai_pc_gen_ord_type, order));
    order_pos += FSIZ( cai_pc_gen_ord_type, order );

    add_record_len = b_unpackb(buf_ptr, order_pos,
      FSIZ(cai_pc_gen_ord_type, add_record_len));
    order_pos += FSIZ(cai_pc_gen_ord_type, add_record_len);

    if ((order_pos + (add_record_len * 8)) > len)
    {
      /* ---------------------------------------------------
      ** ADD_RECORD_LEN field indicates that message exceeds
      ** received length -- stop parsing message
      ** --------------------------------------------------- */
      break;
    }

    /* ------------------------------
    ** Fill in order dependent fields
    ** ------------------------------ */
    switch (int_ptr->pc_ord.ords[num_recs].gen.order)
    {
      case CAI_ABBR_ALERT_ORD:
      case CAI_REORDER_ORD:
      case CAI_AUDIT_ORD:
      case CAI_INTERCEPT_ORD:
      case CAI_BS_ACK_ORD:
      case CAI_SLOTTED_MODE_ORD:
#ifdef FEATURE_IS2000_REL_C
      case CAI_TRANSIT_TO_IDLE_ORD:
#endif /* FEATURE_IS2000_REL_C */
        /* --------------------------------------------
        ** No order qualifier implicitly means ordq = 0
        ** (see PN-3118 Section 7.7.4)
        ** -------------------------------------------- */
        int_ptr->pc_ord.ords[num_recs].ordq.ordq = 0;

        /* -----------------------------------------
        ** Account for possible additional fields in
        ** future revs of the spec
        ** ----------------------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;
        break;

      case CAI_BS_CHAL_CONF_ORD:
        /* -----------------------------------------
        ** Base Station Challenge Confirmation Order
        ** ----------------------------------------- */
        if (add_record_len >= 4)
        {
          int_ptr->pc_ord.ords[num_recs].chal.ordq = b_unpackb(buf_ptr,
            order_pos, FSIZ(cai_pc_bs_chal_type, ordq));
          order_pos += FSIZ(cai_pc_bs_chal_type, ordq);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

          int_ptr->pc_ord.ords[num_recs].chal.authbs = b_unpackd(buf_ptr,
            order_pos, FSIZ(cai_pc_bs_chal_type, authbs));
          order_pos += FSIZ(cai_pc_bs_chal_type, authbs) +
            FSIZ(cai_pc_bs_chal_type, reserved);

          if (add_record_len > 4)
          {
            /* -----------------------------------------
            ** Account for possible additional fields in
            ** future revs of the spec
            ** ----------------------------------------- */
            order_pos += ((add_record_len - 4) * 8);
          }
          num_recs++;
        }
        else
        {
          /* ----------------------------------------------------
          ** Invalid order length - something is very wrong here.
          ** Pretend like we didn't see it and let BS retransmit.
          ** ---------------------------------------------------- */
          order_pos += (add_record_len * 8);
        }
        break;

      case CAI_RETRY_ORD:
        int_ptr->pc_ord.ords[num_recs].retry.ordq = b_unpackb(buf_ptr,
          order_pos, FSIZ(cai_pc_retry_type, ordq));
        order_pos += FSIZ(cai_pc_retry_type, ordq);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

        int_ptr->pc_ord.ords[num_recs].retry.retry_type = b_unpackb(buf_ptr,
          order_pos, FSIZ(cai_pc_retry_type, retry_type));
        order_pos += FSIZ(cai_pc_retry_type, retry_type);
        if (int_ptr->pc_ord.ords[num_recs].retry.retry_type)
        {
          int_ptr->pc_ord.ords[num_recs].retry.retry_delay =
            b_unpackb(buf_ptr, order_pos, FSIZ(cai_pc_retry_type, retry_delay));
          order_pos += FSIZ(cai_pc_retry_type, retry_delay);
        }
        order_pos += FSIZ(cai_pc_retry_type, reserved);
        num_recs++;
        break;

      case CAI_LOCK_OR_MAINT_ORD:
        /* -------------------------------------------
        ** Type which only requires an order qualifier
        ** ------------------------------------------- */
        if (add_record_len >= 1)
        {
          /* ---------------------
          ** Parse order qualifier
          ** --------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq = b_unpackb(buf_ptr,
            order_pos, FSIZ(cai_pc_ordq_type, ordq));

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

          /* -----------------------------------------
          ** Account for possible additional fields in
          ** future revs of the spec
          ** ----------------------------------------- */
          order_pos += (add_record_len * 8);
          num_recs++;
        }
        else
        {
          /* ----------------------------------------------------
          ** Invalid order length - something is very wrong here.
          ** Pretend like we didn't see it and let BS retransmit.
          ** ---------------------------------------------------- */
          order_pos += (add_record_len * 8);
        }
        break;

      case CAI_REG_ORD:
        if (add_record_len >= 1)
        {
          /* ---------------------
          ** Parse order qualifier
          ** --------------------- */

          msg_pos = order_pos;
  
          int_ptr->pc_ord.ords[num_recs].ordq.ordq =
            b_unpackb(buf_ptr, msg_pos, FSIZ( cai_pc_ordq_type, ordq));
          msg_pos += FSIZ(cai_pc_ordq_type, ordq);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

          /* --------------------------------------------
          ** Registration Accepted Order, ROAM_INDI included
          ** -------------------------------------------- */
          if (int_ptr->pc_ord.ords[num_recs].ordq.ordq == CAI_REG_ACC)
          {
            int_ptr->pc_ord.ords[num_recs].regacc.roam_indi =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, roam_indi));
            msg_pos += FSIZ(cai_pc_reg_acc_type, roam_indi);
          }
#ifdef FEATURE_IS2000_REL_A
          else if (int_ptr->pc_ord.ords[num_recs].ordq.ordq ==
                   CAI_REG_ACC_ROAM_ENC)
          {
            int_ptr->pc_ord.ords[num_recs].regacc.roam_indi =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, roam_indi));
            msg_pos += FSIZ(cai_pc_reg_acc_type, roam_indi);

            int_ptr->pc_ord.ords[num_recs].regacc.c_sig_encrypt_mode =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ( cai_pc_reg_acc_type, c_sig_encrypt_mode));
            msg_pos += FSIZ(cai_pc_reg_acc_type, c_sig_encrypt_mode);

            if ((int_ptr->pc_ord.ords[num_recs].regacc.c_sig_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
                (int_ptr->pc_ord.ords[num_recs].regacc.c_sig_encrypt_mode == CAI_ENC_MODE_REA))
            {
              int_ptr->pc_ord.ords[num_recs].regacc.key_size =
                b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, key_size));
              msg_pos += FSIZ(cai_pc_reg_acc_type, key_size);
            }

#ifdef FEATURE_IS2000_REL_C
            /* ----------------------------------------------------------------
            ** Parse Release C fields if the length indicates there are more
            ** fields.  We could be parsing reserved bits, but that will have the
            ** result of setting msg_int_info_incl to 0, which is okay.
            ** ---------------------------------------------------------------- */
            if ((order_pos + (add_record_len * 8)) > msg_pos)
            {
              int_ptr->pc_ord.ords[num_recs].regacc.msg_int_info_incl =
                b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, msg_int_info_incl));
              msg_pos += FSIZ(cai_pc_reg_acc_type, msg_int_info_incl);
        
              if (int_ptr->pc_ord.ords[num_recs].regacc.msg_int_info_incl)
              {
                int_ptr->pc_ord.ords[num_recs].regacc.change_keys =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, change_keys));
                msg_pos += FSIZ(cai_pc_reg_acc_type, change_keys);
    
                int_ptr->pc_ord.ords[num_recs].regacc.use_uak =
                  b_unpackb(buf_ptr, msg_pos, FSIZ(cai_pc_reg_acc_type, use_uak));
                msg_pos += FSIZ(cai_pc_reg_acc_type, use_uak);
              }
            }
#endif /* FEATURE_IS2000_REL_C */

          }
#endif /* FEATURE_IS2000_REL_A */

        }
        else /* (add_record_len == 0) */
        {
          /* --------------------------------------------
          ** No order qualifier implicitly means ordq = 0
          ** (see PN-3118 Section 7.7.4)
          ** -------------------------------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq = 0;
        }

        /* -----------------------------------------
        ** Account for possible additional fields in
        ** future revs of the spec
        ** ----------------------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;
        break;

      case CAI_RELEASE_ORD:
      case CAI_LOCAL_CTL_ORD:
        if (add_record_len >= 1)
        {
          /* ---------------------
          ** Parse order qualifier
          ** --------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq =
            b_unpackb(buf_ptr, order_pos, FSIZ(cai_pc_ordq_type, ordq));

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

        }
        else /* (add_record_len == 0) */
        {
          /* --------------------------------------------
          ** No order qualifier implicitly means ordq = 0
          ** (see PN-3118 Section 7.7.4)
          ** -------------------------------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq = 0;
        }

        /* -----------------------------------------
        ** Account for possible additional fields in
        ** future revs of the spec
        ** ----------------------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;
        break;

#ifdef FEATURE_IS2000_REL_A
      case CAI_BS_REJ_ORD:
        if (add_record_len >= 1)
        {
          /* ---------------------
          ** Parse order qualifier
          ** --------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq =
            b_unpackb(buf_ptr, order_pos, FSIZ(cai_pc_ordq_type, ordq));

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

#ifdef FEATURE_IS2000_REL_C
          if (int_ptr->pc_ord.ords[num_recs].ordq.ordq ==
              CAI_BS_REJ_ORDER_MSG_NOT_ACCEPTED)
          {
            msg_pos = order_pos;

            /* Increment position for this record only */
            msg_pos += FSIZ(cai_pc_ordq_type, ordq);

            int_ptr->pc_ord.ords[num_recs].bsrej.reject_reason =
              b_unpackb(buf_ptr, msg_pos, FSIZ(cai_bs_rej_type, reject_reason));
            msg_pos += FSIZ(cai_bs_rej_type, reject_reason);

            int_ptr->pc_ord.ords[num_recs].bsrej.rejected_msg_type =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_bs_rej_type, rejected_msg_type));
            msg_pos += FSIZ(cai_bs_rej_type, rejected_msg_type);

            int_ptr->pc_ord.ords[num_recs].bsrej.rejected_msg_seq =
              b_unpackb(buf_ptr, msg_pos,
              FSIZ(cai_bs_rej_type, rejected_msg_seq));
            msg_pos += FSIZ(cai_bs_rej_type, rejected_msg_seq);
          }
#endif /* FEATURE_IS2000_REL_C */
        }
        else /* (add_record_len == 0) */
        {
          /* --------------------------------------------
          ** No order qualifier implicitly means ordq = 0
          ** (see PN-3118 Section 7.7.4)
          ** -------------------------------------------- */
          int_ptr->pc_ord.ords[num_recs].ordq.ordq = 0;
        }

        /* -----------------------------------------
        ** Account for possible additional fields in
        ** future revs of the spec
        ** ----------------------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;
        break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      default:

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

        /* ----------------------------
        ** Unknown Paging Channel Order
        ** ---------------------------- */
        order_pos += (add_record_len * 8);
        num_recs++;

        break;

    } /* end switch */

    int_ptr->pc_ord.num_ords = num_recs;

  } /* end while */


  return (status);

} /* xlate_ext_pc_ord */

/*===========================================================================

FUNCTION XLATE_EXT_CHN_ASN

DESCRIPTION
  This function translates a Paging Channel Channel Assignment Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Channel Assignment message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_chn_asn
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of channel assignment order relative to start of buf_ptr */
  byte add_record_len;
    /* Temporary storage for the add_record_len field */
  word num_recs;
    /* Number of variable parts of message */
  word i;
    /* Index through parameters */
  word old_ext_msg_pos;
    /* For caculating # of reserved bits in a single chn asn record */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ext_msg_pos = FSIZ( cai_pc_hdr_type, msg_type );

  /* ---------------------------------
  ** Initialize number of records to 0
  ** --------------------------------- */
  num_recs = 0;

  while ((len > ext_msg_pos) && ((len - ext_msg_pos) >= CAI_CHN_ASN_REC_MIN))
  {
    xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr, 
      &int_ptr->chnasn.chns[num_recs].gen.hdr );

#ifdef FEATURE_IS2000_REL_A
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Extended Encryption fields if
    ** there is one, and run the decryption algorithm.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
         &int_ptr->chnasn.chns[num_recs].gen.hdr, int_ptr->chnasn.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */

    /* ----------------------
    ** Unpack base of message
    ** ---------------------- */
    #define MTYPE cai_chnasn_base_type

    UNPACKB_PG(chnasn.chns[num_recs].gen.assign_mode,
      MTYPE, assign_mode);

    add_record_len = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(MTYPE, add_record_len));
    ext_msg_pos += FSIZ(cai_chnasn_base_type, add_record_len);

    old_ext_msg_pos = ext_msg_pos;

    #undef MTYPE

    /* -------------------------
    ** Switch on Assignment Mode
    ** ------------------------- */
    switch (int_ptr->chnasn.chns[num_recs].gen.assign_mode)
    {
      case CAI_TRAFFIC_CHAN_ASSIGN:
        
        #define VTYPE cai_chnasn_am0_type

        UNPACKB_PG(chnasn.chns[num_recs].am0.freq_incl, VTYPE, freq_incl);
        UNPACKB_PG(chnasn.chns[num_recs].am0.code_chan, VTYPE, code_chan);

        if (int_ptr->chnasn.chns[num_recs].am0.freq_incl)
        {
          UNPACKW_PG(chnasn.chns[num_recs].am0.cdma_freq, VTYPE, cdma_freq);
        }

        UNPACKB_PG(chnasn.chns[num_recs].am0.frame_offset, VTYPE, frame_offset);
        UNPACKB_PG(chnasn.chns[num_recs].am0.encrypt_mode, VTYPE, encrypt_mode);

#ifdef FEATURE_IS2000_REL_A
        if ((ext_msg_pos - old_ext_msg_pos) < (add_record_len * 8))
        {
          if (int_ptr->chnasn.chns[num_recs].am0.encrypt_mode ==
              CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
          {
            UNPACKB_PG(chnasn.chns[num_recs].am0.d_sig_encrypt_mode,
              VTYPE, d_sig_encrypt_mode);
          }

          if ((int_ptr->chnasn.chns[num_recs].am0.encrypt_mode ==
               CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG)||
              (int_ptr->chnasn.chns[num_recs].am0.encrypt_mode ==
               CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
          {
            UNPACKB_PG(chnasn.chns[num_recs].am0.enc_key_size,
              VTYPE, enc_key_size);
          }

          UNPACKB_PG(chnasn.chns[num_recs].am0.c_sig_encrypt_mode_incl,
            VTYPE, c_sig_encrypt_mode_incl);

          if (int_ptr->chnasn.chns[num_recs].am0.c_sig_encrypt_mode_incl)
          {
            UNPACKB_PG(chnasn.chns[num_recs].am0.c_sig_encrypt_mode,
              VTYPE, c_sig_encrypt_mode);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_PAGING_CHAN_ASSIGN:

        #define VTYPE cai_chnasn_am1_type

        UNPACKB_PG(chnasn.chns[num_recs].am1.respond, VTYPE, respond);
        UNPACKB_PG(chnasn.chns[num_recs].am1.freq_incl, VTYPE, freq_incl);

        if (int_ptr->chnasn.chns[num_recs].am1.freq_incl)
        {
          UNPACKW_PG(chnasn.chns[num_recs].am1.cdma_freq, VTYPE, cdma_freq);

          int_ptr->chnasn.chns[num_recs].am1.num_pilots =
            ( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl ) - FSIZ( VTYPE, cdma_freq ) 
            ) / FSIZ( VTYPE, pilot_pn );
        }
        else
        {
          int_ptr->chnasn.chns[num_recs].am1.num_pilots =
            ( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl ) 
            ) / FSIZ( VTYPE, pilot_pn);
        }

        for (i=0; i < int_ptr->chnasn.chns[num_recs].am1.num_pilots; i++)
        {
          UNPACKW_PG(chnasn.chns[num_recs].am1.pilot_pn[i], VTYPE,
            pilot_pn);
        }

        #undef VTYPE 
        
        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_ACQ_ANALOG_SYSTEM:

        #define VTYPE cai_chnasn_am2_type

        UNPACKB_PG(chnasn.chns[num_recs].am2.respond, VTYPE, respond);
        UNPACKB_PG(chnasn.chns[num_recs].am2.analog_sys, VTYPE, analog_sys);
        UNPACKB_PG(chnasn.chns[num_recs].am2.use_analog_sys, VTYPE, 
          use_analog_sys);
        UNPACKB_PG(chnasn.chns[num_recs].am2.band_class, VTYPE, band_class);

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_ANALOG_VCHAN_ASSIGN:

        #define VTYPE cai_chnasn_am3_type

        UNPACKW_PG(chnasn.chns[num_recs].am3.sid, VTYPE, sid);
        UNPACKB_PG(chnasn.chns[num_recs].am3.vmac, VTYPE, vmac);
        UNPACKW_PG(chnasn.chns[num_recs].am3.analog_chan, VTYPE, analog_chan);
        UNPACKB_PG(chnasn.chns[num_recs].am3.scc, VTYPE, scc);
        UNPACKB_PG(chnasn.chns[num_recs].am3.mem, VTYPE, mem);
        UNPACKB_PG(chnasn.chns[num_recs].am3.an_chan_type, VTYPE, an_chan_type);
        UNPACKB_PG(chnasn.chns[num_recs].am3.dscc_msb, VTYPE, dscc_msb);
        UNPACKB_PG(chnasn.chns[num_recs].am3.band_class, VTYPE, band_class);

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_EXT_TRAF_CHAN_ASSIGN:

        #define VTYPE cai_chnasn_am4_type

        UNPACKB_PG(chnasn.chns[num_recs].am4.freq_incl, VTYPE, freq_incl);

        ext_msg_pos += FSIZ(VTYPE, reserved);

        UNPACKB_PG(chnasn.chns[num_recs].am4.bypass_alert_answer, VTYPE, 
          bypass_alert_answer);
        UNPACKB_PG(chnasn.chns[num_recs].am4.default_config, VTYPE, 
          default_config);
        UNPACKB_PG(chnasn.chns[num_recs].am4.grant_mode, VTYPE, grant_mode);
        UNPACKB_PG(chnasn.chns[num_recs].am4.code_chan, VTYPE, code_chan);
        UNPACKB_PG(chnasn.chns[num_recs].am4.frame_offset, VTYPE, frame_offset);
        UNPACKB_PG(chnasn.chns[num_recs].am4.encrypt_mode, VTYPE, encrypt_mode);

        if (int_ptr->chnasn.chns[num_recs].am4.freq_incl)
        {
          UNPACKB_PG(chnasn.chns[num_recs].am4.band_class, VTYPE, band_class);
          UNPACKW_PG(chnasn.chns[num_recs].am4.cdma_freq, VTYPE, cdma_freq);
        }

#ifdef FEATURE_IS2000_REL_A
        if ((ext_msg_pos - old_ext_msg_pos) < (add_record_len * 8))
        {
          if (int_ptr->chnasn.chns[num_recs].am4.encrypt_mode ==
              CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
          {
            UNPACKB_PG(chnasn.chns[num_recs].am4.d_sig_encrypt_mode,
              VTYPE, d_sig_encrypt_mode);
          }

          if ((int_ptr->chnasn.chns[num_recs].am4.encrypt_mode ==
               CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG)||
              (int_ptr->chnasn.chns[num_recs].am4.encrypt_mode ==
               CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
          {
            UNPACKB_PG(chnasn.chns[num_recs].am4.enc_key_size,
              VTYPE, enc_key_size);
          }

          UNPACKB_PG(chnasn.chns[num_recs].am4.c_sig_encrypt_mode_incl,
            VTYPE, c_sig_encrypt_mode_incl);

          if (int_ptr->chnasn.chns[num_recs].am4.c_sig_encrypt_mode_incl)
          {
            UNPACKB_PG(chnasn.chns[num_recs].am4.c_sig_encrypt_mode,
              VTYPE, c_sig_encrypt_mode);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      case CAI_EXT_PAGING_CHAN_ASSIGN:

        #define VTYPE cai_chnasn_am5_type

        UNPACKB_PG(chnasn.chns[num_recs].am5.respond, VTYPE, respond);
        UNPACKB_PG(chnasn.chns[num_recs].am5.freq_incl, VTYPE, freq_incl);

        if (int_ptr->chnasn.chns[num_recs].am5.freq_incl)
        {
          UNPACKB_PG(chnasn.chns[num_recs].am5.band, VTYPE, band_class);
          UNPACKW_PG(chnasn.chns[num_recs].am5.cdma_freq, VTYPE, cdma_freq);

          int_ptr->chnasn.chns[num_recs].am5.num_pilots =
            ( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, band_class ) - FSIZ( VTYPE, freq_incl ) -
              FSIZ( VTYPE, cdma_freq )
            ) / FSIZ( VTYPE, pilot_pn );
        }
        else
        {
          int_ptr->chnasn.chns[num_recs].am5.num_pilots =
            ( ( add_record_len * 8 ) - FSIZ( VTYPE, respond ) -
              FSIZ( VTYPE, freq_incl )
            ) / FSIZ( VTYPE, pilot_pn );
        }

        for (i=0; i < int_ptr->chnasn.chns[num_recs].am5.num_pilots; i++)
        {
          UNPACKW_PG(chnasn.chns[num_recs].am5.pilot_pn[i], VTYPE, pilot_pn);
        }

        #undef VTYPE

        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;

      default:
        MSG_MED( "Unknown ASSIGN_MODE %d",
                 int_ptr->chnasn.chns[num_recs].gen.assign_mode, 0, 0 );
        /* --------------------------------------------------
        ** Adjust order_pos according to ADD_RECORD_LEN field
        ** -------------------------------------------------- */
        ext_msg_pos = old_ext_msg_pos + (add_record_len * 8);
        break;
    } /* end of switch */

    num_recs++;

  } /* end while */

  int_ptr->chnasn.num_chns = num_recs;

  return (status);

} /* xlate_ext_chn_asn */

/*===========================================================================

FUNCTION XLATE_EXT_PC_TMSI

DESCRIPTION
  This function translates a Paging Channel TMSI Assignment Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the TMSI Assignment message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_tmsi
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
          
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->pc_tmsi.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->pc_tmsi.hdr.msg_int, 
       int_ptr->pc_tmsi.msg_type,
       int_ptr->pc_tmsi.hdr.ack_req
         )) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
       &int_ptr->pc_tmsi.hdr, int_ptr->pc_tmsi.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_pc_tmsi_asgn_type

  msg_pos += FSIZ(FTYPE, reserved1);

  int_ptr->pc_tmsi.data.zone_len  = b_unpackb(buf_ptr, msg_pos,
    FSIZ(FTYPE, tmsi_zone_len));
  msg_pos += FSIZ(FTYPE, tmsi_zone_len);

  qw_set(int_ptr->pc_tmsi.data.info.tmsi_zone, 0L, 0L);
  b_unpackq(buf_ptr, msg_pos, (int_ptr->pc_tmsi.data.zone_len << 3),
    int_ptr->pc_tmsi.data.info.tmsi_zone);
  msg_pos += (int_ptr->pc_tmsi.data.zone_len << 3);

  int_ptr->pc_tmsi.data.info.tmsi_code = b_unpackd(buf_ptr, msg_pos,
    FSIZ(FTYPE, tmsi_code));
  msg_pos += FSIZ(FTYPE, tmsi_code);

  int_ptr->pc_tmsi.data.exp_time = b_unpackd(buf_ptr, msg_pos,
    FSIZ(FTYPE, tmsi_exp_time));
  msg_pos += FSIZ(FTYPE, tmsi_exp_time);

  #undef FTYPE

  return (status);

} /* xlate_ext_pc_tmsi */

/*===========================================================================

FUNCTION XLATE_EXT_PC_BURST

DESCRIPTION
  This function translates a Paging Channel Data Burst Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Data Burst message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_burst
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through characters */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
       
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->pc_burst.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one. Also validate MACI.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->pc_burst.hdr.msg_int, int_ptr->pc_burst.msg_type,
       int_ptr->pc_burst.hdr.ack_req
         )) 
      != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
       &int_ptr->pc_burst.hdr, int_ptr->pc_burst.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_burst_pc_fix_type

  int_ptr->pc_burst.msg_number =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, msg_number));
  msg_pos += FSIZ(FTYPE, msg_number );

  int_ptr->pc_burst.burst_type =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, burst_type));
  msg_pos += FSIZ(FTYPE, burst_type );

  int_ptr->pc_burst.num_msgs  =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, num_msgs));
  msg_pos += FSIZ(FTYPE, num_msgs);

  int_ptr->pc_burst.num_fields  =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, num_fields));
  msg_pos += FSIZ(FTYPE, num_fields );

  #undef FTYPE

  for (i=0; i<int_ptr->pc_burst.num_fields; i++)
  {
    #define VTYPE cai_burst_pc_var_type

    int_ptr->pc_burst.chari[i] =
      b_unpackb(buf_ptr, msg_pos, FSIZ(VTYPE, chari));
    msg_pos += FSIZ(VTYPE, chari);

    #undef VTYPE
  }

  return (status);

} /* xlate_ext_pc_burst */

/*===========================================================================

FUNCTION XLATE_EXT_PC_AUTH

DESCRIPTION
  This function translates a Paging Channel Authentication Challenge Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Authentication Challenge message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_auth
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position in message relative to start of buf_ptr */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
        
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ext_msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr, &int_ptr->pc_auth.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
       CAIX_MACI_NOT_REQUIRED, &ext_msg_pos,
       buf_ptr, &int_ptr->pc_auth.hdr.msg_int, int_ptr->pc_auth.msg_type,
       int_ptr->pc_auth.hdr.ack_req
         )) 
       != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
       &int_ptr->pc_auth.hdr, int_ptr->pc_auth.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define MTYPE cai_pc_auth_ch_type

  UNPACKD_PG(pc_auth.randu, MTYPE, randu);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  #undef MTYPE

  return (status);

} /* xlate_ext_pc_auth */

/*===========================================================================

FUNCTION XLATE_EXT_PC_SSD

DESCRIPTION
  This function translates a Paging Channel SSD Update Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the SSD Update message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None.

===========================================================================*/

word xlate_ext_pc_ssd
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
            
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->pc_ssd.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->pc_ssd.hdr.msg_int, int_ptr->pc_ssd.msg_type,
       int_ptr->pc_ssd.hdr.ack_req
         )) 
      != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
       &int_ptr->pc_ssd.hdr, int_ptr->pc_ssd.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_pc_ssd_type

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, randssd), int_ptr->pc_ssd.randssd);
  msg_pos += FSIZ(FTYPE, randssd);

  #undef FTYPE

  return (status);

} /* xlate_ext_pc_ssd */

/*===========================================================================

FUNCTION XLATE_EXT_PC_FEATURE

DESCRIPTION
  This function translates a Feature Notification Message from external
  to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Feature Notification message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_feature
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  byte i;
    /* Index */
  word msg_pos;
    /* Position of record in message */
  byte *msg_ptr;
    /* Pointer to position inside internal message type */
  byte rec_type;
    /* Temporary storage for record type */
  word rec_len;
    /* Temporary storage for record length */
  word min_rec_len;
    /* Minimum record length */
             
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->pc_feat.hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->pc_feat.hdr.msg_int, int_ptr->pc_feat.msg_type,
       int_ptr->pc_feat.hdr.ack_req
       )) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
       &int_ptr->pc_feat.hdr, int_ptr->pc_feat.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_pc_feature_type

  int_ptr->pc_feat.release = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, release));
  msg_pos += FSIZ(FTYPE, release);

  #undef FTYPE

  /* ---------------------------------
  ** Initialize number of records to 0
  ** --------------------------------- */
  int_ptr->pc_feat.num_recs = 0;

  msg_ptr = (byte*)(&int_ptr->pc_feat.recs[0]);
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
  
  min_rec_len = sizeof(cai_rec_hdr_type);

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->pc_feat.hdr.msg_int.maci_incl)
  {
    min_rec_len += FSIZ(cai_msg_int_type, maci);
  }
#endif /* FEATURE_IS2000_REL_C */
 
  while ((len > msg_pos) && ((len- msg_pos) >= min_rec_len))
  {
    word start_msg_pos;

    /* ------------------------------
    ** Unpack message type and length
    ** ------------------------------ */
    ((caii_rec_hdr_type *) msg_ptr)->record_type = rec_type =
      b_unpackb(buf_ptr, msg_pos, FSIZ(cai_rec_hdr_type, record_type));
    msg_pos += FSIZ(cai_rec_hdr_type, record_type);

    /* -------------------------
    ** Get record length in bits
    ** ------------------------- */
    rec_len = b_unpackb(buf_ptr, msg_pos,
      FSIZ(cai_rec_hdr_type, record_len)) * 8;
    msg_pos += FSIZ(cai_rec_hdr_type, record_len);

    start_msg_pos = msg_pos;

    if ((rec_len + msg_pos) > len)
    {
      /* ---------------------------------------------------
      ** RECORD_LEN field indicates that record size exceeds
      ** received length -- stop parsing message
      ** --------------------------------------------------- */
      break;
    }
    else
    {
      /* --------------------------------------
      ** Attempt to parse information record(s)
      ** -------------------------------------- */
      switch (rec_type)
      {
        case CAI_DISPLAY_REC:
          /* --------------------------
          ** Display Information Record
          ** -------------------------- */

          #define RTYPE caii_display_rec_type
          #define VTYPE cai_display_rec_var_type

            ((RTYPE *) msg_ptr)->fix.num_char = (byte) (rec_len / sizeof(VTYPE));

            for (i=0; i < ((RTYPE *) msg_ptr)->fix.num_char; i++)
            {
              ((RTYPE *) msg_ptr)->var[i] =
                b_unpackb(buf_ptr, start_msg_pos, FSIZ(VTYPE, chari));
              start_msg_pos += FSIZ(VTYPE, chari);
            }

            /* -------------------------------------------------
            ** Increment internal message pointer to next record
            ** ------------------------------------------------- */
            msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1]);

            msg_pos += rec_len;

            int_ptr->pc_feat.num_recs++;

            #undef VTYPE
            #undef RTYPE

            break;

        case CAI_CALLED_REC:
          /* --------------------------------------
          ** Called Party Number Information Record
          ** -------------------------------------- */

          #define RTYPE caii_called_rec_type
          #define FTYPE cai_called_fix_type
          #define VTYPE cai_called_var_type

          ((RTYPE *) msg_ptr)->fix.number_type =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, number_type));
          start_msg_pos += FSIZ(FTYPE, number_type);

          ((RTYPE *) msg_ptr)->fix.number_plan =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, number_plan));
          start_msg_pos += FSIZ(FTYPE, number_plan);

          ((RTYPE *) msg_ptr)->fix.num_char =
            (byte) ((rec_len - sizeof(FTYPE)) / sizeof(VTYPE));

          for (i=0; i < ((RTYPE *) msg_ptr)->fix.num_char; i++) {
            ((RTYPE *) msg_ptr)->var[i] =
              b_unpackb(buf_ptr, start_msg_pos, FSIZ(VTYPE, chari));
            start_msg_pos += FSIZ(VTYPE, chari);
          }

          /* ----------------------------------------------------------
          ** Increment internal message pointer to point to next record
          ** ---------------------------------------------------------- */
          msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1] );

          msg_pos += rec_len;  

          int_ptr->pc_feat.num_recs++;

          #undef VTYPE
          #undef FTYPE
          #undef RTYPE

          break;

        case CAI_CALLING_REC:
        case CAI_CONNECT_REC:
          /* -----------------------------------------------------------
          ** Calling Party Number or Connected Number Information Record
          ** ----------------------------------------------------------- */

          #define RTYPE caii_calling_rec_type
          #define FTYPE cai_calling_fix_type
          #define VTYPE cai_calling_var_type

          ((RTYPE *) msg_ptr)->fix.number_type =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, number_type ));
          start_msg_pos += FSIZ(FTYPE, number_type);

          ((RTYPE *) msg_ptr)->fix.number_plan =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, number_plan));
          start_msg_pos += FSIZ(FTYPE, number_plan);

          ((RTYPE *) msg_ptr)->fix.pi =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, pi ));
          start_msg_pos += FSIZ(FTYPE, pi);

          ((RTYPE *) msg_ptr)->fix.si =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, si ));
          start_msg_pos += FSIZ(FTYPE, si);

          ((RTYPE *) msg_ptr)->fix.num_char =
            (byte) ((rec_len - sizeof(FTYPE)) / sizeof(VTYPE));

          for (i=0; i < ((RTYPE *) msg_ptr)->fix.num_char; i++)
          {
            ((RTYPE *) msg_ptr)->var[i] =
              b_unpackb(buf_ptr, start_msg_pos, FSIZ(VTYPE, chari));
            start_msg_pos += FSIZ(VTYPE, chari);
          }

          /* -------------------------------
          ** Update internal message pointer
          ** ------------------------------- */
          msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1] );

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;

          #undef VTYPE
          #undef FTYPE
          #undef RTYPE

          break;

        case CAI_SIGNAL_REC:
          /* -------------------------
          ** Signal Information Record
          ** ------------------------- */

          #define RTYPE caii_signal_rec_type
          #define FTYPE cai_signal_rec_type

          ((RTYPE *) msg_ptr)->signal_type =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, signal_type));
          start_msg_pos += FSIZ(FTYPE, signal_type);

          ((RTYPE *) msg_ptr)->alert_pitch =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, alert_pitch));
          start_msg_pos += FSIZ(FTYPE, alert_pitch);

          ((RTYPE *) msg_ptr)->signal =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, signal));
          start_msg_pos += FSIZ(FTYPE, signal) + FSIZ(FTYPE, reserved);

          /* -------------------------------
          ** Update internal message pointer
          ** ------------------------------- */
          msg_ptr += sizeof(RTYPE);

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;

          #undef FTYPE
          #undef RTYPE

          break;

        case CAI_MSG_WAITING_REC:
          /* ----------------------------------
          ** Message Waiting Information Record
          ** ---------------------------------- */
          #define RTYPE caii_msg_waiting_rec_type
          #define FTYPE cai_msg_waiting_rec_type

          ((RTYPE *) msg_ptr)->msg_count =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, msg_count));
          start_msg_pos += FSIZ(FTYPE, msg_count);

          /* -------------------------------
          ** Update internal message pointer
          ** ------------------------------- */
          msg_ptr += sizeof(RTYPE);

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;

          #undef RTYPE
          #undef FTYPE

          break;

        case CAI_CALLED_SUB_REC:
        case CAI_CALLING_SUB_REC:
        case CAI_REDIR_SUB_REC:
          /* --------------------------------------------------------
          ** Calling Party Subaddress or Called Party Subaddress
          ** or Redirecting Subaddress info record
          ** -------------------------------------------------------- */
          /* Unpack Information Record */
          status = xlate_ext_sub_rec(rec_len, buf_ptr, msg_ptr, &start_msg_pos);

          /* -------------------------------------------------
          ** Increment internal message pointer to next record
          ** ------------------------------------------------- */
          #define RTYPE caii_subaddr_rec_type

          msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1]);

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;

          #undef RTYPE

          break;

        case CAI_REDIR_NUM_REC:
          /* --------------------------------------------------------
          ** Redirecting Number Information Record
          ** -------------------------------------------------------- */
          /* Unpack Information Record */
          status = xlate_ext_redir_num_rec(rec_len, buf_ptr, msg_ptr,
            &start_msg_pos);

          /* -------------------------------------------------
          ** Increment internal message pointer to next record
          ** ------------------------------------------------- */
          #define RTYPE caii_redir_rec_type

          msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_char - 1]);

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;

          #undef RTYPE

          break;

        case CAI_EXT_DISPLAY_REC:
          /* ------------------------------
          ** Extended Display Info Record
          ** ------------------------------ */
          status = xlate_ext_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
            &start_msg_pos);

          /* -------------------------------
          ** xlate function already updated
          ** internal message pointer
          ** ------------------------------- */

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;

          break;

        case CAI_PARA_ALERT_REC:
          /* --------------------------------------
          ** Parametric Alerting Information Record
          ** -------------------------------------- */
          status = xlate_ext_para_alert_rec(rec_len, buf_ptr, msg_ptr,
            &start_msg_pos);

          /* -------------------------------
          ** Update internal message pointer
          ** ------------------------------- */

          #define RTYPE caii_para_alert_rec_type

#if defined(FEATURE_IS2000_REL_A) && defined(FEATURE_MSG_PACK_UNIT_TEST)
#error code not present
#else
          if (((RTYPE *) msg_ptr)->fix.num_groups == 0)
          {
            msg_ptr += FENDPOS(RTYPE, fix);
          }
          else
          {
            msg_ptr += FENDPOS(RTYPE, var[((RTYPE *) msg_ptr)->fix.num_groups - 1]);
          }
#endif /* FEATURE_IS2000_REL_A && FEATURE_MSG_PACK_UNIT_TEST */
          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;

          #undef RTYPE

          break;

        case CAI_USER_ZONE_REJECT_REC:

          #define RTYPE caii_user_zone_reject_type
          #define FTYPE cai_user_zone_reject_type

          ((RTYPE *) msg_ptr)->reject_uzid =
            b_unpackw(buf_ptr, start_msg_pos, FSIZ(FTYPE, reject_uzid));
          start_msg_pos += FSIZ(FTYPE, reject_uzid);

          ((RTYPE *) msg_ptr)->reject_action_indi =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, reject_action_indi));
          start_msg_pos += FSIZ(FTYPE, reject_action_indi);

          ((RTYPE *) msg_ptr)->uzid_assign_incl =
            b_unpackb(buf_ptr, start_msg_pos, FSIZ(FTYPE, uzid_assign_incl));
          start_msg_pos += FSIZ(FTYPE, uzid_assign_incl);

          if (((RTYPE *) msg_ptr)->uzid_assign_incl)
          {
            ((RTYPE *) msg_ptr)->assign_uzid =
              b_unpackw(buf_ptr, start_msg_pos, FSIZ(FTYPE, assign_uzid));
            start_msg_pos += FSIZ(FTYPE, assign_uzid);
            msg_ptr += FENDPOS(RTYPE, assign_uzid);
          }
          else
          {
            msg_ptr += FENDPOS(RTYPE, uzid_assign_incl);
          }

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;

          #undef FTYPE
          #undef RTYPE

          break;

#ifdef FEATURE_IS2000_REL_A
        case CAI_MC_EXT_DISP_REC:
          /* ---------------------------------------------
          ** Multi-character Extended Display Info Record
          ** --------------------------------------------- */
          status = xlate_ext_mc_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
            &start_msg_pos);

          /* -------------------------------
          ** xlate function already updated
          ** internal message pointer
          ** ------------------------------- */

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;
          break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
        case CAI_ENH_MC_EXT_DISP_REC:
          /* ---------------------------------------------
          ** Enhanced Multi-character Extended Display Info Record
          ** --------------------------------------------- */
          status = xlate_ext_enh_mc_ext_disp_rec(rec_len, buf_ptr, &msg_ptr,
            &start_msg_pos);

          /* -------------------------------
          ** xlate function already updated
          ** internal message pointer
          ** ------------------------------- */

          msg_pos += rec_len; 

          int_ptr->pc_feat.num_recs++;
          break;
#endif /* FEATURE_IS2000_REL_C */

        default:
          /* ------------------------
          ** Unknown info record type
          ** ------------------------ */
          /* ----------------------------------------------------------
          ** Increment internal message pointer to point to next record
          ** ---------------------------------------------------------- */
          msg_ptr += FENDPOS(caii_rec_hdr_type, record_type);

          msg_pos += rec_len;

          int_ptr->pc_feat.num_recs++;
          break;
      } /* end switch (rec_type) */

      msg_ptr = (byte*)ALIGN_DWORD(((dword)msg_ptr));

    }
  } /* end of while */

  return (status);

} /* xlate_ext_pc_feature */

/*===========================================================================

FUNCTION XLATE_EXT_EXT_SYS_PARM

DESCRIPTION
  This function translates a Paging Channel Extended System Parameters
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended System Parameters message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ext_sys_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  word min_len;
    /* Protocol dependent minimum length requirement */
  byte i; /* Index */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_ext_sysparm_msg_type

  /* ---------------------------------------
  ** Check length to make sure it is correct
  ** --------------------------------------- */
  if ( len < CAI_EXT_SYSPARM_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ----------------------------------------------------------------
    ** Length is ok - start translating message at field after msg_type
    ** ---------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(ext_sysparm.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(ext_sysparm.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(ext_sysparm.delete_for_tmsi, MTYPE, delete_for_tmsi);
    UNPACKB_PG(ext_sysparm.pref_msid_type, MTYPE, pref_msid_type);
    UNPACKW_PG(ext_sysparm.mcc, MTYPE, mcc);
    UNPACKB_PG(ext_sysparm.imsi_11_12, MTYPE, imsi_11_12);
    UNPACKB_PG(ext_sysparm.tmsi_zone_len, MTYPE, tmsi_zone_len);

    b_unpackq(buf_ptr, ext_msg_pos, int_ptr->ext_sysparm.tmsi_zone_len << 3,
              int_ptr->ext_sysparm.tmsi_zone );
    ext_msg_pos += int_ptr->ext_sysparm.tmsi_zone_len << 3;

    UNPACKB_PG(ext_sysparm.bcast_index, MTYPE, bcast_index);

    /* IS-95A and JSTD ends parsing right here */

    /* -------------------------------------------------------------
    ** At this point we need to check to see if the ESPM is in
    ** IS-95B format. If it is not IS-95B, there should not be
    ** enough length for P_REV field. Note: length passed into
    ** the parser is for the message body ( not including length
    ** field and CRC )
    ** ------------------------------------------------------------- */
    min_len = FSIZ( MTYPE, imsi_t_supported ) +
              FSIZ( MTYPE, p_rev ) +
              FSIZ( MTYPE, min_p_rev ) +
              FSIZ( MTYPE, soft_slope ) +
              FSIZ( MTYPE, add_intercept ) +
              FSIZ( MTYPE, drop_intercept ) +
              FSIZ( MTYPE, packet_zone_id ) +
              FSIZ( MTYPE, max_num_alt_so ) +
              FSIZ( MTYPE, reselect_included ) +
              FSIZ( MTYPE, pilot_report ) +
              FSIZ( MTYPE, nghbr_set_entry_info ) +
              FSIZ( MTYPE, nghbr_set_access_info );
    min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8; 

    if ((len - ext_msg_pos) < min_len )
    {
      /* -------------------------------------------------------------
      ** Length less than the minimum required by IS-95B, stop parsing
      ** and set p_rev to 0 to notify MC that we received a pre-IS95B
      ** format. MC should ignore all the IS-95B fields.
      ** ------------------------------------------------------------- */
      int_ptr->ext_sysparm.p_rev = CAIX_P_REV_UNKNOWN;
    }
#ifdef FEATURE_DYNAMIC_P_REV
    else if (cdma.mob_cai_rev < P_REV_IS95B)
    {
      int_ptr->ext_sysparm.p_rev = CAIX_P_REV_UNKNOWN;
    }
#endif /* FEATURE_DYNAMIC_P_REV */
    else
    {
      int_ptr->ext_sysparm.is95b_incl = TRUE;
      /* -------------------------------------------------------------
      ** Length greater or equal than the minimum required by IS-95B,
      ** keep parsing
      ** ------------------------------------------------------------- */
      UNPACKB_PG(ext_sysparm.imsi_t_supported, MTYPE, imsi_t_supported);
      UNPACKB_PG(ext_sysparm.p_rev, MTYPE, p_rev);
      UNPACKB_PG(ext_sysparm.min_p_rev, MTYPE, min_p_rev);
      UNPACKB_PG(ext_sysparm.soft_slope, MTYPE, soft_slope);
      UNPACKB_PG(ext_sysparm.add_intercept, MTYPE, add_intercept);
      UNPACKB_PG(ext_sysparm.drop_intercept, MTYPE, drop_intercept);
      UNPACKB_PG(ext_sysparm.packet_zone_id, MTYPE, packet_zone_id);
      UNPACKB_PG(ext_sysparm.max_num_alt_so, MTYPE, max_num_alt_so);
      UNPACKB_PG(ext_sysparm.reselect_included, MTYPE, reselect_included);

      if (int_ptr->ext_sysparm.reselect_included)
      {
        UNPACKB_PG(ext_sysparm.ec_thresh, MTYPE, ec_thresh);
        UNPACKB_PG(ext_sysparm.ec_io_thresh, MTYPE, ec_io_thresh);
      }

      UNPACKB_PG(ext_sysparm.pilot_report, MTYPE, pilot_report);
      UNPACKB_PG(ext_sysparm.nghbr_set_entry_info, MTYPE, nghbr_set_entry_info);

      if (int_ptr->ext_sysparm.nghbr_set_entry_info)
      {
        UNPACKB_PG(ext_sysparm.acc_ent_ho_order, MTYPE, acc_ent_ho_order);
      }

      UNPACKB_PG(ext_sysparm.nghbr_set_access_info, MTYPE, nghbr_set_access_info);

      if (int_ptr->ext_sysparm.nghbr_set_access_info)
      {
        UNPACKB_PG(ext_sysparm.access_ho, MTYPE, access_ho);

        if (int_ptr->ext_sysparm.access_ho)
        {
          UNPACKB_PG(ext_sysparm.access_ho_msg_rsp, MTYPE, access_ho_msg_rsp);
        }

        UNPACKB_PG(ext_sysparm.access_probe_ho, MTYPE, access_probe_ho);

        if (int_ptr->ext_sysparm.access_probe_ho)
        {
          UNPACKB_PG(ext_sysparm.acc_ho_list_upd, MTYPE, acc_ho_list_upd);
          UNPACKB_PG(ext_sysparm.acc_probe_ho_other_msg, MTYPE, acc_probe_ho_other_msg);
          UNPACKB_PG(ext_sysparm.max_num_probe_ho, MTYPE, max_num_probe_ho);
        }
      }

      if (int_ptr->ext_sysparm.nghbr_set_entry_info ||
          int_ptr->ext_sysparm.nghbr_set_access_info)
      {
        UNPACKB_PG(ext_sysparm.nghbr_set_size, MTYPE, nghbr_set_size);
      }

      if (int_ptr->ext_sysparm.nghbr_set_entry_info)
      {
        for (i = 0; ((i < int_ptr->ext_sysparm.nghbr_set_size) &&
                     (i < MAX_NGHBR_SET_SIZE)); i++)
        {
          UNPACKB_PG(ext_sysparm.access_entry_ho[i], MTYPE, access_entry_ho);
        }
      }

      if (int_ptr->ext_sysparm.nghbr_set_access_info)
      {
        for (i = 0; ((i < int_ptr->ext_sysparm.nghbr_set_size) &&
                     (i < MAX_NGHBR_SET_SIZE)); i++)
        {
          UNPACKB_PG(ext_sysparm.access_ho_allowed[i], MTYPE, access_ho_allowed);
        }
      }

      if (int_ptr->ext_sysparm.p_rev >= CAIX_P_REV_IS2000)
      {
        UNPACKB_PG(ext_sysparm.broadcast_gps_asst, MTYPE, broadcast_gps_asst);
        UNPACKB_PG(ext_sysparm.qpch_supported, MTYPE, qpch_supported);

        if (int_ptr->ext_sysparm.qpch_supported)
        {
          UNPACKB_PG(ext_sysparm.num_qpch, MTYPE, num_qpch);
          UNPACKB_PG(ext_sysparm.qpch_rate, MTYPE, qpch_rate);
          UNPACKB_PG(ext_sysparm.qpch_power_level_page, MTYPE, qpch_power_level_page);
          UNPACKB_PG(ext_sysparm.qpch_cci_supported, MTYPE, qpch_cci_supported);

          if (int_ptr->ext_sysparm.qpch_cci_supported)
          {
            UNPACKB_PG(ext_sysparm.qpch_power_level_config, MTYPE, qpch_power_level_config);
          }
        }

        UNPACKB_PG(ext_sysparm.sdb_supported, MTYPE, sdb_supported);
        UNPACKB_PG(ext_sysparm.rlgain_traffic_pilot, MTYPE, rlgain_traffic_pilot);
        UNPACKB_PG(ext_sysparm.rev_pwr_cntl_delay_incl, MTYPE, rev_pwr_cntl_delay_incl);

        if (int_ptr->ext_sysparm.rev_pwr_cntl_delay_incl)
        {
          UNPACKB_PG(ext_sysparm.rev_pwr_cntl_delay, MTYPE, rev_pwr_cntl_delay);
        }

        #undef R0VTYPE
        #undef R0MTYPE
      }

#ifdef FEATURE_IS2000_REL_A
      if (int_ptr->ext_sysparm.p_rev >= CAIX_P_REV_IS2000_REL_A)
      {
        UNPACKB_PG(ext_sysparm.auto_msg_supported, MTYPE, auto_msg_supported);

        if (int_ptr->ext_sysparm.auto_msg_supported)
        {
          UNPACKB_PG(ext_sysparm.auto_msg_interval, MTYPE, auto_msg_interval);
        }

        UNPACKB_PG(ext_sysparm.mob_qos, MTYPE, mob_qos);
        UNPACKB_PG(ext_sysparm.enc_supported, MTYPE, enc_supported);

        if (int_ptr->ext_sysparm.enc_supported)
        {
          UNPACKB_PG(ext_sysparm.sig_encrypt_sup, MTYPE, sig_encrypt_sup);
          UNPACKB_PG(ext_sysparm.ui_encrypt_sup, MTYPE, ui_encrypt_sup);
        }

        UNPACKB_PG(ext_sysparm.use_sync_id, MTYPE, use_sync_id);
        UNPACKB_PG(ext_sysparm.cs_supported, MTYPE, cs_supported);
        UNPACKB_PG(ext_sysparm.bcch_supported, MTYPE, bcch_supported);
        UNPACKB_PG(ext_sysparm.ms_init_pos_loc_sup_ind, MTYPE, ms_init_pos_loc_sup_ind);
        UNPACKB_PG(ext_sysparm.pilot_info_req_supported, MTYPE, pilot_info_req_supported);
      }
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      if (int_ptr->ext_sysparm.p_rev >= CAIX_P_REV_IS2000_REL_B)
      {
        if (int_ptr->ext_sysparm.qpch_supported)
        {
          UNPACKB_PG(ext_sysparm.qpch_bi_supported, MTYPE, qpch_bi_supported);

          if (int_ptr->ext_sysparm.qpch_bi_supported)
          {
            UNPACKB_PG(ext_sysparm.qpch_power_level_bcast, MTYPE, qpch_power_level_bcast);
          }
        }

        UNPACKB_PG(ext_sysparm.band_class_info_req, MTYPE, band_class_info_req);

        if (int_ptr->ext_sysparm.band_class_info_req)
        {
          UNPACKB_PG(ext_sysparm.alt_band_class, MTYPE, alt_band_class);
        }

        UNPACKB_PG(ext_sysparm.cdma_off_time_rep_sup_ind, MTYPE,
          cdma_off_time_rep_sup_ind);

        if (int_ptr->ext_sysparm.cdma_off_time_rep_sup_ind)
        {
          UNPACKB_PG(ext_sysparm.cdma_off_time_rep_threshold_unit, MTYPE,
            cdma_off_time_rep_threshold_unit);
          UNPACKB_PG(ext_sysparm.cdma_off_time_rep_threshold, MTYPE,
            cdma_off_time_rep_threshold);
        }
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (int_ptr->ext_sysparm.p_rev >= CAIX_P_REV_IS2000_REL_C)
      {
        UNPACKB_PG(ext_sysparm.chm_supported, MTYPE, chm_supported);
        UNPACKB_PG(ext_sysparm.release_to_idle_ind, MTYPE, release_to_idle_ind);
        UNPACKB_PG(ext_sysparm.reconnect_msg_ind, MTYPE, reconnect_msg_ind);
        UNPACKB_PG(ext_sysparm.msg_integrity_sup, MTYPE, msg_integrity_sup);

        if (int_ptr->ext_sysparm.msg_integrity_sup)
        {
          UNPACKB_PG(ext_sysparm.sig_integrity_sup_incl, MTYPE, sig_integrity_sup_incl);

          if (int_ptr->ext_sysparm.sig_integrity_sup_incl)
          {
            UNPACKB_PG(ext_sysparm.sig_integrity_sup, MTYPE, sig_integrity_sup);
          }
        }

        UNPACKB_PG(ext_sysparm.for_pdch_supported, MTYPE, for_pdch_supported);

        if (int_ptr->ext_sysparm.for_pdch_supported)
        {
          UNPACKB_PG(ext_sysparm.pdch_chm_supported, MTYPE, pdch_chm_supported);
          UNPACKB_PG(ext_sysparm.pdch_parms_incl, MTYPE, pdch_parms_incl);

          if (int_ptr->ext_sysparm.pdch_parms_incl)
          {
            UNPACKB_PG(ext_sysparm.for_pdch_rlgain_incl, MTYPE, for_pdch_rlgain_incl);

            if (int_ptr->ext_sysparm.for_pdch_rlgain_incl)
            {
              UNPACKB_PG(ext_sysparm.rlgain_ackch_pilot, MTYPE, rlgain_ackch_pilot);
              UNPACKB_PG(ext_sysparm.rlgain_cqich_pilot, MTYPE, rlgain_cqich_pilot);
            }

            UNPACKB_PG(ext_sysparm.num_soft_switching_frames, MTYPE, num_soft_switching_frames);
            UNPACKB_PG(ext_sysparm.num_softer_switching_frames, MTYPE, num_softer_switching_frames);
            UNPACKB_PG(ext_sysparm.num_soft_switching_slots , MTYPE, num_soft_switching_slots);
            UNPACKB_PG(ext_sysparm.num_softer_switching_slots, MTYPE, num_softer_switching_slots);
            UNPACKB_PG(ext_sysparm.pdch_soft_switching_delay, MTYPE, pdch_soft_switching_delay);
            UNPACKB_PG(ext_sysparm.pdch_softer_switching_delay, MTYPE, pdch_softer_switching_delay);
            UNPACKB_PG(ext_sysparm.walsh_table_id, MTYPE, walsh_table_id);
            UNPACKB_PG(ext_sysparm.num_pdcch, MTYPE, num_pdcch);

            for (i = 0; i < int_ptr->ext_sysparm.num_pdcch+1; i++)
            {
              UNPACKB_PG(ext_sysparm.for_pdcch_walsh[i], MTYPE, for_pdcch_walsh);
            }
          }
        }

        UNPACKB_PG(ext_sysparm.imsi_10_incl, MTYPE, imsi_10_incl);

        if (int_ptr->ext_sysparm.imsi_10_incl)
        {
          UNPACKB_PG(ext_sysparm.imsi_10, MTYPE, imsi_10);
        }
      }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_ext_sys_parm */

/*===========================================================================

FUNCTION XLATE_EXT_PC_STREQ

DESCRIPTION
  This function translates a Paging Channel Status Request Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Status Request Message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pc_streq
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Return status */
  caii_pc_streq_type  *i_ptr = &int_ptr->pc_streq;
    /* Pointer to internal Status Request Message */
  word i;
    /* Index for looping through requested record types */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
  byte qual_len;
    /* For reading length of qualification information */
             
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Skip over message type */
  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  /* Translate paging channel header */
  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &i_ptr->hdr);

#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &i_ptr->hdr.msg_int, i_ptr->msg_type,
       i_ptr->hdr.ack_req
      )) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
      &i_ptr->hdr, i_ptr->msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_pc_streq_fix_type
  #define VTYPE cai_streq_var_type

  msg_pos += FSIZ(FTYPE, reserved);  /* Skip over reserved field */

  i_ptr->qual = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, qual_typ));
    /* Translate qualification info type */
  msg_pos += FSIZ(FTYPE, qual_typ);

  /* Translate qual info length */
  qual_len = (byte) (b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, qual_len)) * 8);
  msg_pos += FSIZ(FTYPE, qual_len);

  if (msg_pos + qual_len + FSIZ(FTYPE, num_fields ) > len)
  {
    return (CAIX_INV_LEN_S); /* Message too small */
  }

  if (i_ptr->qual == CAI_NO_QUAL) /* No qual info specified */
  {
    i_ptr->band = CAI_BAND_CLASS0;         /* Assume cellular band */
      
    i_ptr->op_mode = CAI_IS95_CDMA_OP_MODE; /* Assume CDMA mode */

    msg_pos += qual_len; /* Skip over qual info field */
  }
  else if (i_ptr->qual == CAI_BAND_QUAL) /* Band qual info specified */
  {
    if (sizeof(cai_qual_info1_type) > qual_len)
    {
      return (CAIX_INV_LEN_S); /* Message too small */
    }
    else
    {
      i_ptr->band = b_unpackb(buf_ptr, msg_pos, FSIZ(cai_qual_info1_type, band));
          /* Translate band qual info */
      msg_pos += qual_len; /* Skip over qual info field */

      i_ptr->op_mode = CAI_IS95_CDMA_OP_MODE; /* Assume CDMA mode */
    }
  }
  else if (i_ptr->qual == CAI_BAND_OP_MODE_QUAL) /* Band and mode */
  {
    if (sizeof(cai_qual_info2_type) > qual_len)
    {
      return (CAIX_INV_LEN_S);  /* Message too small */
    }
    else
    {
      i_ptr->band = b_unpackb(buf_ptr, msg_pos, FSIZ(cai_qual_info2_type, band));
          /* Unpack band qual info */

      i_ptr->op_mode = b_unpackb(buf_ptr, msg_pos +
        FSIZ(cai_qual_info2_type, band), FSIZ(cai_qual_info2_type, op_mode));
          /* Translate mode qual info */
      msg_pos += qual_len; /* Skip over qual info field */
    }
  }
  else
  {
    return (CAIX_INV_MSG_S);  /* Unknown qualification type */
  }

  /* Translate number of info req requests */
  i_ptr->num_fields = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, num_fields));
  msg_pos += FSIZ(FTYPE, num_fields);

  if (msg_pos + (i_ptr->num_fields * sizeof(VTYPE)) > len)
  {
    return (CAIX_INV_LEN_S); /* Message too small */
  }

  /* Translate request info rec types */
  for ( i = 0; i < i_ptr->num_fields; i++ )
  {
    i_ptr->rec_typ[i] = b_unpackb(buf_ptr, msg_pos, FSIZ(VTYPE, rec_typ));
    msg_pos += FSIZ(VTYPE, rec_typ);
  }

  #undef FTYPE
  #undef VTYPE

  return (status);

} /* xlate_ext_pc_streq */

/*===========================================================================

FUNCTION XLATE_EXT_SRVC_REDIR

DESCRIPTION
  This function translates a Paging Channel Service Redirection Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Service Redirection message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_srvc_redir
(
  word len,
    /* Length of message in bits */
    /*lint -esym(715,len) */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status;
    /* Status returned to calling procedure */
  word msg_pos = 0;
    /* Position of record in message */
  word i;
    /* Index */
                
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------
  ** Initialize status to everything ok
  ** ---------------------------------- */
  status = CAIX_DONE_S;

    msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

    xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->serv_redir.hdr);

#ifdef FEATURE_IS2000_REL_C
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Message Integrity fields if
    ** there is one.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
         CAIX_MACI_REQUIRED, &msg_pos,
         buf_ptr, &int_ptr->serv_redir.hdr.msg_int, 
         int_ptr->serv_redir.msg_type,
         int_ptr->serv_redir.hdr.ack_req
     )) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
    /* ------------------------------------------------------------------
    ** Now we have to take a look at the Extended Encryption fields if
    ** there is one, and run the decryption algorithm.
    ** ------------------------------------------------------------------ */
    if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
        &int_ptr->serv_redir.hdr, int_ptr->serv_redir.msg_type, 0, 0)) != CAIX_DONE_S)
    {
      return status;
    }
#endif /* FEATURE_IS2000_REL_A */

  /* ----------------------
  ** Unpack base of message
  ** ---------------------- */

  #define FTYPE cai_serv_redirect_fix_type

  int_ptr->serv_redir.return_if_fail =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, return_if_fail));
  msg_pos += FSIZ(FTYPE, return_if_fail);

  int_ptr->serv_redir.delete_tmsi =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, delete_tmsi));
  msg_pos += FSIZ(FTYPE, delete_tmsi);

  int_ptr->serv_redir.redirect_type =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, redirect_type));
  msg_pos += FSIZ(FTYPE, redirect_type);

  int_ptr->serv_redir.record_type =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, record_type));
  msg_pos += FSIZ(FTYPE, record_type);

  int_ptr->serv_redir.record_len =
    b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, record_len));
  msg_pos += FSIZ(FTYPE, record_len);

  #undef FTYPE

  /* ---------------------
  ** Switch on record type
  ** --------------------- */
  switch (int_ptr->serv_redir.record_type)
  {
    case CAI_NDSS_OFF_INDICATION:
      /* IS-95B, NDSS off, no type specific fields included */
      break;

    case CAI_ANALOG_REDIRECTION_REC:

      #define RTYPE cai_redirect_rec1_type

      int_ptr->serv_redir.redir.rec1.expected_sid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_sid));
      msg_pos += FSIZ(RTYPE, expected_sid);

      int_ptr->serv_redir.redir.rec1.ignore_cdma =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, ignore_cdma));
      msg_pos += FSIZ(RTYPE, ignore_cdma);

      int_ptr->serv_redir.redir.rec1.sys_ordering =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, sys_ordering));
      msg_pos += FSIZ(RTYPE, sys_ordering);

      int_ptr->serv_redir.redir.rec1.max_redirect_delay = 0;

      #undef RTYPE

      break;

    case CAI_CDMA_REDIRECTION_REC:

      #define RTYPE cai_redirect_rec2_type

      int_ptr->serv_redir.redir.rec2.band_class =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, band_class));
      msg_pos += FSIZ(RTYPE, band_class);

      int_ptr->serv_redir.redir.rec2.expected_sid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_sid));
      msg_pos += FSIZ(RTYPE, expected_sid);

      int_ptr->serv_redir.redir.rec2.expected_nid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_nid));
      msg_pos += FSIZ(RTYPE, expected_nid);

      msg_pos += FSIZ(RTYPE, reserved);

      int_ptr->serv_redir.redir.rec2.num_chans =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, num_chans ));
      msg_pos += FSIZ(RTYPE, num_chans );

      if ((len - msg_pos) >=
          (int_ptr->serv_redir.redir.rec2.num_chans * FSIZ(RTYPE, cdma_chan)))
      {
        for (i=0; i < int_ptr->serv_redir.redir.rec2.num_chans; i++)
        {
          int_ptr->serv_redir.redir.rec2.cdma_chan[i] =
            b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, cdma_chan));
          msg_pos += FSIZ(RTYPE, cdma_chan );
        }
      }
      else
      {
        status = CAIX_INV_MSG_S;
      }

      #undef RTYPE

      break;

    case CAI_JTACS_REDIRECTION_REC:

      #define RTYPE cai_redirect_rec4_type

      int_ptr->serv_redir.redir.rec4.expected_aid =
        b_unpackw(buf_ptr, msg_pos, FSIZ(RTYPE, expected_aid));
      msg_pos += FSIZ(RTYPE, expected_aid);

      int_ptr->serv_redir.redir.rec4.ignore_cdma =
        b_unpackb(buf_ptr, msg_pos, FSIZ(RTYPE, ignore_cdma));
      msg_pos += FSIZ(RTYPE, ignore_cdma);

      #undef RTYPE

      break;

    default:
      MSG_MED( "Invalid rec type %d", int_ptr->serv_redir.record_type, 0, 0 );
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_ext_srvc_redir */

/*===========================================================================

FUNCTION XLATE_EXT_GENERAL_PAGE

DESCRIPTION
  This function translates a Paging Channel General Page Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the General Page message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_general_page
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of page within page message */
  word num_pages;
    /* Number of pages in page array */
  byte add_length;
    /* Number of ADD_PFIELD octets in received General Page Message */
  byte i;
    /* Loop counter */
  boolean invalid_page_rec;
    /* Indicates if we have encountered an invalid page record */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_gen_page_fix_type

  /* ------------------------------------------------------
  ** First determine if the message is of sufficient length
  ** ------------------------------------------------------ */
  if (len < sizeof( cai_gen_page_fix_type ))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    int_ptr->gen_page.config_msg_seq = b_unpackb( PARAMS( config_msg_seq ));
    int_ptr->gen_page.acc_msg_seq    = b_unpackb( PARAMS( acc_msg_seq ));
    int_ptr->gen_page.class_0_done   = b_unpackb( PARAMS( class_0_done ));
    int_ptr->gen_page.class_1_done   = b_unpackb( PARAMS( class_1_done ));
    int_ptr->gen_page.tmsi_done      = b_unpackb( PARAMS( tmsi_done ));
    int_ptr->gen_page.ordered_tmsis  = b_unpackb( PARAMS( ordered_tmsis ));
    int_ptr->gen_page.broadcast_done = b_unpackb( PARAMS( broadcast_done ));

    add_length = b_unpackb( PARAMS( add_length ));

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    ext_msg_pos = sizeof( cai_gen_page_fix_type );

    for (i=0; i < add_length; i++)
    {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
      ext_msg_pos += FSIZ( cai_gen_page_pfield_type, add_pfield );
    }

    /* ----------------------------------
    ** Initialize status to everything ok
    ** ---------------------------------- */
    invalid_page_rec = FALSE;

    num_pages = 0; /* Initialize */

    while ((len >= (CAI_GEN_PAGE_MIN + ext_msg_pos)) &&
           (!invalid_page_rec))
    {
      int_ptr->gen_page.gen_page[num_pages].page_class =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_gen_page_class_type, page_class ));
      ext_msg_pos += FSIZ( cai_gen_page_class_type, page_class );

      int_ptr->gen_page.gen_page[num_pages].page_subclass =
        b_unpackb( buf_ptr, ext_msg_pos,
                   FSIZ( cai_gen_page_class_type, page_subclass ));
      ext_msg_pos += FSIZ( cai_gen_page_class_type, page_subclass );

#ifdef FEATURE_IS2000_REL_A
      if (int_ptr->gen_page.gen_page[num_pages].page_class == CAI_PAGE_CLASS_3 &&
          int_ptr->gen_page.gen_page[num_pages].page_subclass != CAI_PAGE_SUBCLASS_0)
      {
        int_ptr->gen_page.gen_page[num_pages].page_subclass_ext =
          b_unpackb( buf_ptr, ext_msg_pos,
                     FSIZ( cai_gen_page_class_type, page_subclass_ext ));
        ext_msg_pos += FSIZ( cai_gen_page_class_type, page_subclass_ext );
      }
#endif /* FEATURE_IS2000_REL_A */
      switch (int_ptr->gen_page.gen_page[num_pages].page_class)
      {
        case CAI_PAGE_CLASS_0:  /* PAGE_CLASS = '00' */
          if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
              CAI_PAGE_SUBCLASS_0)
          {
            /* -----------------------------------------
            ** PAGE_CLASS = '00' and PAGE_SUBCLASS = '00'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format0.msg_seq =
            b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, msg_seq );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_0_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format0.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format0.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format0.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format0.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_0_sc_0_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '00' and PAGE_SUBCLASS = '01'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format1.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format1.imsi_11_12 =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_1_type, imsi_11_12 ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, imsi_11_12 );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_1_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format1.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format1.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format1.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format1.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_0_sc_1_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '00' and PAGE_SUBCLASS = '10'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format2.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_2_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format2.mcc =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_2_type, mcc ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, mcc );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_2_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format2.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format2.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_2_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format2.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format2.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_2_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_0_sc_2_type, service_option );
            }
          }
          else /* (page_subclass == 3) */
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '00' and PAGE_SUBCLASS = '11'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format3.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_3_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format3.mcc =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_3_type, mcc ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, mcc );

            int_ptr->gen_page.gen_page[num_pages].rec.format3.imsi_11_12 =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_3_type, imsi_11_12 ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, imsi_11_12 );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_0_sc_3_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format3.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format3.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_0_sc_3_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format3.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format3.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_0_sc_3_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_0_sc_3_type, service_option );
            }
          }
          break;

        case CAI_PAGE_CLASS_1: /* PAGE_CLASS == '01' */
          if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
              CAI_PAGE_SUBCLASS_0)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '01' and PAGE_SUBCLASS = '00'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format4.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format4.imsi_addr_num =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_0_type, imsi_addr_num ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, imsi_addr_num );

            int_ptr->gen_page.gen_page[num_pages].rec.format4.imsi_11_12 =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_0_type, imsi_11_12 ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, imsi_11_12 );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_1_sc_0_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format4.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format4.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format4.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format4.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_1_sc_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_1_sc_0_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '01' and PAGE_SUBCLASS = '01'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format5.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format5.imsi_addr_num =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, imsi_addr_num ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, imsi_addr_num );

            int_ptr->gen_page.gen_page[num_pages].rec.format5.mcc =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, mcc ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, mcc );

            int_ptr->gen_page.gen_page[num_pages].rec.format5.imsi_11_12 =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, imsi_11_12 ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, imsi_11_12 );

            b_unpackq(
              buf_ptr, ext_msg_pos, FSIZ( cai_pc_1_sc_1_type, imsi_s ),
              int_ptr->gen_page.gen_page[num_pages].rec.format5.imsi_s );
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, imsi_s );

            int_ptr->gen_page.gen_page[num_pages].rec.format5.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_1_sc_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format5.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format5.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_1_sc_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_1_sc_1_type, service_option );
            }
          }
          else
          {
            /* ---------------------
            ** Illegal page subclass
            ** --------------------- */
            invalid_page_rec = TRUE;
            continue;
          }
          break;

        case CAI_PAGE_CLASS_2:  /* PAGE_CLASS = '10' - TMSI addressing */
          if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
              CAI_PAGE_SUBCLASS_0)
          {
            /* -----------------------------------------
            ** PAGE_CLASS = '10' and PAGE_SUBCLASS = '00'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format8.msg_seq =
            b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_0_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format8.tmsi_code_addr =
              b_unpackd( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_0_type, tmsi_code_addr ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_0_type, tmsi_code_addr );

            int_ptr->gen_page.gen_page[num_pages].rec.format8.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format8.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format8.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_2_sc_0_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '10' and PAGE_SUBCLASS = '01'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format9.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_1_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format9.tmsi_code_addr =
              b_unpackd( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_1_type, tmsi_code_addr ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_1_type, tmsi_code_addr );

            int_ptr->gen_page.gen_page[num_pages].rec.format9.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format9.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format9.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_2_sc_1_type, service_option );
            }
          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '10' and PAGE_SUBCLASS = '10'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format10.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_2_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_2_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format10.tmsi_code_addr =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_2_type, tmsi_code_addr ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_2_type, tmsi_code_addr );

            int_ptr->gen_page.gen_page[num_pages].rec.format10.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_2_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_2_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format10.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format10.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_2_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_2_sc_2_type, service_option );
            }
          }
          else /* (page_subclass == 3) */
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '10' and PAGE_SUBCLASS = '11'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format11.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_3_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format11.tmsi_zone_len =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_3_type, tmsi_zone_len ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, tmsi_zone_len );

            /* Initialize destination TMSI zone to zero */
            /* before unpacking.                        */
            qw_set(
              int_ptr->gen_page.gen_page[num_pages].rec.format11.info.tmsi_zone,
              0L, 0L );

            b_unpackq(
              buf_ptr, ext_msg_pos,
              (int_ptr->gen_page.gen_page[num_pages].rec.format11.tmsi_zone_len * 8 ),
              int_ptr->gen_page.gen_page[num_pages].rec.format11.info.tmsi_zone );
            ext_msg_pos +=
              int_ptr->gen_page.gen_page[num_pages].rec.format11.tmsi_zone_len * 8;

            int_ptr->gen_page.gen_page[num_pages].rec.format11.info.tmsi_code =
              b_unpackd( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_3_type, tmsi_code_addr ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, tmsi_code_addr );

            int_ptr->gen_page.gen_page[num_pages].rec.format11.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_2_sc_3_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format11.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format11.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_2_sc_3_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_2_sc_3_type, service_option );
            }
          }
          break;

        case CAI_PAGE_CLASS_3:
          if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
              CAI_PAGE_SUBCLASS_0)
          {
            /* ------------------------------------------
            ** PAGE_CLASS = '11' and PAGE_SUBCLASS = '00'
            ** ------------------------------------------ */
            int_ptr->gen_page.gen_page[num_pages].rec.format12.burst_type =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_0_fix_type, burst_type ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_0_fix_type, burst_type );

            int_ptr->gen_page.gen_page[num_pages].rec.format12.addr_len =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_0_fix_type, addr_len ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_0_fix_type, addr_len );

            for (i=0; i < int_ptr->gen_page.gen_page[num_pages].
                 rec.format12.addr_len; i++)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format12.bc_addr[i] =
                b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_0_var_type, bc_addr ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_0_var_type, bc_addr );
            }
          }
#ifdef FEATURE_IS2000_REL_A
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_0)
          {
            /* For page format 13.0, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format13_0.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_0_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_0_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format13_0.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format13_0.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format13_0.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_1_sce_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_0_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_1)
          {
            /* For format 13.1, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format13_1.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_1_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_1_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format13_1.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format13_1.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format13_1.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_1_sce_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_1_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_2)
          {
            /* For format 13.2, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format13_2.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_2_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_2_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_2_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format13_2.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_2_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_2_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format13_2.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format13_2.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_1_sce_2_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_2_type, service_option );
            }


          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_1 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_3)
          {
            /* For format 13.3, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format13_3.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_3_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_3_type, msg_seq );

            int_ptr->gen_page.gen_page[num_pages].rec.format13_3.length =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_3_type, length ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_3_type, length );

            /* Skip the reserved fields */
            ext_msg_pos += (8*int_ptr->gen_page.gen_page[num_pages].rec.format13_3.length
              + FSIZ( cai_pc_3_sc_1_sce_3_type, reserved ));

            int_ptr->gen_page.gen_page[num_pages].rec.format13_3.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_1_sce_3_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_3_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format13_3.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format13_3.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_1_sce_3_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_1_sce_3_type, service_option );
            }


          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_0)
          {
            /* For format 14.0, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format14_0.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_0_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_0_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_0_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format14_0.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_0_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_0_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format14_0.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format14_0.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_2_sce_0_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_0_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_1)
          {
            /* For format 14.1, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format14_1.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_1_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_1_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_1_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format14_1.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_1_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_1_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format14_1.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format14_1.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_2_sce_1_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_1_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_2 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_2)
          {
            /* For format 14.1, skip this record */
            int_ptr->gen_page.gen_page[num_pages].rec.format14_2.msg_seq =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_2_type, msg_seq ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_2_type, msg_seq );

            /* Skip the reserved fields */
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_2_type, reserved );

            int_ptr->gen_page.gen_page[num_pages].rec.format14_2.special_service =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_2_sce_2_type, special_service ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_2_type, special_service );

            if (int_ptr->gen_page.gen_page[num_pages].rec.format14_2.special_service)
            {
              int_ptr->gen_page.gen_page[num_pages].rec.format14_2.service_option =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_2_sce_2_type, service_option ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_2_sce_2_type, service_option );
            }

          }
          else if (int_ptr->gen_page.gen_page[num_pages].page_subclass ==
                   CAI_PAGE_SUBCLASS_3 &&
                   int_ptr->gen_page.gen_page[num_pages].page_subclass_ext ==
                   CAI_PAGE_SUBCLASS_EXT_0)
          {
            /* -------------------------------------------
            ** PAGE_CLASS = '11' and PAGE_SUBCLASS = '11'
            ** and PAGE_SUBCLASS_EXT = '00'
            ** ------------------------------------------- */
            caii_pc_3_sc_3_sce_0_type *pg_ptr;

            pg_ptr = &int_ptr->gen_page.gen_page[num_pages].rec.format15_0;

            pg_ptr->burst_type =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type, burst_type ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type, burst_type );

            pg_ptr->addr_len =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type, addr_len ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type, addr_len );

            for (i=0; i < pg_ptr->addr_len; i++)
            {
              pg_ptr->bc_addr[i] =
                b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_3_sce_0_var1_type, bc_addr ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_var1_type, bc_addr );
            }

            pg_ptr->ext_bcast_sdu_length_ind =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                               ext_bcast_sdu_length_ind ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                              ext_bcast_sdu_length_ind );

            if (pg_ptr->ext_bcast_sdu_length_ind == 2 ||
                pg_ptr->ext_bcast_sdu_length_ind == 3)
            {
              pg_ptr->ext_bcast_sdu_length =
                b_unpackb( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                                 ext_bcast_sdu_length ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                                ext_bcast_sdu_length );

            }

            pg_ptr->bcn =
              b_unpackb( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type, bcn ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type, bcn );

            pg_ptr->time_offset =
              b_unpackw( buf_ptr, ext_msg_pos,
                         FSIZ( cai_pc_3_sc_3_sce_0_fix_type, time_offset ));
            ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type, time_offset );

            if (pg_ptr->ext_bcast_sdu_length_ind == 1 ||
                pg_ptr->ext_bcast_sdu_length_ind == 3)
            {
              /* Length of the SDU is 18 or 18+8k */
              pg_ptr->repeat_time_offset =
                b_unpackw( buf_ptr, ext_msg_pos,
                           FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                                 repeat_time_offset ));
              ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_fix_type,
                                repeat_time_offset );

            }
            else
            {
              /* if ext_bcast_sdu_length_ind is 0 or 2 */
              /* Length of the SDU is 13 or 13+8k */
              pg_ptr->repeat_time_offset = CAI_INV_REPEAT_TIME_OFFSET;
            }

            if (pg_ptr->ext_bcast_sdu_length_ind == 2 ||
                pg_ptr->ext_bcast_sdu_length_ind == 3)
            {
              for (i=0; i < pg_ptr->ext_bcast_sdu_length; i++)
              {
                pg_ptr->add_bcast_record[i] =
                  b_unpackb( buf_ptr, ext_msg_pos,
                             FSIZ( cai_pc_3_sc_3_sce_0_var2_type,
                                   add_bcast_record ));
                ext_msg_pos += FSIZ( cai_pc_3_sc_3_sce_0_var2_type,
                                  add_bcast_record );
              }
            }
          }
#endif /* FEATURE_IS2000_REL_A */
          else
          {
            /* ---------------------
            ** Illegal page subclass
            ** --------------------- */
            invalid_page_rec = TRUE;
            continue;
          }
          break;

        default:
          /* ------------------
          ** Illegal page class
          ** ------------------ */
          invalid_page_rec = TRUE;
          continue;
      } /* end switch (page_class) */

      num_pages++;
    } /* end of while */

    int_ptr->gen_page.num_pages = num_pages;

    status = CAIX_DONE_S;
  }

  #undef MTYPE
  return (status);

} /* xlate_ext_general_page */

#ifdef FEATURE_IS2000_REL_A_CC
/*===========================================================================

FUNCTION XLATE_EXT_UNIV_PAGE_COMMON_FIELD

DESCRIPTION
  This function translates the common fields of Universal Page from external
  to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_univ_page_common_field
(
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  word *offset,
    /* Offset from the buffer pointer to start translation */
  caii_univ_page_common_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;        /* Status returned to calling procedure */

  status = CAIX_DONE_S;

  int_ptr->config_msg_seq = b_unpackb( buf_ptr, *offset,
    FSIZ( cai_univ_page_fix_type, config_msg_seq ));
  *offset += FSIZ( cai_univ_page_fix_type, config_msg_seq );
  int_ptr->acc_msg_seq = b_unpackb( buf_ptr, *offset,
    FSIZ( cai_univ_page_fix_type, acc_msg_seq ));
  *offset += FSIZ( cai_univ_page_fix_type, acc_msg_seq );
  int_ptr->read_next_slot = b_unpackb( buf_ptr, *offset,
    FSIZ( cai_univ_page_fix_type, read_next_slot ));
  *offset += FSIZ( cai_univ_page_fix_type, read_next_slot );
  int_ptr->read_next_slot_bcast = b_unpackb( buf_ptr, *offset,
    FSIZ( cai_univ_page_fix_type, read_next_slot_bcast ));
  *offset += FSIZ( cai_univ_page_fix_type, read_next_slot_bcast );

   return (status);

} /* xlate_ext_univ_page_common_field */

/*===========================================================================

FUNCTION XLATE_EXT_UNIV_PAGE_INTERLEAVED_ADDR_FIELD

DESCRIPTION
  This function translates interleaved address fields of Universal Page from
  external to internal format.

DEPENDENCIES
  Fields prior to specified one must be translated.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_univ_page_interleaved_addr_field
(
  caii_univ_page_field_type msg_field,
    /* Translation state */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  word *offset,
    /* Offset from the buffer pointer to start translation */
  caii_univ_page_interleaved_addr_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;   /* Status returned to calling procedure */
  int  i;        /* Loop counter */
#ifndef FEATURE_MSG_PACK_UNIT_TEST
  int bit_pos;
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */
  qword *tmp_ptr;

  status = CAIX_DONE_S;

  switch (msg_field)
  {
    case CAII_UPM_BCAST_INCLUDED:

      int_ptr->bcast_included = b_unpackb( buf_ptr, *offset,
        FSIZ( cai_univ_page_fix_type, bcast_included ));
      *offset += FSIZ( cai_univ_page_fix_type, bcast_included );
      break;

    case CAII_UPM_NUM_BCAST:

      if (int_ptr->bcast_included)
      {
        int_ptr->num_bcast = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_var_type, num_bcast ));
        *offset += FSIZ( cai_univ_page_var_type, num_bcast );
      }
      else
      {
        int_ptr->num_bcast = 0;
      }
      break;

    case CAII_UPM_IMSI_INCLUDED:

      int_ptr->imsi_included = b_unpackb( buf_ptr, *offset,
        FSIZ( cai_univ_page_fix_type, imsi_included ));
      *offset += FSIZ( cai_univ_page_fix_type, imsi_included );
      break;

    case CAII_UPM_NUM_IMSI:

      if (int_ptr->imsi_included)
      {
        int_ptr->num_imsi = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_var_type, num_imsi ));
        *offset += FSIZ( cai_univ_page_var_type, num_imsi );
      }
      break;

    case CAII_UPM_TMSI_INCLUDED:

      int_ptr->tmsi_included = b_unpackb( buf_ptr, *offset,
        FSIZ( cai_univ_page_fix_type, tmsi_included ));
      *offset += FSIZ( cai_univ_page_fix_type, tmsi_included );
      break;

    case CAII_UPM_NUM_TMSI:

      if (int_ptr->tmsi_included)
      {
        int_ptr->num_tmsi = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_var_type, num_tmsi ));
        *offset += FSIZ( cai_univ_page_var_type, num_tmsi );
      }
      else
      {
        int_ptr->num_tmsi = 0;
      }
      break;

    case CAII_UPM_RES_TYPE_INCLUDED:

      int_ptr->res_type_included = b_unpackb( buf_ptr, *offset,
        FSIZ( cai_univ_page_fix_type, res_type_included ));
      *offset += FSIZ( cai_univ_page_fix_type, res_type_included );
      break;

    case CAII_UPM_NUM_RES_TYPE:

      if (int_ptr->res_type_included)
      {
        int_ptr->num_res_type = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_var_type, num_res_type ));
        *offset += FSIZ( cai_univ_page_var_type, num_res_type );
      }
      else
      {
        int_ptr->num_res_type = 0;
      }
      break;

    case CAII_UPM_BURST_TYPE:

      if (int_ptr->bcast_included)
      {
        for (i=0; i<=int_ptr->num_bcast; i++)
        {
          int_ptr->burst_type[i] = b_unpackb( buf_ptr,
            *offset, FSIZ( cai_univ_page_var_type, burst_type ));
          *offset += FSIZ( cai_univ_page_var_type, burst_type );
        }
      }
      break;

    case CAII_UPM_ADDR_BLOCK:

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
      {
        if (int_ptr->bcast_included)
        {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
          /* Reassemble the service field of broadcast address from
             broadcast partial address bits */
          (void) b_unpackd(buf_ptr, *offset, int_ptr->num_bcast + 1);
          bit_pos = CAI_UNIV_PAGE_INTERLEAVED_ADDR_PORTION -
            int_ptr->iaddr_portion_rxed - 1;
          for (i=0; i<=int_ptr->num_bcast; i++)
          {
            b_copy(buf_ptr, *offset, int_ptr->bc_addr[i],
              bit_pos, 1);
            *offset += 1;
          }
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
        }

        if (int_ptr->imsi_included)
        {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
          tmp_ptr = &int_ptr->imsi_addr; /*lint !e545*/
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
          b_unpackq(buf_ptr, *offset, int_ptr->num_imsi + 1, *tmp_ptr);
#ifndef FEATURE_MSG_PACK_UNIT_TEST
          qw_shift(*tmp_ptr,
            CAI_UNIV_PAGE_NUM_IMSI_REC_MAX - int_ptr->num_imsi - 1);
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */
          *offset += int_ptr->num_imsi+1;
        }

        if (int_ptr->tmsi_included)
        {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
          tmp_ptr = &int_ptr->tmsi_addr; /*lint !e545*/
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
          b_unpackq(buf_ptr, *offset, int_ptr->num_tmsi + 1, *tmp_ptr);
#ifndef FEATURE_MSG_PACK_UNIT_TEST
          qw_shift(*tmp_ptr,
            CAI_UNIV_PAGE_NUM_TMSI_REC_MAX - int_ptr->num_tmsi - 1);
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */
          *offset += int_ptr->num_tmsi+1;
        }

        if (int_ptr->res_type_included)
        {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
          *offset += int_ptr->num_res_type+1;
        }
      }

#ifndef FEATURE_MSG_PACK_UNIT_TEST
      int_ptr->iaddr_portion_rxed++;
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */

      break;

    default:
      MSG_ERROR("Invalid UPM field %d", msg_field, 0, 0);
      break;
  }

  return (status);

} /* xlate_ext_univ_page_interleaved_addr_field */

/*===========================================================================

FUNCTION XLATE_EXT_UNIV_PAGE_RECORD

DESCRIPTION
  This function translates a Universal Page Record from external to internal
  format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_univ_page_record
(
  byte *buf_ptr,
    /* Pointer to received universal page records block to be translated */
  word *offset,
    /* Pointer to bit offset to start translation of received page record */
  caii_univ_page_rec_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status; /* Status returned to calling procedure */
  int  i;      /* Loop counter */

  status = CAIX_DONE_S;

  int_ptr->page_class = b_unpackb( buf_ptr, *offset,
    FSIZ( cai_gen_page_class_type, page_class ));
  *offset += FSIZ( cai_gen_page_class_type, page_class );

  int_ptr->page_subclass = b_unpackb( buf_ptr, *offset,
    FSIZ( cai_gen_page_class_type, page_subclass ));
  *offset += FSIZ( cai_gen_page_class_type, page_subclass );

  switch (int_ptr->page_class)
  {
    case CAI_PAGE_CLASS_0:  /* PAGE_CLASS = '00' */

      if (int_ptr->page_subclass > CAI_PAGE_SUBCLASS_3)
      {
        status = CAIX_INV_PAGE_REC_S;
      }
      else
      {
        /* PAGE_SUBCLASS = '00' */
        if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_0)
        {
          caii_univ_page_rec_fmt_0_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt0;

          rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_arq_type, msg_seq ));
          *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

          rec_ptr->imsi_s_33_16 = b_unpackd( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_0_type, imsi_s_33_16 ));
          *offset += FSIZ( cai_univ_page_typespec_0_type, imsi_s_33_16 );

          rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length_incl );

          if (rec_ptr->ext_ms_sdu_length_incl)
          {
            rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
            *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
              ext_ms_sdu_length );
          }
          else
          {
            rec_ptr->ext_ms_sdu_length = 0;
          }

          rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

          for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
          {
            rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
            *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
          }
        }

        /* PAGE_SUBCLASS = '01' */
        else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_1)
        {
          caii_univ_page_rec_fmt_1_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt1;

          rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_arq_type, msg_seq ));
          *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

          rec_ptr->imsi_11_12 = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_1_type, imsi_11_12 ));
          *offset += FSIZ( cai_univ_page_typespec_1_type, imsi_11_12 );

          rec_ptr->imsi_s_33_16 = b_unpackd( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_1_type, imsi_s_33_16 ));
          *offset += FSIZ( cai_univ_page_typespec_1_type, imsi_s_33_16 );


          rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length_incl );

          if (rec_ptr->ext_ms_sdu_length_incl)
          {
            rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
            *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
              ext_ms_sdu_length );
          }
          else
          {
            rec_ptr->ext_ms_sdu_length = 0;
          }

          rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

          for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
          {
            rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
            *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
          }
        }

        /* PAGE_SUBCLASS = '10' */
        else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_2)
        {
          caii_univ_page_rec_fmt_2_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt2;

          rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_arq_type, msg_seq ));
          *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

          rec_ptr->mcc = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_2_type, mcc ));
          *offset += FSIZ( cai_univ_page_typespec_2_type, mcc );

          rec_ptr->imsi_s_33_16 = b_unpackd( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_2_type, imsi_s_33_16 ));
          *offset += FSIZ( cai_univ_page_typespec_2_type, imsi_s_33_16 );

          rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length_incl );

          if (rec_ptr->ext_ms_sdu_length_incl)
          {
            rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
            *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
              ext_ms_sdu_length );
          }
          else
          {
            rec_ptr->ext_ms_sdu_length = 0;
          }

          rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

          for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
          {
            rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
            *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
          }
        }

        /* PAGE_SUBCLASS = '11' */
        else
        {
          caii_univ_page_rec_fmt_3_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt3;

          rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_arq_type, msg_seq ));
          *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

          rec_ptr->mcc = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_3_type, mcc ));
          *offset += FSIZ( cai_univ_page_typespec_3_type, mcc );

          rec_ptr->imsi_11_12 = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_3_type, imsi_11_12 ));
          *offset += FSIZ( cai_univ_page_typespec_3_type, imsi_11_12 );

          rec_ptr->imsi_s_33_16 = b_unpackd( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_3_type, imsi_s_33_16 ));
          *offset += FSIZ( cai_univ_page_typespec_3_type, imsi_s_33_16 );

          rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length_incl );

          if (rec_ptr->ext_ms_sdu_length_incl)
          {
            rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
            *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
              ext_ms_sdu_length );
          }
          else
          {
            rec_ptr->ext_ms_sdu_length = 0;
          }

          rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

          for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
          {
            rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
            *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
          }
        }
      }
      break;

    case CAI_PAGE_CLASS_1: /* PAGE_CLASS == '01' */

      /* PAGE_SUBCLASS = '00' */
      if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_0)
      {
        caii_univ_page_rec_fmt_4_type *rec_ptr;
        rec_ptr = &int_ptr->type.fmt4;

        rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_arq_type, msg_seq ));
        *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

        rec_ptr->imsi_addr_num = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_4_type, imsi_addr_num ));
        *offset += FSIZ( cai_univ_page_typespec_4_type, imsi_addr_num );

        rec_ptr->imsi_11_12 = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_4_type, imsi_11_12 ));
        *offset += FSIZ( cai_univ_page_typespec_4_type, imsi_11_12 );

        rec_ptr->imsi_s_33_16 = b_unpackd( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_4_type, imsi_s_33_16 ));
        *offset += FSIZ( cai_univ_page_typespec_4_type, imsi_s_33_16 );

        rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
        *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
          ext_ms_sdu_length_incl );

        if (rec_ptr->ext_ms_sdu_length_incl)
        {
          rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length );
        }
        else
        {
          rec_ptr->ext_ms_sdu_length = 0;
        }

        rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
          FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
        *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

        for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
        {
          rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
        }
      }

      /* PAGE_SUBCLASS = '01' */
      else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_1)
      {
        caii_univ_page_rec_fmt_5_type *rec_ptr;
        rec_ptr = &int_ptr->type.fmt5;

        rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_arq_type, msg_seq ));
        *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

        rec_ptr->imsi_addr_num = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_5_type, imsi_addr_num ));
        *offset += FSIZ( cai_univ_page_typespec_5_type, imsi_addr_num );

        rec_ptr->mcc = b_unpackw( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_5_type, mcc ));
        *offset += FSIZ( cai_univ_page_typespec_5_type, mcc );

        rec_ptr->imsi_11_12 = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_5_type, imsi_11_12 ));
        *offset += FSIZ( cai_univ_page_typespec_5_type, imsi_11_12 );

        rec_ptr->imsi_s_33_16 = b_unpackd( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_5_type, imsi_s_33_16 ));

        *offset += FSIZ( cai_univ_page_typespec_5_type, imsi_s_33_16 );

        rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
        *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
          ext_ms_sdu_length_incl );

        if (rec_ptr->ext_ms_sdu_length_incl)
        {
          rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length );
        }
        else
        {
          rec_ptr->ext_ms_sdu_length = 0;
        }

        rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
          FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
        *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

        for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
        {
          rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
        }
      }

      /* PAGE_SUBCLASS = '10' */
      else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_2)
      {
        caii_univ_page_rec_fmt_6_type *rec_ptr;
        rec_ptr = &int_ptr->type.fmt6;

        rec_ptr->reserved_len = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_6_type, reserved_len ));
        *offset += FSIZ( cai_univ_page_typespec_6_type, reserved_len );
        for (i=0; i<rec_ptr->reserved_len; i++)
        {
          rec_ptr->reserved[i] = b_unpackb( buf_ptr, *offset,
           FSIZ( cai_univ_page_typespec_6_type, reserved ));
          *offset += FSIZ( cai_univ_page_typespec_6_type, reserved );
        }
      }

      /* PAGE_SUBCLASS = '11' */
      else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_3)
      {
        caii_univ_page_rec_fmt_7_type *rec_ptr;
        rec_ptr = &int_ptr->type.fmt7;

        rec_ptr->reserved_len = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_7_type, reserved_len ));
        *offset += FSIZ( cai_univ_page_typespec_7_type, reserved_len );

        for (i=0; i<rec_ptr->reserved_len; i++)
        {
          rec_ptr->reserved[i] = b_unpackb( buf_ptr, *offset,
           FSIZ( cai_univ_page_typespec_7_type, reserved ));
          *offset += FSIZ( cai_univ_page_typespec_7_type, reserved );
        }
      }
      break;

    case CAI_PAGE_CLASS_2:  /* PAGE_CLASS = '10' */

      if (int_ptr->page_subclass > CAI_PAGE_SUBCLASS_3)
      {
        status = CAIX_INV_PAGE_REC_S;
      }
      else
      {
        /* PAGE_SUBCLASS = '00' */
        if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_0)
        {
          caii_univ_page_rec_fmt_8_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt8;

          rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_arq_type, msg_seq ));
          *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

          rec_ptr->tmsi_code_addr_31_16 = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_8_type, tmsi_code_addr_31_16 ));
          *offset += FSIZ( cai_univ_page_typespec_8_type, tmsi_code_addr_31_16 );

          rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length_incl );

          if (rec_ptr->ext_ms_sdu_length_incl)
          {
            rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
            *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
              ext_ms_sdu_length );
          }
          else
          {
            rec_ptr->ext_ms_sdu_length = 0;
          }

          rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

          for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
          {
            rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
            *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
          }
        }

        /* PAGE_SUBCLASS = '01' */
        else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_1)
        {
          caii_univ_page_rec_fmt_9_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt9;

          rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_arq_type, msg_seq ));
          *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

          rec_ptr->tmsi_code_addr_23_16 = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_9_type, tmsi_code_addr_23_16 ));
          *offset += FSIZ( cai_univ_page_typespec_9_type, tmsi_code_addr_23_16 );

          rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length_incl );

          if (rec_ptr->ext_ms_sdu_length_incl)
          {
            rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
            *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
              ext_ms_sdu_length );
          }
          else
          {
            rec_ptr->ext_ms_sdu_length = 0;
          }

          rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

          for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
          {
            rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
            *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
          }
        }

        /* PAGE_SUBCLASS = '10' */
        else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_2)
        {
          caii_univ_page_rec_fmt_10_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt10;

                  rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_arq_type, msg_seq ));
          *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

          rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length_incl );

          if (rec_ptr->ext_ms_sdu_length_incl)
          {
            rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
            *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
              ext_ms_sdu_length );
          }
          else
          {
            rec_ptr->ext_ms_sdu_length = 0;
          }

          rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

          for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
          {
            rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
            *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
          }
        }

        /* PAGE_SUBCLASS = '11' */
        else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_3)
        {
          caii_univ_page_rec_fmt_11_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt11;

          rec_ptr->msg_seq = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_arq_type, msg_seq ));
          *offset += FSIZ( cai_univ_page_arq_type, msg_seq );

          rec_ptr->tmsi_zone_len = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_11_type , tmsi_zone_len));
          *offset += FSIZ( cai_univ_page_typespec_11_type, tmsi_zone_len );

          /* Initialize destination TMSI zone to zero before unpacking. */
          qw_set( rec_ptr->tmsi_zone, 0L, 0L );

          b_unpackq( buf_ptr, *offset, rec_ptr->tmsi_zone_len * 8,
            rec_ptr->tmsi_zone );
          *offset += rec_ptr->tmsi_zone_len * 8;

          rec_ptr->tmsi_code_addr_31_16 = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_11_type, tmsi_code_addr_31_16 ));
          *offset += FSIZ( cai_univ_page_typespec_11_type, tmsi_code_addr_31_16 );

          rec_ptr->ext_ms_sdu_length_incl = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length_incl ));
          *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
            ext_ms_sdu_length_incl );

          if (rec_ptr->ext_ms_sdu_length_incl)
          {
            rec_ptr->ext_ms_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_recspec_type, ext_ms_sdu_length ));
            *offset += FSIZ( cai_univ_page_ms_addr_recspec_type,
              ext_ms_sdu_length );
          }
          else
          {
            rec_ptr->ext_ms_sdu_length = 0;
          }

          rec_ptr->service_option = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_ms_addr_sdu_type, service_option ));
          *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, service_option );

          for (i = 0; i < rec_ptr->ext_ms_sdu_length; i++)
          {
            rec_ptr->add_ms_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record ));
            *offset += FSIZ( cai_univ_page_ms_addr_sdu_type, add_ms_record );
          }
        }
      }
      break;

    case CAI_PAGE_CLASS_3: /* PAGE_CLASS = '11' */

      /* PAGE_SUBCLASS = '00' */
      if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_0)
      {
        caii_univ_page_rec_fmt_12_type *rec_ptr;
        rec_ptr = &int_ptr->type.fmt12;

        rec_ptr->burst_type = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_12_type, burst_type ));
        *offset += FSIZ( cai_univ_page_typespec_12_type, burst_type );
        rec_ptr->addr_len = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_12_type, addr_len ));
        *offset += FSIZ( cai_univ_page_typespec_12_type, addr_len );
        for (i = 0; i < rec_ptr->addr_len; i++)
        {
          rec_ptr->bc_addr[i] = b_unpackb( buf_ptr, *offset,
          FSIZ( cai_univ_page_typespec_12_type, bc_addr ));
          *offset += FSIZ( cai_univ_page_typespec_12_type, bc_addr );
        }
      }

      /* PAGE_SUBCLASS = '01' */
      else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_1)
      {
        int_ptr->page_subclass_ext = b_unpackb( buf_ptr,
          *offset, FSIZ( cai_gen_page_class_type, page_subclass_ext ));
        *offset += FSIZ( cai_gen_page_class_type, page_subclass_ext );

        /* PAGE_SUBCLASS_EXT = '00' */
        if (int_ptr->page_subclass_ext == CAI_PAGE_SUBCLASS_EXT_0)
        {
          caii_univ_page_rec_fmt_13_0_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt13_0;

          rec_ptr->reserved = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_13_0_type, reserved ));
          *offset += FSIZ( cai_univ_page_typespec_13_0_type, reserved );
        }

        /* PAGE_SUBCLASS_EXT = '01' */
        else if (int_ptr->page_subclass_ext == CAI_PAGE_SUBCLASS_EXT_1)
        {
          caii_univ_page_rec_fmt_13_1_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt13_1;

          rec_ptr->reserved = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_13_1_type, reserved ));
          *offset += FSIZ( cai_univ_page_typespec_13_1_type, reserved );
        }

        /* PAGE_SUBCLASS_EXT = '11' */
        else if (int_ptr->page_subclass_ext == CAI_PAGE_SUBCLASS_EXT_3)
        {
          caii_univ_page_rec_fmt_13_3_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt13_3;

          rec_ptr->reserved_len = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_13_3_type, reserved_len ));
          *offset += FSIZ( cai_univ_page_typespec_13_3_type, reserved_len );
          for (i = 0; i < rec_ptr->reserved_len+2; i++)
          {
            rec_ptr->reserved[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_typespec_13_3_type, reserved ));
            *offset += FSIZ( cai_univ_page_typespec_13_3_type, reserved );
          }
        }
      }

      /* PAGE_SUBCLASS = '10' */
      else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_2)
      {
        int_ptr->page_subclass_ext = b_unpackb( buf_ptr,
          *offset, FSIZ( cai_gen_page_class_type, page_subclass_ext ));
        *offset += FSIZ( cai_gen_page_class_type, page_subclass_ext );

        /* PAGE_SUBCLASS_EXT = '00' */
        if (int_ptr->page_subclass_ext == CAI_PAGE_SUBCLASS_EXT_0)
        {
          caii_univ_page_rec_fmt_14_0_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt14_0;

          rec_ptr->reserved = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_14_0_type, reserved ));
          *offset += FSIZ( cai_univ_page_typespec_14_0_type, reserved );
        }

        /* PAGE_SUBCLASS_EXT = '01' */
        else if (int_ptr->page_subclass_ext == CAI_PAGE_SUBCLASS_EXT_1)
        {
          caii_univ_page_rec_fmt_14_1_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt14_1;

          b_unpackq( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_14_1_type, reserved),
            rec_ptr->reserved );
          *offset += FSIZ( cai_univ_page_typespec_14_1_type, reserved );
        }

        /* PAGE_SUBCLASS_EXT = '10' */
        else if (int_ptr->page_subclass_ext == CAI_PAGE_SUBCLASS_EXT_2)
        {
          caii_univ_page_rec_fmt_14_2_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt14_2;

          b_unpackq( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_14_2_type, reserved),
            rec_ptr->reserved );
          *offset += FSIZ( cai_univ_page_typespec_14_2_type, reserved );
        }

        /* PAGE_SUBCLASS_EXT = '11' */
        else
        {
          caii_univ_page_rec_fmt_14_3_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt14_3;

          rec_ptr->reserved_len = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_14_3_type, reserved_len ));
          *offset += FSIZ( cai_univ_page_typespec_14_3_type, reserved_len );
          for (i = 0; i < rec_ptr->reserved_len; i++)
          {
            rec_ptr->reserved[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_typespec_14_3_type, reserved ));
            *offset += FSIZ( cai_univ_page_typespec_14_3_type, reserved );
          }
        }
      }

      /* PAGE_SUBCLASS = '11' */
      else if (int_ptr->page_subclass == CAI_PAGE_SUBCLASS_3)
      {
        int_ptr->page_subclass_ext = b_unpackb( buf_ptr,
          *offset, FSIZ( cai_gen_page_class_type, page_subclass_ext ));
        *offset += FSIZ( cai_gen_page_class_type, page_subclass_ext );

        /* PAGE_SUBCLASS_EXT = '00' */
        if (int_ptr->page_subclass_ext == CAI_PAGE_SUBCLASS_EXT_0)
        {
          caii_univ_page_rec_fmt_15_0_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt15_0;

          rec_ptr->addr_len = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_15_0_type, addr_len ));
          *offset += FSIZ( cai_univ_page_typespec_15_0_type, addr_len );

          for (i = 0; i < rec_ptr->addr_len - 2; i++)
          {
            rec_ptr->bc_addr_remainder[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_typespec_15_0_type, bc_addr_remainder ));
            *offset += FSIZ( cai_univ_page_typespec_15_0_type,
              bc_addr_remainder );
          }

          rec_ptr->ext_bcast_sdu_length_ind = b_unpackb( buf_ptr,
            *offset, FSIZ( cai_univ_page_en_bcast_recspec_type,
            ext_bcast_sdu_length_ind ));
          *offset += FSIZ( cai_univ_page_en_bcast_recspec_type,
            ext_bcast_sdu_length_ind );

          if ((rec_ptr->ext_bcast_sdu_length_ind  == 2) ||
              (rec_ptr->ext_bcast_sdu_length_ind  == 3))
          {
            rec_ptr->ext_bcast_sdu_length = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_en_bcast_recspec_type,
              ext_bcast_sdu_length ));
            *offset += FSIZ( cai_univ_page_en_bcast_recspec_type,
              ext_bcast_sdu_length );
          }
          else
          {
            rec_ptr->ext_bcast_sdu_length = 0;
          }

          rec_ptr->bcn = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_en_bcast_sdu_type, bcn ));
          *offset += FSIZ( cai_univ_page_en_bcast_sdu_type, bcn );

          rec_ptr->time_offset = b_unpackw( buf_ptr, *offset,
            FSIZ( cai_univ_page_en_bcast_sdu_type, time_offset ));
          *offset += FSIZ( cai_univ_page_en_bcast_sdu_type, time_offset );

          if ((rec_ptr->ext_bcast_sdu_length_ind  == 1) ||
              (rec_ptr->ext_bcast_sdu_length_ind  == 3))
          {
            rec_ptr->repeat_time_offset = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_en_bcast_sdu_type, repeat_time_offset ));
            *offset += FSIZ( cai_univ_page_en_bcast_sdu_type,
              repeat_time_offset );
          }
          else
          {
            rec_ptr->repeat_time_offset = CAI_INV_REPEAT_TIME_OFFSET;
          }
          for (i = 0; i < rec_ptr->ext_bcast_sdu_length; i++)
          {
            rec_ptr->add_bcast_record[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_en_bcast_sdu_type, add_bcast_record ));
            *offset += FSIZ( cai_univ_page_en_bcast_sdu_type,
              add_bcast_record );
          }
        }

        /* PAGE_SUBCLASS_EXT = '11' */
        else if (int_ptr->page_subclass_ext == CAI_PAGE_SUBCLASS_EXT_3)
        {
          caii_univ_page_rec_fmt_15_3_type *rec_ptr;
          rec_ptr = &int_ptr->type.fmt15_3;

          rec_ptr->reserved_len = b_unpackb( buf_ptr, *offset,
            FSIZ( cai_univ_page_typespec_15_3_type, reserved_len ));
          *offset += FSIZ( cai_univ_page_typespec_15_3_type, reserved_len );

          for (i = 0; i < rec_ptr->reserved_len; i++)
          {
            rec_ptr->reserved[i] = b_unpackb( buf_ptr, *offset,
              FSIZ( cai_univ_page_typespec_15_3_type, reserved ));
            *offset += FSIZ( cai_univ_page_typespec_15_3_type, reserved );
          }
        }
      }
      break;

    default: /* Illegal page class */
      status = CAIX_INV_PAGE_REC_S;
      break;
  }

  return (status);

} /* xlate_ext_univ_page_record */

/*===========================================================================

FUNCTION XLATE_EXT_UNIV_PAGE

DESCRIPTION
  This function translates a Universal Page Message from external to internal
  format.  Only common fields and interleaved address fields (other than
  address block) are translated in this routine.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Universal Page message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_univ_page
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;            /* Status returned to calling procedure */
  word ext_msg_pos;          /* Position of page within page message */
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_univ_page_fix_type

  /* msg_type has already been unpacked */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  /* ------------------------------------------------------
  ** First determine if the message is of sufficient length
  ** ------------------------------------------------------ */
  if (len < sizeof( cai_univ_page_fix_type ))
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */

    /* Common fields */
    if ((status = xlate_ext_univ_page_common_field(buf_ptr, &ext_msg_pos,
         &int_ptr->upm.common)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - bcast_included */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_BCAST_INCLUDED, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - num_bcast */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_NUM_BCAST, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - imsi_included */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_IMSI_INCLUDED, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - num_imsi */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_NUM_IMSI, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - tmsi_included */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_TMSI_INCLUDED, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - num_tmsi */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_NUM_TMSI, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - res_type_included */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_RES_TYPE_INCLUDED, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - num_res_type */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_NUM_RES_TYPE, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

    /* Interleaved address fields - burst_type */
    if ((status = xlate_ext_univ_page_interleaved_addr_field(
         CAII_UPM_BURST_TYPE, buf_ptr, &ext_msg_pos,
         &int_ptr->upm.interleaved_addr)) != CAIX_DONE_S)
    {
      return (status);
    }

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else /* FEATURE_MSG_PACK_UNIT_TEST */
    /* Mark the start of partial address matching */
    int_ptr->upm.interleaved_addr.initialized = FALSE;
    int_ptr->upm.interleaved_addr.iaddr_portion_rxed =
    int_ptr->upm.interleaved_addr.iaddr_portion_matched = 0;
    int_ptr->upm.page_block.offset = 0;
    int_ptr->upm.page_block.length = len - ext_msg_pos;
    /* Parsing page block is done later in the partial address match operation
       and page match operation. */
    b_copy(buf_ptr, ext_msg_pos, int_ptr->upm.page_block.data, 0,
      int_ptr->upm.page_block.length);
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_univ_page */

/*===========================================================================

FUNCTION XLATE_EXT_UNIV_PAGE_SEGMENT

DESCRIPTION
  This function translates a Universal Page Segment Message from external to
  internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Universal Page message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_univ_page_segment
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;   /* Status returned to calling procedure */
  word ext_msg_pos; /* Position of page within page message */

  status = CAIX_DONE_S;

  /* -----------------------------
  ** Set up MTYPE for PARAMS macro
  ** ----------------------------- */
  #define MTYPE cai_univ_page_seg_type

  /* msg_type has already been unpacked */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  switch (int_ptr->gen_pc.msg_type)
  {
    case CAI_UPM_FIRST_SEG_MSG:
      int_ptr->upsm.page_seg_block_len = len - ext_msg_pos;
      b_copy(buf_ptr, ext_msg_pos, int_ptr->upsm.page_seg_block, 0,
        int_ptr->upsm.page_seg_block_len);
      break;

    case CAI_UPM_MIDDLE_SEG_MSG:
    case CAI_UPM_FINAL_SEG_MSG:
      UNPACKB_PG(upsm.segment_seq, MTYPE, segment_seq);
      int_ptr->upsm.page_seg_block_len = len - ext_msg_pos;
      b_copy(buf_ptr, ext_msg_pos, int_ptr->upsm.page_seg_block, 0,
        int_ptr->upsm.page_seg_block_len);
      break;

    default:
      status = CAIX_INV_MSG_S;
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_univ_page_segment */

/*===========================================================================

FUNCTION XLATE_EXT_SEGMENTED_UNIV_PAGE

DESCRIPTION
  This function translates a Universal Page Message which reassembled from
  Universal Page Segment Messages from external to internal format. Only
  common fields and interleaved address fields (other than address block)
  are translated in this routine.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_segmented_univ_page
(
  caii_seg_univ_page_type *seg_ptr
    /* Pointer to segmented Universal Page assembly buffer */
)
{
  word status;        /* Status returned to calling procedure */
  word len;           /* Length variable */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  status = CAIX_DONE_S;

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_univ_page_fix_type

  switch (seg_ptr->msg_field)
  {
    case CAII_UPM_CONFIG_MSG_SEQ:

      /* First determine if page block is of sufficient length to do
         translation */
      len = sizeof( cai_univ_page_fix_type ) - FSIZ( MTYPE, msg_type );
      if (seg_ptr->page_block.length < len)
      {
        break;
      }

      /* Common fields */
      if ((status = xlate_ext_univ_page_common_field(
           seg_ptr->page_block.data, &seg_ptr->page_block.offset,
           &seg_ptr->common)) != CAIX_DONE_S)
      {
        break;
      }

      /* Interleaved address fields - bcast_included */
      if ((status = xlate_ext_univ_page_interleaved_addr_field(
           CAII_UPM_BCAST_INCLUDED, seg_ptr->page_block.data,
           &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
           CAIX_DONE_S)
      {
        break;
      }
      /* fall through */
      /*lint -fallthrough */
    case CAII_UPM_NUM_BCAST:

      /* First determine if page block is of sufficient length to do
         translation */
      len = seg_ptr->page_block.offset + FSIZ( MTYPE, imsi_included );
      if (seg_ptr->interleaved_addr.bcast_included)
      {
        len += FSIZ( cai_univ_page_var_type, num_bcast );
      }
      if (seg_ptr->page_block.length < len)
      {
        seg_ptr->msg_field = CAII_UPM_NUM_BCAST;
        break;
      }

      /* Interleaved address fields - num_bcast */
      if ((status = xlate_ext_univ_page_interleaved_addr_field(
           CAII_UPM_NUM_BCAST, seg_ptr->page_block.data,
           &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
           CAIX_DONE_S)
      {
        break;
      }

      /* Interleaved address fields - imsi_included */
      if ((status = xlate_ext_univ_page_interleaved_addr_field(
           CAII_UPM_IMSI_INCLUDED, seg_ptr->page_block.data,
           &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
           CAIX_DONE_S)
      {
        break;
      }
      /* fall through */
      /*lint -fallthrough */
    case CAII_UPM_NUM_IMSI:

      /* First determine if page block is of sufficient length to do
         translation */
      len = seg_ptr->page_block.offset + FSIZ( MTYPE, tmsi_included );
      if (seg_ptr->interleaved_addr.imsi_included)
      {
        len += FSIZ( cai_univ_page_var_type, num_imsi );
      }
      if (seg_ptr->page_block.length < len)
      {
        seg_ptr->msg_field = CAII_UPM_NUM_IMSI;
        break;
      }

      /* Interleaved address fields - num_imsi */
      if ((status = xlate_ext_univ_page_interleaved_addr_field(
           CAII_UPM_NUM_IMSI, seg_ptr->page_block.data,
           &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
           CAIX_DONE_S)
      {
        break;
      }

      /* Interleaved address fields - tmsi_included */
      if ((status = xlate_ext_univ_page_interleaved_addr_field(
           CAII_UPM_TMSI_INCLUDED, seg_ptr->page_block.data,
           &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
           CAIX_DONE_S)
      {
        break;
      }
      /* fall through */
      /*lint -fallthrough */
    case CAII_UPM_NUM_TMSI:

      /* First determine if page block is of sufficient length to do
         translation */
      len = seg_ptr->page_block.offset + FSIZ( MTYPE, res_type_included );
      if (seg_ptr->interleaved_addr.tmsi_included)
      {
        len += FSIZ( cai_univ_page_var_type, num_tmsi );
      }
      if (seg_ptr->page_block.length < len)
      {
        seg_ptr->msg_field = CAII_UPM_NUM_TMSI;
        break;
      }

      /* Interleaved address fields - num_tmsi */
      if ((status = xlate_ext_univ_page_interleaved_addr_field(
           CAII_UPM_NUM_TMSI, seg_ptr->page_block.data,
           &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
           CAIX_DONE_S)
      {
        break;
      }

      /* Interleaved address fields - res_type_included */
      if ((status = xlate_ext_univ_page_interleaved_addr_field(
           CAII_UPM_RES_TYPE_INCLUDED, seg_ptr->page_block.data,
           &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
           CAIX_DONE_S)
      {
        break;
      }
      /* fall through */
      /*lint -fallthrough */
    case CAII_UPM_NUM_RES_TYPE:

      /* First determine if page block is of sufficient length to do
         translation */
      if (seg_ptr->interleaved_addr.res_type_included)
      {
        len = seg_ptr->page_block.offset +
              FSIZ( cai_univ_page_var_type, num_res_type );
      }
      else
      {
        len = 0;
      }
      if (seg_ptr->page_block.length < len)
      {
        seg_ptr->msg_field = CAII_UPM_NUM_RES_TYPE;
        break;
      }

      /* Interleaved address fields - num_res_type */
      if ((status = xlate_ext_univ_page_interleaved_addr_field(
           CAII_UPM_NUM_RES_TYPE, seg_ptr->page_block.data,
           &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
           CAIX_DONE_S)
      {
        break;
      }
      /* fall through */
      /*lint -fallthrough */
    case CAII_UPM_BURST_TYPE:

      /* First determine if page block is of sufficient length to do
         translation */
      if (seg_ptr->interleaved_addr.bcast_included)
      {
        len = seg_ptr->page_block.offset +
              ((seg_ptr->interleaved_addr.num_bcast + 1) *
                FSIZ( cai_univ_page_var_type, burst_type ));
        if (seg_ptr->page_block.length < len)
        {
          seg_ptr->msg_field = CAII_UPM_BURST_TYPE;
          break;
        }

        /* Interleaved address fields - burst type */
        if ((status = xlate_ext_univ_page_interleaved_addr_field(
             CAII_UPM_BURST_TYPE, seg_ptr->page_block.data,
             &seg_ptr->page_block.offset, &seg_ptr->interleaved_addr)) !=
             CAIX_DONE_S)
        {
          break;
        }
      }
      if (!seg_ptr->interleaved_addr.bcast_included &&
          !seg_ptr->interleaved_addr.imsi_included &&
          !seg_ptr->interleaved_addr.tmsi_included)
      {
        seg_ptr->msg_field = CAII_UPM_DONE;
        break;
      }
      seg_ptr->msg_field = CAII_UPM_ADDR_BLOCK;

      break;

    default:
      /* Should never be here */
      MSG_ERROR("Invalid UPM msg field %d", seg_ptr->msg_field, 0, 0);
      break;

  }

  #undef MTYPE

  return (status);

} /* xlate_ext_segmented_univ_page */
#endif /* FEATURE_IS2000_REL_A_CC */

/*===========================================================================

FUNCTION XLATE_EXT_GLOB_REDIR

DESCRIPTION
  This function translates a Paging Channel Global Service Redirection
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Global Service Redirection message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_glob_redir
(
  word len,
    /* Length of message in bits */
    /*lint -esym(715,len) */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  word i;
    /* Index */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_global_redirect_type

  /* -------------------------------------------------
  ** Start translating message at field after msg_type
  ** ------------------------------------------------- */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(glob_redir.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(glob_redir.config_msg_seq, MTYPE, config_msg_seq);
  UNPACKW_PG(glob_redir.redirect_accolc, MTYPE, redirect_accolc);
  UNPACKB_PG(glob_redir.return_if_fail, MTYPE, return_if_fail);
  UNPACKB_PG(glob_redir.delete_tmsi, MTYPE, delete_tmsi);

  /* in pre-IS2000 system, this field is reserved. If P_REV is less than 6,
   * excl_p_rev_ms field has no meaning. */
  UNPACKB_PG(glob_redir.excl_p_rev_ms, MTYPE, reserved);

#ifdef FEATURE_DYNAMIC_P_REV
  if (cdma.mob_cai_rev < P_REV_IS2000)
  {
    int_ptr->glob_redir.excl_p_rev_ms = 0;
  }
#endif /* FEATURE_DYNAMIC_P_REV */

  UNPACKB_PG(glob_redir.record_type, MTYPE, record_type);
  UNPACKB_PG(glob_redir.record_len, MTYPE, record_len);

  /* ---------------------
  ** Switch on record type
  ** --------------------- */
  switch (int_ptr->glob_redir.record_type)
  {
    case CAI_NDSS_OFF_INDICATION:
      /* IS-95B, NDSS off, no type specific fields included */
      break;

    case CAI_ANALOG_REDIRECTION_REC:
      UNPACKW_PG(glob_redir.redir.rec1.expected_sid,
        cai_redirect_rec1_type, expected_sid);
      UNPACKB_PG(glob_redir.redir.rec1.ignore_cdma,
        cai_redirect_rec1_type, ignore_cdma);
      UNPACKB_PG(glob_redir.redir.rec1.sys_ordering,
        cai_redirect_rec1_type, sys_ordering);
      UNPACKB_PG(glob_redir.redir.rec1.max_redirect_delay,
        cai_redirect_rec1_type, max_redirect_delay);
      break;

    case CAI_CDMA_REDIRECTION_REC:
      UNPACKB_PG(glob_redir.redir.rec2.band_class,
        cai_redirect_rec2_type, band_class);
      UNPACKW_PG(glob_redir.redir.rec2.expected_sid,
        cai_redirect_rec2_type, expected_sid);
      UNPACKW_PG(glob_redir.redir.rec2.expected_nid,
        cai_redirect_rec2_type, expected_nid);

      ext_msg_pos += FSIZ(cai_redirect_rec2_type, reserved);

      UNPACKB_PG(glob_redir.redir.rec2.num_chans,
        cai_redirect_rec2_type, num_chans);

      for (i=0; i < int_ptr->glob_redir.redir.rec2.num_chans; i++)
      {
        UNPACKW_PG(glob_redir.redir.rec2.cdma_chan[i],
          cai_redirect_rec2_type, cdma_chan);
      }
      break;

    case CAI_JTACS_REDIRECTION_REC:
      UNPACKW_PG(glob_redir.redir.rec4.expected_aid,
        cai_redirect_rec4_type, expected_aid);
      UNPACKB_PG(glob_redir.redir.rec4.ignore_cdma,
        cai_redirect_rec4_type, ignore_cdma);
      break;

    default:
      MSG_MED( "Invalid rec type %d", int_ptr->glob_redir.record_type, 0, 0 );
      status = CAIX_INV_MSG_S;
      break;

  } /* end of switch */

  #undef MTYPE

  return (status);

} /* xlate_ext_glob_redir */

/*===========================================================================

FUNCTION XLATE_EXT_PACA

DESCRIPTION
  This function translates a Paging Channel PACA
  Message from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the PACA message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_paca
(
  word len,
    /* Length of message in bits */
    /*lint -esym(715,len) */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
             
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------------------------------------
  ** Length is ok - finish converting message from external to internal
  ** format starting with the first field after message_type
  ** ------------------------------------------------------------------ */
  msg_pos = FSIZ( cai_pc_hdr_type, msg_type );

  xlate_ext_pc_hdr( &msg_pos, buf_ptr, &int_ptr->paca.hdr );
  
#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields if
  ** there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
       CAIX_MACI_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->paca.hdr.msg_int, int_ptr->paca.msg_type,
       int_ptr->paca.hdr.ack_req
         )) 
       != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
      &int_ptr->paca.hdr, int_ptr->paca.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define FTYPE cai_paca_type

  /* Skip reserved field */
  msg_pos += FSIZ(FTYPE, reserved);

  int_ptr->paca.purpose  = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, purpose));
  msg_pos += FSIZ(FTYPE, purpose);

  int_ptr->paca.q_pos  = b_unpackb(buf_ptr, msg_pos, FSIZ(FTYPE, q_pos));
  msg_pos += FSIZ(FTYPE, q_pos);

  int_ptr->paca.paca_timeout = b_unpackb(buf_ptr, msg_pos, 
    FSIZ(FTYPE, paca_timeout));
  msg_pos += FSIZ(FTYPE, paca_timeout);

  #undef FTYPE

  return (status);

} /*  xlate_ext_paca  */

/*===========================================================================

FUNCTION XLATE_EXT_EXT_CHN_ASN

DESCRIPTION
  This function translates an ECAM or MEID ECAM from external to internal 
  format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Channel Assignment message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_ext_chn_asn
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of channel assignment order relative to start of buf_ptr */
  byte add_record_len = 0;
    /* Temporary storage for the add_record_len field */
  word num_recs;
    /* Number of variable parts of message */
  word i = 0;
    /* for loop iterator */
  int  j;
    /* Index through parameters */
  word old_ext_msg_pos;
    /* For caculating # of reserved bits in a single chn asn record */
  byte *int_buf_ptr;
    /* Keep track of the starting point of the next packed order */
  word my_fendpos=0;
  word min_len;
    /* Protocol dependent minimum length */
  word temp_len;
#ifdef FEATURE_IS2000_REL_C
  word maci_pos; /* Postion of MACIa field */
#endif /* FEATURE_IS2000_REL_C */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
  #endif  /* FEATURE_IS2000_REL_C_MI */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------
  ** Determine if message is of sufficient length
  ** -------------------------------------------- */
  if (len < CAI_EXT_CHN_ASN_MIN)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------------
    ** Length is ok - initialize pointer and finish converting message
    ** from external to internal format starting with the first field
    ** after message_type
    ** --------------------------------------------------------------- */
    ext_msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

    /* ---------------------------------
    ** Initialize number of records to 0
    ** --------------------------------- */
    num_recs = 0;

    /* ---------------------------------------------------------
    ** Initialize first record pointer to buf
    ** --------------------------------------------------------- */
    int_buf_ptr = int_ptr->ext_chnasn.buf;
    int_buf_ptr = (byte *)ALIGN_DWORD((dword)int_buf_ptr);
    int_ptr->ext_chnasn.chns[0] = (caii_ext_ca_ord_type*)int_buf_ptr;

    while ((len > ext_msg_pos) &&
           ((len - ext_msg_pos) >= CAI_EXT_CHN_ASN_REC_MIN))
    {
      #ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
      #endif /* FEATURE_IS2000_REL_C_AKA */
   
      xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr,
        &int_ptr->ext_chnasn.chns[num_recs]->gen.hdr);

#ifdef FEATURE_IS2000_REL_C
      /* ------------------------------------------------------------------
      ** Now we have to take a look at the Message Integrity fields if
      ** there is one.
      ** ------------------------------------------------------------------ */
      if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd,
           CAIX_MACI_NOT_REQUIRED, &ext_msg_pos,
           buf_ptr, &int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.msg_int,
           int_ptr->ext_chnasn.msg_type,
           int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.ack_req
           )) 
           != CAIX_DONE_S)
      {
        return status;
      }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
      /* ------------------------------------------------------------------
      ** Now we have to take a look at the Extended Encryption fields if
      ** there is one, and run the decryption algorithm.
      ** ------------------------------------------------------------------ */
      if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
           &int_ptr->ext_chnasn.chns[num_recs]->gen.hdr, int_ptr->ext_chnasn.msg_type, 0, 0)) != CAIX_DONE_S)
      {
        return status;
      }
#endif /* FEATURE_IS2000_REL_A */

      /* ----------------------
      ** Unpack base of message
      ** ---------------------- */
      ext_msg_pos += FSIZ(cai_ext_chnasn_base_type, reserved1);

      add_record_len = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(cai_ext_chnasn_base_type, add_record_len));
      ext_msg_pos += FSIZ(cai_ext_chnasn_base_type, add_record_len);

#ifdef FEATURE_IS2000_REL_C
      if ( int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.msg_int.maci_incl )
      {
        /* ------------------------------------------------------------------
        ** Now we have to take a look at the MACI field itself
        ** ------------------------------------------------------------------ */
        maci_pos = ext_msg_pos + add_record_len * 8;

        
        /* Unpack the MACI for this record */
        int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.msg_int.maci =
                    b_unpackd(buf_ptr, maci_pos, FSIZ(cai_msg_int_type, maci));
        

        #ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
        #endif /* FEATURE_IS2000_REL_C_AKA */

      } /* if maci_incl */

#endif /* FEATURE_IS2000_REL_C */
  
#ifdef FEATURE_IS2000_REL_A
      if (int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.enc_fields_incl)
      {
        /* ----------------------------------------------------------
        ** The message is encrypted, have to decrypt it first. The
        ** decryptor accepts the encryption fields, crypto text, and
        ** its start pointer, returns with plain text, and modified
        ** message length, so the parser can continue.
        ** ---------------------------------------------------------- */
        temp_len = add_record_len * 8;

        #ifndef FEATURE_MSG_PACK_UNIT_TEST

        #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
        #else
        if ( int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.enc.sdu_encrypt_mode != CAI_ENC_MODE_DISABLED )
        {
          return CAIX_INV_ENC_MODE_NOT_SUP_S;
        }
        #endif /* FEATURE_IS2000_REL_A_AES */
        
        #endif /* !FEATURE_MSG_PACK_UNIT_TEST */

      } /* enc_fields_incl */
#endif /* FEATURE_IS2000_REL_A */

      UNPACKB_PG(ext_chnasn.chns[num_recs]->gen.assign_mode,
        cai_ext_chnasn_base_type, assign_mode);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
      {
        ext_msg_pos += FSIZ(cai_ext_chnasn_base_type, direct_ch_assign_ind);
      }

      ext_msg_pos += FSIZ(cai_ext_chnasn_base_type, reserved2);

      old_ext_msg_pos = ext_msg_pos;

      /* -------------------------
      ** Switch on Assignment Mode
      ** ------------------------- */
      switch (int_ptr->ext_chnasn.chns[num_recs]->gen.assign_mode)
      {
        /* ASSIGN_MODE = '000' */
        case CAI_TRAFFIC_CHAN_ASSIGN:

          #define MTYPE cai_ext_chnasn_am0_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.freq_incl, MTYPE,
            freq_incl);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.default_config, MTYPE,
            default_config);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.bypass_alert_answer, MTYPE,
            bypass_alert_answer);

          ext_msg_pos += FSIZ(MTYPE, reserved);

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.num_pilots, MTYPE,
            num_pilots);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.granted_mode, MTYPE,
            granted_mode);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.frame_offset, MTYPE,
            frame_offset);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.encrypt_mode, MTYPE,
            encrypt_mode);

          my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, encrypt_mode);

          if (int_ptr->ext_chnasn.chns[num_recs]->am0.freq_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.band_class, MTYPE,
              band_class);
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am0.cdma_freq, MTYPE,
              cdma_freq);

            my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, cdma_freq);
          }

          for (i=0; i < int_ptr->ext_chnasn.chns[num_recs]->am0.num_pilots+1 &&
                    i < CAI_EXT_CHNASN_AM0_MAX; i++)
          {
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am0.pilot_rec[i].pilot_pn,
              MTYPE, pilot_pn);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.pilot_rec[i].pwr_comb_ind,
              MTYPE, pwr_comb_ind);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.pilot_rec[i].code_chan,
              MTYPE, code_chan);

            my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, pilot_rec[i]);
          }

          /* Length check on mandatory fields */
          min_len = FENDPOS( MTYPE, rev_fch_gating_mode ) -
                    FENDPOS( MTYPE, code_chan );
          temp_len = ext_msg_pos - old_ext_msg_pos;
          if ( ( ( temp_len + min_len ) % 8 ) > 0 )
          {
            min_len += 8 - ( temp_len + min_len ) % 8;
          }

          
          if ( ( ( ( add_record_len - 1 ) * 8 ) > temp_len ) && 
               ( ( ( add_record_len - 1 ) * 8 - temp_len ) >= min_len )
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.for_fch_rc, MTYPE,
              for_fch_rc);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rev_fch_rc, MTYPE,
              rev_fch_rc);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_fch_init_setpt,
              MTYPE, fpc_fch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_subchan_gain,
              MTYPE, fpc_subchan_gain);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rl_gain_adj,
              MTYPE, rl_gain_adj);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_fch_fer, MTYPE,
              fpc_fch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_fch_min_setpt,
              MTYPE, fpc_fch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.fpc_fch_max_setpt,
              MTYPE, fpc_fch_max_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rev_fch_gating_mode,
              MTYPE, rev_fch_gating_mode);

            my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, rev_fch_gating_mode);

            if (int_ptr->ext_chnasn.chns[num_recs]->am0.rev_fch_gating_mode)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rev_pwr_cntl_delay_incl,
                MTYPE, rev_pwr_cntl_delay_incl);

              my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, rev_pwr_cntl_delay_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am0.rev_pwr_cntl_delay_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.rev_pwr_cntl_delay,
                  MTYPE, rev_pwr_cntl_delay);

                my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, rev_pwr_cntl_delay);
              }
            }

#ifdef FEATURE_IS2000_REL_A
            /* Length check on mandatory fields */
            min_len = FSIZ( MTYPE, c_sig_encrypt_mode_incl );
            temp_len = ext_msg_pos - old_ext_msg_pos;
            if ( ( ( temp_len + min_len ) % 8 ) > 0 )
            {
              min_len += 8 - ( temp_len + min_len ) % 8;
            }
          
            if ( ( ( ( add_record_len - 1 ) * 8 ) > temp_len ) && 
                 ( ( ( add_record_len - 1 ) * 8 - temp_len ) >= min_len )
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
               )
            {
              if (int_ptr->ext_chnasn.chns[num_recs]->am0.encrypt_mode ==
                  CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.d_sig_encrypt_mode,
                  MTYPE, d_sig_encrypt_mode);

                my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, d_sig_encrypt_mode);
              }

              if ((int_ptr->ext_chnasn.chns[num_recs]->am0.encrypt_mode ==
                   CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG)||
                  (int_ptr->ext_chnasn.chns[num_recs]->am0.encrypt_mode ==
                   CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.enc_key_size, MTYPE,
                  enc_key_size);
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.c_sig_encrypt_mode_incl,
                MTYPE, c_sig_encrypt_mode_incl);

              my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, c_sig_encrypt_mode_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am0.c_sig_encrypt_mode_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.c_sig_encrypt_mode,
                  MTYPE, c_sig_encrypt_mode);

                my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, c_sig_encrypt_mode);
              }

#ifdef FEATURE_IS2000_REL_C
              /* Length check on mandatory fields */
              min_len = FSIZ( MTYPE,  plcm_type_incl );
              temp_len = ext_msg_pos - old_ext_msg_pos;
              if ( ( ( temp_len + min_len ) % 8 ) > 0 )
              {
                min_len += 8 - ( temp_len + min_len ) % 8;
              }
          
              if ( ( ( ( add_record_len - 1 ) * 8 ) > temp_len ) && 
                   ( ( ( add_record_len - 1 ) * 8 - temp_len ) >= min_len )
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
                 )
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.msg_int_info_incl,
                  MTYPE, msg_int_info_incl);

                if (int_ptr->ext_chnasn.chns[num_recs]->am0.msg_int_info_incl)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.change_keys, MTYPE,
                    change_keys);
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.use_uak, MTYPE,
                    use_uak);
                }

                UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.plcm_type_incl,
                  MTYPE, plcm_type_incl);

                my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, plcm_type_incl);

                if (int_ptr->ext_chnasn.chns[num_recs]->am0.plcm_type_incl)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am0.plcm_type, MTYPE,
                    plcm_type);

                  my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, plcm_type);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am0.plcm_type ==
                      CAI_PLCM_TYPE_BS_SPEC)
                  {
                    UNPACKQ_PG(ext_chnasn.chns[num_recs]->am0.plcm_39, MTYPE,
                      plcm_39);

                    my_fendpos = FENDPOS(caii_ext_chnasn_am0_type, plcm_39);
                  }
                }
              }
#endif /* FEATURE_IS2000_REL_C */

            }
#endif /* FEATURE_IS2000_REL_A */

            #undef MTYPE
          }

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += my_fendpos;

          break;

        /* ASSIGN_MODE = '001' */
        case CAI_PAGING_CHAN_ASSIGN:

          #define MTYPE cai_ext_chnasn_am1_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am1.respond, MTYPE, respond);

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am1.freq_incl, MTYPE, freq_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am1.freq_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am1.band_class, MTYPE, band_class);
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am1.cdma_freq, MTYPE, cdma_freq);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am1.num_pilots, MTYPE, num_pilots);

          my_fendpos = FENDPOS(caii_ext_chnasn_am1_type, num_pilots);

          for (i=0; i < int_ptr->ext_chnasn.chns[num_recs]->am1.num_pilots+1 &&
                    i < CAI_EXT_CHNASN_AM1_MAX; i++)
          {
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am1.pilot_pn[i], MTYPE, pilot_pn);
            my_fendpos = FENDPOS(caii_ext_chnasn_am1_type, pilot_pn[i]);
          }

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += my_fendpos;
          break;

        /* ASSIGN_MODE = '010' */
        case CAI_ACQ_ANALOG_SYSTEM:

          #define MTYPE cai_ext_chnasn_am2_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am2.respond, MTYPE, respond);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am2.analog_sys, MTYPE, analog_sys);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am2.use_analog_sys, MTYPE, use_analog_sys);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am2.band_class, MTYPE, band_class);

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += FENDPOS(caii_ext_chnasn_am2_type, band_class);

          break;

        /* ASSIGN_MODE = '011' */
        case CAI_ANALOG_VCHAN_ASSIGN:

          #define MTYPE cai_ext_chnasn_am3_type

          UNPACKW_PG(ext_chnasn.chns[num_recs]->am3.sid, MTYPE, sid);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.vmac, MTYPE, vmac);
          UNPACKW_PG(ext_chnasn.chns[num_recs]->am3.analog_chan, MTYPE,
            analog_chan);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.scc, MTYPE, scc);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.mem, MTYPE, mem);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.an_chan_type, MTYPE,
            an_chan_type);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.dscc_msb, MTYPE, dscc_msb);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am3.band_class, MTYPE, band_class);

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += FENDPOS(caii_ext_chnasn_am3_type, band_class);
          break;

        /* ASSIGN_MODE = '100' */
        case CAI_EXT_TRAF_CHAN_ASSIGN:
        {
          word record_start_pos = 0, record_len = 0;

          #define MTYPE cai_ext_chnasn_am4_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.freq_incl, MTYPE, freq_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am4.freq_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.band_class, MTYPE,
              band_class);
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.cdma_freq, MTYPE,
              cdma_freq);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.bypass_alert_answer, MTYPE,
            bypass_alert_answer);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.granted_mode, MTYPE,
            granted_mode);

#ifdef FEATURE_IS2000_REL_C
          if (int_ptr->ext_chnasn.chns[num_recs]->am4.granted_mode ==
              CAI_GRANT_SRID_RESTORE)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.sr_id_restore, MTYPE,
              sr_id_restore);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          }
#endif /* FEATURE_IS2000_REL_C */

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.default_config, MTYPE,
            default_config);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.for_rc, MTYPE, for_rc);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rev_rc, MTYPE, rev_rc);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.frame_offset, MTYPE,
            frame_offset);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.encrypt_mode, MTYPE,
            encrypt_mode);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.fpc_subchan_gain, MTYPE,
            fpc_subchan_gain);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rlgain_adj, MTYPE,
            rlgain_adj);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.num_pilots, MTYPE,
            num_pilots);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_ind, MTYPE, ch_ind);

          my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, ch_ind);

          record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, ch_record_len));
          ext_msg_pos += FSIZ(MTYPE, ch_record_len);

          record_start_pos = ext_msg_pos;

          if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_ind == CAI_CHIND_FCH_ONLY)
          {
            #define IND_TYPE   cai_ext_ch_ind1_type
            #define IND_PRTYPE cai_ext_ch_ind1_pilot_rec_type

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fpc_fch_init_setpt,
              IND_TYPE, fpc_fch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fpc_fch_fer,
              IND_TYPE, fpc_fch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fpc_fch_min_setpt,
              IND_TYPE, fpc_fch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fpc_fch_max_setpt,
              IND_TYPE, fpc_fch_max_setpt);

            for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                      j<CAI_EXT_CHNASN_AM4_MAX; j++)
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].pilot_pn,
                IND_PRTYPE, pilot_pn);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].add_pilot_rec_incl,
                IND_PRTYPE, add_pilot_rec_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].add_pilot_rec_incl)
              {
                word tmp_record_len = 0;
                word tmp_record_start_pos = 0;

                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].pilot_rec_type,
                  IND_PRTYPE, pilot_rec_type);

                tmp_record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(IND_PRTYPE, record_len));
                ext_msg_pos += FSIZ(IND_PRTYPE, record_len);

                tmp_record_start_pos = ext_msg_pos;

                xlate_add_pilot_rec(int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].pilot_rec_type,
                  buf_ptr, ext_msg_pos,
                  &int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].add_pilot_rec);
                ext_msg_pos = tmp_record_start_pos + tmp_record_len*8;
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].pwr_comb_ind,
                IND_PRTYPE, pwr_comb_ind);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].code_chan_fch,
                IND_PRTYPE, code_chan_fch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.pilot_rec[j].qof_mask_id_fch,
                IND_PRTYPE, qof_mask_id_fch);
            }

            #undef IND_TYPE
            #undef IND_PRTYPE

#ifdef FEATURE_IS2000_REL_A
            if (((8 * record_len) > (ext_msg_pos - record_start_pos))
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
               )
            {
              #define X3_MTYPE cai_ext_ch_3x_fch_fix_type
              #define X3_VTYPE cai_ext_ch_3x_fch_var_type

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.x3_fch_info_incl,
                X3_MTYPE, x3_fch_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.x3_fch_info_incl)
              {
                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                          j<CAI_EXT_CHNASN_AM4_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].x3_fch_low_incl,
                    X3_VTYPE, x3_fch_low_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].x3_fch_low_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].qof_mask_id_fch_low,
                      X3_VTYPE, qof_mask_id_fch_low);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].code_chan_fch_low,
                      X3_VTYPE, code_chan_fch_low);
                  }

                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].x3_fch_high_incl,
                    X3_VTYPE, x3_fch_high_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].x3_fch_high_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].qof_mask_id_fch_high,
                      X3_VTYPE, qof_mask_id_fch_high);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind1.fch_info[j].code_chan_fch_high,
                      X3_VTYPE, code_chan_fch_high);
                  }
                }
              }

              #undef X3_MTYPE
              #undef X3_VTYPE
            }
#endif /* FEATURE_IS2000_REL_A */

          }

          else if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_ind ==
                   CAI_CHIND_DCCH_ONLY)
          {
            #define IND_TYPE   cai_ext_ch_ind2_type
            #define IND_PRTYPE cai_ext_ch_ind2_pilot_rec_type

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.fpc_dcch_init_setpt,
              IND_TYPE,fpc_dcch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.fpc_dcch_fer,
              IND_TYPE,fpc_dcch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.fpc_dcch_min_setpt,
              IND_TYPE,fpc_dcch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.fpc_dcch_max_setpt,
              IND_TYPE,fpc_dcch_max_setpt);

            for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                      j<CAI_EXT_CHNASN_AM4_MAX; j++)
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].pilot_pn,
                IND_PRTYPE, pilot_pn);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].add_pilot_rec_incl,
                IND_PRTYPE, add_pilot_rec_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].add_pilot_rec_incl)
              {
                word tmp_record_len = 0;
                word tmp_record_start_pos = 0;

                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].pilot_rec_type,
                  IND_PRTYPE, pilot_rec_type);

                tmp_record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(IND_PRTYPE,record_len));
                ext_msg_pos += FSIZ(IND_PRTYPE, record_len);

                tmp_record_start_pos = ext_msg_pos;

                xlate_add_pilot_rec(
                  int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].pilot_rec_type,
                  buf_ptr, ext_msg_pos,
                  &int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].add_pilot_rec);

                ext_msg_pos = tmp_record_start_pos + tmp_record_len*8;
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].pwr_comb_ind,
                IND_PRTYPE, pwr_comb_ind);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].code_chan_dcch,
                IND_PRTYPE, code_chan_dcch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.pilot_rec[j].qof_mask_id_dcch,
                IND_PRTYPE, qof_mask_id_dcch);
            }

            #undef IND_TYPE
            #undef IND_PRTYPE

#ifdef FEATURE_IS2000_REL_A
            if (((8 * record_len) > (ext_msg_pos - record_start_pos))
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
               )
            {
              #define X3_MTYPE cai_ext_ch_3x_dcch_fix_type
              #define X3_VTYPE cai_ext_ch_3x_dcch_var_type

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.x3_dcch_info_incl,
                X3_MTYPE, x3_dcch_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.x3_dcch_info_incl)
              {
                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                          j<CAI_EXT_CHNASN_AM4_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].x3_dcch_low_incl,
                    X3_VTYPE, x3_dcch_low_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].x3_dcch_low_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].qof_mask_id_dcch_low,
                      X3_VTYPE, qof_mask_id_dcch_low);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].code_chan_dcch_low,
                      X3_VTYPE, code_chan_dcch_low);
                  }

                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].x3_dcch_high_incl,
                    X3_VTYPE, x3_dcch_high_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].x3_dcch_high_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].qof_mask_id_dcch_high,
                      X3_VTYPE, qof_mask_id_dcch_high);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind2.dcch_info[j].code_chan_dcch_high,
                      X3_VTYPE, code_chan_dcch_high);
                  }
                } /* end for */
              } /* end if (ind_ptr->x3_dcch_info_incl) */

              #undef X3_MTYPE
              #undef X3_VTYPE
            }
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          }

          else if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_ind ==
                   CAI_CHIND_FCH_AND_DCCH)
          {
            #define IND_TYPE   cai_ext_ch_ind3_type
            #define IND_PRTYPE cai_ext_ch_ind3_pilot_rec_type

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_fch_init_setpt,
              IND_TYPE, fpc_fch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_dcch_init_setpt,
              IND_TYPE, fpc_dcch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_pri_chan,
              IND_TYPE, fpc_pri_chan);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_fch_fer,
              IND_TYPE, fpc_fch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_fch_min_setpt,
              IND_TYPE, fpc_fch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_fch_max_setpt,
              IND_TYPE, fpc_fch_max_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_dcch_fer,
              IND_TYPE, fpc_dcch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_dcch_min_setpt,
              IND_TYPE, fpc_dcch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fpc_dcch_max_setpt,
              IND_TYPE, fpc_dcch_max_setpt);

            for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                      j<CAI_EXT_CHNASN_AM4_MAX; j++)
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].pilot_pn,
                IND_PRTYPE, pilot_pn);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].add_pilot_rec_incl,
                IND_PRTYPE,add_pilot_rec_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].add_pilot_rec_incl)
              {
                word tmp_record_len = 0;
                word tmp_record_start_pos = 0;

                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].pilot_rec_type,
                  IND_PRTYPE, pilot_rec_type);

                tmp_record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(IND_PRTYPE, record_len));
                ext_msg_pos += FSIZ(IND_PRTYPE, record_len);

                tmp_record_start_pos = ext_msg_pos;

                xlate_add_pilot_rec(
                  int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].pilot_rec_type,
                  buf_ptr, ext_msg_pos,
                  &int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].add_pilot_rec);

                ext_msg_pos = tmp_record_start_pos + tmp_record_len*8;
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].pwr_comb_ind,
                IND_PRTYPE, pwr_comb_ind);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].code_chan_fch,
                IND_PRTYPE, code_chan_fch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].qof_mask_id_fch,
                IND_PRTYPE, qof_mask_id_fch);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].code_chan_dcch,
                IND_PRTYPE, code_chan_dcch);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.pilot_rec[j].qof_mask_id_dcch,
                IND_PRTYPE, qof_mask_id_dcch);
            }

            #undef IND_TYPE
            #undef IND_PRTYPE

#ifdef FEATURE_IS2000_REL_A
            if (((8 * record_len) > (ext_msg_pos - record_start_pos))
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
               )
            {
              #define X3_FTYPE cai_ext_ch_3x_fch_fix_type
              #define X3_VTYPE cai_ext_ch_3x_fch_var_type

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.x3_fch_info_incl,
                X3_FTYPE, x3_fch_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.x3_fch_info_incl)
              {
                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                           j<CAI_EXT_CHNASN_AM4_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].x3_fch_low_incl,
                    X3_VTYPE, x3_fch_low_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].x3_fch_low_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].qof_mask_id_fch_low,
                      X3_VTYPE, qof_mask_id_fch_low);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].code_chan_fch_low,
                      X3_VTYPE, code_chan_fch_low);
                  }

                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].x3_fch_high_incl,
                    X3_VTYPE, x3_fch_high_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].x3_fch_high_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].qof_mask_id_fch_high,
                      X3_VTYPE, qof_mask_id_fch_high);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.fch_info[j].code_chan_fch_high,
                      X3_VTYPE, code_chan_fch_high);
                  }
                }
              }

              #undef X3_FTYPE
              #undef X3_VTYPE
            }

            if (((8 * record_len) > (ext_msg_pos - record_start_pos))
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
               )
            {
              #define X3_MTYPE cai_ext_ch_3x_dcch_fix_type
              #define X3_VTYPE cai_ext_ch_3x_dcch_var_type

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.x3_dcch_info_incl,
                X3_MTYPE, x3_dcch_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.x3_dcch_info_incl)
              {
                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am4.num_pilots+1 &&
                          j<CAI_EXT_CHNASN_AM4_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].x3_dcch_low_incl,
                    X3_VTYPE, x3_dcch_low_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].x3_dcch_low_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].qof_mask_id_dcch_low,
                      X3_VTYPE, qof_mask_id_dcch_low);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].code_chan_dcch_low,
                      X3_VTYPE, code_chan_dcch_low);
                  }

                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].x3_dcch_high_incl,
                    X3_VTYPE, x3_dcch_high_incl);

                  if (int_ptr->ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].x3_dcch_high_incl)
                  {
                    UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].qof_mask_id_dcch_high,
                      X3_VTYPE, qof_mask_id_dcch_high);
                    UNPACKW_PG(ext_chnasn.chns[num_recs]->am4.ch_rec.ind3.dcch_info[j].code_chan_dcch_high,
                      X3_VTYPE, code_chan_dcch_high);
                  }
                } /* end for */
              } /* end if (ind_ptr->x3_dcch_info_incl) */

              #undef X3_FTYPE
              #undef X3_VTYPE
            }
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          }

          ext_msg_pos = record_start_pos + record_len * 8;

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rev_fch_gating_mode, MTYPE,
            rev_fch_gating_mode);

          my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, rev_fch_gating_mode);

          if (int_ptr->ext_chnasn.chns[num_recs]->am4.rev_fch_gating_mode)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rev_pwr_cntl_delay_incl,
              MTYPE, rev_pwr_cntl_delay_incl);

            my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, rev_pwr_cntl_delay_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am4.rev_pwr_cntl_delay_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.rev_pwr_cntl_delay,
                MTYPE, rev_pwr_cntl_delay);

              my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, rev_pwr_cntl_delay);
            }
          }

#if defined(FEATURE_IS2000_REL_A) || defined(FEATURE_MEID_SUPPORT)
          /* Length check on mandatory fields */
          min_len = FSIZ( MTYPE, c_sig_encrypt_mode_incl ) +
                    FSIZ( MTYPE, x3fl_1xrl_incl );

          if ( ( ( ( ( add_record_len - 1 ) * 8 ) - 
                   ( ext_msg_pos - old_ext_msg_pos )
                 ) >= min_len
               )
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
             )
          {
            if (int_ptr->ext_chnasn.chns[num_recs]->am4.encrypt_mode ==
                CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.d_sig_encrypt_mode,
                MTYPE, d_sig_encrypt_mode);
            }

            if ((int_ptr->ext_chnasn.chns[num_recs]->am4.encrypt_mode ==
                 CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG) ||
                (int_ptr->ext_chnasn.chns[num_recs]->am4.encrypt_mode ==
                 CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.enc_key_size,
                MTYPE, enc_key_size);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.c_sig_encrypt_mode_incl,
              MTYPE, c_sig_encrypt_mode_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am4.c_sig_encrypt_mode_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.c_sig_encrypt_mode,
                MTYPE, c_sig_encrypt_mode);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.x3fl_1xrl_incl,
              MTYPE, x3fl_1xrl_incl);

            my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, x3fl_1xrl_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am4.x3fl_1xrl_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.x1rl_freq_offset,
                MTYPE, x1rl_freq_offset);

              my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, x1rl_freq_offset);
            }

#if defined(FEATURE_IS2000_REL_C) || defined(FEATURE_MEID_SUPPORT)
            /* Length check on mandatory fields */
            min_len = FSIZ( MTYPE, plcm_type_incl );

            if ( ( ( ( ( add_record_len - 1 ) * 8 ) - 
                       ( ext_msg_pos - old_ext_msg_pos )
                   ) >= min_len
                 )
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
               )
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.msg_int_info_incl,
                MTYPE, msg_int_info_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.msg_int_info_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.change_keys,
                  MTYPE, change_keys);
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.use_uak,
                  MTYPE, use_uak);
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.plcm_type_incl,
                MTYPE, plcm_type_incl);

              my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, plcm_type_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am4.plcm_type_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am4.plcm_type,
                  MTYPE, plcm_type);

                my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, plcm_type);

                if (int_ptr->ext_chnasn.chns[num_recs]->am4.plcm_type ==
                    CAI_PLCM_TYPE_BS_SPEC)
                {
                  UNPACKQ_PG(ext_chnasn.chns[num_recs]->am4.plcm_39, MTYPE, 
                    plcm_39);

                  my_fendpos = FENDPOS(caii_ext_chnasn_am4_type, plcm_39);
                }
              }
            }
#endif /* FEATURE_IS2000_REL_C || FEATURE_MEID_SUPPORT */

          }
#endif /* FEATURE_IS2000_REL_A || FEATURE_MEID_SUPPORT */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += my_fendpos;
          break;
        }

#ifdef FEATURE_IS2000_REL_C
        /* ASSIGN_MODE = '101' */
        case CAI_PACKET_DATA_TRAF_CHAN_ASSIGN:
        {
          #define MTYPE cai_ext_chnasn_am5_type

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.freq_incl, MTYPE, freq_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.freq_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.band_class, MTYPE, band_class);
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.cdma_freq, MTYPE, cdma_freq);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.bypass_alert_answer, MTYPE,
            bypass_alert_answer);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.granted_mode, MTYPE,
            granted_mode);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.granted_mode ==
              CAI_GRANT_SRID_RESTORE)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.sr_id_restore, MTYPE,
              sr_id_restore);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.frame_offset, MTYPE,
            frame_offset);

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.encrypt_mode, MTYPE,
            encrypt_mode);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.encrypt_mode ==
              CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.d_sig_encrypt_mode,
              MTYPE, d_sig_encrypt_mode);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.encrypt_mode ==
               CAI_ENHANCED_ENCRYPT_CALL_CTL_MSG) ||
              (int_ptr->ext_chnasn.chns[num_recs]->am5.encrypt_mode ==
               CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG))
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.enc_key_size,
              MTYPE, enc_key_size);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.c_sig_encrypt_mode_incl,
            MTYPE, c_sig_encrypt_mode_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.c_sig_encrypt_mode_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.c_sig_encrypt_mode,
              MTYPE, c_sig_encrypt_mode);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.msg_int_info_incl,
            MTYPE, msg_int_info_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.msg_int_info_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.change_keys,
              MTYPE, change_keys);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.use_uak,
              MTYPE, use_uak);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.plcm_type_incl,
            MTYPE, plcm_type_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.plcm_type_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.plcm_type,
              MTYPE, plcm_type);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.plcm_type ==
                CAI_PLCM_TYPE_BS_SPEC)
            {
              UNPACKQ_PG(ext_chnasn.chns[num_recs]->am5.plcm_39, MTYPE,
                plcm_39);
            }
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rlgain_adj,
            MTYPE, rlgain_adj);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.num_pilots,
            MTYPE, num_pilots);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.ext_ch_ind,
            MTYPE, ext_ch_ind);

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PF_F) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PD_D) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_subchan_gain,
              MTYPE, fpc_subchan_gain);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PC_F) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_F) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_fch_gating_mode,
              MTYPE, rev_fch_gating_mode);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.rev_fch_gating_mode)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_pwr_cntl_delay_incl,
                MTYPE, rev_pwr_cntl_delay_incl);

              if (int_ptr->ext_chnasn.chns[num_recs]->am5.rev_pwr_cntl_delay_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_pwr_cntl_delay,
                  MTYPE, rev_pwr_cntl_delay);
              }
            }
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.full_ci_feedback_ind,
            MTYPE, full_ci_feedback_ind);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_cqich_frame_offset,
            MTYPE, rev_cqich_frame_offset);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_cqich_reps,
            MTYPE, rev_cqich_reps);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_ackch_reps,
            MTYPE, rev_ackch_reps);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_rc,
            MTYPE, for_pdch_rc);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PF_F) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PD_D) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_fch_dcch_rc,
              MTYPE, for_fch_dcch_rc);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PC_F) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PC_D) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_F) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PD_D) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.rev_fch_dcch_rc,
              MTYPE, rev_fch_dcch_rc);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_pri_chan,
              MTYPE, fpc_pri_chan);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PF_F) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PF_FD) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_fch_init_setpt,
              MTYPE, fpc_fch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_fch_fer,
              MTYPE, fpc_fch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_fch_min_setpt,
              MTYPE, fpc_fch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_fch_max_setpt,
              MTYPE, fpc_fch_max_setpt);
          }

          if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
               CAI_EXT_CHIND_PD_D) 
              || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                  CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
             )
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_dcch_init_setpt,
              MTYPE, fpc_dcch_init_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_dcch_fer,
              MTYPE, fpc_dcch_fer);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_dcch_min_setpt,
              MTYPE, fpc_dcch_min_setpt);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.fpc_dcch_max_setpt,
              MTYPE, fpc_dcch_max_setpt);
          }

          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pdch_group_ind_incl,
            MTYPE, pdch_group_ind_incl);
          UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parms_incl,
            MTYPE, for_pdch_parms_incl);

          my_fendpos = FENDPOS(caii_ext_chnasn_am5_type, for_pdch_parms_incl);

          if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parms_incl)
          {
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.for_pdch_rlgain_incl,
              MTYPE, for_pdch_rlgain_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parm.for_pdch_rlgain_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.rlgain_ackch_pilot,
                MTYPE, rlgain_ackch_pilot);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.rlgain_cqich_pilot,
                MTYPE, rlgain_cqich_pilot);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_soft_switching_frames,
              MTYPE, num_soft_switching_frames);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_softer_switching_frames,
              MTYPE, num_softer_switching_frames);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_soft_switching_slots,
              MTYPE, num_soft_switching_slots);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_softer_switching_slots,
              MTYPE, num_softer_switching_slots);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.chm_switching_params_incl,
              MTYPE, chm_switching_params_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parm.chm_switching_params_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_soft_switching_frames_chm,
                MTYPE, num_soft_switching_frames_chm);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_softer_switching_frames_chm,
                MTYPE, num_softer_switching_frames_chm);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_soft_switching_slots_chm,
                MTYPE, num_soft_switching_slots_chm);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.num_softer_switching_slots_chm,
                MTYPE, num_softer_switching_slots_chm);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.pdch_soft_switching_delay,
              MTYPE, pdch_soft_switching_delay);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.for_pdch_parm.pdch_softer_switching_delay,
              MTYPE, pdch_softer_switching_delay);

            my_fendpos = FENDPOS(caii_ext_chnasn_am5_type, 
              for_pdch_parm.pdch_softer_switching_delay);

          } /* end if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parms_incl) */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          #define VTYPE cai_ext_chnasn_pilot_info_type

          for (i=0; i<int_ptr->ext_chnasn.chns[num_recs]->am5.num_pilots+1 &&
                    i<CAI_EXT_CHNASN_AM5_MAX; i++)
          {
            UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pilot_pn,
              VTYPE, pilot_pn);
            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].add_pilot_rec_incl,
              VTYPE, add_pilot_rec_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].add_pilot_rec_incl)
            {
              word tmp_record_len = 0;
              word tmp_record_start_pos = ext_msg_pos;

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pilot_rec_type,
                VTYPE, pilot_rec_type);

              tmp_record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(VTYPE, record_len));
              ext_msg_pos += FSIZ(VTYPE, record_len);

              tmp_record_start_pos = ext_msg_pos;

              xlate_add_pilot_rec(
                int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pilot_rec_type,
                buf_ptr, ext_msg_pos,
                &int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].add_pilot_rec);

              ext_msg_pos = tmp_record_start_pos + tmp_record_len * 8;
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdch_incl,
              VTYPE, for_pdch_incl);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdch_incl)
            {
              if (int_ptr->ext_chnasn.chns[num_recs]->am5.for_pdch_parms_incl)
              {
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].walsh_table_id,
                  VTYPE, walsh_table_id);
                UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].num_pdcch,
                  VTYPE, num_pdcch);

                for (j=0; j<int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].num_pdcch+1 &&
                          j<CAI_EXT_CHNASN_AM5_MAX; j++)
                {
                  UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdcch_walsh[j],
                    VTYPE, for_pdcch_walsh);
                }
              }

              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].mac_id,
                VTYPE, mac_id);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].rev_cqich_cover,
                VTYPE, rev_cqich_cover);
            } /* end if (int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdch_incl) */

            if ((((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                   CAI_EXT_CHIND_PC_F) 
                  || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                      CAI_EXT_CHIND_PC_D)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
                 )
                 && (int_ptr->ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_pdch_incl)
                )
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
               )
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_cpcch_walsh,
                VTYPE, for_cpcch_walsh);
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].for_cpcsch,
                VTYPE, for_cpcsch);
            }

            UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pwr_comb_ind,
              VTYPE, pwr_comb_ind);

            if (int_ptr->ext_chnasn.chns[num_recs]->am5.pdch_group_ind_incl)
            {
              UNPACKB_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].pdch_group_ind,
                VTYPE, pdch_group_ind);
            }

            if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                 CAI_EXT_CHIND_PF_F)
                || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                    CAI_EXT_CHIND_PF_FD) 
                || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                    CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
               )
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].code_chan_fch,
                VTYPE, code_chan_fch);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].qof_mask_id_fch,
                VTYPE, qof_mask_id_fch);
            }

            if ((int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                 CAI_EXT_CHIND_PD_D) 
                || (int_ptr->ext_chnasn.chns[num_recs]->am5.ext_ch_ind ==
                    CAI_EXT_CHIND_PFD_FD)
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
               )
            {
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].code_chan_dcch,
                VTYPE, code_chan_dcch);
              UNPACKW_PG(ext_chnasn.chns[num_recs]->am5.pilot_rec[i].qof_mask_id_dcch,
                VTYPE, qof_mask_id_dcch);
            }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

            my_fendpos = FENDPOS(caii_ext_chnasn_am5_type, pilot_rec[i]); 

          } /* for loop */

          #undef VTYPE

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          #undef MTYPE

          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          int_buf_ptr += my_fendpos;
          break;
        }

#endif /* FEATURE_IS2000_REL_C */

        default:
          MSG_MED( "Unknown ASSIGN_MODE %d",
                    int_ptr->ext_chnasn.chns[num_recs]->gen.assign_mode, 0, 0 );
          /* --------------------------------------------------
          ** Adjust order_pos according to ADD_RECORD_LEN field
          ** -------------------------------------------------- */
          ext_msg_pos = old_ext_msg_pos + ((add_record_len - 1) * 8);
          break;
      } /* end of switch */

#ifdef FEATURE_IS2000_REL_C
      /* ----------------------------------------
      ** Adjust order_pos according to MACI field
      ** ---------------------------------------- */
      if (int_ptr->ext_chnasn.chns[num_recs]->gen.hdr.msg_int.maci_incl)
      {
        ext_msg_pos += FSIZ(cai_msg_int_type, maci);
      }
#endif /* FEATURE_IS2000_REL_C */

      num_recs++;

      if( num_recs < CAI_EXT_CHN_ASN_MAX )
      {
        int_buf_ptr = (byte *)ALIGN_DWORD((dword)int_buf_ptr);
        int_ptr->ext_chnasn.chns[num_recs] =
          (caii_ext_ca_ord_type*)int_buf_ptr;
      }
      else
      {
        /* ----------------------------------------------------
        ** num_recs is too big, stop processing and return
        ** ---------------------------------------------------- */
        MSG_ERROR( "Too many ECAM records", 0, 0, 0);
        break;
      }

      if ((CAII_MAX_EXT_CHNASN_MSG_BUF_SIZ - 
           (int_buf_ptr - int_ptr->ext_chnasn.buf)) < CAII_MAX_INT_ECAM_SIZ)
      {
        /* ----------------------------------------------------------------
        ** Because we have reserved worst case plus CAII_MAX_INT_ECAM_SIZ,
        ** if the empty space left is less than the headroom, we either
        ** under-estimated the worst case or something else went wrong.
        ** ---------------------------------------------------------------- */
        MSG_ERROR( "Buf is too small for this ECAM", 0, 0, 0);
        break;
      }
    } /* end while */

    int_ptr->ext_chnasn.num_chns = num_recs;
  }

  return (status);

} /* xlate_ext_ext_chn_asn */

/*===========================================================================

FUNCTION XLATE_EXT_GEN_NL

DESCRIPTION
  This function translates a Paging Channel General Neighbor List Message
  from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the General Neighbor List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_gen_nl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos;
    /* Bit offset in variable portion of message */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word min_len;
    /* Protocol dependent minimum length requirement */
  word i;
    /* Index for looping through neighbors */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_gen_nghbr_msg_type

  /* Minimum size is size of fixed type, minus all the dependant fields */
  if (len < CAI_GEN_NGHBR_MIN ) 
  {
    status = CAIX_INV_LEN_S;
  }

  else
  {
    /* ---------------------------------------------------------------
    ** Length is ok - convert message from external to internal format
    ** starting with the first field after message_type
    ** --------------------------------------------------------------- */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(gen_nghbr.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(gen_nghbr.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(gen_nghbr.pilot_inc, MTYPE, pilot_inc);
    UNPACKB_PG(gen_nghbr.nghbr_srch_mode, MTYPE, nghbr_srch_mode);
    UNPACKB_PG(gen_nghbr.nghbr_config_pn_incl, MTYPE, nghbr_config_pn_incl);
    UNPACKB_PG(gen_nghbr.freq_fields_incl, MTYPE, freq_fields_incl);
    UNPACKB_PG(gen_nghbr.use_timing, MTYPE, use_timing);

    /*--------------------------------------------------------------- */
    /* Unpack dependent fields of fixed type                          */
    /*--------------------------------------------------------------- */
    if (int_ptr->gen_nghbr.use_timing)
    {
     UNPACKB_PG(gen_nghbr.global_timing_incl, MTYPE, global_timing_incl);

     if (int_ptr->gen_nghbr.global_timing_incl)
     {
       UNPACKB_PG(gen_nghbr.global_tx_duration, MTYPE, global_tx_duration);
       UNPACKB_PG(gen_nghbr.global_tx_period, MTYPE, global_tx_period);
     }
    }

    UNPACKB_PG(gen_nghbr.num_nghbr, MTYPE, num_nghbr);

    /*----------------------------------------------------------------- */
    /* Unpack variable type (cdma neighbors)                            */
    /*----------------------------------------------------------------- */
    for (i=0; i < int_ptr->gen_nghbr.num_nghbr && i < CAI_GEN_NGHBR_MAX; i++)
    {
      if (int_ptr->gen_nghbr.nghbr_config_pn_incl)
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_config, MTYPE, nghbr_config);
        UNPACKW_PG(gen_nghbr.nghbr[i].nghbr_pn, MTYPE, nghbr_pn);
      }

      if( int_ptr->gen_nghbr.nghbr_srch_mode == SRCH_PRI_AND_WIN ||
            int_ptr->gen_nghbr.nghbr_srch_mode == SRCH_PRI_ONLY )
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].search_pri, MTYPE, search_pri);
      }

      if ((int_ptr->gen_nghbr.nghbr_srch_mode == SRCH_PRI_AND_WIN) ||
          (int_ptr->gen_nghbr.nghbr_srch_mode == SRCH_WIN_ONLY))
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].srch_win_nghbr, MTYPE, srch_win_nghbr);
      }

      if (int_ptr->gen_nghbr.freq_fields_incl)
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].freq_incl, MTYPE, freq_incl);

        /* Check if neighbor freq and band are included */
        /* for this set.                                */
        if (int_ptr->gen_nghbr.nghbr[i].freq_incl)
        {
          UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_band, MTYPE, nghbr_band);
          UNPACKW_PG(gen_nghbr.nghbr[i].nghbr_freq, MTYPE, nghbr_freq);
        }
      }

      if (int_ptr->gen_nghbr.use_timing)
      {
        UNPACKB_PG(gen_nghbr.nghbr[i].timing_incl, MTYPE, timing_incl);

        /* Include timing information */
        if (int_ptr->gen_nghbr.nghbr[i].timing_incl)
        {
          UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_tx_offset, MTYPE, nghbr_tx_offset );

          /* Only include if global_timing_incl is set to zero. */
          if ( !(int_ptr->gen_nghbr.global_timing_incl) )
          {
            UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_tx_duration, MTYPE, nghbr_tx_duration);

            UNPACKB_PG(gen_nghbr.nghbr[i].nghbr_tx_period, MTYPE, nghbr_tx_period);
          }
        }
      }

      /* ----------------------------------------------------
      ** If NGHBR_CONFIGr is equal to '000', '001', or '010',
      ** then NGHBR_CONFIGs = NGHBR_CONFIGr, otherwise,
      ** NGHBR_CONFIGs = '011'.
      ** ---------------------------------------------------- */
      if (int_ptr->gen_nghbr.nghbr[i].nghbr_config > 3)
      {
        int_ptr->gen_nghbr.nghbr[i].nghbr_config = 3;
      }
    }  /* End num_neighbor occurences of a cdma neighbor record */

    UNPACKB_PG(gen_nghbr.num_analog_nghbr, MTYPE, num_analog_nghbr);

    /* Num_analog_neighbr occurrences of the following record */
    for (i=0; i < int_ptr->gen_nghbr.num_analog_nghbr &&
              i < CAI_GEN_ANALOG_NGHBR_MAX; i++)
    {
      UNPACKB_PG(gen_nghbr.analog_nghbr[i].band_class, MTYPE, band_class);
      UNPACKB_PG(gen_nghbr.analog_nghbr[i].sys_a_b, MTYPE, sys_a_b);
    } /* End num_analog_nghbr occurences of the prev. record. */

    /* Check length for mandatory fields and minimum reserved bits */
    min_len = ( int_ptr->gen_nghbr.num_nghbr * FSIZ( MTYPE, add_pilot_rec_incl ) ) + 
              FSIZ( MTYPE, srch_offset_incl );
    if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
    {
      min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
    }
 
    if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_DYNAMIC_P_REV
         && ( cdma.mob_cai_rev >= P_REV_IS2000 )
#endif /* FEATURE_DYNAMIC_P_REV */
       )
    {
      word j;

      int_ptr->gen_nghbr.is2000_incl = TRUE;
      UNPACKB_PG(gen_nghbr.srch_offset_incl, MTYPE, srch_offset_incl);

      for (j=0; j<int_ptr->gen_nghbr.num_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
      {
        UNPACKB_PG(gen_nghbr.add_nghbr[j].add_pilot_rec_incl, MTYPE,
          add_pilot_rec_incl);

        if (int_ptr->gen_nghbr.add_nghbr[j].add_pilot_rec_incl)
        {
          word record_len = 0;
          word record_start_pos = 0;

          UNPACKB_PG(gen_nghbr.add_nghbr[j].nghbr_pilot_rec_type, MTYPE, nghbr_pilot_rec_type);

          record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, record_len));
          ext_msg_pos += FSIZ(MTYPE, record_len);

          record_start_pos = ext_msg_pos;
          xlate_add_pilot_rec(int_ptr->gen_nghbr.add_nghbr[j].nghbr_pilot_rec_type,
                              buf_ptr, ext_msg_pos,
                              &(int_ptr->gen_nghbr.add_nghbr[j].add_pilot_rec));
          ext_msg_pos = record_start_pos + record_len*8;
        }

        if (int_ptr->gen_nghbr.srch_offset_incl)
        {
          UNPACKB_PG(gen_nghbr.add_nghbr[j].srch_offset_nghbr, MTYPE, srch_offset_nghbr);
        }
      }

#ifdef FEATURE_IS2000_REL_A
      /* Check length for mandatory fields and minimum reserved bits */
      min_len = FSIZ( MTYPE, bcch_ind_incl ); 
      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
      }

      if ( ( ( len - ext_msg_pos ) >= min_len ) 
#ifdef FEATURE_DYNAMIC_P_REV
           && ( cdma.mob_cai_rev >= P_REV_IS2000_REL_A )
#endif /* FEATURE_DYNAMIC_P_REV */
         )
      {
        int_ptr->gen_nghbr.is2000_rel_a_incl = TRUE;
        UNPACKB_PG(gen_nghbr.bcch_ind_incl, MTYPE, bcch_ind_incl);

        if (int_ptr->gen_nghbr.bcch_ind_incl)
        {
          for (j=0; j<int_ptr->gen_nghbr.num_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
          {
            UNPACKB_PG(gen_nghbr.bcch_support[j], MTYPE, bcch_support);
          }
        }
      }
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      /* Check length for mandatory fields and minimum reserved bits */
      min_len = FSIZ( MTYPE, resq_enabled ); 
      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
      }

      if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_DYNAMIC_P_REV
           && ( cdma.mob_cai_rev >= P_REV_IS2000_REL_B )
#endif /* FEATURE_DYNAMIC_P_REV */
         )
      {
        int_ptr->gen_nghbr.is2000_rel_b_incl = TRUE;

        UNPACKB_PG(gen_nghbr.resq_enabled, MTYPE, resq_enabled);

        if (int_ptr->gen_nghbr.resq_enabled)
        {
          UNPACKB_PG(gen_nghbr.resq_delay_time, MTYPE, resq_delay_time);
          UNPACKB_PG(gen_nghbr.resq_allowed_time, MTYPE, resq_allowed_time);
          UNPACKB_PG(gen_nghbr.resq_attempt_time , MTYPE, resq_attempt_time);
          UNPACKW_PG(gen_nghbr.resq_code_chan, MTYPE, resq_code_chan);
          UNPACKB_PG(gen_nghbr.resq_qof, MTYPE, resq_qof);
          UNPACKB_PG(gen_nghbr.resq_min_period_incl, MTYPE, resq_min_period_incl);

          if (int_ptr->gen_nghbr.resq_min_period_incl)
          {
            UNPACKB_PG(gen_nghbr.resq_min_period, MTYPE, resq_min_period);
          }

          UNPACKB_PG(gen_nghbr.resq_num_tot_trans_incl, MTYPE, resq_num_tot_trans_incl);

          if (int_ptr->gen_nghbr.resq_num_tot_trans_incl)
          {
            UNPACKB_PG(gen_nghbr.resq_num_tot_trans_20ms, MTYPE, resq_num_tot_trans_20ms);
            UNPACKB_PG(gen_nghbr.resq_num_tot_trans_5ms, MTYPE, resq_num_tot_trans_5ms);
          }

          UNPACKB_PG(gen_nghbr.resq_num_preamble_rc1_rc2, MTYPE, resq_num_preamble_rc1_rc2);
          UNPACKB_PG(gen_nghbr.resq_num_preamble, MTYPE, resq_num_preamble);
          UNPACKB_PG(gen_nghbr.resq_power_delta, MTYPE, resq_power_delta);

          for (j=0; j<int_ptr->gen_nghbr.num_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
          {
            UNPACKB_PG(gen_nghbr.nghbr_resq_configured[j], MTYPE, nghbr_resq_configured);
          }
        }
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      /* Check length for mandatory fields and minimum reserved bits */
      min_len = ( int_ptr->gen_nghbr.num_nghbr * FSIZ( MTYPE, nghbr_pdch_supported) ) + 
                FSIZ( MTYPE, hrpd_nghbr_incl ); 
      if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
      }

      if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_DYNAMIC_P_REV
           && ( cdma.mob_cai_rev >= P_REV_IS2000_REL_C )
#endif /* FEATURE_DYNAMIC_P_REV */
         )
      {
        uint8 hrpd_nghbr_rec_len;
        word old_ext_msg_pos;

        int_ptr->gen_nghbr.is2000_rel_c_incl = TRUE;

        for (j=0; j<int_ptr->gen_nghbr.num_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
        {
          UNPACKB_PG(gen_nghbr.nghbr_pdch_supported[j], MTYPE, nghbr_pdch_supported);
        }

        UNPACKB_PG(gen_nghbr.hrpd_nghbr_incl, MTYPE, hrpd_nghbr_incl);

        if (int_ptr->gen_nghbr.hrpd_nghbr_incl)
        {
          UNPACKB_PG(gen_nghbr.num_hrpd_nghbr, MTYPE, num_hrpd_nghbr);

          for (j=0; j<int_ptr->gen_nghbr.num_hrpd_nghbr && j<CAI_GEN_NGHBR_MAX; j++)
          {
            old_ext_msg_pos = ext_msg_pos;

            hrpd_nghbr_rec_len = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(MTYPE, hrpd_nghbr_rec_len));
            ext_msg_pos += FSIZ(MTYPE, hrpd_nghbr_rec_len);

            UNPACKW_PG(gen_nghbr.hrpd_nghbr[j].nghbr_pn, MTYPE, nghbr_pn);
            UNPACKB_PG(gen_nghbr.hrpd_nghbr[j].nghbr_freq_incl, MTYPE, nghbr_freq_incl);

            if (int_ptr->gen_nghbr.hrpd_nghbr[j].nghbr_freq_incl)
            {
              UNPACKB_PG(gen_nghbr.hrpd_nghbr[j].nghbr_band, MTYPE, nghbr_band);
              UNPACKW_PG(gen_nghbr.hrpd_nghbr[j].nghbr_freq, MTYPE, nghbr_freq);
            }

            UNPACKB_PG(gen_nghbr.hrpd_nghbr[j].pn_association_ind, MTYPE, pn_association_ind);
            UNPACKB_PG(gen_nghbr.hrpd_nghbr[j].data_association_ind, MTYPE, data_association_ind);

            ext_msg_pos = old_ext_msg_pos + (hrpd_nghbr_rec_len + 1) * 8;
          }
        }
      }
#endif /* FEATURE_IS2000_REL_C */

    }
  }

  #undef MTYPE

  return (status);

} /* xlate_ext_gen_nl */

/*===========================================================================

FUNCTION XLATE_EXT_E_GLB_REDIR_REC

DESCRIPTION
  This function translates a ESGRM redirection record from external to 
  internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Global Service Redirection message
  type.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

void xlate_ext_e_glb_redir_rec
(
  word record_type,
    /* Type of redirection record */
  word len,
    /* Length of message in bits */
  word pos,
    /* Position of record in message */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_ext_glb_redir_rec_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word ext_msg_pos = pos;
    /* Position of record in message */
  word i;
    /* Index */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (record_type)
  {
    case CAI_ANALOG_REDIRECTION_REC:
    {
      #define RMTYPE cai_redirect_rec1_type

      UNPACKW_PG(rec1.expected_sid, RMTYPE, expected_sid);
      UNPACKB_PG(rec1.ignore_cdma, RMTYPE, ignore_cdma);
      UNPACKB_PG(rec1.sys_ordering, RMTYPE, sys_ordering);
      UNPACKB_PG(rec1.max_redirect_delay, RMTYPE, max_redirect_delay);

      #undef RMTYPE

      break;
    }

    case CAI_CDMA_REDIRECTION_REC:
    {
      #define RMTYPE cai_redirect_rec2_type

      UNPACKB_PG(rec2.band_class, RMTYPE, band_class);
      UNPACKW_PG(rec2.expected_sid, RMTYPE, expected_sid);
      UNPACKW_PG(rec2.expected_nid, RMTYPE, expected_nid);
      ext_msg_pos += FSIZ(RMTYPE, reserved);

      UNPACKB_PG(rec2.num_chans, RMTYPE, num_chans);

      for (i=0; i < int_ptr->rec2.num_chans && i < CAI_MAX_CDMA_CHANS; i++)
      {
        UNPACKW_PG(rec2.cdma_chan[i], RMTYPE, cdma_chan);
      }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      #undef RMTYPE

      break;
    }

    default:
    {
      MSG_MED( "Invalid rec type %d", record_type, 0, 0 );
      break;
    }

  } /* end of switch */

} /* xlate_ext_e_glb_redir_rec */

/*===========================================================================

FUNCTION XLATE_EXT_E_GLB_REDIR

DESCRIPTION
  This function translates a Paging Channel Extended Global Service Redirection
  Message (EGSRM) from external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Extended Global Service Redirection message
  type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_e_glb_redir
(
  word len,
    /* Length of message in bits */
    /*lint -esym(715,len) */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  byte record_len;

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_ext_glb_redir_msg_type

  /* -------------------------------------------------
  ** Start translating message at field after msg_type
  ** ------------------------------------------------- */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(egsrm.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(egsrm.config_msg_seq, MTYPE, config_msg_seq);
  UNPACKW_PG(egsrm.first.redirect_accolc, MTYPE, redirect_accolc);
  UNPACKB_PG(egsrm.return_if_fail, MTYPE, return_if_fail);
  UNPACKB_PG(egsrm.first.delete_tmsi, MTYPE, delete_tmsi);
  UNPACKB_PG(egsrm.first.redirect_p_rev_incl, MTYPE, redirect_p_rev_incl);

  if (int_ptr->egsrm.first.redirect_p_rev_incl)
  {
    UNPACKB_PG(egsrm.first.excl_p_rev_ind, MTYPE, excl_p_rev_ind);
    UNPACKB_PG(egsrm.first.redirect_p_min, MTYPE, redirect_p_min);
    UNPACKB_PG(egsrm.first.redirect_p_max, MTYPE, redirect_p_max);
  }

  UNPACKB_PG(egsrm.first.record_type, MTYPE, record_type);

  record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, record_len));
  ext_msg_pos += FSIZ(MTYPE, record_len);

  xlate_ext_e_glb_redir_rec(int_ptr->egsrm.first.record_type, len, ext_msg_pos,
    buf_ptr, &int_ptr->egsrm.first.redir); 
  ext_msg_pos += record_len * 8;

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  #undef MTYPE

  return (status);

} /* xlate_ext_e_glb_redir */

/*===========================================================================

FUNCTION XLATE_EXT_E_CL

DESCRIPTION
  This function translates an Extended CDMA Channel List Message (ECCLM) from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the ExtendedCDMA Channel List message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_e_cl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
#ifdef FEATURE_IS2000_REL_A
  word min_len;
    /* Protocol dependent minimum length requirement */
#endif /* FEATURE_IS2000_REL_A */
  word i;
    /* Index for looping through channels */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_ext_chnlist_msg_type

  if ( len < CAI_EXT_CHNLIST_MIN )
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------------------------------------------------------------
    ** Length is ok - finish converting message from external to internal
    ** format starting with the first field after message_type
    ** ------------------------------------------------------------------ */
    ext_msg_pos = FSIZ(MTYPE, msg_type);

    UNPACKW_PG(ecclm.pilot_pn, MTYPE, pilot_pn);
    UNPACKB_PG(ecclm.config_msg_seq, MTYPE, config_msg_seq);
    UNPACKB_PG(ecclm.num_freq, MTYPE, num_freq);

    for (i=0; i < int_ptr->ecclm.num_freq && 
              i < CAI_EXT_CHNLIST_FREQ_MAX; i++)
    {
      UNPACKW_PG(ecclm.cdma_freq[i], MTYPE, cdma_freq);
    }

    UNPACKB_PG(ecclm.rc_qpch_sel_incl, MTYPE, rc_qpch_sel_incl);

    if (int_ptr->ecclm.rc_qpch_sel_incl)
    {
      for (i=0; i < int_ptr->ecclm.num_freq && 
                i < CAI_EXT_CHNLIST_FREQ_MAX; i++)
      {
        UNPACKB_PG(ecclm.rc_qpch_hash_ind[i], MTYPE, rc_qpch_hash_ind );
      }
    }

#ifdef FEATURE_IS2000_REL_A
    /* Length check on mandatory fields + minimim reserved bits */
    min_len = FSIZ( MTYPE, td_sel_incl );
    if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
    {
      min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
    }

    if ( ( ( len - ext_msg_pos ) >= min_len )
#ifdef FEATURE_DYNAMIC_P_REV
         && ( cdma.mob_cai_rev >= CAIX_P_REV_IS2000_REL_A )
#endif /* FEATURE_DYNAMIC_P_REV */
       )
    {
      int_ptr->ecclm.is2000_rel_a_incl = TRUE;

      UNPACKB_PG(ecclm.td_sel_incl, MTYPE, td_sel_incl);

      if (int_ptr->ecclm.td_sel_incl)
      {
        UNPACKB_PG(ecclm.td_mode, MTYPE, td_mode);

        for (i=0; i < int_ptr->ecclm.num_freq && 
                  i < CAI_EXT_CHNLIST_FREQ_MAX; i++)
        {
          UNPACKB_PG(ecclm.td_sel[i].td_hash_ind, MTYPE, td_hash_ind);
          if (int_ptr->ecclm.td_sel[i].td_hash_ind)
          {
            UNPACKB_PG(ecclm.td_sel[i].td_power_level, MTYPE, td_power_level);
          }
        }
      }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    }
#endif /* FEATURE_IS2000_REL_A */

  }

  #undef MTYPE

  return (status);

} /* xlate_ext_e_cl */

#ifdef FEATURE_IS2000_REL_D_BCMCS
#error code not present
#endif /* FEATURE_IS2000_REL_D_BCMCS */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_EXT_SMCM

DESCRIPTION
  This function translates the Security Mode Command Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_smcm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position in message relative to start of buf_ptr */
  #ifdef FEATURE_IS2000_REL_C
  word min_len;
    /* Protocol dependent length check */
  #endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */
    
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ext_msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&ext_msg_pos, buf_ptr, &int_ptr->smcm.hdr);
  
#ifdef FEATURE_IS2000_REL_C
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
       CAIX_MACI_REQUIRED, &ext_msg_pos,
       buf_ptr, &int_ptr->smcm.hdr.msg_int, int_ptr->smcm.msg_type,
       int_ptr->smcm.hdr.ack_req
       )) 
       != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &ext_msg_pos, buf_ptr,
       &int_ptr->smcm.hdr, int_ptr->smcm.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }
#endif /* FEATURE_IS2000_REL_A */

  #define MTYPE cai_sec_mode_cmd_msg_type

  UNPACKB_PG(smcm.c_sig_encrypt_mode, MTYPE, c_sig_encrypt_mode);

  if ((int_ptr->smcm.c_sig_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
      (int_ptr->smcm.c_sig_encrypt_mode == CAI_ENC_MODE_REA))
  {
    UNPACKB_PG(smcm.enc_key_size, MTYPE, enc_key_size);
  }

#ifdef FEATURE_IS2000_REL_C
  /* Minimum length check */
  min_len = FSIZ(MTYPE, msg_int_info_incl);
  if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
  {
    min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
  }

  if ( ( len - ext_msg_pos ) >= min_len )
  {
    int_ptr->smcm.is2000_rel_c_incl = TRUE;

    UNPACKB_PG(smcm.msg_int_info_incl, MTYPE, msg_int_info_incl);

    if (int_ptr->smcm.msg_int_info_incl)
    {
      UNPACKB_PG(smcm.change_keys, MTYPE, change_keys);
      UNPACKB_PG(smcm.use_uak, MTYPE, use_uak);
    }
  }
#endif /* FEATURE_IS2000_REL_C */

  #undef MTYPE

  return (status);

}  /* xlate_ext_smcm */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_EXT_AUTH_REQ

DESCRIPTION
  This function translates the Authentication Request Message from external
  to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the message type.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ext_auth_req
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr,
    /* Pointer to place where translated message should be placed */
  word chn,
    /* Physical Channel this message is received on */
  byte pd
    /* Protocol discriminator */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word msg_pos;
    /* Position in message relative to start of buf_ptr */
         
#ifdef FEATURE_IS2000_REL_C_AKA
#error code not present
#endif /* FEATURE_IS2000_REL_C_AKA */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------------------------------------
  ** Length is ok - finish converting message from external to internal
  ** format starting with the first field after message_type
  ** ------------------------------------------------------------------ */
  msg_pos = FSIZ(cai_pc_hdr_type, msg_type);

  xlate_ext_pc_hdr(&msg_pos, buf_ptr, &int_ptr->auth_req.hdr);
  
  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Message Integrity fields and
  ** MACI field if there is one.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_mi_and_validate_maci(len, chn, pd, 
       CAIX_MACI_NOT_REQUIRED, &msg_pos,
       buf_ptr, &int_ptr->auth_req.hdr.msg_int, 
       int_ptr->auth_req.msg_type,
       int_ptr->auth_req.hdr.ack_req
       )) 
      != CAIX_DONE_S)
  {
    return status;
  }

  /* ------------------------------------------------------------------
  ** Now we have to take a look at the Extended Encryption fields if
  ** there is one, and run the decryption algorithm.
  ** ------------------------------------------------------------------ */
  if ((status = xlate_ext_ext_enc(&len, chn, pd, &msg_pos, buf_ptr,
      &int_ptr->auth_req.hdr, int_ptr->auth_req.msg_type, 0, 0)) != CAIX_DONE_S)
  {
    return status;
  }

  #define FTYPE cai_auth_req_type

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, randa)/2, int_ptr->auth_req.randa_hi);
  msg_pos += FSIZ(FTYPE, randa) / 2;

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, randa)/2, int_ptr->auth_req.randa_lo);
  msg_pos += FSIZ(FTYPE, randa) / 2;

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, con_sqn), int_ptr->auth_req.con_sqn);
  msg_pos += FSIZ(FTYPE, con_sqn);

  int_ptr->auth_req.amf = b_unpackw(buf_ptr, msg_pos, FSIZ(FTYPE, amf));
  msg_pos += FSIZ(FTYPE, amf);

  b_unpackq(buf_ptr, msg_pos, FSIZ(FTYPE, mac_a), int_ptr->auth_req.mac_a);
  msg_pos += FSIZ(FTYPE, mac_a);

  #undef FTYPE

  return (status);

}  /* xlate_ext_auth_req */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A_CC
/*===========================================================================

FUNCTION XLATE_ANSI41_SYS_PARM

DESCRIPTION
  This function translates an ANSI-41 System Parameters Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the ANSI-41 Sys Parm type

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ansi41_sys_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  #ifdef FEATURE_IS2000_REL_C
  word min_len;
    /* Protocol dependent minimum length requirement */
  #endif /* FEATURE_IS2000_REL_C */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_a41_sys_parm_msg_type

  /* ------------------------------------------------------------------
  ** Length is ok - finish converting message from external to internal
  ** format starting with the first field after message_type
  ** ------------------------------------------------------------------ */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(a41spm.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(a41spm.config_msg_seq, MTYPE, config_msg_seq);
  UNPACKW_PG(a41spm.sid, MTYPE, sid);
  UNPACKW_PG(a41spm.nid, MTYPE, nid);
  UNPACKB_PG(a41spm.packet_zone_id, MTYPE, packet_zone_id);
  UNPACKW_PG(a41spm.reg_zone, MTYPE, reg_zone);
  UNPACKB_PG(a41spm.total_zones, MTYPE, total_zones);
  UNPACKB_PG(a41spm.zone_timer, MTYPE, zone_timer);
  UNPACKB_PG(a41spm.mult_sids, MTYPE, mult_sids);
  UNPACKB_PG(a41spm.mult_nids, MTYPE, mult_nids);
  UNPACKB_PG(a41spm.home_reg, MTYPE, home_reg);
  UNPACKB_PG(a41spm.for_sid_reg, MTYPE, for_sid_reg);
  UNPACKB_PG(a41spm.for_nid_reg, MTYPE, for_nid_reg);
  UNPACKB_PG(a41spm.power_up_reg, MTYPE, power_up_reg);
  UNPACKB_PG(a41spm.power_down_reg, MTYPE, power_down_reg);
  UNPACKB_PG(a41spm.parameter_reg, MTYPE, parameter_reg);
  UNPACKB_PG(a41spm.reg_prd, MTYPE, reg_prd);
  UNPACKB_PG(a41spm.dist_reg_incl, MTYPE, dist_reg_incl);

  if (int_ptr->a41spm.dist_reg_incl)
  {
    UNPACKW_PG(a41spm.reg_dist, MTYPE ,reg_dist);
  }

  UNPACKB_PG(a41spm.delete_for_tmsi, MTYPE, delete_for_tmsi);
  UNPACKB_PG(a41spm.use_tmsi, MTYPE, use_tmsi);
  UNPACKB_PG(a41spm.pref_msid_type, MTYPE, pref_msid_type);
  UNPACKB_PG(a41spm.tmsi_zone_len, MTYPE, tmsi_zone_len);

  b_unpackq(buf_ptr, ext_msg_pos, int_ptr->a41spm.tmsi_zone_len * 8,
    int_ptr->a41spm.tmsi_zone);
  ext_msg_pos += int_ptr->a41spm.tmsi_zone_len * 8;

  UNPACKB_PG(a41spm.imsi_t_supported, MTYPE, imsi_t_supported);
  UNPACKB_PG(a41spm.max_num_alt_so, MTYPE, max_num_alt_so);
  UNPACKB_PG(a41spm.auto_msg_supported, MTYPE, auto_msg_supported);

  if (int_ptr->a41spm.auto_msg_supported)
  {
    UNPACKB_PG(a41spm.auto_msg_interval, MTYPE, auto_msg_interval);
  }

  UNPACKB_PG(a41spm.other_info_incl, MTYPE, other_info_incl);

  if (int_ptr->a41spm.other_info_incl)
  {
    UNPACKW_PG(a41spm.base_id, MTYPE, base_id);
    UNPACKW_PG(a41spm.mcc, MTYPE, mcc);
    UNPACKB_PG(a41spm.imsi_11_12, MTYPE, imsi_11_12);
    UNPACKB_PG(a41spm.broadcast_gps_asst, MTYPE, broadcast_gps_asst);
    UNPACKB_PG(a41spm.sig_encrypt_sup, MTYPE, sig_encrypt_sup);
  }

  UNPACKB_PG(a41spm.cs_supported, MTYPE, cs_supported);
  UNPACKB_PG(a41spm.ms_init_pos_loc_sup_ind, MTYPE, ms_init_pos_loc_sup_ind);

#ifdef FEATURE_IS2000_REL_C
    /* Length check on mandatory fields + minimim reserved bits */
    min_len = FSIZ( MTYPE, msg_integrity_sup ) +
              int_ptr->a41spm.other_info_incl * FSIZ( MTYPE, imsi_10_incl );
    if ( ( ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8 ) > 0 )
    {
      min_len += 8 - ( ext_msg_pos + min_len + CAI_PC_CRC_SIZE ) % 8;
    }

  if ( ( ( ( len - ext_msg_pos ) >= min_len ) )
#ifdef FEATURE_DYNAMIC_P_REV
       && ( cdma.mob_cai_rev >= P_REV_IS2000_REL_C )
#endif /* FEATURE_DYNAMIC_P_REV */
     )
  {
    int_ptr->a41spm.is2000_rel_c_incl = TRUE;

    UNPACKB_PG(a41spm.msg_integrity_sup, MTYPE, msg_integrity_sup);

    if (int_ptr->a41spm.msg_integrity_sup)
    {
      UNPACKB_PG(a41spm.sig_integrity_sup_incl, MTYPE, sig_integrity_sup_incl);

      if (int_ptr->a41spm.sig_integrity_sup_incl)
      {
        UNPACKB_PG(a41spm.sig_integrity_sup, MTYPE, sig_integrity_sup);
      }
    }

    if (int_ptr->a41spm.other_info_incl)
    {
      UNPACKB_PG(a41spm.imsi_10_incl, MTYPE, imsi_10_incl);

      if (int_ptr->a41spm.imsi_10_incl)
      {
        UNPACKB_PG(a41spm.imsi_10, MTYPE, imsi_10);
      }
    }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  }
#endif /* FEATURE_IS2000_REL_C */

  #undef MTYPE

  return (status);

} /* xlate_ansi41_sys_parm */

/*===========================================================================

FUNCTION XLATE_MC_RR_PARM

DESCRIPTION
  This function translates an MC-RR Parameters Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the MC-RR Parm type

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_mc_rr_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word ext_msg_pos;
    /* Position of record in message */
  word i;
    /* index */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_mc_rr_parm_msg_type

  /* ------------------------------------------------------------------
  ** Length is ok - finish converting message from external to internal
  ** format starting with the first field after message_type
  ** ------------------------------------------------------------------ */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(mcrrpm.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(mcrrpm.config_msg_seq, MTYPE, config_msg_seq);
  UNPACKW_PG(mcrrpm.base_id, MTYPE, base_id);
  UNPACKB_PG(mcrrpm.p_rev, MTYPE, p_rev);
  UNPACKB_PG(mcrrpm.min_p_rev, MTYPE, min_p_rev);
  UNPACKB_PG(mcrrpm.sr3_incl, MTYPE, sr3_incl);

  if (int_ptr->mcrrpm.sr3_incl)
  {
    UNPACKB_PG(mcrrpm.sr3_center_freq_incl, MTYPE, sr3_center_freq_incl);
    if (int_ptr->mcrrpm.sr3_center_freq_incl)
    {
      UNPACKW_PG(mcrrpm.sr3_center_freq, MTYPE, sr3_center_freq);
    }
    UNPACKB_PG(mcrrpm.sr3_brat, MTYPE, sr3_brat);
    UNPACKB_PG(mcrrpm.sr3_bcch_code_chan, MTYPE, sr3_bcch_code_chan);
    UNPACKB_PG(mcrrpm.sr3_primary_pilot, MTYPE, sr3_primary_pilot);
    UNPACKB_PG(mcrrpm.sr3_pilot_power1, MTYPE, sr3_pilot_power1);
    UNPACKB_PG(mcrrpm.sr3_pilot_power2, MTYPE, sr3_pilot_power2);
  }

  UNPACKB_PG(mcrrpm.srch_win_a, MTYPE, srch_win_a);
  UNPACKB_PG(mcrrpm.srch_win_r, MTYPE, srch_win_r);
  UNPACKB_PG(mcrrpm.t_add, MTYPE, t_add);
  UNPACKB_PG(mcrrpm.t_drop, MTYPE, t_drop);
  UNPACKB_PG(mcrrpm.t_comp, MTYPE, t_comp);
  UNPACKB_PG(mcrrpm.t_tdrop, MTYPE, t_tdrop);
  UNPACKB_PG(mcrrpm.nghbr_max_age, MTYPE, nghbr_max_age);
  UNPACKB_PG(mcrrpm.soft_slope, MTYPE, soft_slope);
  UNPACKB_PG(mcrrpm.add_intercept, MTYPE, add_intercept);
  UNPACKB_PG(mcrrpm.drop_intercept, MTYPE, drop_intercept);

  UNPACKB_PG(mcrrpm.enc_supported, MTYPE, enc_supported);

  if (int_ptr->mcrrpm.enc_supported)
  {
    UNPACKB_PG(mcrrpm.sig_encrypt_sup, MTYPE, sig_encrypt_sup);
    UNPACKB_PG(mcrrpm.ui_encrypt_sup, MTYPE, ui_encrypt_sup);
  }

  UNPACKB_PG(mcrrpm.add_fields_len, MTYPE, add_fields_len);

  if (int_ptr->mcrrpm.add_fields_len > 0)
  {
    ext_msg_pos += int_ptr->mcrrpm.add_fields_len * 8;
  }

  UNPACKB_PG(mcrrpm.cch_info_incl, MTYPE, cch_info_incl);

  if (int_ptr->mcrrpm.cch_info_incl)
  {
    UNPACKW_PG(mcrrpm.mcc, MTYPE, mcc);
    UNPACKB_PG(mcrrpm.imsi_11_12, MTYPE, imsi_11_12);
    UNPACKB_PG(mcrrpm.max_slot_cycle_index, MTYPE, max_slot_cycle_index);
    UNPACKB_PG(mcrrpm.pwr_rep_thresh, MTYPE, pwr_rep_thresh);
    UNPACKB_PG(mcrrpm.pwr_rep_frames, MTYPE, pwr_rep_frames);
    UNPACKB_PG(mcrrpm.pwr_thresh_enable, MTYPE, pwr_thresh_enable);
    UNPACKB_PG(mcrrpm.pwr_period_enable, MTYPE, pwr_period_enable);
    UNPACKB_PG(mcrrpm.pwr_rep_delay, MTYPE, pwr_rep_delay);
    UNPACKB_PG(mcrrpm.reselect_included, MTYPE, reselect_included);

    if (int_ptr->mcrrpm.reselect_included)
    {
      UNPACKB_PG(mcrrpm.ec_thresh, MTYPE, ec_thresh);
      UNPACKB_PG(mcrrpm.ec_io_thresh, MTYPE, ec_io_thresh);
    }

    UNPACKD_PG(mcrrpm.base_lat, MTYPE, base_lat);
    UNPACKD_PG(mcrrpm.base_long, MTYPE, base_long);
    UNPACKB_PG(mcrrpm.pilot_report, MTYPE, pilot_report);
    UNPACKB_PG(mcrrpm.acc_ent_ho_order, MTYPE, acc_ent_ho_order);
    UNPACKB_PG(mcrrpm.access_ho, MTYPE, access_ho);

    if (int_ptr->mcrrpm.access_ho)
    {
      UNPACKB_PG(mcrrpm.access_ho_msg_rsp, MTYPE, access_ho_msg_rsp);
    }

    UNPACKB_PG(mcrrpm.access_probe_ho, MTYPE, access_probe_ho);

    if (int_ptr->mcrrpm.access_probe_ho)
    {
      UNPACKB_PG(mcrrpm.acc_ho_list_upd, MTYPE, acc_ho_list_upd);
      UNPACKB_PG(mcrrpm.acc_probe_ho_other_msg, MTYPE, acc_probe_ho_other_msg);
      UNPACKB_PG(mcrrpm.max_number_probe_ho, MTYPE, max_number_probe_ho);
    }

    UNPACKB_PG(mcrrpm.num_fccch, MTYPE, num_fccch);
    UNPACKB_PG(mcrrpm.fccch_rate, MTYPE, fccch_rate);
    UNPACKB_PG(mcrrpm.fccch_code_rate, MTYPE, fccch_code_rate);

    for (i=0; i<int_ptr->mcrrpm.num_fccch; i++)
    {
      UNPACKB_PG(mcrrpm.fccch_code_chan[i], MTYPE, fccch_code_chan);
    }

    UNPACKB_PG(mcrrpm.bcast_index, MTYPE, bcast_index);
    UNPACKB_PG(mcrrpm.num_bcch_bcast, MTYPE, num_bcch_bcast);

    for (i=0; i<int_ptr->mcrrpm.num_bcch_bcast; i++)
    {
      UNPACKB_PG(mcrrpm.bcch_info[i].bcch_code_chan, MTYPE, bcch_code_chan);
      UNPACKB_PG(mcrrpm.bcch_info[i].brat, MTYPE, brat);
      UNPACKB_PG(mcrrpm.bcch_info[i].bcch_code_rate, MTYPE, bcch_code_rate);
    }

    UNPACKB_PG(mcrrpm.qpch_supported, MTYPE, qpch_supported);

    if (int_ptr->mcrrpm.qpch_supported)
    {
      UNPACKB_PG(mcrrpm.num_qpch, MTYPE, num_qpch);
      UNPACKB_PG(mcrrpm.qpch_rate, MTYPE, qpch_rate);
      UNPACKB_PG(mcrrpm.qpch_power_level_page, MTYPE, qpch_power_level_page);
      UNPACKB_PG(mcrrpm.qpch_cci_supported, MTYPE, qpch_cci_supported);

      if (int_ptr->mcrrpm.qpch_cci_supported)
      {
        UNPACKB_PG(mcrrpm.qpch_power_level_config, MTYPE, qpch_power_level_config);
      }

      if (int_ptr->mcrrpm.sr3_incl)
      {
        for (i=0; i<int_ptr->mcrrpm.num_qpch; i++)
        {
          UNPACKB_PG(mcrrpm.qpch_code_chan[i], MTYPE, qpch_code_chan);
        }
      }

      UNPACKB_PG(mcrrpm.qpch_bi_supported, MTYPE, qpch_bi_supported);

      if (int_ptr->mcrrpm.qpch_bi_supported)
      {
        UNPACKB_PG(mcrrpm.qpch_power_level_bcast, MTYPE,
          qpch_power_level_bcast);
      }
    }

    UNPACKB_PG(mcrrpm.sdb_supported, MTYPE, sdb_supported);
    UNPACKB_PG(mcrrpm.broadcast_gps_asst, MTYPE, broadcast_gps_asst);
    UNPACKB_PG(mcrrpm.rlgain_traffic_pilot, MTYPE, rlgain_traffic_pilot);
    UNPACKB_PG(mcrrpm.rev_pwr_cntl_delay_incl, MTYPE, rev_pwr_cntl_delay_incl);

    if (int_ptr->mcrrpm.rev_pwr_cntl_delay_incl)
    {
      UNPACKB_PG(mcrrpm.rev_pwr_cntl_delay, MTYPE, rev_pwr_cntl_delay);
    }

    UNPACKB_PG(mcrrpm.mob_qos, MTYPE, mob_qos);
    UNPACKB_PG(mcrrpm.use_sync_id, MTYPE, use_sync_id);
    UNPACKB_PG(mcrrpm.num_opt_msg, MTYPE, num_opt_msg);

    if (int_ptr->mcrrpm.num_opt_msg >= 1)
    {
      UNPACKB_PG(mcrrpm.sending_rand, MTYPE, sending_rand);

      if (int_ptr->mcrrpm.num_opt_msg >= 2)
      {
        UNPACKB_PG(mcrrpm.pri_nghbr_list, MTYPE, pri_nghbr_list);

        if (int_ptr->mcrrpm.num_opt_msg >= 3)
        {
          UNPACKB_PG(mcrrpm.user_zone_id, MTYPE, user_zone_id);

          if (int_ptr->mcrrpm.num_opt_msg >= 4)
          {
            UNPACKB_PG(mcrrpm.ext_global_redirect, MTYPE, ext_global_redirect);

            if (int_ptr->mcrrpm.num_opt_msg >= 5)
            {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
              /* advance position to skip reserved bits */
              ext_msg_pos += int_ptr->mcrrpm.num_opt_msg - 4;
            }
          }
        }
      }
    }

    UNPACKB_PG(mcrrpm.pilot_info_req_supported, MTYPE,
      pilot_info_req_supported);
  }

#ifdef FEATURE_IS2000_REL_B
  if (int_ptr->mcrrpm.p_rev >= CAIX_P_REV_IS2000_REL_B)
  {
    if (int_ptr->mcrrpm.cch_info_incl)
    {
      UNPACKB_PG(mcrrpm.band_class_info_req, MTYPE, band_class_info_req);

      if (int_ptr->mcrrpm.band_class_info_req)
      {
        UNPACKB_PG(mcrrpm.alt_band_class, MTYPE, alt_band_class);
      }
    }

    UNPACKB_PG(mcrrpm.cdma_off_time_rep_sup_ind, MTYPE,
      cdma_off_time_rep_sup_ind);

    if (int_ptr->mcrrpm.cdma_off_time_rep_sup_ind)
    {
      UNPACKB_PG(mcrrpm.cdma_off_time_rep_threshold_unit, MTYPE,
        cdma_off_time_rep_threshold_unit);
      UNPACKB_PG(mcrrpm.cdma_off_time_rep_threshold, MTYPE,
        cdma_off_time_rep_threshold);
    }
  }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->mcrrpm.p_rev >= CAIX_P_REV_IS2000_REL_C)
  {
    UNPACKB_PG(mcrrpm.chm_supported, MTYPE, chm_supported);
    UNPACKB_PG(mcrrpm.release_to_idle_ind, MTYPE, release_to_idle_ind);
    UNPACKB_PG(mcrrpm.reconnect_msg_ind, MTYPE, reconnect_msg_ind);
    UNPACKB_PG(mcrrpm.t_tdrop_range_incl, MTYPE, t_tdrop_range_incl);

    if (int_ptr->mcrrpm.t_tdrop_range_incl)
    {
      UNPACKB_PG(mcrrpm.t_tdrop_range, MTYPE, t_tdrop_range);
    }

    UNPACKB_PG(mcrrpm.for_pdch_supported, MTYPE, for_pdch_supported);

    if (int_ptr->mcrrpm.for_pdch_supported)
    {
      UNPACKB_PG(mcrrpm.pdch_chm_supported, MTYPE, pdch_chm_supported);
      UNPACKB_PG(mcrrpm.pdch_parms_incl, MTYPE, pdch_parms_incl);

      if (int_ptr->mcrrpm.pdch_parms_incl)
      {
        UNPACKB_PG(mcrrpm.for_pdch_rlgain_incl, MTYPE, for_pdch_rlgain_incl);

        if (int_ptr->mcrrpm.for_pdch_rlgain_incl)
        {
          UNPACKB_PG(mcrrpm.rlgain_ackch_pilot, MTYPE, rlgain_ackch_pilot);
          UNPACKB_PG(mcrrpm.rlgain_cqich_pilot, MTYPE, rlgain_cqich_pilot);
        }

        UNPACKB_PG(mcrrpm.num_soft_switching_frames, MTYPE,
          num_soft_switching_frames);
        UNPACKB_PG(mcrrpm.num_softer_switching_frames, MTYPE,
          num_softer_switching_frames);
        UNPACKB_PG(mcrrpm.num_soft_switching_slots, MTYPE,
          num_soft_switching_slots);
        UNPACKB_PG(mcrrpm.num_softer_switching_slots, MTYPE,
          num_softer_switching_slots);
        UNPACKB_PG(mcrrpm.pdch_soft_switching_delay, MTYPE,
          pdch_soft_switching_delay);
        UNPACKB_PG(mcrrpm.pdch_softer_switching_delay, MTYPE,
          pdch_softer_switching_delay);
        UNPACKB_PG(mcrrpm.walsh_table_id, MTYPE, walsh_table_id);
        UNPACKB_PG(mcrrpm.num_pdcch, MTYPE, num_pdcch);

        for (i = 0; i < int_ptr->mcrrpm.num_pdcch+1; i++)
        {
          UNPACKB_PG(mcrrpm.for_pdcch_walsh[i], MTYPE, for_pdcch_walsh);
        }
      }
    }

    if (int_ptr->mcrrpm.cch_info_incl)
    {
      UNPACKB_PG(mcrrpm.imsi_10_incl, MTYPE, imsi_10_incl);

      if (int_ptr->mcrrpm.imsi_10_incl)
      {
        UNPACKB_PG(mcrrpm.imsi_10, MTYPE, imsi_10);
      }
    }
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  #undef MTYPE

  return (status);

} /* xlate_mc_rr_parm */

/*===========================================================================

FUNCTION XLATE_ANSI41_RAND

DESCRIPTION
  This function translates an ANSI-41 RAND Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the ANSI-41 RAND  type

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_ansi41_rand
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)

{

  word ext_msg_pos;
    /* Position of record in message */
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_a41_rand_msg_type

  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(a41rm.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(a41rm.acc_msg_seq, MTYPE, acc_msg_seq);
  UNPACKD_PG(a41rm.rand, MTYPE, rand);

  #undef MTYPE

  return (status);

} /* xlate_ansi41_rand */

/*===========================================================================

FUNCTION XLATE_EN_AC_PARM

DESCRIPTION
  This function translates an Enhanced Access Parameters Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the EN AC Parm type

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_en_ac_parm
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i;
    /* Index for looping through channels */
  word ext_msg_pos = 0;
    /* Position of record in message */
  word begin_group_pos = 0;
    /* beginning position of this group */
  byte group_length = 0;
    /* length of the current group */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------
  ** Define type for use in PARAMS macro
  ** ----------------------------------- */
  #define MTYPE cai_en_ac_parm_type

  /* msg_type has already been unpacked */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(enacpm.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(enacpm.acc_msg_seq, MTYPE, acc_msg_seq);

  UNPACKB_PG(enacpm.psist_parms_incl, MTYPE, psist_parms_incl);
  if (int_ptr->enacpm.psist_parms_incl)
  {
    /* store page position at beginning of group */
    begin_group_pos = ext_msg_pos;
    /* store the length of this group and increment the page position */
    group_length = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, psist_parms_len));
    ext_msg_pos += FSIZ(MTYPE, psist_parms_len);
    /* unpack the rest of the group */
    UNPACKB_PG(enacpm.psist_0_9_each, MTYPE, psist_0_9_each);
    UNPACKB_PG(enacpm.psist_10_each, MTYPE, psist_10_each);
    UNPACKB_PG(enacpm.psist_11_each, MTYPE, psist_11_each);
    UNPACKB_PG(enacpm.psist_12_each, MTYPE, psist_12_each);
    UNPACKB_PG(enacpm.psist_13_each, MTYPE, psist_13_each);
    UNPACKB_PG(enacpm.psist_14_each, MTYPE, psist_14_each);
    UNPACKB_PG(enacpm.psist_15_each, MTYPE, psist_15_each);
    UNPACKB_PG(enacpm.psist_emg, MTYPE, psist_emg);
    UNPACKB_PG(enacpm.msg_psist_each, MTYPE, msg_psist_each);
    UNPACKB_PG(enacpm.reg_psist_each, MTYPE, reg_psist_each);
    /* move page position to the end of the group (in case we skipped
       fields and to ensure we are on a byte boundary) */
    ext_msg_pos = begin_group_pos + group_length * 8;
  }

  begin_group_pos = ext_msg_pos;
  group_length = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, lac_parms_len));
  ext_msg_pos += FSIZ(MTYPE, lac_parms_len);
  UNPACKB_PG(enacpm.acc_tmo,MTYPE,acc_tmo);

  ext_msg_pos += FSIZ(MTYPE, reserved1);

  UNPACKB_PG(enacpm.max_req_seq, MTYPE, max_req_seq);
  UNPACKB_PG(enacpm.max_rsp_seq, MTYPE, max_rsp_seq);
  ext_msg_pos = begin_group_pos + group_length * 8;

  UNPACKB_PG(enacpm.num_mode_selection_entries, MTYPE,
    num_mode_selection_entries);
  for (i=0; i<int_ptr->enacpm.num_mode_selection_entries+1; i++)
  {
    UNPACKB_PG(enacpm.mode_selection[i].access_mode, MTYPE,
      access_mode);
    UNPACKW_PG(enacpm.mode_selection[i].access_mode_min_duration, MTYPE,
      access_mode_min_duration);
    UNPACKW_PG(enacpm.mode_selection[i].access_mode_max_duration, MTYPE,
      access_mode_max_duration);
  }

  UNPACKB_PG(enacpm.rlgain_common_pilot, MTYPE, rlgain_common_pilot);
  UNPACKB_PG(enacpm.ic_thresh, MTYPE, ic_thresh);
  UNPACKB_PG(enacpm.ic_max, MTYPE, ic_max);

  UNPACKB_PG(enacpm.num_mode_parm_rec, MTYPE, num_mode_parm_rec);
  for (i=0; i<int_ptr->enacpm.num_mode_parm_rec+1; i++)
  {
    begin_group_pos = ext_msg_pos;
    group_length = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(MTYPE, each_parm_rec_len));
    ext_msg_pos += FSIZ(MTYPE, each_parm_rec_len);
    UNPACKB_PG(enacpm.mode_parms[i].applicable_modes, MTYPE, applicable_modes);
    UNPACKB_PG(enacpm.mode_parms[i].each_nom_pwr, MTYPE, each_nom_pwr);
    UNPACKB_PG(enacpm.mode_parms[i].each_init_pwr, MTYPE, each_init_pwr);
    UNPACKB_PG(enacpm.mode_parms[i].each_pwr_step, MTYPE, each_pwr_step);
    UNPACKB_PG(enacpm.mode_parms[i].each_num_step, MTYPE, each_num_step);
    UNPACKB_PG(enacpm.mode_parms[i].each_preamble_enabled, MTYPE,
      each_preamble_enabled);
    if (int_ptr->enacpm.mode_parms[i].each_preamble_enabled)
    {
      UNPACKB_PG(enacpm.mode_parms[i].each_preamble_num_frac, MTYPE,
        each_preamble_num_frac);
      UNPACKB_PG(enacpm.mode_parms[i].each_preamble_frac_duration, MTYPE,
        each_preamble_frac_duration);
      UNPACKB_PG(enacpm.mode_parms[i].each_preamble_off_duration, MTYPE,
        each_preamble_off_duration);
      UNPACKB_PG(enacpm.mode_parms[i].each_preamble_add_duration, MTYPE,
        each_preamble_add_duration);
    }

    ext_msg_pos += FSIZ(MTYPE, reserved2);

    UNPACKB_PG(enacpm.mode_parms[i].each_probe_bkoff, MTYPE, each_probe_bkoff);
    UNPACKB_PG(enacpm.mode_parms[i].each_bkoff, MTYPE, each_bkoff);
    UNPACKB_PG(enacpm.mode_parms[i].each_slot, MTYPE, each_slot);
    UNPACKB_PG(enacpm.mode_parms[i].each_slot_offset1, MTYPE,
      each_slot_offset1);
    UNPACKB_PG(enacpm.mode_parms[i].each_slot_offset2, MTYPE,
      each_slot_offset2);
    ext_msg_pos = begin_group_pos + group_length * 8;
  }

  int_ptr->enacpm.ba_parms_len = b_unpackb(buf_ptr, ext_msg_pos,
    FSIZ(MTYPE, ba_parms_len));
  ext_msg_pos += FSIZ(MTYPE, ba_parms_len);
  if (int_ptr->enacpm.ba_parms_len)
  {
    begin_group_pos = ext_msg_pos;
    UNPACKB_PG(enacpm.num_each_ba, MTYPE, num_each_ba);
    UNPACKB_PG(enacpm.each_ba_rates_supported, MTYPE, each_ba_rates_supported);
    ext_msg_pos = begin_group_pos + int_ptr->enacpm.ba_parms_len * 8;
  }

  int_ptr->enacpm.ra_parms_len = b_unpackb(buf_ptr, ext_msg_pos,
    FSIZ(MTYPE, ra_parms_len));
  ext_msg_pos += FSIZ(MTYPE, ra_parms_len);
  if (int_ptr->enacpm.ra_parms_len)
  {
    begin_group_pos = ext_msg_pos;
    UNPACKB_PG(enacpm.num_each_ra, MTYPE, num_each_ra);
    //  UNPACKB_PG(enacpm.each_ra_rates_supported,MTYPE,each_ra_rates_supported);
    UNPACKB_PG(enacpm.num_cach, MTYPE, num_cach);
    UNPACKB_PG(enacpm.cach_code_rate, MTYPE, cach_code_rate);
    for (i=0; i<int_ptr->enacpm.num_cach+1; i++)
    {
      UNPACKB_PG(enacpm.cach_code_chan[i], MTYPE, cach_code_chan);
    }

    UNPACKB_PG(enacpm.num_rccch, MTYPE, num_rccch);
    UNPACKB_PG(enacpm.rccch_rates_supported, MTYPE, rccch_rates_supported);
    UNPACKB_PG(enacpm.rccch_preamble_enabled, MTYPE, rccch_preamble_enabled);
    if (int_ptr->enacpm.rccch_preamble_enabled)
    {
      UNPACKB_PG(enacpm.rccch_preamble_num_frac, MTYPE, rccch_preamble_num_frac);
      UNPACKB_PG(enacpm.rccch_preamble_frac_duration, MTYPE,
        rccch_preamble_frac_duration);
      UNPACKB_PG(enacpm.rccch_preamble_off_duration, MTYPE,
        rccch_preamble_off_duration);
      UNPACKB_PG(enacpm.rccch_preamble_add_duration, MTYPE,
        rccch_preamble_add_duration);
    }
    UNPACKB_PG(enacpm.rccch_slot, MTYPE, rccch_slot);
    UNPACKB_PG(enacpm.rccch_slot_offset1, MTYPE, rccch_slot_offset1);
    UNPACKB_PG(enacpm.rccch_slot_offset2, MTYPE, rccch_slot_offset2);
    UNPACKB_PG(enacpm.rccch_nom_pwr, MTYPE, rccch_nom_pwr);
    UNPACKB_PG(enacpm.rccch_init_pwr, MTYPE, rccch_init_pwr);
    UNPACKB_PG(enacpm.ra_pc_delay, MTYPE, ra_pc_delay);

    UNPACKB_PG(enacpm.eacam_cach_delay, MTYPE, eacam_cach_delay);
    UNPACKB_PG(enacpm.rccch_ho_supported, MTYPE, rccch_ho_supported);
    if (int_ptr->enacpm.rccch_ho_supported)
    {
      UNPACKB_PG(enacpm.rccch_ho_thresh, MTYPE, rccch_ho_thresh);
      UNPACKB_PG(enacpm.eacam_pccam_delay, MTYPE, eacam_pccam_delay);
    }
    UNPACKB_PG(enacpm.num_cpcch, MTYPE, num_cpcch);
    UNPACKB_PG(enacpm.cpcch_rate, MTYPE, cpcch_rate);
    for (i=0; i<int_ptr->enacpm.num_cpcch+1; i++)
    {
      UNPACKB_PG(enacpm.cpcch_code_chan[i], MTYPE, cpcch_code_chan);
    }

    UNPACKB_PG(enacpm.num_pcsch_ra, MTYPE, num_pcsch_ra);
    ext_msg_pos = begin_group_pos + int_ptr->enacpm.ra_parms_len * 8;
  }

  /* Support for ACCT fields */
  UNPACKB_PG(enacpm.acct_incl, MTYPE, acct_incl);

  if (int_ptr->enacpm.acct_incl)
  {
    UNPACKB_PG(enacpm.acct_incl_emg, MTYPE, acct_incl_emg);
    UNPACKB_PG(enacpm.acct_aoc_bitmap_incl, MTYPE, acct_aoc_bitmap_incl);
    UNPACKB_PG(enacpm.acct_so_incl, MTYPE, acct_so_incl);

    if (int_ptr->enacpm.acct_so_incl)
    {
      UNPACKB_PG(enacpm.num_acct_so, MTYPE, num_acct_so);

      for (i=0; i<(int_ptr->enacpm.num_acct_so+1); i++)
      {
        if (int_ptr->enacpm.acct_aoc_bitmap_incl)
        {
          UNPACKB_PG(enacpm.acct_so_info[i].acct_aoc_bitmap1, MTYPE,
            acct_aoc_bitmap1);
        }
        UNPACKW_PG(enacpm.acct_so_info[i].acct_so, MTYPE, acct_so);
      }
    }

    UNPACKB_PG(enacpm.acct_so_grp_incl, MTYPE, acct_so_grp_incl);

    if (int_ptr->enacpm.acct_so_grp_incl)
    {
      UNPACKB_PG(enacpm.num_acct_so_grp, MTYPE, num_acct_so_grp);
      for (i=0; i<(int_ptr->enacpm.num_acct_so_grp+1); i++)
      {
        if (int_ptr->enacpm.acct_aoc_bitmap_incl)
        {
          UNPACKB_PG(enacpm.acct_so_grp_info[i].acct_aoc_bitmap2, MTYPE,
            acct_aoc_bitmap2);
        }
        UNPACKB_PG(enacpm.acct_so_grp_info[i].acct_so_grp, MTYPE, acct_so_grp);
      }
    }
  }

  #undef MTYPE

  return (status);

} /* xlate_en_ac_parm_msg */

/*===========================================================================

FUNCTION XLATE_UNIV_NL

DESCRIPTION
  This function translates an Universal Neighbor List Message from
  external to internal format.

DEPENDENCIES
  Assumes that the internal message type received as an input to the
  procedure already includes the Univ NL type

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
word xlate_univ_nl
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word i,j;
    /* Indexes for looping through channels */
  word ext_msg_pos;
    /* Position of record in message */
  word old_ext_msg_pos;
    /* stored position of record in message */
  word record_len;
    /* length of sub_record */
  word radio_interface_len;
    /* length of radio_interface */
  #ifdef FEATURE_IS2000_REL_B
  word min_len;
    /* Protocol dependent minimum length requirement */
  #endif /* FEATURE_IS2000_REL_B */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_univ_nl_msg_type

  /* msg_type has already been unpacked */
  ext_msg_pos = FSIZ(MTYPE, msg_type);

  UNPACKW_PG(unlm.pilot_pn, MTYPE, pilot_pn);
  UNPACKB_PG(unlm.config_msg_seq, MTYPE, config_msg_seq);
  UNPACKB_PG(unlm.num_radio_interface, MTYPE ,num_radio_interface);

  for (i=0; i<int_ptr->unlm.num_radio_interface &&
            i<CAI_MAX_NUM_RADIO_INTERFACE; i++)
  {
    UNPACKB_PG(unlm.ri_info[i].radio_interface_type, MTYPE ,radio_interface_type);
    radio_interface_len = b_unpackb(buf_ptr, ext_msg_pos, 
      FSIZ(MTYPE, radio_interface_len));
    ext_msg_pos += FSIZ(MTYPE, radio_interface_len);

    old_ext_msg_pos = ext_msg_pos;

    if (int_ptr->unlm.ri_info[i].radio_interface_type == CAI_UNLM_RADIO_INTERFACE_MC)
    {
      UNPACKB_PG(unlm.ri_info[i].ri.type0.pilot_inc, MTYPE, pilot_inc);
      UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr_srch_mode, MTYPE, nghbr_srch_mode);

      if ((int_ptr->unlm.ri_info[i].ri.type0.nghbr_srch_mode == SRCH_NO_PRI_OR_WIN)||
          (int_ptr->unlm.ri_info[i].ri.type0.nghbr_srch_mode == SRCH_PRI_ONLY))
      {
        UNPACKB_PG(unlm.ri_info[i].ri.type0.srch_win_n, MTYPE, srch_win_n);
      }

      UNPACKB_PG(unlm.ri_info[i].ri.type0.srch_offset_incl, MTYPE, srch_offset_incl);
      UNPACKB_PG(unlm.ri_info[i].ri.type0.freq_fields_incl, MTYPE, freq_fields_incl);
      UNPACKB_PG(unlm.ri_info[i].ri.type0.use_timing, MTYPE, use_timing);

      if (int_ptr->unlm.ri_info[i].ri.type0.use_timing)
      {
        UNPACKB_PG(unlm.ri_info[i].ri.type0.global_timing_incl, MTYPE, global_timing_incl);

        if (int_ptr->unlm.ri_info[i].ri.type0.global_timing_incl)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.global_tx_duration, MTYPE, global_tx_duration);
          UNPACKB_PG(unlm.ri_info[i].ri.type0.global_tx_period, MTYPE, global_tx_period);
        }
      }

      UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr_set_entry_info, MTYPE, nghbr_set_entry_info);
      UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr_set_access_info, MTYPE, nghbr_set_access_info);
      UNPACKB_PG(unlm.ri_info[i].ri.type0.num_nghbr, MTYPE, num_nghbr);

      for (j=0; j<int_ptr->unlm.ri_info[i].ri.type0.num_nghbr &&
                j<CAI_UNLM_MAX_NUM_NGHBR; j++)
      {
        UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].nghbr_config, MTYPE, nghbr_config);
        UNPACKW_PG(unlm.ri_info[i].ri.type0.nghbr[j].nghbr_pn, MTYPE, nghbr_pn);

        if (int_ptr->unlm.ri_info[i].ri.type0.nghbr[j].nghbr_config == 3)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].bcch_support, MTYPE, bcch_support);
        }

        UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].add_pilot_rec_incl, MTYPE, add_pilot_rec_incl);

        if (int_ptr->unlm.ri_info[i].ri.type0.nghbr[j].add_pilot_rec_incl)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].nghbr_pilot_rec_type,
            MTYPE, nghbr_pilot_rec_type);

          record_len = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(MTYPE, record_len));
          ext_msg_pos += FSIZ(MTYPE, record_len);

          /* translate the additional pilot record fields */
          xlate_add_pilot_rec(int_ptr->unlm.ri_info[i].ri.type0.nghbr[j].nghbr_pilot_rec_type,
            buf_ptr, ext_msg_pos, &(int_ptr->unlm.ri_info[i].ri.type0.nghbr[j].pilot_rec));
          ext_msg_pos += record_len * 8;
        }

        if ((int_ptr->unlm.ri_info[i].ri.type0.nghbr_srch_mode == 1)||
            (int_ptr->unlm.ri_info[i].ri.type0.nghbr_srch_mode == 3))
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].search_priority, MTYPE,
            search_priority);
        }

        if ((int_ptr->unlm.ri_info[i].ri.type0.nghbr_srch_mode == 2)||
            (int_ptr->unlm.ri_info[i].ri.type0.nghbr_srch_mode == 3))
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].srch_win_nghbr, MTYPE,
            srch_win_nghbr);
        }

        if (int_ptr->unlm.ri_info[i].ri.type0.srch_offset_incl)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].srch_offset_nghbr, MTYPE,
            srch_offset_nghbr);
        }

        if (int_ptr->unlm.ri_info[i].ri.type0.freq_fields_incl)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].freq_incl, MTYPE, freq_incl);

          if (int_ptr->unlm.ri_info[i].ri.type0.nghbr[j].freq_incl)
          {
            UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].nghbr_band, MTYPE, nghbr_band);
            UNPACKW_PG(unlm.ri_info[i].ri.type0.nghbr[j].nghbr_freq, MTYPE, nghbr_freq);
          }
        }

        if (int_ptr->unlm.ri_info[i].ri.type0.use_timing)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].timing_incl, MTYPE, timing_incl);

          if (int_ptr->unlm.ri_info[i].ri.type0.nghbr[j].timing_incl)
          {
            UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].nghbr_tx_offset, MTYPE,
              nghbr_tx_offset);

            if (!int_ptr->unlm.ri_info[i].ri.type0.global_timing_incl)
            {
              UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].nghbr_tx_duration, 
                MTYPE, nghbr_tx_duration);
              UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].nghbr_tx_period, 
                MTYPE, nghbr_tx_period);
            }
          }
        }

        if (int_ptr->unlm.ri_info[i].ri.type0.nghbr_set_entry_info)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].access_entry_ho, 
            MTYPE, access_entry_ho);
        }

        if (int_ptr->unlm.ri_info[i].ri.type0.nghbr_set_access_info)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr[j].access_ho_allowed, MTYPE,
            access_ho_allowed);
        }
      }

#ifdef FEATURE_IS2000_REL_B
      /* Length check on mandatory fields + minimum reserved bits */
      min_len = FSIZ( MTYPE, resq_enabled );

      if ( ( ( ext_msg_pos - old_ext_msg_pos + min_len ) % 8 ) > 0 )
      {
        min_len += 8 - ( ext_msg_pos - old_ext_msg_pos + min_len ) % 8;
      }

      if ( ( ( ext_msg_pos - old_ext_msg_pos ) < ( radio_interface_len * 8 ) )
           && ( ( radio_interface_len * 8 - ext_msg_pos + old_ext_msg_pos ) >= min_len )
#ifdef FEATURE_DYNAMIC_P_REV
           && ( cdma.mob_cai_rev >= P_REV_IS2000_REL_B )
#endif /* FEATURE_DYNAMIC_P_REV */
         )
      {
        int_ptr->unlm.ri_info[i].ri.type0.is2000_rel_b_incl = TRUE;

        UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_enabled, MTYPE, resq_enabled);

        if (int_ptr->unlm.ri_info[i].ri.type0.resq_enabled)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_delay_time, MTYPE,
            resq_delay_time);
          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_allowed_time, MTYPE,
            resq_allowed_time);
          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_attempt_time, MTYPE,
            resq_attempt_time);
          UNPACKW_PG(unlm.ri_info[i].ri.type0.resq_code_chan, MTYPE, resq_code_chan);
          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_qof, MTYPE, resq_qof);
          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_min_period_incl, MTYPE,
            resq_min_period_incl);

          if (int_ptr->unlm.ri_info[i].ri.type0.resq_min_period_incl)
          {
            UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_min_period, MTYPE,
              resq_min_period);
          }

          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_num_tot_trans_incl, MTYPE,
            resq_num_tot_trans_incl);

          if (int_ptr->unlm.ri_info[i].ri.type0.resq_num_tot_trans_incl)
          {
            UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_num_tot_trans_20ms, MTYPE,
              resq_num_tot_trans_20ms);
            UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_num_tot_trans_5ms, MTYPE,
              resq_num_tot_trans_5ms);
          }

          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_num_preamble_rc1_rc2, MTYPE,
            resq_num_preamble_rc1_rc2);
          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_num_preamble, MTYPE,
            resq_num_preamble);
          UNPACKB_PG(unlm.ri_info[i].ri.type0.resq_power_delta, MTYPE,
            resq_power_delta);

          for (j=0; j<int_ptr->unlm.ri_info[i].ri.type0.num_nghbr &&
                    j<CAI_UNLM_MAX_NUM_NGHBR; j++)
          {
            UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr_resq_configured[j],
              MTYPE, nghbr_resq_configured);
          }
        }

#ifdef FEATURE_IS2000_REL_C
        /* Length check on mandatory fields + minimum reserved bits */
        min_len = int_ptr->unlm.ri_info[i].ri.type0.num_nghbr *
                  FSIZ( MTYPE, nghbr_pdch_supported );
  
        if ( min_len > 0 )
        {
          if ( ( ( ext_msg_pos - old_ext_msg_pos + min_len ) % 8 ) > 0 )
          {
            min_len += 8 - ( ext_msg_pos - old_ext_msg_pos + min_len ) % 8;
          }

          if ( ( ( ext_msg_pos - old_ext_msg_pos ) < ( radio_interface_len * 8 ) ) 
               && ( ( radio_interface_len * 8 - ext_msg_pos + old_ext_msg_pos ) >= min_len )
#ifdef FEATURE_DYNAMIC_P_REV
               && (cdma.mob_cai_rev >= P_REV_IS2000_REL_C)
#endif /* FEATURE_DYNAMIC_P_REV */
             )
          {
            int_ptr->unlm.ri_info[i].ri.type0.is2000_rel_c_incl = TRUE;

            for (j=0; j<int_ptr->unlm.ri_info[i].ri.type0.num_nghbr &&
                      j<CAI_UNLM_MAX_NUM_NGHBR; j++)
            {
              UNPACKB_PG(unlm.ri_info[i].ri.type0.nghbr_pdch_supported[j],
                MTYPE, nghbr_pdch_supported);
            }
          }
        }
#endif /* FEATURE_IS2000_REL_C */

      }
#endif /* FEATURE_IS2000_REL_B */

    }

    else if (int_ptr->unlm.ri_info[i].radio_interface_type == CAI_UNLM_RADIO_INTERFACE_AMPS)
    {
      UNPACKB_PG(unlm.ri_info[i].ri.type1.num_analog_nghbr, MTYPE,
        num_analog_nghbr);

      for (j=0; j<int_ptr->unlm.ri_info[i].ri.type1.num_analog_nghbr &&
                j<CAI_UNLM_MAX_NUM_ANALOG_NGHBR; j++)
      {
        UNPACKB_PG(unlm.ri_info[i].ri.type1.nghbr[j].band_class, MTYPE,
          band_class);
        UNPACKB_PG(unlm.ri_info[i].ri.type1.nghbr[j].sys_a_b, MTYPE, sys_a_b);
      }
    }

#ifdef FEATURE_IS2000_REL_C
    else if(int_ptr->unlm.ri_info[i].radio_interface_type == CAI_UNLM_RADIO_INTERFACE_HRPD)
    {
      uint8 hrpd_nghbr_rec_len;
      word last_ext_msg_pos;

      UNPACKB_PG(unlm.ri_info[i].ri.type2.num_nghbr, MTYPE, num_nghbr);

      for (j=0; j<int_ptr->unlm.ri_info[i].ri.type2.num_nghbr &&
                j<CAI_UNLM_MAX_NUM_NGHBR; j++)
      {
        last_ext_msg_pos = ext_msg_pos;

        hrpd_nghbr_rec_len = b_unpackb(buf_ptr, ext_msg_pos, 
          FSIZ(MTYPE, hrpd_nghbr_rec_len));
        ext_msg_pos += FSIZ(MTYPE, hrpd_nghbr_rec_len);

        UNPACKW_PG(unlm.ri_info[i].ri.type2.nghbr[j].nghbr_pn, MTYPE, nghbr_pn);
        UNPACKB_PG(unlm.ri_info[i].ri.type2.nghbr[j].nghbr_freq_incl, MTYPE, nghbr_freq_incl);

        if (int_ptr->unlm.ri_info[i].ri.type2.nghbr[j].nghbr_freq_incl)
        {
          UNPACKB_PG(unlm.ri_info[i].ri.type2.nghbr[j].nghbr_band, MTYPE, nghbr_band);
          UNPACKW_PG(unlm.ri_info[i].ri.type2.nghbr[j].nghbr_freq, MTYPE, nghbr_freq);
        }

        UNPACKB_PG(unlm.ri_info[i].ri.type2.nghbr[j].pn_association_ind, MTYPE,
          pn_association_ind);
        UNPACKB_PG(unlm.ri_info[i].ri.type2.nghbr[j].data_association_ind, MTYPE,
          data_association_ind);

        ext_msg_pos = last_ext_msg_pos + (hrpd_nghbr_rec_len + 1) * 8;
      }
    }
#endif /* FEATURE_IS2000_REL_C */

    ext_msg_pos = old_ext_msg_pos + radio_interface_len * 8;
  }

  #undef MTYPE

  return (status);

} /* xlate_univ_nl */

/*===========================================================================

FUNCTION XLATE_EXT_BCCH_MSG

DESCRIPTION
  This function translates a received Broadcast Control Channel message from
  external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_bcch_msg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word msg_type_pd;
    /* message type field, word for future extension */
  byte pd;
    /* Protocol discriminator */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -------------------
  ** Decode message type
  ** ------------------- */
  msg_type_pd = b_unpackb(buf_ptr, FPOS( cai_gen_type, msg_type ),
                                   FSIZ( cai_gen_type, msg_type ));
  UNPACK_MSG_TYPE(int_ptr->gen_pc.msg_type, msg_type_pd);

  /* -----------------------------
  ** Decode protocol discriminator
  ** ----------------------------- */
  UNPACK_PD(pd, msg_type_pd);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /* PD validation */
  if (pd != 0)
  {
    return CAIX_INV_MSG_S;
  }

  switch (int_ptr->gen_pc.msg_type)
  {
    case CAI_ANSI41_SYS_PARM_MSG:
      status = xlate_ansi41_sys_parm( len, buf_ptr, int_ptr );
      break;

    case CAI_MC_RR_PARM_MSG:
      status = xlate_mc_rr_parm( len, buf_ptr, int_ptr );
      break;

    case CAI_ANSI41_RAND_MSG:
      status = xlate_ansi41_rand( len, buf_ptr, int_ptr );
      break;

    case CAI_EN_AC_PARM_MSG:
      status = xlate_en_ac_parm( len, buf_ptr, int_ptr );
      break;

    case CAI_UNIV_NL_MSG:
      status = xlate_univ_nl( len, buf_ptr, int_ptr );
      break;

    case CAI_EXT_GLB_REDIR_MSG:
      status = xlate_ext_e_glb_redir( len, buf_ptr, int_ptr );
      break;

    case CAI_EXT_CDMA_CHN_LIST_MSG:
      status = xlate_ext_e_cl( len, buf_ptr, int_ptr );
      break;

#ifdef FEATURE_IS2000_REL_A_CC_BCSMS
    case CAI_PC_BURST_MSG:
      status = xlate_ext_pc_burst( len, buf_ptr, int_ptr, CAIX_BCCH, pd );
      break;
#endif /* FEATURE_IS2000_REL_A_CC_BCSMS */

#ifdef FEATURE_IS2000_REL_D_BCMCS
#error code not present
#endif /* FEATURE_IS2000_REL_D_BCMCS */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_ext_bcch_msg */

/*===========================================================================

FUNCTION XLATE_EXT_FCCCH_MSG

DESCRIPTION
  This function translates a received Forward Common Control Channel message
  from external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_fccch_msg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word msg_type_pd;
    /* message type field, word for future extension */
  byte pd;
    /* Protocol discriminator */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -------------------
  ** Decode message type
  ** ------------------- */
  msg_type_pd = b_unpackb(buf_ptr, FPOS( cai_gen_type, msg_type ),
                                   FSIZ( cai_gen_type, msg_type ));
  UNPACK_MSG_TYPE(int_ptr->gen_pc.msg_type, msg_type_pd);

  /* -----------------------------
  ** Decode protocol discriminator
  ** ----------------------------- */
  UNPACK_PD(pd, msg_type_pd);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /* PD validation */
  if ((pd != 0)
#ifdef FEATURE_IS2000_REL_C
      && (pd != 2)
#endif /* FEATURE_IS2000_REL_C */
     )
  {
    return CAIX_INV_MSG_S;
  }

  switch (int_ptr->gen_pc.msg_type)
  {
    case CAI_PC_ORD_MSG:
      status = xlate_ext_pc_ord(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_PC_BURST_MSG:
      status = xlate_ext_pc_burst(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_PC_AUTH_MSG:
      status = xlate_ext_pc_auth(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_PC_SSD_UP_MSG:
      status = xlate_ext_pc_ssd(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_FEATURE_MSG:
      status = xlate_ext_pc_feature(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_PC_STREQ_MSG:
      status = xlate_ext_pc_streq(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_SERVICE_REDIR_MSG:
      status = xlate_ext_srvc_redir(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_GENERAL_PAGE_MSG:
      status = xlate_ext_general_page(len, buf_ptr, int_ptr);
      break;

    case CAI_PC_TMSI_ASGN_MSG:
      status = xlate_ext_pc_tmsi(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_PACA_MSG:
      status = xlate_ext_paca(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_EXT_CHN_ASN_MSG:
#ifdef FEATURE_MEID_SUPPORT
    case CAI_MEID_EXT_CHN_ASN_MSG:
#endif /* FEATURE_MEID_SUPPORT */
      status = xlate_ext_ext_chn_asn(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_SEC_MODE_CMD_MSG:
      status = xlate_ext_smcm(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;

    case CAI_UNIVERSAL_PAGE_MSG:
      status = xlate_ext_univ_page(len, buf_ptr, int_ptr);
      break;

    case CAI_UPM_FIRST_SEG_MSG:
    case CAI_UPM_MIDDLE_SEG_MSG:
    case CAI_UPM_FINAL_SEG_MSG:
      status = xlate_ext_univ_page_segment(len, buf_ptr, int_ptr);
      break;

#ifdef FEATURE_IS2000_REL_C
    case CAI_AUTH_REQ_MSG:
      status = xlate_ext_auth_req(len, buf_ptr, int_ptr, CAIX_FCCCH, pd);
      break;
#endif /* FEATURE_IS2000_REL_C */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_ext_fccch_msg */

#endif /* FEATURE_IS2000_REL_A_CC */

/*===========================================================================

FUNCTION XLATE_EXT_PCH_MSG

DESCRIPTION
  This function translates a received Paging Channel message from external to
  internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_pch_msg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status returned to calling procedure */
  word msg_type_pd;
    /* message type field, word for future extension */
  byte pd;
    /* Protocol discriminator */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -------------------
  ** Decode message type
  ** ------------------- */
  msg_type_pd = b_unpackb(buf_ptr, FPOS( cai_gen_type, msg_type ),
                                   FSIZ( cai_gen_type, msg_type ));
  UNPACK_MSG_TYPE(int_ptr->gen_pc.msg_type, msg_type_pd);

  /* -----------------------------
  ** Decode protocol discriminator
  ** ----------------------------- */
  UNPACK_PD(pd, msg_type_pd);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /* PD validation */
  if (pd >
#ifdef FEATURE_IS2000_REL_C
      2
#elif defined(FEATURE_IS2000_REL_A)
      1
#else
      0
#endif /* FEATURE_IS2000_REL_C */
     )
  {
    return CAIX_INV_MSG_S;
  }

  switch (int_ptr->gen_pc.msg_type)
  {
    case CAI_SYS_PARM_MSG:
      status = xlate_ext_sys_parm(len, buf_ptr, int_ptr);
      break;

    case CAI_ACC_PARM_MSG:
      status = xlate_ext_acc_parm(len, buf_ptr, int_ptr);
      break;

    case CAI_EXT_NL_MSG:
      status = xlate_ext_ext_nl(len, buf_ptr, int_ptr);
      break;

    case CAI_NL_MSG:
      status = xlate_ext_nl(len, buf_ptr, int_ptr);
      break;

    case CAI_CL_MSG:
      status = xlate_ext_cl(len, buf_ptr, int_ptr);
      break;

    case CAI_SLT_PAGE_MSG:
      status = xlate_ext_slt_page(len, buf_ptr, int_ptr);
      break;

    case CAI_PAGE_MSG:
      status = xlate_ext_page(len, buf_ptr, int_ptr);
      break;

    case CAI_PC_ORD_MSG:
      status = xlate_ext_pc_ord(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_CHN_ASN_MSG:
      status = xlate_ext_chn_asn(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_PC_BURST_MSG:
      status = xlate_ext_pc_burst(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_PC_AUTH_MSG:
      status = xlate_ext_pc_auth(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_PC_SSD_UP_MSG:
      status = xlate_ext_pc_ssd(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_FEATURE_MSG:
      status = xlate_ext_pc_feature(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_EXT_SYS_PARM_MSG:
      status = xlate_ext_ext_sys_parm(len, buf_ptr, int_ptr);
      break;

    case CAI_PC_STREQ_MSG:
      status = xlate_ext_pc_streq(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_SERVICE_REDIR_MSG:
      status = xlate_ext_srvc_redir(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_GENERAL_PAGE_MSG:
      status = xlate_ext_general_page(len, buf_ptr, int_ptr);
      break;

    case CAI_GLOBAL_REDIR_MSG:
      status = xlate_ext_glob_redir(len, buf_ptr, int_ptr);
      break;

    case CAI_PC_TMSI_ASGN_MSG:
      status = xlate_ext_pc_tmsi(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_PACA_MSG:
      status = xlate_ext_paca(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_EXT_CHN_ASN_MSG:
#ifdef FEATURE_MEID_SUPPORT
    case CAI_MEID_EXT_CHN_ASN_MSG:
#endif /* FEATURE_MEID_SUPPORT */
      status = xlate_ext_ext_chn_asn(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;

    case CAI_GEN_NL_MSG:
      status = xlate_ext_gen_nl(len, buf_ptr, int_ptr);
      break;

    case CAI_EXT_GLB_REDIR_MSG:
      status = xlate_ext_e_glb_redir(len, buf_ptr, int_ptr);
      break;

    case CAI_EXT_CDMA_CHN_LIST_MSG:
      status = xlate_ext_e_cl(len, buf_ptr, int_ptr);
      break;

#ifdef FEATURE_IS2000_REL_A
    case CAI_SEC_MODE_CMD_MSG:
      status = xlate_ext_smcm(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    case CAI_AUTH_REQ_MSG:
      status = xlate_ext_auth_req(len, buf_ptr, int_ptr, CAIX_PC, pd);
      break;
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D_BCMCS
#error code not present
#endif /* FEATURE_IS2000_REL_D_BCMCS */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_ext_pch_msg */

/*===========================================================================

FUNCTION XLATE_EXT_SC_MSG

DESCRIPTION
  This function translates a received Sync Channel Message from
  external to internal format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_ext_sc_msg
(
  word len,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status = CAIX_DONE_S;
  /* ------------------------------------------------------
  ** Message must contain elements up to and including PRAT
  ** ------------------------------------------------------ */
  int  ext_msg_pos = FPOS(cai_sync_type,cdma_freq);

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
#define MTYPE cai_sync_type

  if ((int_ptr->sync.msg_type =
       b_unpackb( PARAMS( msg_type ))) != CAI_SYNC_MSG)
  {
    /* --------------------
    ** Invalid message type
    ** -------------------- */
    status = CAIX_INV_MSG_S;
  }

  else
  {
    /* ------------------------------------------------
    ** Convert message from external to internal format
    ** ------------------------------------------------ */
    int_ptr->sync.p_rev       = b_unpackb( PARAMS( p_rev ));
    int_ptr->sync.min_p_rev   = b_unpackb( PARAMS( min_p_rev ));
    int_ptr->sync.sid         = b_unpackw( PARAMS( sid ));
    int_ptr->sync.nid         = b_unpackw( PARAMS( nid ));
    int_ptr->sync.pilot_pn    = b_unpackw( PARAMS( pilot_pn ));
    b_unpackq( PARAMS( lc_state ), int_ptr->sync.lc_state );
    b_unpackq( PARAMS( sys_time ), int_ptr->sync.sys_time );
    int_ptr->sync.lp_sec      = b_unpackb( PARAMS( lp_sec ));
    int_ptr->sync.ltm_off     = b_unpackb( PARAMS( ltm_off ));
    int_ptr->sync.daylt       = b_unpackb( PARAMS( daylt ));
    int_ptr->sync.prat        = b_unpackb( PARAMS( prat ));

    if (len >= FENDPOS(MTYPE, cdma_freq))
    {
      int_ptr->sync.cdma_freq = b_unpackw( PARAMS( cdma_freq ));
      ext_msg_pos += FSIZ(MTYPE,cdma_freq);
    }

    if ((int_ptr->sync.p_rev >= CAIX_P_REV_IS2000)
#ifdef FEATURE_DYNAMIC_P_REV
        && (cdma.mob_cai_rev >= CAIX_P_REV_IS2000)
#endif //FEATURE_DYNAMIC_P_REV
       )
    {
      int_ptr->sync.ext_cdma_freq = b_unpackw ( PARAMS( ext_cdma_freq ));
      ext_msg_pos += FSIZ(MTYPE,ext_cdma_freq);
    }

#ifdef FEATURE_IS2000_REL_A
    if ((int_ptr->sync.p_rev >= CAIX_P_REV_IS2000_REL_A)
#ifdef FEATURE_DYNAMIC_P_REV
      && (cdma.mob_cai_rev >= CAIX_P_REV_IS2000_REL_A)
#endif //FEATURE_DYNAMIC_P_REV
       )
    {
      UNPACKB_PG(sync.sr1_bcch_non_td_incl,MTYPE,sr1_bcch_non_td_incl);
      if(int_ptr->sync.sr1_bcch_non_td_incl == 1)
      {
        UNPACKB_PG(sync.sr1_non_td_freq_incl,MTYPE,sr1_non_td_freq_incl);
        if(int_ptr->sync.sr1_non_td_freq_incl == 1)
        {
          UNPACKW_PG(sync.sr1_cdma_freq_non_td,MTYPE,sr1_cdma_freq_non_td);
        }
        UNPACKB_PG(sync.sr1_brat_non_td,MTYPE,sr1_brat_non_td);
        UNPACKB_PG(sync.sr1_crat_non_td,MTYPE,sr1_crat_non_td);
        UNPACKB_PG(sync.sr1_bcch_code_chan_non_td,MTYPE,sr1_bcch_code_chan_non_td);
      }

      UNPACKB_PG(sync.sr1_td_incl,MTYPE,sr1_td_incl);
      if(int_ptr->sync.sr1_td_incl == 1)
      {
        UNPACKW_PG(sync.sr1_cdma_freq_td ,MTYPE,sr1_cdma_freq_td );
        UNPACKB_PG(sync.sr1_brat_td ,MTYPE,sr1_brat_td );
        UNPACKB_PG(sync.sr1_crat_td ,MTYPE,sr1_crat_td );
        UNPACKB_PG(sync.sr1_bcch_code_chan_td ,MTYPE,sr1_bcch_code_chan_td );
        UNPACKB_PG(sync.sr1_td_mode ,MTYPE,sr1_td_mode );
        UNPACKB_PG(sync.sr1_td_power_level ,MTYPE,sr1_td_power_level );
      }

      UNPACKB_PG(sync.sr3_incl,MTYPE,sr3_incl);
      if(int_ptr->sync.sr3_incl == 1)
      {
        UNPACKB_PG(sync.sr3_center_freq_incl,MTYPE,sr3_center_freq_incl);
        if(int_ptr->sync.sr3_center_freq_incl== 1)
        {
          UNPACKW_PG(sync.sr3_center_freq,MTYPE,sr3_center_freq);
        }
        UNPACKB_PG(sync.sr3_brat,MTYPE,sr3_brat);
        UNPACKB_PG(sync.sr3_bcch_code_chan,MTYPE,sr3_bcch_code_chan);
        UNPACKB_PG(sync.sr3_primary_pilot,MTYPE,sr3_primary_pilot);
        UNPACKB_PG(sync.sr3_pilot_power1,MTYPE,sr3_pilot_power1);
        UNPACKB_PG(sync.sr3_pilot_power2,MTYPE,sr3_pilot_power2);
      }

      UNPACKB_PG(sync.ds_incl,MTYPE,ds_incl);
      if (int_ptr->sync.ds_incl)
      {
        UNPACKD_PG(sync.ds_blob,MTYPE,ds_blob);
      }
    }

#endif /* FEATURE_IS2000_REL_A */
  }

  if (ext_msg_pos > len)
  {
    status = CAIX_INV_LEN_S;
  }

#undef MTYPE
  return (status);

} /* xlate_ext_sc_msg */

/*===========================================================================

FUNCTION CAIX_EXT_TO_INT

DESCRIPTION
  This function translates a message from the external format used
  by the Receive task to the internal format used by the Main Control
  task.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word caix_ext_to_int
(
  word len,
    /* Length of message in bits (not including length byte or CRC) */
  word chn,
    /* Channel message was received on */
  cai_rx_msg_type *rx_msg_ptr,
    /* Pointer to received message to be translated */
  caii_rx_msg_type *int_msg_ptr
    /* Pointer to place where translated message should be placed */
)
{
  word status;
    /* Status to be returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#ifndef FEATURE_MSG_PACK_UNIT_TEST
  caix_p_rev_in_use = mc_get_p_rev_in_use();
  if (int_msg_ptr != NULL)
  {
    /* Initialize all fields of received message */
    memset(int_msg_ptr, 0, sizeof(caii_rx_msg_type));
  }
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  switch (chn) {
    case CAIX_SC:
      status = ((len > CAI_SC_BODY_SIZE) ?
         CAIX_INV_LEN_S :
         xlate_ext_sc_msg( len, rx_msg_ptr->sc.body, int_msg_ptr ));
      break;

    case CAIX_PC:
      status = ((len > CAI_PC_BODY_SIZE) ?
        CAIX_INV_LEN_S :
        xlate_ext_pch_msg( len, rx_msg_ptr->pc.body, int_msg_ptr ));
      break;

#ifdef FEATURE_IS2000_REL_A_CC
    case CAIX_BCCH:
      status = ((len > CAI_BCCH_BODY_SIZE) ?
        CAIX_INV_LEN_S :
        xlate_ext_bcch_msg( len, rx_msg_ptr->bcch.body, int_msg_ptr ));
      break;

    case CAIX_FCCCH:
      status = ((len > CAI_FCCCH_BODY_SIZE) ?
        CAIX_INV_LEN_S :
        xlate_ext_fccch_msg( len, rx_msg_ptr->fccch.body, int_msg_ptr ));
      break;
#endif /* FEATURE_IS2000_REL_A_CC */

    case CAIX_TC:
      status = ((len > CAI_FWD_TC_MSG_BODY_SIZE) ?
        CAIX_INV_LEN_S :
        xlate_ext_tc_msg( len, rx_msg_ptr->tc.body, int_msg_ptr ));
      break;

    default:
      status = CAIX_INV_CHN_S;
      break;
  } /* end of switch */

  return (status);

} /* caix_ext_to_int */

/*===========================================================================

FUNCTION CAIX_GET_MESSAGE_TYPE

DESCRIPTION
  This function peeks at the first byte of a bitstream to determine the 
  message type.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while getting the message type.

SIDE EFFECTS
  Msg_type will hold the value of the message type.

===========================================================================*/

word caix_get_message_type
(
  byte * msg_type,
  /* This will hold the message type of the message */
  word chn,
  /* Channel message was received on */
  byte *buf_ptr
  /* Pointer to received message to be translated */
)
{
  word msg_type_pd;
  /* Message type field, word for future extension */
  word status = CAIX_DONE_S;
  /* Status to be returned to calling procedure */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (chn)
  {
    case CAIX_PC:
#ifdef FEATURE_IS2000_REL_A_CC
    case CAIX_BCCH:
    case CAIX_FCCCH:
#endif
    {
      msg_type_pd = b_unpackb(buf_ptr, FPOS( cai_gen_type, msg_type ),
                              FSIZ( cai_gen_type, msg_type ));
      UNPACK_MSG_TYPE(*msg_type, msg_type_pd);
      break;
    }

    case CAIX_TC:
    {
      *msg_type = b_unpackb( buf_ptr, FPOS( cai_gen_type, msg_type ), 
                             FSIZ( cai_gen_type, msg_type ));
      break;
    }

    default:
      MSG_HIGH("Caix_get_message_type specified an invalid channel: %d", chn,0,0);
      status = CAIX_INV_CHN_S;
      break;
  } /* end of switch */

  return(status);

} /* caix_get_message_type */

/* <EJECT> */
/*===========================================================================

FUNCTION XLATE_INT_NON_NEG_SRV_CFG

DESCRIPTION
  This function translates a non-neg service configuration record from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_non_neg_srv_cfg
(
  byte *buf_ptr,
    /* Pointer to message buffer which is to contain translated
       service configuration record. */

  word *buf_pos,
    /* Offset in message buffer at which to start non-neg service
       configuration record. */

  caii_non_neg_srv_cfg_type *i_ptr
    /* Pointer to internal non_neg service configuration record to be
       translated */
)
{
  word ext_msg_pos = *buf_pos;
  word record_len;
  word record_start_pos;
  word i;
#ifdef FEATURE_IS2000_REL_A
  word j, k;
  byte temp_mux_header_len;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  (void) b_unpackb(buf_ptr,ext_msg_pos,
                   FSIZ(cai_ho_msg_is2000_type,record_type));
  ext_msg_pos += FSIZ(cai_ho_msg_is2000_type,record_type);
  record_len = b_unpackb(buf_ptr,ext_msg_pos,
                         FSIZ(cai_ho_msg_is2000_type,record_len));
  record_len *= 8;
  ext_msg_pos += FSIZ(cai_ho_msg_is2000_type,record_len);
  record_start_pos = ext_msg_pos;

  #define FTYPE cai_nnscr_type

  i_ptr->fpc_incl = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(FTYPE, fpc_incl));
  ext_msg_pos += FSIZ(FTYPE, fpc_incl);

  if (i_ptr->fpc_incl)
  {
    i_ptr->fpc_pri_chan = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, fpc_pri_chan));
    ext_msg_pos += FSIZ(FTYPE, fpc_pri_chan);

    i_ptr->fpc_mode = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(FTYPE, fpc_mode));
    ext_msg_pos += FSIZ(FTYPE, fpc_mode);

    i_ptr->fpc_olpc_fch_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, fpc_olpc_fch_incl));
    ext_msg_pos += FSIZ(FTYPE, fpc_olpc_fch_incl);

    if (i_ptr->fpc_olpc_fch_incl)
    {
      i_ptr->fpc_fch_fer = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_fch_fer));
      ext_msg_pos += FSIZ(FTYPE, fpc_fch_fer);

      i_ptr->fpc_fch_min_setpt = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_fch_min_setpt));
      ext_msg_pos += FSIZ(FTYPE, fpc_fch_min_setpt);

      i_ptr->fpc_fch_max_setpt = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_fch_max_setpt));
      ext_msg_pos += FSIZ(FTYPE, fpc_fch_max_setpt);
    }

    i_ptr->fpc_olpc_dcch_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, fpc_olpc_dcch_incl));
    ext_msg_pos += FSIZ(FTYPE, fpc_olpc_dcch_incl);

    if (i_ptr->fpc_olpc_dcch_incl)
    {
      i_ptr->fpc_dcch_fer = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_dcch_fer));
      ext_msg_pos += FSIZ(FTYPE, fpc_dcch_fer);

      i_ptr->fpc_dcch_min_setpt = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_dcch_min_setpt));
      ext_msg_pos += FSIZ(FTYPE, fpc_dcch_min_setpt);

      i_ptr->fpc_dcch_max_setpt = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, fpc_dcch_max_setpt));
      ext_msg_pos += FSIZ(FTYPE, fpc_dcch_max_setpt);
    }
  }

  i_ptr->gating_rate_incl = b_unpackb(buf_ptr, ext_msg_pos,
    FSIZ(FTYPE, gating_rate_incl));
  ext_msg_pos += FSIZ(FTYPE, gating_rate_incl);

  if (i_ptr->gating_rate_incl)
  {
    i_ptr->pilot_gate_rate = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, pilot_gate_rate));
    ext_msg_pos += FSIZ(FTYPE, pilot_gate_rate);
  }

  if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
  {
    /* Advance past reserved bits */
    ext_msg_pos += FSIZ(FTYPE, reserved);
  }

#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    #define OTYPE cai_nnscr_sch_fix_type
    #define VTYPE cai_nnscr_sch_var_type

    i_ptr->for_sch_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(OTYPE, for_sch_incl));
    ext_msg_pos += FSIZ(OTYPE, for_sch_incl);

    if (i_ptr->for_sch_incl)
    {
      i_ptr->num_for_sch = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(OTYPE, num_for_sch));
      ext_msg_pos += FSIZ(OTYPE, num_for_sch);

      for (i=0; i<i_ptr->num_for_sch; i++)
      {
        i_ptr->for_sch[i].sch_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(VTYPE, sch_id));
        ext_msg_pos += FSIZ(VTYPE, sch_id);

        i_ptr->for_sch[i].frame_offset = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(VTYPE, frame_offset));
        ext_msg_pos += FSIZ(VTYPE, frame_offset);
      }
    }

    i_ptr->rev_sch_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(OTYPE, rev_sch_incl));
    ext_msg_pos += FSIZ(OTYPE, rev_sch_incl);

    if (i_ptr->rev_sch_incl)
    {
      i_ptr->num_rev_sch = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(OTYPE, num_rev_sch));
      ext_msg_pos += FSIZ(OTYPE, num_rev_sch);

      for (i=0; i<i_ptr->num_rev_sch; i++)
      {
        i_ptr->rev_sch[i].sch_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(VTYPE, sch_id));
        ext_msg_pos += FSIZ(VTYPE, sch_id);

        i_ptr->rev_sch[i].frame_offset = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(VTYPE, frame_offset));
        ext_msg_pos += FSIZ(VTYPE, frame_offset);
      }
    }

    #undef OTYPE
    #undef VTYPE
  }
#endif /* FEATURE_IS2000_REL_A */

  i_ptr->lpm_ind = b_unpackb(buf_ptr,ext_msg_pos,
    FSIZ(FTYPE, lpm_ind));
  ext_msg_pos += FSIZ(FTYPE, lpm_ind);

  if (i_ptr->lpm_ind == CAI_LPM_SUPPLIED)
  {
    i_ptr->num_lpm_entries = b_unpackb(buf_ptr,ext_msg_pos,
      FSIZ(FTYPE, num_lpm_entries));
    ext_msg_pos += FSIZ(FTYPE, num_lpm_entries);

    #define VTYPE cai_nnscr_lpm_entry_type

    for (i=0; i<i_ptr->num_lpm_entries; i++)
    {
      i_ptr->lpm_entries[i].sr_id = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, sr_id));
      ext_msg_pos += FSIZ(VTYPE, sr_id);

      i_ptr->lpm_entries[i].logical_resource = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, logical_resource));
      ext_msg_pos += FSIZ(VTYPE, logical_resource);

      i_ptr->lpm_entries[i].physical_resource = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, physical_resource));
      ext_msg_pos += FSIZ(VTYPE, physical_resource);

      i_ptr->lpm_entries[i].forward_flag = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, forward_flag));
      ext_msg_pos += FSIZ(VTYPE, forward_flag);

      i_ptr->lpm_entries[i].reverse_flag = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, reverse_flag));
      ext_msg_pos += FSIZ(VTYPE, reverse_flag);

      i_ptr->lpm_entries[i].priority = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, priority));
      ext_msg_pos += FSIZ(VTYPE, priority);
    }

    #undef VTYPE
  }

  #undef FTYPE

#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    #define FTYPE cai_nnscr_so_rec_fix_type
    #define VTYPE cai_nnscr_so_rec_var_type

    i_ptr->numrec = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(FTYPE, numrec));
    ext_msg_pos += FSIZ(FTYPE, numrec);

    /* unpack each rec */
    for (i=0; i<i_ptr->numrec; i++)
    {
      (void) b_unpackb(buf_ptr, ext_msg_pos, FSIZ(VTYPE, record_len));
      ext_msg_pos += FSIZ(VTYPE, record_len);

      i_ptr->rec[i].sr_id = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(VTYPE, sr_id));
      ext_msg_pos += FSIZ(VTYPE, sr_id);

      i_ptr->rec[i].sdb_so_omit = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(VTYPE, sdb_so_omit));
      ext_msg_pos += FSIZ(VTYPE, sdb_so_omit);

      ext_msg_pos += 4; /* for reserved */
    }

    #undef VTYPE
    #undef FTYPE

    /*----------------------------------------------------------
            FLEX TABLES
    ---------------------------------------------------------*/

    #define FTYPE cai_nnscr_num_bits_table_fix_type

    i_ptr->use_flex_num_bits = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, use_flex_num_bits));
    ext_msg_pos += FSIZ(FTYPE, use_flex_num_bits);

    if (i_ptr->use_flex_num_bits)
    {
      i_ptr->num_bits_tables_incl = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, num_bits_tables_incl));
      ext_msg_pos += FSIZ(FTYPE, num_bits_tables_incl);

      if (i_ptr->num_bits_tables_incl)
      {
        i_ptr->num_bits_tables_count = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, num_bits_tables_count));
        ext_msg_pos += FSIZ(FTYPE, num_bits_tables_count);

        #define VTYPE1 cai_nnscr_num_bits_table_var1_type
        #define VTYPE2 cai_nnscr_num_bits_table_var2_type

        for (i=0; i<i_ptr->num_bits_tables_count+1; i++)
        {
          i_ptr->bit_table[i].num_bits_table_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, num_bits_table_id));
          ext_msg_pos += FSIZ(VTYPE1, num_bits_table_id);

          i_ptr->bit_table[i].num_recs = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, num_recs));
          ext_msg_pos += FSIZ(VTYPE1, num_recs);

          for (j=0; j<i_ptr->bit_table[i].num_recs+1; j++)
          {
            i_ptr->bit_table[i].recs[j].num_bits_idx = b_unpackb(buf_ptr,
              ext_msg_pos, FSIZ(VTYPE2, num_bits_idx));
            ext_msg_pos += FSIZ(VTYPE2, num_bits_idx);

            i_ptr->bit_table[i].recs[j].num_bits = b_unpackw(buf_ptr, ext_msg_pos,
              FSIZ(VTYPE2, num_bits));
            ext_msg_pos += FSIZ(VTYPE2, num_bits);

            i_ptr->bit_table[i].recs[j].crc_len_idx = b_unpackb(buf_ptr,
              ext_msg_pos, FSIZ(VTYPE2, crc_len_idx));
            ext_msg_pos += FSIZ(VTYPE2, crc_len_idx);
          }
        }

        #undef VTYPE1
        #undef VTYPE2

      } /* end if (num_bits_tables_incl) */
    } /* end if (use_flex_num_bits) */

    #undef FTYPE

    /*----------------------------------------------------------
            VAR TABLES
      ---------------------------------------------------------*/

    #define FTYPE cai_nnscr_var_rate_table_fix_type

    i_ptr->use_var_rate = b_unpackb(buf_ptr,ext_msg_pos, FSIZ(FTYPE, use_var_rate));
    ext_msg_pos += FSIZ(FTYPE, use_var_rate);

    if (i_ptr->use_var_rate)
    {
      i_ptr->var_tables_incl = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, var_tables_incl));
      ext_msg_pos += FSIZ(FTYPE, var_tables_incl);

      if (i_ptr->var_tables_incl)
      {
        i_ptr->var_rate_tables_count = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, var_rate_tables_count));
        ext_msg_pos += FSIZ(FTYPE, var_rate_tables_count);

        #define VTYPE1 cai_nnscr_var_rate_table_var1_type
        #define VTYPE2 cai_nnscr_var_rate_table_var2_type

        for (i=0; i<i_ptr->var_rate_tables_count+1; i++)
        {
          i_ptr->var_table[i].var_rate_table_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, var_rate_table_id));
          ext_msg_pos += FSIZ(VTYPE1, var_rate_table_id);

          i_ptr->var_table[i].num_recs = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, num_recs));
          ext_msg_pos += FSIZ(VTYPE1, num_recs);

          for (j=0; j<i_ptr->var_table[i].num_recs+1; j++)
          {
            i_ptr->var_table[i].recs[j].num_bits_idx = b_unpackb(buf_ptr,
              ext_msg_pos, FSIZ(VTYPE2, num_bits_idx));
            ext_msg_pos += FSIZ(VTYPE2, num_bits_idx);

            i_ptr->var_table[i].recs[j].mask = b_unpackw(buf_ptr,
              ext_msg_pos, i_ptr->var_table[i].recs[j].num_bits_idx);
            ext_msg_pos += i_ptr->var_table[i].recs[j].num_bits_idx;
          }
        }

        #undef VTYPE2
        #undef VTYPE1

      } /* end if (var_tables_incl) */
    } /* end if (use_var_rate) */

    #undef FTYPE

    /*----------------------------------------------------------
            FLEX MAPPING
    ---------------------------------------------------------*/

    if (i_ptr->use_flex_num_bits)
    {
      #define FTYPE cai_nnscr_flex_map_type

      i_ptr->use_old_flex_mapping = b_unpackb(buf_ptr,ext_msg_pos,
        FSIZ(FTYPE, use_old_flex_mapping));
      ext_msg_pos += FSIZ(FTYPE, use_old_flex_mapping);

      if (!i_ptr->use_old_flex_mapping)
      {
        i_ptr->fsch0_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
         FSIZ(FTYPE, fsch0_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, fsch0_nbit_table_id);

        i_ptr->rsch0_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
         FSIZ(FTYPE, rsch0_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, rsch0_nbit_table_id);

        i_ptr->fsch1_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, fsch1_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, fsch1_nbit_table_id);

        i_ptr->rsch1_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rsch1_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, rsch1_nbit_table_id);

        i_ptr->ffch_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, ffch_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, ffch_nbit_table_id);

        i_ptr->rfch_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rfch_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, rfch_nbit_table_id);

        i_ptr->fdcch_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, fdcch_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, fdcch_nbit_table_id);

        if (i_ptr->fdcch_nbit_table_id != 0)
        {
          i_ptr->fdcch_nbits_idx = b_unpackb(buf_ptr, ext_msg_pos,
           FSIZ(FTYPE, fdcch_nbits_idx));
          ext_msg_pos += FSIZ(FTYPE, fdcch_nbits_idx);
        }

        i_ptr->rdcch_nbit_table_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rdcch_nbit_table_id));
        ext_msg_pos += FSIZ(FTYPE, rdcch_nbit_table_id);

        if (i_ptr->rdcch_nbit_table_id != 0)
        {
         i_ptr->rdcch_nbits_idx = b_unpackb(buf_ptr, ext_msg_pos,
           FSIZ(FTYPE, rdcch_nbits_idx));
         ext_msg_pos += FSIZ(FTYPE, rdcch_nbits_idx);
        }

      } /* end if (!use_old_flex_mapping) */

    #undef FTYPE

    } /* end if (use_flex_num_bits) */


  /*----------------------------------------------------------
            VAR MAPPING
    ---------------------------------------------------------*/

    if (i_ptr->use_var_rate)
    {
      #define FTYPE cai_nnscr_var_map_type

      i_ptr->use_old_var_mapping = b_unpackb(buf_ptr,ext_msg_pos,
        FSIZ(FTYPE, use_old_var_mapping));
      ext_msg_pos += FSIZ(FTYPE, use_old_var_mapping);

      if (!i_ptr->use_old_var_mapping)
      {
        i_ptr->fsch0_var_table_id = b_unpackb(buf_ptr,ext_msg_pos,
          FSIZ(FTYPE, fsch0_var_table_id));
        ext_msg_pos += FSIZ(FTYPE, fsch0_var_table_id);

        i_ptr->rsch0_var_table_id = b_unpackb(buf_ptr,ext_msg_pos,
          FSIZ(FTYPE, rsch0_var_table_id));
        ext_msg_pos += FSIZ(FTYPE, rsch0_var_table_id);

        i_ptr->fsch1_var_table_id = b_unpackb(buf_ptr,ext_msg_pos,
          FSIZ(FTYPE, fsch1_var_table_id));
        ext_msg_pos += FSIZ(FTYPE, fsch1_var_table_id);

        i_ptr->rsch1_var_table_id = b_unpackb(buf_ptr,ext_msg_pos,
          FSIZ(FTYPE, rsch1_var_table_id));
        ext_msg_pos += FSIZ(FTYPE, rsch1_var_table_id);
      }

      i_ptr->r_inc_rate_allowed = b_unpackb(buf_ptr,ext_msg_pos,
        FSIZ(FTYPE, r_inc_rate_allowed));
      ext_msg_pos += FSIZ(FTYPE, r_inc_rate_allowed);

      i_ptr->f_inc_rate_allowed = b_unpackb(buf_ptr,ext_msg_pos,
        FSIZ(FTYPE, f_inc_rate_allowed));
      ext_msg_pos += FSIZ(FTYPE, f_inc_rate_allowed);

      #undef FTYPE

    } /* end if (use_var_rate) */


    /*----------------------------------------------------------
            LTU TABLES
    ---------------------------------------------------------*/

    #define FTYPE cai_nnscr_ltu_fix_type

    i_ptr->ltu_info_incl = b_unpackb(buf_ptr, ext_msg_pos,
      FSIZ(FTYPE, ltu_info_incl));
    ext_msg_pos += FSIZ(FTYPE, ltu_info_incl);

    if (i_ptr->ltu_info_incl)
    {
      i_ptr->ltu_tables_incl = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, ltu_tables_incl));
      ext_msg_pos += FSIZ(FTYPE, ltu_tables_incl);

      if (i_ptr->ltu_tables_incl)
      {

        i_ptr->num_ltu_tables = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, num_ltu_tables));
        ext_msg_pos += FSIZ(FTYPE, num_ltu_tables);

        #define VTYPE1 cai_nnscr_ltu_var1_type
        #define VTYPE2 cai_nnscr_ltu_var2_type

        for (i=0; i<i_ptr->num_ltu_tables+1; i++)
        {
          i_ptr->table[i].ltu_table_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, ltu_table_id));
          ext_msg_pos += FSIZ(VTYPE1, ltu_table_id);

          i_ptr->table[i].num_rows = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(VTYPE1, num_rows));
          ext_msg_pos += FSIZ(VTYPE1, num_rows);

          for (j=0; j<i_ptr->table[i].num_rows+1; j++)
          {
            i_ptr->table[i].row[j].nbits_idx = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(VTYPE2, nbits_idx));
            ext_msg_pos += FSIZ(VTYPE2, nbits_idx);

            i_ptr->table[i].row[j].num_ltus = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(VTYPE2, num_ltus));
            ext_msg_pos += FSIZ(VTYPE2, num_ltus);
          }
        }

        #undef VTYPE1
        #undef VTYPE2

      } /* end if (ltu_tables_incl) */
    } /* end if (ltu_info_incl) */

    #undef FTYPE

    /*----------------------------------------------------------
            LTU MAPPING
    ---------------------------------------------------------*/

    if (i_ptr->ltu_info_incl)
    {
      #define FTYPE cai_nnscr_ltu_map_type

      i_ptr->use_old_ltu_mapping = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, use_old_ltu_mapping));
      ext_msg_pos += FSIZ(FTYPE, use_old_ltu_mapping);

      if (!i_ptr->use_old_ltu_mapping)
      {
        i_ptr->fsch0_ltu_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, fsch0_ltu_tab_id));
        ext_msg_pos += FSIZ(FTYPE, fsch0_ltu_tab_id);

        i_ptr->rsch0_ltu_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rsch0_ltu_tab_id));
        ext_msg_pos += FSIZ(FTYPE, rsch0_ltu_tab_id);

        i_ptr->fsch1_ltu_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, fsch1_ltu_tab_id));
        ext_msg_pos += FSIZ(FTYPE, fsch1_ltu_tab_id);

        i_ptr->rsch1_ltu_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, rsch1_ltu_tab_id));
        ext_msg_pos += FSIZ(FTYPE, rsch1_ltu_tab_id);
      } /* end if (!use_old_ltu_mapping) */

      #undef FTYPE

    } /* end if (ltu_info_incl) */

    /*----------------------------------------------------------
            PARTITION TABLES AND MAPPING
    ---------------------------------------------------------*/

    if (i_ptr->use_flex_num_bits)
    {
      #define FTYPE cai_nnscr_partition_table_fix_type

      i_ptr->partition_tables_info_incl = b_unpackb(buf_ptr, ext_msg_pos,
        FSIZ(FTYPE, partition_tables_info_incl));
      ext_msg_pos += FSIZ(FTYPE, partition_tables_info_incl);

      if (i_ptr->partition_tables_info_incl)
      {
        i_ptr->partition_tables_incl = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, partition_tables_incl));
        ext_msg_pos += FSIZ(FTYPE, partition_tables_incl);

        if (i_ptr->partition_tables_incl)
        {
          i_ptr->num_partition_tables = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(FTYPE, num_partition_tables));
          ext_msg_pos += FSIZ(FTYPE, num_partition_tables);

          #define VTYPE1 cai_nnscr_partition_table_var1_type
          #define VTYPE2 cai_nnscr_partition_table_var2_type
          #define VTYPE3 cai_nnscr_partition_table_var3_type

          for (i=0; i<i_ptr->num_partition_tables+1; i++)
          {
            i_ptr->part_table[i].partition_table_id = b_unpackb(buf_ptr,
              ext_msg_pos, FSIZ(VTYPE1, partition_table_id));
            ext_msg_pos += FSIZ(VTYPE1, partition_table_id);

            i_ptr->part_table[i].num_rows = b_unpackb(buf_ptr, ext_msg_pos,
              FSIZ(VTYPE1, num_rows));
            ext_msg_pos += FSIZ(VTYPE1, num_rows);

            for (j=0; j<i_ptr->part_table[i].num_rows+1; j++)
            {
              i_ptr->part_table[i].row[j].category = b_unpackb(buf_ptr,
                ext_msg_pos, FSIZ(VTYPE2, category));
              ext_msg_pos += FSIZ(VTYPE2,category);

              temp_mux_header_len = b_unpackb(buf_ptr, ext_msg_pos,
                FSIZ(VTYPE2, mux_header_len));
              ext_msg_pos += FSIZ(VTYPE2, mux_header_len);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

              i_ptr->part_table[i].row[j].mux_header = b_unpackb(buf_ptr,
                ext_msg_pos, temp_mux_header_len);
              ext_msg_pos += temp_mux_header_len;

              i_ptr->part_table[i].row[j].num_partitions = b_unpackb(buf_ptr,
                ext_msg_pos, FSIZ(VTYPE2, num_partitions));
              ext_msg_pos += FSIZ(VTYPE2, num_partitions);

              for (k=0 ; k<i_ptr->part_table[i].row[j].num_partitions+1 ; k++)
              {
                i_ptr->part_table[i].row[j].part[k].sr_id = b_unpackb(buf_ptr,
                  ext_msg_pos, FSIZ(VTYPE3, sr_id));
                ext_msg_pos += FSIZ(VTYPE3, sr_id);

                i_ptr->part_table[i].row[j].part[k].srv_num_bits =
                  b_unpackw(buf_ptr, ext_msg_pos, FSIZ(VTYPE3, srv_num_bits));
                ext_msg_pos += FSIZ(VTYPE3, srv_num_bits);
              }
            }
          }

          #undef VTYPE3
          #undef VTYPE2
          #undef VTYPE1

        } /* end if (part_tables_incl) */

        #define OTYPE cai_nnscr_part_map_type

        i_ptr->use_old_part_mapping = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(OTYPE, use_old_part_mapping));
        ext_msg_pos += FSIZ(OTYPE, use_old_part_mapping);

        if (!i_ptr->use_old_part_mapping)
        {
          i_ptr->ffpc_part_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(OTYPE, ffpc_part_tab_id));
          ext_msg_pos += FSIZ(OTYPE, ffpc_part_tab_id);

          i_ptr->rfpc_part_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(OTYPE, rfpc_part_tab_id));
          ext_msg_pos += FSIZ(OTYPE, rfpc_part_tab_id);

          i_ptr->fdcch_part_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
            FSIZ(OTYPE, fdcch_part_tab_id));
          ext_msg_pos += FSIZ(OTYPE, fdcch_part_tab_id);
  
          i_ptr->rdcch_part_tab_id = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(OTYPE, rdcch_part_tab_id));
          ext_msg_pos += FSIZ(OTYPE, rdcch_part_tab_id);
        } /* end if (!use_old_part_mapping) */
  
        #undef OTYPE

      } /* end if (part_tables_info_incl) */

        #undef FTYPE

    } /* end if (use_flex_num_bits) */
  } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A) */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
  {
      #define FTYPE cai_nnscr_is2000_rel_b_type

      if ((i_ptr->use_flex_num_bits) || (i_ptr->use_var_rate))
      {
        i_ptr->use_eram = b_unpackb(buf_ptr, ext_msg_pos, FSIZ(FTYPE, use_eram));
        ext_msg_pos += FSIZ(FTYPE, use_eram);
      }
   
      #undef FTYPE
  }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
      #define FTYPE cai_nnscr_is2000_rel_c_type

      if (i_ptr->gating_rate_incl)
      {
        i_ptr->switching_params_incl = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, switching_params_incl));
        ext_msg_pos += FSIZ(FTYPE, switching_params_incl);
      }

      if (i_ptr->switching_params_incl)
      {
        i_ptr->num_soft_switching_frames_chm = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, num_soft_switching_frames_chm));
        ext_msg_pos += FSIZ(FTYPE, num_soft_switching_frames_chm);

        i_ptr->num_softer_switching_frames_chm = b_unpackb(buf_ptr, ext_msg_pos,
          FSIZ(FTYPE, num_softer_switching_frames_chm));
        ext_msg_pos += FSIZ(FTYPE, num_softer_switching_frames_chm);
      }

      #undef FTYPE

  } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  ext_msg_pos = record_start_pos + record_len;
  *buf_pos = ext_msg_pos;

} /* xlate_int_non_neg_srv_cfg */

/*===========================================================================

FUNCTION XLATE_INT_SRV_CFG

DESCRIPTION
  This function translates a service configuration record from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_cfg
(
  word *len_ptr,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to message buffer which is to contain translated
       service configuration record. */

  word buf_pos,
    /* Offset in message buffer at which to start service
       configuration record. */

  caii_srv_cfg_type *i_ptr
    /* Pointer to internal service configuration record to be
       translated */
)
{
  word status;
    /* Status to be returned to calling procedure */

  word i;
    /* For indexing through service option connection records */

  word record_len_pos = 0;
  word record_start_pos = 0;
  word record_num_bits = 0;
  word record_num_bytes = 0;
  word record_num_reserved = 0;


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (i_ptr->num_con > CAII_SRV_CON_MAX)
  {
    status = CAIX_INV_MSG_S;
      /* Too many service option connections specified */
  }

  else
  {
    /* First do service configuration record header fields. */

    b_packb(CAI_RTC_SRV_CFG_REC, REC_P(record_type));
      /* Fill in information record type */

    record_len_pos = buf_pos + FSIZ(cai_rec_hdr_type,record_type);

    buf_pos += sizeof(cai_rec_hdr_type);
      /* Skip over info rec header */

    record_start_pos = buf_pos;

    /* Translate the fixed message fields */
    b_packw(i_ptr->fwd_mux,   HDR_P(fwd_mux));
    b_packw(i_ptr->rev_mux,   HDR_P(rev_mux));
    b_packb(i_ptr->fwd_rates, HDR_P(fwd_rates));
    b_packb(i_ptr->rev_rates, HDR_P(rev_rates));
    b_packb(i_ptr->num_con,   HDR_P(num_con));

    buf_pos += sizeof(cai_srv_cfg_hdr_type);
      /* Skip over configuration header record */

    for (i = 0; i < i_ptr->num_con; i++)
    {
      /* Translate the specified number of service option connection
         records. */

      word con_rec_len;
      word con_num_bits = sizeof(cai_srv_cfg_con_type);
      word con_num_reserved = 0;

      con_rec_len = (FENDPOS(cai_srv_cfg_con_type, rev_traf))/8;


      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000 )
      {
        if (i_ptr->con[i].rlp_info_incl)
        {
          con_num_bits += FSIZ(cai_srv_cfg_con_var_type, rlp_blob_len) +
            (FSIZ(cai_srv_cfg_con_var_type, rlp_blob) *
             i_ptr->con[i].rlp_blob_len);
        }

#ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
        {
          /* for qos_incl */
          con_num_bits += sizeof(cai_srv_cfg_con_is2000_rel_a_fix_type);

          if (i_ptr->con[i].qos_parms_incl)
          {
            con_num_bits += FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type,
              qos_parms_len) + (FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type,
              qos_parms) * i_ptr->con[i].qos_parms_len);
          }
        }
#endif /* FEATURE_IS2000_REL_A */

        con_rec_len = (con_num_bits/8);
        con_num_reserved = 8 - (con_num_bits % 8);
        if (con_num_reserved != 8)
        {
          con_rec_len += 1;
        }
      }

      b_packb(con_rec_len, CON_P(rec_len));
      b_packb(i_ptr->con[i].con_ref, CON_P( con_ref));
      b_packw(i_ptr->con[i].so, CON_P(so));
      b_packb(i_ptr->con[i].fwd_traf, CON_P(fwd_traf));
      b_packb(i_ptr->con[i].rev_traf, CON_P(rev_traf));

      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        b_packb(i_ptr->con[i].ui_encrypt_mode, CON_P(ui_encrypt_mode));
        b_packb(i_ptr->con[i].sr_id, CON_P(sr_id));
        b_packb(i_ptr->con[i].rlp_info_incl, CON_P(rlp_info_incl));
        buf_pos += sizeof(cai_srv_cfg_con_type);

        if (i_ptr->con[i].rlp_info_incl)
        {
          word cur;

          b_packb(i_ptr->con[i].rlp_blob_len, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_con_var_type, rlp_blob_len));
          buf_pos += FSIZ(cai_srv_cfg_con_var_type, rlp_blob_len);

          for (cur=0; cur<i_ptr->con[i].rlp_blob_len; cur++)
          {
            b_packb(i_ptr->con[i].rlp_blob[cur], buf_ptr, buf_pos,
              FSIZ(cai_srv_cfg_con_var_type, rlp_blob));
            buf_pos += FSIZ(cai_srv_cfg_con_var_type,rlp_blob);
          }
        }

#ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
        {
          b_packb(i_ptr->con[i].qos_parms_incl,buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_con_is2000_rel_a_fix_type, qos_parms_incl));
          buf_pos += FSIZ(cai_srv_cfg_con_is2000_rel_a_fix_type, qos_parms_incl);

          if (i_ptr->con[i].qos_parms_incl)
          {
            word cur;

            b_packb(i_ptr->con[i].qos_parms_len,buf_ptr, buf_pos,
              FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type, qos_parms_len));
            buf_pos += FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type, qos_parms_len);

            for (cur=0; cur<i_ptr->con[i].qos_parms_len; cur++)
            {
              b_packb(i_ptr->con[i].qos_parms[cur], buf_ptr, buf_pos,
                  FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type, qos_parms));
              buf_pos += FSIZ(cai_srv_cfg_con_is2000_rel_a_var_type, qos_parms);
            }

            /* now pack the qos_reserved fields
            j = ((i_ptr->con[i].qos_parms_len + 6) % 8);
            b_packb(0, buf_ptr, buf_pos, j);
            buf_pos += j;       */
          }
        }
#endif /* FEATURE_IS2000_REL_A */

        if (con_num_reserved != 8)
        {
          b_packb(0, buf_ptr, buf_pos, con_num_reserved);
          buf_pos += con_num_reserved;
        }
      }
      else
      {
        buf_pos += con_rec_len * 8;
      }

      /* Skip to next service option connection record */
    } /* end for */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      b_packb(i_ptr->fch_cc_incl, buf_ptr, buf_pos,
        FSIZ(cai_srv_cfg_is2000_type, fch_cc_incl));
      buf_pos += FSIZ(cai_srv_cfg_is2000_type, fch_cc_incl);

      if (i_ptr->fch_cc_incl)
      {
        b_packb(i_ptr->fch_frame_size, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, fch_frame_size));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, fch_frame_size);

        b_packb(i_ptr->for_fch_rc, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, for_fch_rc));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, for_fch_rc);

        b_packb(i_ptr->rev_fch_rc, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, rev_fch_rc));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, rev_fch_rc);
      }

      b_packb(i_ptr->dcch_cc_incl, buf_ptr, buf_pos,
        FSIZ(cai_srv_cfg_is2000_type, dcch_cc_incl));
      buf_pos += FSIZ(cai_srv_cfg_is2000_type, dcch_cc_incl);

      if (i_ptr->dcch_cc_incl)
      {
        b_packb(i_ptr->dcch_frame_size, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, dcch_frame_size));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, dcch_frame_size);

        b_packb(i_ptr->for_dcch_rc, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, for_dcch_rc));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, for_dcch_rc);

        b_packb(i_ptr->rev_dcch_rc, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, rev_dcch_rc));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, rev_dcch_rc);
      }

      b_packb(i_ptr->for_sch_cc_incl, buf_ptr, buf_pos,
        FSIZ(cai_srv_cfg_is2000_type, for_sch_cc_incl));
      buf_pos += FSIZ(cai_srv_cfg_is2000_type, for_sch_cc_incl);

      if (i_ptr->for_sch_cc_incl)
      {
        b_packb(i_ptr->num_for_sch, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, num_for_sch));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, num_for_sch);

        for (i=0; i<i_ptr->num_for_sch; i++)
        {
          b_packb(i_ptr->for_sch[i].for_sch_id, buf_ptr, buf_pos,
            FSIZ(cai_for_sch_type, for_sch_id));
          buf_pos += FSIZ(cai_for_sch_type, for_sch_id);

          b_packw(i_ptr->for_sch[i].for_sch_mux, buf_ptr, buf_pos,
            FSIZ(cai_for_sch_type, for_sch_mux));
          buf_pos += FSIZ(cai_for_sch_type, for_sch_mux);

          b_packb(2, buf_ptr, buf_pos, FSIZ(cai_sch_chn_cfg_type, sch_rec_len));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, sch_rec_len);

          b_packb(i_ptr->for_sch[i].sch_chn_cfg.sch_rc, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, sch_rc));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, sch_rc);

          b_packb(i_ptr->for_sch[i].sch_chn_cfg.coding, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, coding));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, coding);

#ifdef FEATURE_IS2000_REL_A
          b_packb(i_ptr->for_sch[i].sch_chn_cfg.frame_40_used, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, frame_40_used));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, frame_40_used);

          b_packb(i_ptr->for_sch[i].sch_chn_cfg.frame_80_used,buf_ptr,buf_pos,
            FSIZ(cai_sch_chn_cfg_type,frame_80_used));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,frame_80_used);

          b_packb(i_ptr->for_sch[i].sch_chn_cfg.max_rate,buf_ptr,buf_pos,
            FSIZ(cai_sch_chn_cfg_type,max_rate));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,max_rate);
#else
          b_packb(0, buf_ptr, buf_pos, 6);
          buf_pos += 6;
#endif /* FEATURE_IS2000_REL_A */
        }
      }

      b_packb(i_ptr->rev_sch_cc_incl, buf_ptr, buf_pos,
        FSIZ(cai_srv_cfg_is2000_type, rev_sch_cc_incl));
      buf_pos += FSIZ(cai_srv_cfg_is2000_type, rev_sch_cc_incl);

      if (i_ptr->rev_sch_cc_incl)
      {
        b_packb(i_ptr->num_rev_sch, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_type, num_rev_sch));
        buf_pos += FSIZ(cai_srv_cfg_is2000_type, num_rev_sch);

        for (i=0; i<i_ptr->num_rev_sch; i++)
        {
          b_packb(i_ptr->rev_sch[i].rev_sch_id, buf_ptr, buf_pos,
            FSIZ(cai_rev_sch_type, rev_sch_id));
          buf_pos += FSIZ(cai_rev_sch_type, rev_sch_id);

          b_packw(i_ptr->rev_sch[i].rev_sch_mux, buf_ptr,buf_pos,
            FSIZ(cai_rev_sch_type, rev_sch_mux));
          buf_pos += FSIZ(cai_rev_sch_type, rev_sch_mux);

          b_packb(2, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type,sch_rec_len));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,sch_rec_len);

          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.sch_rc,buf_ptr,buf_pos,
            FSIZ(cai_sch_chn_cfg_type,sch_rc));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,sch_rc);

          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.coding,buf_ptr,buf_pos,
            FSIZ(cai_sch_chn_cfg_type,coding));
          buf_pos += FSIZ(cai_sch_chn_cfg_type,coding);

#ifdef FEATURE_IS2000_REL_A
          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.frame_40_used, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, frame_40_used));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, frame_40_used);

          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.frame_80_used, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, frame_80_used));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, frame_80_used);

          b_packb(i_ptr->rev_sch[i].sch_chn_cfg.max_rate, buf_ptr, buf_pos,
            FSIZ(cai_sch_chn_cfg_type, max_rate));
          buf_pos += FSIZ(cai_sch_chn_cfg_type, max_rate);
#else
          b_packb(0, buf_ptr, buf_pos, 6);
          buf_pos += 6;
#endif /* FEATURE_IS2000_REL_A */

        }
      }

#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        b_packb(i_ptr->fch_dcch_mux_option_ind, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_rel_b_type, fch_dcch_mux_option_ind));
        buf_pos += FSIZ(cai_srv_cfg_is2000_rel_b_type, fch_dcch_mux_option_ind);

        if (i_ptr->fch_dcch_mux_option_ind == CAI_MUX_OPTION_DIFF_FOR_FCH_AND_DCCH)
        {
          b_packw(i_ptr->for_dcch_mux, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_is2000_rel_b_type, for_dcch_mux));
          buf_pos += FSIZ(cai_srv_cfg_is2000_rel_b_type, for_dcch_mux);

          b_packw(i_ptr->rev_dcch_mux, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_is2000_rel_b_type, rev_dcch_mux));
          buf_pos += FSIZ(cai_srv_cfg_is2000_rel_b_type, rev_dcch_mux);
        }
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb(i_ptr->for_pdch_cc_incl, buf_ptr, buf_pos,
          FSIZ(cai_srv_cfg_is2000_rel_c_fix_type, for_pdch_cc_incl));
        buf_pos += FSIZ(cai_srv_cfg_is2000_rel_c_fix_type, for_pdch_cc_incl);

        if (i_ptr->for_pdch_cc_incl)
        {
          b_packw(i_ptr->for_pdch_mux_option, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_is2000_rel_c_var_type, for_pdch_mux_option));
          buf_pos += FSIZ(cai_srv_cfg_is2000_rel_c_var_type, for_pdch_mux_option);

          b_packb(i_ptr->for_pdch_rc, buf_ptr, buf_pos,
            FSIZ(cai_srv_cfg_is2000_rel_c_var_type, for_pdch_rc));
          buf_pos += FSIZ(cai_srv_cfg_is2000_rel_c_var_type, for_pdch_rc);
        }
      }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    }

    record_num_bits = buf_pos - record_start_pos;
    record_num_bytes = (record_num_bits / 8);
    record_num_reserved = 8 - (record_num_bits % 8);
    if (record_num_reserved != 8)
    {
      record_num_bytes += 1;
      b_packb(0, buf_ptr, buf_pos, record_num_reserved);
      buf_pos += record_num_reserved;
    }

    b_packb(record_num_bytes, buf_ptr, record_len_pos,
      FSIZ(cai_rec_hdr_type, record_len));

    *len_ptr = (record_num_bytes * 8) + sizeof(cai_rec_hdr_type);

    status = CAIX_DONE_S;

  }

  return (status);

} /* xlate_int_srv_cfg */

/*===========================================================================

FUNCTION XLATE_INT_INFO_REC

DESCRIPTION
  This function translates an information record from internal to external
  format.

DEPENDENCIES
  Depends on the internal information record to be of valid format.

RETURN VALUE
  Errors that were encountered while translating the information record.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_info_rec
(
  byte *i_ptr,
    /* Pointer to internal info rec to be translated */
  word *ilen_ptr,
    /* Pointer to variable in which to return the length, in bytes,
       of the internal info rec processed. */
  word max_xlen,
    /* Specifies the maximum length, in bits, that can be used to
       hold the external info rec. */
  byte *x_ptr,
    /* Pointer to buffer which is to contain external information
       record. */
  word x_pos,
    /* Offset in buffer at which to start external info rec. */
  word *xlen_ptr
    /* On exit, set to the actual number of bits used to
       hold the external info rec. */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i, j = 0;
    /* Index to loop through records */
  word rec_len;
    /* Number of bits in record */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------------------------
  ** Check to make sure that there is room for the header
  ** ---------------------------------------------------- */
  if ( sizeof(cai_rec_hdr_type) > max_xlen )
  {
    return ( CAIX_INV_LEN_S ); /* No room even for info rec header */
  }

  /* Put record type into info rec header */
  b_packb(((caii_rec_hdr_type *) i_ptr)->record_type,
    x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_type ) );
  x_pos += FSIZ(cai_rec_hdr_type, record_type);

  switch ( ((caii_rec_hdr_type *)i_ptr)->record_type )
  {
    /* ----------------------------
    ** Call Mode Information Record
    ** ---------------------------- */
    case CAI_CALL_MODE_REC:
    {
      caii_call_mode_rec_type *rec_ptr = (caii_call_mode_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_call_mode_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->orig_mode,
               x_ptr, x_pos, FSIZ( cai_call_mode_type, orig_mode ));
      x_pos += FSIZ( cai_call_mode_type, orig_mode );

      b_packw( rec_ptr->pri_service,
               x_ptr, x_pos, FSIZ( cai_call_mode_type, pri_service ));
      x_pos += FSIZ( cai_call_mode_type, pri_service );

      b_packw( rec_ptr->sec_service,
               x_ptr, x_pos, FSIZ( cai_call_mode_type, sec_service ));
      x_pos += FSIZ( cai_call_mode_type, sec_service );

      b_packb( 0, x_ptr, x_pos, FSIZ( cai_call_mode_type, reserved ));
      x_pos += FSIZ( cai_call_mode_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_call_mode_rec_type);

      break;
    } /* case CAI_CALL_MODE_REC */

    /* --------------------------------
    ** Terminal Information Info Record
    ** -------------------------------- */
    case CAI_TERM_INFO_REC:
    {
      caii_term_rec_type *rec_ptr = (caii_term_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* Compute record length, add in reserved bits (3 for Rel D, 4 otherwise) */
        rec_len = sizeof(cai_term_info_fix_type) +
#ifdef FEATURE_IS2000_REL_D
#error code not present
#else
                  (sizeof(cai_term_info_var_type) * rec_ptr->fix.num_so) + 4;
#endif /* FEATURE_IS2000_REL_D */

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ) );
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->fix.mob_p_rev,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, mob_p_rev ));
      x_pos += FSIZ( cai_term_info_fix_type, mob_p_rev );

      b_packb( rec_ptr->fix.mob_mfg_code,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, mob_mfg_code ) );
      x_pos += FSIZ( cai_term_info_fix_type, mob_mfg_code );

      b_packb( rec_ptr->fix.mob_model,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, mob_model ));
      x_pos += FSIZ( cai_term_info_fix_type, mob_model );

      b_packw( rec_ptr->fix.mob_firm_rev,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, mob_firm_rev ));
      x_pos += FSIZ( cai_term_info_fix_type, mob_firm_rev );

      b_packb( rec_ptr->fix.scm,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, scm ));
      x_pos += FSIZ( cai_term_info_fix_type, scm );

      b_packb( rec_ptr->fix.local_ctrl,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, local_ctrl ));
      x_pos += FSIZ( cai_term_info_fix_type, local_ctrl );

      b_packb( rec_ptr->fix.slot_cycle_index,
               x_ptr, x_pos,
               FSIZ( cai_term_info_fix_type, slot_cycle_index ));
      x_pos += FSIZ( cai_term_info_fix_type, slot_cycle_index );

      /* -----------------------------
      ** Pack array of service options
      ** ----------------------------- */
      for ( i = 0; i < rec_ptr->fix.num_so; i++ )
      {
        b_packw( rec_ptr->var[i].service_option,
                 x_ptr, x_pos,
                 FSIZ( cai_term_info_var_type, service_option ) );
        x_pos += FSIZ( cai_term_info_var_type, service_option );
      }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
      {
        /* Otherwise, pack 4 reserved bits */
        b_packb( 0, x_ptr, x_pos, 4 );
        x_pos += 4;
      }

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_term_rec_fix_type) +
                  (sizeof(caii_term_rec_var_type) * rec_ptr->fix.num_so);

      break;
    } /* case CAI_TERM_INFO_REC */

    /* -------------------------------
    ** Roaming Information Info Record
    ** ------------------------------- */
    case CAI_ROAM_INFO_REC:
    {
      caii_roam_rec_type *rec_ptr = (caii_roam_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* --------------------------
      ** Calculate RECORD_LEN field
      ** -------------------------- */
      rec_len = sizeof(cai_roam_info_fix_type) +
                (sizeof(cai_roam_info_var_type) * rec_ptr->fix.num_vars);

      if ( sizeof(cai_rec_hdr_type) + RND8( rec_len ) > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( RND8( rec_len ) / 8,
               x_ptr, x_pos,
               FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->fix.accolc, x_ptr,
               x_pos, FSIZ( cai_roam_info_fix_type, accolc ));
      x_pos += FSIZ( cai_roam_info_fix_type, accolc );

      b_packb( rec_ptr->fix.mob_term_home,
               x_ptr, x_pos,
               FSIZ( cai_roam_info_fix_type, mob_term_home ));
      x_pos += FSIZ( cai_roam_info_fix_type, mob_term_home );

      b_packb( rec_ptr->fix.mob_term_for_sid,
               x_ptr, x_pos,
               FSIZ( cai_roam_info_fix_type,mob_term_for_sid ));
      x_pos += FSIZ( cai_roam_info_fix_type, mob_term_for_sid );

      b_packb( rec_ptr->fix.mob_term_for_nid,
               x_ptr, x_pos,
               FSIZ( cai_roam_info_fix_type,mob_term_for_nid ));
      x_pos += FSIZ( cai_roam_info_fix_type, mob_term_for_nid );

      for ( i = 0; i < rec_ptr->fix.num_vars; i++ )
      {
        b_packw( rec_ptr->var[i].sid,
                 x_ptr, x_pos, FSIZ( cai_roam_info_var_type, sid ));
        x_pos += FSIZ( cai_roam_info_var_type, sid );

        b_packw( rec_ptr->var[i].nid,
                 x_ptr, x_pos, FSIZ( cai_roam_info_var_type, nid ));
        x_pos += FSIZ( cai_roam_info_var_type, nid );
      }

      b_packb ( 0, x_ptr, x_pos, RND8( rec_len ) - rec_len );
      x_pos += RND8( rec_len ) - rec_len;

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = RND8( rec_len ) + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_roam_rec_fix_type) +
                  (sizeof(caii_roam_rec_var_type) * rec_ptr->fix.num_vars);

      break;
    } /* case CAI_ROAM_INFO_REC */

    /* ----------------------------------
    ** Security Status Information Record
    ** ---------------------------------- */
    case CAI_SEC_REC:
    {
      caii_sec_stat_rec_type *rec_ptr = (caii_sec_stat_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* -----------------------------------------------------
      ** Compute record length
      ** ----------------------------------------------------- */
      rec_len = sizeof(cai_sec_stat_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->auth_mode,
               x_ptr, x_pos, FSIZ( cai_sec_stat_type, auth_mode ));
      x_pos += FSIZ( cai_sec_stat_type, auth_mode );

      b_packb( rec_ptr->encrypt_mode,
               x_ptr, x_pos, FSIZ( cai_sec_stat_type, encrypt_mode ));
      x_pos += FSIZ( cai_sec_stat_type, encrypt_mode );

      b_packb( rec_ptr->private_lcm,
               x_ptr, x_pos, FSIZ( cai_sec_stat_type, private_lcm ));
      x_pos += FSIZ( cai_sec_stat_type, private_lcm );

      b_packb( 0, x_ptr, x_pos, FSIZ( cai_sec_stat_type, reserved ));
      x_pos += FSIZ( cai_sec_stat_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_sec_stat_rec_type);

      break;
    } /* case CAI_SEC_REC */

    /* -----------------------
    ** IMSI Information Record
    ** ----------------------- */
    case CAI_IMSI_REC:
    case CAI_IMSI_M_REC:
    case CAI_IMSI_T_REC:
    {
      caii_imsi_rec_type *rec_ptr = (caii_imsi_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* --------------------------------------------
      ** IMSI Info Record length = 7 octets (56 bits)
      ** -------------------------------------------- */
      rec_len = sizeof(cai_imsi_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->imsi_class,
               x_ptr, x_pos, FSIZ( cai_imsi_info_type, imsi_class ));
      x_pos += FSIZ( cai_imsi_info_type, imsi_class );

      b_packb( rec_ptr->imsi_addr_num,
               x_ptr, x_pos,
               FSIZ( cai_imsi_info_type, imsi_addr_num ));
      x_pos += FSIZ( cai_imsi_info_type, imsi_addr_num );

      b_packw( rec_ptr->mcc,
               x_ptr, x_pos, FSIZ( cai_imsi_info_type, mcc ));
      x_pos += FSIZ( cai_imsi_info_type, mcc );

      b_packb( rec_ptr->imsi_11_12,
               x_ptr, x_pos, FSIZ( cai_imsi_info_type, imsi_11_12 ));
      x_pos += FSIZ( cai_imsi_info_type, imsi_11_12 );

      b_packq( rec_ptr->imsi_s,
               x_ptr, x_pos, FSIZ( cai_imsi_info_type, imsi_s ));
      x_pos += FSIZ( cai_imsi_info_type, imsi_s );

      b_packb( 0, x_ptr, x_pos, FSIZ( cai_imsi_info_type, reserved ));
      x_pos += FSIZ( cai_imsi_info_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_imsi_rec_type);

      break;
    } /* case CAI_IMSI_REC */

    /* ----------------------
    ** ESN Information Record
    ** ---------------------- */
    case CAI_ESN_REC:
    {
      caii_esn_rec_type *rec_ptr = (caii_esn_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      /* -------------------------------------------
      ** ESN Info Record length = 4 octets (32 bits)
      ** ------------------------------------------- */
      rec_len = sizeof(cai_esn_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packd( rec_ptr->esn,
               x_ptr, x_pos, FSIZ( cai_esn_info_type, esn ));
      x_pos += FSIZ( cai_esn_info_type, esn );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_esn_rec_type);

      break;
    } /* case CAI_ESN_REC */

    /* ---------------------------------
    ** Band Class Information Record
    ** --------------------------------- */
    case CAI_BAND_REC:
    {
      caii_band_rec_type *rec_ptr = (caii_band_rec_type *) i_ptr;
      /* Convenient helper pointer of correct type to avoid casting */
      uint8 num_bytes = 1;
      /* Num of bytes needed for this IR */
      uint32 band_mask = 0; 
      /* Band classes can go all the way up to 32 */

      /* Construct the band mask to reflect how many band classes are 
         supported. This is a bit mask with  LSB 0 representing BC 0 */
      for (i=0; i<CAI_MAX_BAND_CLASSES; i++)
      {
        if (rec_ptr->band[i])
        {
          band_mask |= 1 << i;
        }
      }

      /* Now use the band mask to figure out how many bytes we need for representing 
         the band classes */
      if (band_mask > ((1<<24)-1))
      {
        /* Value needs more than 24 bits */
        num_bytes = 4;
      }
      else if (band_mask > ((1<<16)-1))
      {
        /* Value needs more than 16 bits */
        num_bytes = 3;
      }
      else if (band_mask > ((1<<8)-1))
      {
        /* Value needs more than 8 bits */
        num_bytes = 2;
      }

      /* Convert rec length to bits from bytes */
      rec_len = num_bytes << 3; 

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return(CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packw(rec_len / 8,
              x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */
      for (i=0 ; i<num_bytes*8 ; i++)
      {
        /* Now pack the band class values.  Note number of bits in the IR
           could be more than the array size itself as this accounts for 
           reserved bits too, so do a bounds check here */
        if (i < CAI_MAX_BAND_CLASSES)
        {
          b_packb(rec_ptr->band[i],
                  x_ptr, x_pos, FSIZ( cai_band_info_type, band));
        }
        else
        {
          /* Past the array means we are certainly in reserved bits area, 
             pack 0's here */
          b_packb(0, x_ptr, x_pos, FSIZ( cai_band_info_type, band));
        }
        x_pos += FSIZ(cai_band_info_type, band);
      }

      /* Set external info rec length, and internal rec length */
      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_band_rec_type);
      break;
    } /* case CAI_BAND_REC */

    /* ------------------------------
    ** Power Class Information Record
    ** ------------------------------ */
    case CAI_PWR_REC:
    {
      caii_pwr_rec_type *rec_ptr = (caii_pwr_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_pwr_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb ( rec_ptr->max_eirp,
                x_ptr, x_pos, FSIZ( cai_pwr_info_type, max_eirp ) );
      x_pos += FSIZ( cai_pwr_info_type, max_eirp );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_pwr_rec_type);

      break;
    } /* case CAI_PWR_REC */

    /* ---------------------------------
    ** Operating Mode Information Record
    ** --------------------------------- */
    case CAI_OP_MODE_REC:
    {
      caii_op_mode_rec_type *rec_ptr = (caii_op_mode_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_op_mode_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->op_mode0,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode0 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode0 );

      b_packb( rec_ptr->op_mode1,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode1 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode1 );

      b_packb( rec_ptr->op_mode2,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode2 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode2 );

      b_packb( rec_ptr->op_mode3,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode3 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode3 );

      b_packb( rec_ptr->op_mode4,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, op_mode4 ) );
      x_pos += FSIZ( cai_op_mode_info_type, op_mode4 );

      b_packb( 0,
               x_ptr, x_pos, FSIZ( cai_op_mode_info_type, reserved ) );
      x_pos += FSIZ( cai_op_mode_info_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_op_mode_rec_type);

      break;
    } /* case CAI_OP_MODE_REC */

    /* ---------------------------------
    ** Service Option Information Record
    ** --------------------------------- */
    case CAI_SO_REC:
    {
      caii_so_rec_type *rec_ptr = (caii_so_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_so_info_var_type) * rec_ptr->fix.num_so;

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      for ( i = 0; i < rec_ptr->fix.num_so; i++ )
      {
        b_packb ( 0,
                  x_ptr, x_pos, FSIZ( cai_so_info_var_type, reserved ) );
        x_pos += FSIZ( cai_so_info_var_type, reserved );

        b_packb ( rec_ptr->var[i].fwd,
                  x_ptr, x_pos, FSIZ( cai_so_info_var_type, fwd ) );
        x_pos += FSIZ( cai_so_info_var_type, fwd );

        b_packb ( rec_ptr->var[i].rev,
                  x_ptr, x_pos, FSIZ( cai_so_info_var_type, rev ) );
        x_pos += FSIZ( cai_so_info_var_type, rev );

        b_packw ( rec_ptr->var[i].so,
                  x_ptr, x_pos, FSIZ( cai_so_info_var_type, so ) );
        x_pos += FSIZ( cai_so_info_var_type, so );
      } /* for */

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_so_rec_fix_type) +
                  (sizeof(caii_so_rec_var_type) * rec_ptr->fix.num_so);

      break;
    } /* case CAI_SO_REC */

    /* -----------------------------------
    ** Multiplex Option Information Record
    ** ----------------------------------- */
    case CAI_MUX_REC:
    {
      caii_mux_rec_type *rec_ptr = (caii_mux_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_mux_info_type) * rec_ptr->fix.num_mux;

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      for ( i = 0; i < rec_ptr->fix.num_mux; i++ )
      {
        b_packw ( rec_ptr->var[i].mux,
                  x_ptr, x_pos, FSIZ( cai_mux_info_type, mux ) );
        x_pos += FSIZ( cai_mux_info_type, mux );

        b_packb ( rec_ptr->var[i].fwd_rates,
                  x_ptr, x_pos, FSIZ( cai_mux_info_type, fwd_rates ) );
        x_pos += FSIZ( cai_mux_info_type, fwd_rates );

        b_packb ( rec_ptr->var[i].rev_rates,
                  x_ptr, x_pos, FSIZ( cai_mux_info_type, rev_rates ) );
        x_pos += FSIZ( cai_mux_info_type, rev_rates );
      } /* for */

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_mux_rec_fix_type) +
                  (sizeof(caii_mux_rec_var_type) * rec_ptr->fix.num_mux);

      break;
    } /* case CAI_MUX_REC */

    /* ----------------------------------------
    ** Service Configuration Information Record
    ** ---------------------------------------- */
    case CAI_RTC_SRV_CFG_REC:
    {
      caii_srv_cfg_type  *rec_ptr = (caii_srv_cfg_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_srv_cfg_hdr_type) +
                (sizeof(cai_srv_cfg_con_type) * rec_ptr->num_con);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      x_pos -= FSIZ( cai_rec_hdr_type, record_type );
        /* Backup to start of record. xlate_int_srv_cfg will fill in
           record type and record length */

      status =
        xlate_int_srv_cfg ( xlen_ptr,
                            x_ptr,
                            x_pos,
                            (caii_srv_cfg_type *) i_ptr );

      if ( status != CAIX_DONE_S )
      {
        return ( status );
      }

      /* Set external info rec length, and internal rec length */

      /* Note: *xlen_ptr will be set by xlate_int_srv_cfg */

      *ilen_ptr = sizeof(caii_srv_cfg_type);

      break;
    } /* case CAI_RTC_SRV_CFG_REC */

    /* ------------------------------
    ** Power Control Information Record
    ** ------------------------------ */
    case CAI_PWR_CTRL_REC:
    {
      caii_pwr_ctrl_rec_type *rec_ptr = (caii_pwr_ctrl_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_pwr_ctrl_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb ( rec_ptr->min_pwr_cntl_step,
                x_ptr, x_pos, FSIZ( cai_pwr_ctrl_info_type,
                                      min_pwr_cntl_step ) );
      x_pos += FSIZ( cai_pwr_ctrl_info_type, min_pwr_cntl_step );

      b_packb ( 0,
                x_ptr, x_pos, FSIZ( cai_pwr_ctrl_info_type,
                                      reserved ) );
      x_pos += FSIZ( cai_pwr_ctrl_info_type, reserved );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_pwr_ctrl_rec_type);

      break;
    } /* case CAI_PWR_CTRL_REC */

    /* ------------------------------
    ** Capability Information Record
    ** ------------------------------ */
    case CAI_CAPA_INFO_REC:
    {
      word rec_len_pos = 0;
      word rec_start_pos = 0;
      word rec_num_bits = 0;
      word rec_num_bytes = 0;
      word rec_num_reserved = 0;

      caii_capa_rec_type *rec_ptr = (caii_capa_rec_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len_pos = x_pos;
      x_pos += FSIZ(cai_rec_hdr_type, record_len);
      rec_start_pos = x_pos;

      b_packb(rec_ptr->acc_entry_ho, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, acc_entry_ho));
      x_pos += FSIZ(cai_capa_info_type, acc_entry_ho);

      b_packb(rec_ptr->acc_probe_ho, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, acc_probe_ho));
      x_pos += FSIZ(cai_capa_info_type, acc_probe_ho);

      b_packb(rec_ptr->analog_search, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, analog_search));
      x_pos += FSIZ(cai_capa_info_type, analog_search);

      b_packb(rec_ptr->hop_beacon, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, hop_beacon));
      x_pos += FSIZ(cai_capa_info_type, hop_beacon);

      b_packb(rec_ptr->mahho, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, mahho));
      x_pos += FSIZ(cai_capa_info_type, mahho);

      b_packb(rec_ptr->puf, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, puf));
      x_pos += FSIZ(cai_capa_info_type, puf);

      b_packb(rec_ptr->analog_553, x_ptr, x_pos,
        FSIZ(cai_capa_info_type, analog_553));
      x_pos += FSIZ(cai_capa_info_type, analog_553);
     
      *ilen_ptr = FENDPOS(caii_capa_rec_type, analog_553);

      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        b_packb(rec_ptr->qpch, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type,qpch));
        x_pos += FSIZ(cai_capa_info_is2000_type,qpch);

        b_packb(rec_ptr->slotted_timer, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type,slotted_timer));
        x_pos += FSIZ(cai_capa_info_is2000_type,slotted_timer);

        b_packb(rec_ptr->chs_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type,chs_supported));
        x_pos += FSIZ(cai_capa_info_is2000_type,chs_supported);

        if (rec_ptr->chs_supported)
        {
          b_packb(rec_ptr->gating_rate_set, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_type,gating_rate_set));
          x_pos += FSIZ(cai_capa_info_is2000_type,gating_rate_set);
        }

        b_packb(rec_ptr->ext_cap_included, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type, ext_cap_included));
        x_pos += FSIZ(cai_capa_info_is2000_type, ext_cap_included);

        if (rec_ptr->ext_cap_included)
        {
          b_packb(rec_ptr->mabo, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_type,mabo));
          x_pos += FSIZ(cai_capa_info_is2000_type, mabo);

          b_packb(rec_ptr->sdb, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_type, sdb));
          x_pos += FSIZ(cai_capa_info_is2000_type, sdb);
        }

        b_packb(rec_ptr->rlp_cap_blob_len, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_type,rlp_cap_blob_len));
        x_pos += FSIZ(cai_capa_info_is2000_type, rlp_cap_blob_len);
         
        *ilen_ptr = FENDPOS(caii_capa_rec_type, rlp_cap_blob_len);

        for (i=0; i<rec_ptr->rlp_cap_blob_len && i<CAI_MAX_RLP_INFO_LEN; i++)
        {
          b_packb(rec_ptr->rlp_cap_blob[i], x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_type, rlp_cap_blob));
          x_pos += FSIZ(cai_capa_info_is2000_type, rlp_cap_blob);

          *ilen_ptr = FENDPOS(caii_capa_rec_type, rlp_cap_blob[i]);
        }
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        /* P_REV checking here is really not required by the standard.
           But since we've done that for Rel 0, we will keep the same
           behavior here
        */
        b_packb(rec_ptr->flex_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, flex_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, flex_supported);

        if (rec_ptr->flex_supported)
        {
          b_packb(rec_ptr->f_fch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, f_fch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_fch_flex_supported);

          b_packb(rec_ptr->r_fch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, r_fch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_fch_flex_supported);

          b_packb(rec_ptr->f_dcch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, f_dcch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_dcch_flex_supported);

          b_packb(rec_ptr->r_dcch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, r_dcch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_dcch_flex_supported);

          b_packb(rec_ptr->f_sch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_flex_supported);

          b_packb(rec_ptr->r_sch_flex_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_flex_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_flex_supported);
        }

        b_packb(rec_ptr->var_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, var_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, var_supported);

        if (rec_ptr->var_supported)
        {
          b_packb(rec_ptr->f_sch_var_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_var_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_var_supported);

          b_packb(rec_ptr->r_sch_var_supported, x_ptr, x_pos,
            FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_var_supported));
          x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_var_supported);

          if (rec_ptr->f_sch_var_supported)
          {
            b_packw(rec_ptr->max_num_bits_c, x_ptr, x_pos,
              FSIZ(cai_capa_info_is2000_rel_a_type, max_num_bits_c));
            x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, max_num_bits_c);

            b_packw(rec_ptr->max_num_bits_t, x_ptr, x_pos,
              FSIZ(cai_capa_info_is2000_rel_a_type, max_num_bits_t));
            x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, max_num_bits_t);
          }
        }

        b_packb(rec_ptr->cs_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, cs_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, cs_supported);

        b_packb(rec_ptr->f_sch_ltu_tab_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_ltu_tab_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, f_sch_ltu_tab_supported);

        b_packb(rec_ptr->r_sch_ltu_tab_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_ltu_tab_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_a_type, r_sch_ltu_tab_supported);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, r_sch_ltu_tab_supported);
      }
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_B
      if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B) &&
          (rec_ptr->var_supported || rec_ptr->flex_supported))
      {
        b_packb(rec_ptr->eram_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_b_type, eram_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_b_type, eram_supported);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, eram_supported);
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb(rec_ptr->pdch_chm_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_c_type, pdch_chm_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_c_type, pdch_chm_supported);

        b_packb(rec_ptr->rev_fch_gating_supported, x_ptr, x_pos,
          FSIZ(cai_capa_info_is2000_rel_c_type, rev_fch_gating_supported));
        x_pos += FSIZ(cai_capa_info_is2000_rel_c_type, rev_fch_gating_supported);

        *ilen_ptr = FENDPOS(caii_capa_rec_type, rev_fch_gating_supported);
      } /* end if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      rec_num_bits = x_pos - rec_start_pos;
      rec_num_bytes = (rec_num_bits / 8);
      rec_num_reserved = 8 - (rec_num_bits % 8);

      if (rec_num_reserved != 8)
      {
        rec_num_bytes += 1;
        b_packb(0, x_ptr, x_pos, rec_num_reserved);
        x_pos += rec_num_reserved;
      }

      b_packb(rec_num_bytes, x_ptr, rec_len_pos,
        FSIZ(cai_rec_hdr_type, record_len));

      *xlen_ptr = rec_num_bytes * 8 + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_CAPA_INFO_REC */

    /* ------------------------------
    ** Channel Config Capability Info
    ** ------------------------------ */
    case CAI_CHAN_CFG_CAPA_INFO_REC:
    {
      word rec_len_pos = 0;
      word rec_start_pos = 0;
      word rec_num_bits = 0;
      word rec_num_bytes = 0;
      word rec_num_reserved = 0;

      caii_chan_cfg_capa_info_type *rec_ptr =
        (caii_chan_cfg_capa_info_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len_pos = x_pos;
      x_pos += FSIZ(cai_rec_hdr_type, record_len);
      rec_start_pos = x_pos;

      b_packb(rec_ptr->otd_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, otd_supported));
      x_pos += FSIZ(cai_chan_cfg_capa_info_type, otd_supported);

      b_packb(rec_ptr->fch_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, fch_supported));
      x_pos += FSIZ(cai_chan_cfg_capa_info_type, fch_supported);

      if (rec_ptr->fch_supported)
      {
        b_packb(rec_ptr->fch_fields.fch_frame_size, x_ptr, x_pos,
          FSIZ(cai_fch_spec_fields_type, fch_frame_size));
        x_pos += FSIZ(cai_fch_spec_fields_type, fch_frame_size);

        b_packb(rec_ptr->fch_fields.for_fch_len, x_ptr, x_pos,
          FSIZ(cai_fch_spec_fields_type, for_fch_len));
        x_pos += FSIZ(cai_fch_spec_fields_type, for_fch_len);

        if (rec_ptr->fch_fields.for_fch_len)
        {
          b_packw(rec_ptr->fch_fields.for_fch_rc_map, x_ptr, x_pos,
            (rec_ptr->fch_fields.for_fch_len *
             FSIZ(cai_fch_spec_fields_type, for_fch_rc_map)));
          x_pos += (rec_ptr->fch_fields.for_fch_len *
            FSIZ(cai_fch_spec_fields_type, for_fch_rc_map));
        }

        b_packb(rec_ptr->fch_fields.rev_fch_len, x_ptr, x_pos,
          FSIZ(cai_fch_spec_fields_type, rev_fch_len));
        x_pos += FSIZ(cai_fch_spec_fields_type, rev_fch_len);

        if (rec_ptr->fch_fields.rev_fch_len)
        {
          b_packb(rec_ptr->fch_fields.rev_fch_rc_map, x_ptr, x_pos,
            (rec_ptr->fch_fields.rev_fch_len *
             FSIZ(cai_fch_spec_fields_type, rev_fch_rc_map)));
          x_pos += (rec_ptr->fch_fields.rev_fch_len *
            FSIZ(cai_fch_spec_fields_type, rev_fch_rc_map));
        }
      }

      b_packb(rec_ptr->dcch_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, dcch_supported));
      x_pos += FSIZ(cai_chan_cfg_capa_info_type, dcch_supported);

      if (rec_ptr->dcch_supported)
      {
        b_packb(rec_ptr->dcch_fields.dcch_frame_size, x_ptr, x_pos,
          FSIZ(cai_dcch_spec_fields_type, dcch_frame_size));
        x_pos += FSIZ(cai_dcch_spec_fields_type, dcch_frame_size);

        b_packb(rec_ptr->dcch_fields.for_dcch_len, x_ptr, x_pos,
          FSIZ(cai_dcch_spec_fields_type, for_dcch_len));
        x_pos += FSIZ(cai_dcch_spec_fields_type, for_dcch_len);

        if (rec_ptr->dcch_fields.for_dcch_len)
        {
          b_packw(rec_ptr->dcch_fields.for_dcch_rc_map, x_ptr, x_pos,
            (rec_ptr->dcch_fields.for_dcch_len *
             FSIZ(cai_dcch_spec_fields_type ,for_dcch_rc_map)));
          x_pos += (rec_ptr->dcch_fields.for_dcch_len *
            FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map));
        }

        b_packb(rec_ptr->dcch_fields.rev_dcch_len, x_ptr, x_pos,
          FSIZ(cai_dcch_spec_fields_type, rev_dcch_len));
        x_pos += FSIZ(cai_dcch_spec_fields_type, rev_dcch_len);

        if (rec_ptr->dcch_fields.rev_dcch_len)
        {
          b_packb(rec_ptr->dcch_fields.rev_dcch_rc_map, x_ptr, x_pos,
            (rec_ptr->dcch_fields.rev_dcch_len *
             FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map)));
          x_pos += (rec_ptr->dcch_fields.rev_dcch_len *
            FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map));
        }
      }

      b_packb(rec_ptr->for_sch_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, for_sch_supported));
      x_pos += FSIZ(cai_chan_cfg_capa_info_type, for_sch_supported);

      if (rec_ptr->for_sch_supported)
      {
        b_packb(rec_ptr->for_sch_fields.for_sch_len, x_ptr, x_pos,
          FSIZ(cai_for_sch_spec_fields_type, for_sch_len));
        x_pos += FSIZ(cai_for_sch_spec_fields_type, for_sch_len);

        if (rec_ptr->for_sch_fields.for_sch_len)
        {
          b_packw(rec_ptr->for_sch_fields.for_sch_rc_map, x_ptr, x_pos,
            (rec_ptr->for_sch_fields.for_sch_len *
             FSIZ(cai_for_sch_spec_fields_type, for_sch_rc_map)));
          x_pos += (rec_ptr->for_sch_fields.for_sch_len *
            FSIZ(cai_for_sch_spec_fields_type, for_sch_rc_map));
        }

        b_packb(rec_ptr->for_sch_fields.for_sch_num, x_ptr, x_pos,
          FSIZ(cai_for_sch_spec_fields_type, for_sch_num));
        x_pos += FSIZ(cai_for_sch_spec_fields_type, for_sch_num);

        for (i=0; i<rec_ptr->for_sch_fields.for_sch_num &&
                  i<CAI_MAX_NUM_FOR_SCH; i++)
        {
          b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_turbo_supported,
            x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_turbo_supported));
          x_pos += FSIZ(cai_for_sch_spec_fields_type, for_turbo_supported);

          if (rec_ptr->for_sch_fields.for_sch_recs[i].for_turbo_supported)
          {
            b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_max_turbo_block_size,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_max_turbo_block_size));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_max_turbo_block_size);
          }

          b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_conv_supported,
            x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_conv_supported));
          x_pos += FSIZ(cai_for_sch_spec_fields_type, for_conv_supported);

          if (rec_ptr->for_sch_fields.for_sch_recs[i].for_conv_supported)
          {
            b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_max_conv_block_size,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_max_conv_block_size));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_max_conv_block_size);
          }

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            b_packb( rec_ptr->for_sch_fields.for_sch_recs[i].for_frame_40_supported,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_frame_40_supported));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_frame_40_supported);

            b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_frame_80_supported,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_frame_80_supported));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_frame_80_supported);

            b_packb(rec_ptr->for_sch_fields.for_sch_recs[i].for_max_rate,
              x_ptr, x_pos, FSIZ(cai_for_sch_spec_fields_type, for_max_rate));
            x_pos += FSIZ(cai_for_sch_spec_fields_type, for_max_rate);
          }
          else
#endif /* FEATURE_IS2000_REL_A */
          {
            b_packb(0, x_ptr, x_pos, 6);
            x_pos += 6;
          }
        }
      }

      b_packb(rec_ptr->rev_sch_supported, x_ptr, x_pos,
        FSIZ(cai_chan_cfg_capa_info_type, rev_sch_supported));
      x_pos += FSIZ( cai_chan_cfg_capa_info_type, rev_sch_supported);

      *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type, rev_sch_supported);

      if (rec_ptr->rev_sch_supported)
      {
        b_packb(rec_ptr->rev_sch_fields.rev_sch_len, x_ptr, x_pos,
          FSIZ(cai_rev_sch_spec_fields_type, rev_sch_len));
        x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_sch_len);

        if (rec_ptr->rev_sch_fields.rev_sch_len)
        {

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
          b_packb(rec_ptr->rev_sch_fields.rev_sch_rc_map,
            x_ptr, x_pos, (rec_ptr->rev_sch_fields.rev_sch_len *
            FSIZ(cai_rev_sch_spec_fields_type,rev_sch_rc_map)));
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

          x_pos += (rec_ptr->rev_sch_fields.rev_sch_len *
            FSIZ(cai_rev_sch_spec_fields_type, rev_sch_rc_map));
        }

        b_packb(rec_ptr->rev_sch_fields.rev_sch_num, x_ptr, x_pos,
          FSIZ(cai_rev_sch_spec_fields_type, rev_sch_num));
        x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_sch_num);

        *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type,
          rev_sch_fields.rev_sch_num);

        for (i=0; i<rec_ptr->rev_sch_fields.rev_sch_num &&
                  i<CAI_MAX_NUM_REV_SCH; i++)
        {
          b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_turbo_supported,
            x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_turbo_supported));
          x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_turbo_supported);

          if (rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_turbo_supported)
          {
            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_max_turbo_block_size,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_max_turbo_block_size));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_max_turbo_block_size);
          }

          b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_conv_supported,
            x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_conv_supported));
          x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_conv_supported);

          *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type,
            rev_sch_fields.rev_sch_recs[i].rev_conv_supported);

          if (rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_conv_supported)
          {
            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_max_conv_block_size,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_max_conv_block_size));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_max_conv_block_size);
          }

#ifdef FEATURE_IS2000_REL_A
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_frame_40_supported,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_frame_40_supported));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_frame_40_supported);

            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_frame_80_supported,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_frame_80_supported));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_frame_80_supported);

            b_packb(rec_ptr->rev_sch_fields.rev_sch_recs[i].rev_max_rate,
              x_ptr, x_pos, FSIZ(cai_rev_sch_spec_fields_type, rev_max_rate));
            x_pos += FSIZ(cai_rev_sch_spec_fields_type, rev_max_rate);
          }
          else
#endif /* FEATURE_IS2000_REL_A */
          {
            b_packb(0, x_ptr, x_pos, 6);
            x_pos += 6;
          }
          *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type,
            rev_sch_fields.rev_sch_recs[i]);
        }
      }

      if ((rec_ptr->for_sch_supported) || (rec_ptr->rev_sch_supported))
      {
        b_packb(0, x_ptr, x_pos, FSIZ(cai_chan_cfg_capa_info_type, reserved));
        x_pos += FSIZ( cai_chan_cfg_capa_info_type, reserved );
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        b_packb(rec_ptr->sts_supported, /*lint !e539 */
          x_ptr, x_pos,
          FSIZ(cai_chan_cfg_capa_info_is2000_rel_a_type, sts_supported));
        x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_a_type, sts_supported);

        b_packb(rec_ptr->threex_cch_supported,
          x_ptr, x_pos,
          FSIZ(cai_chan_cfg_capa_info_is2000_rel_a_type, threex_cch_supported) );
        x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_a_type, threex_cch_supported);

        /* revisit with mccsup.c */
        *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type,threex_cch_supported);
      }
#endif /* FEATURE_IS2000_REL_A */


#ifdef FEATURE_IS2000_REL_B
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
      {
        if (rec_ptr->for_sch_supported)
        {
          b_packb(rec_ptr->ccsh_supported, x_ptr, x_pos,
            FSIZ(cai_chan_cfg_capa_info_is2000_rel_b_type, ccsh_supported));
          x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_b_type, ccsh_supported);

          *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type, ccsh_supported);
        }
      }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb(rec_ptr->for_pdch_supported, x_ptr, x_pos,
          FSIZ(cai_chan_cfg_capa_info_is2000_rel_c_type, for_pdch_supported));
        x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_c_type, for_pdch_supported);

        *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type, for_pdch_supported);

        if (rec_ptr->for_pdch_supported)
        {
          b_packb(rec_ptr->for_pdch_fields.ack_delay, x_ptr, x_pos,
            FSIZ(cai_for_pdch_spec_fields_type, ack_delay));
          x_pos += FSIZ(cai_for_pdch_spec_fields_type, ack_delay);

          b_packb(rec_ptr->for_pdch_fields.num_arq_chan, x_ptr, x_pos,
            FSIZ(cai_for_pdch_spec_fields_type, num_arq_chan));
          x_pos += FSIZ(cai_for_pdch_spec_fields_type, num_arq_chan);

          b_packb(rec_ptr->for_pdch_fields.for_pdch_len, x_ptr, x_pos,
            FSIZ(cai_for_pdch_spec_fields_type, for_pdch_len));
          x_pos += FSIZ(cai_for_pdch_spec_fields_type, for_pdch_len);

          b_packw(rec_ptr->for_pdch_fields.for_pdch_rc_map, x_ptr, x_pos,
            ((rec_ptr->for_pdch_fields.for_pdch_len + 1) *
            FSIZ(cai_for_pdch_spec_fields_type, for_pdch_rc_map)));
          x_pos += ((rec_ptr->for_pdch_fields.for_pdch_len + 1) *
            FSIZ(cai_for_pdch_spec_fields_type, for_pdch_rc_map));

          b_packb(rec_ptr->for_pdch_fields.ch_config_sup_map_len, x_ptr, x_pos,
            FSIZ(cai_for_pdch_spec_fields_type, ch_config_sup_map_len));
          x_pos += FSIZ(cai_for_pdch_spec_fields_type, ch_config_sup_map_len);

          b_packw(rec_ptr->for_pdch_fields.ch_config_sup_map, x_ptr, x_pos,
            ((rec_ptr->for_pdch_fields.ch_config_sup_map_len + 1) *
            FSIZ(cai_for_pdch_spec_fields_type, ch_config_sup_map)));
          x_pos += ((rec_ptr->for_pdch_fields.ch_config_sup_map_len + 1) *
            FSIZ(cai_for_pdch_spec_fields_type, ch_config_sup_map));

          *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type,
            for_pdch_fields.ch_config_sup_map);
          
          if (rec_ptr->for_sch_supported)
          {
            b_packb(rec_ptr->for_pdch_sch_supported, x_ptr, x_pos,
              FSIZ(cai_chan_cfg_capa_info_is2000_rel_c_type,
              for_pdch_sch_supported));
            x_pos += FSIZ(cai_chan_cfg_capa_info_is2000_rel_c_type,
              for_pdch_sch_supported);

            *ilen_ptr = FENDPOS(caii_chan_cfg_capa_info_type, for_pdch_sch_supported);
          }
        }
      }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      rec_num_bits = x_pos - rec_start_pos;
      rec_num_bytes = (rec_num_bits / 8);
      rec_num_reserved = 8 - (rec_num_bits % 8);

      if (rec_num_reserved != 8)
      {
        rec_num_bytes += 1;
        b_packb(0, x_ptr, x_pos, rec_num_reserved);
        x_pos += rec_num_reserved;
      }

      b_packb(rec_num_bytes, x_ptr, rec_len_pos,
        FSIZ(cai_rec_hdr_type, record_len));

      *xlen_ptr = rec_num_bytes * 8 + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_CHAN_CFG_CAPA_INFO_REC */

    /* ----------------------------
    ** Extended Multiplex Option Info
    ** ---------------------------- */
    case CAI_EXT_MULT_OPT_INFO_REC:
    {
      word rec_len_pos = 0;
      word rec_start_pos = 0;
      word rec_num_bits = 0;
      word rec_num_bytes = 0;
      word rec_num_reserved = 0;

      caii_ext_mult_opt_info_type *rec_ptr =
        (caii_ext_mult_opt_info_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len_pos = x_pos;
      x_pos += FSIZ(cai_rec_hdr_type, record_len);
      rec_start_pos = x_pos;

      b_packb(rec_ptr->num_mo_for_fch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_for_fch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_for_fch);

      for (i=0; i<rec_ptr->num_mo_for_fch && i<CAI_MAX_MULT_OPT_FCH_DCCH; i++)
      {
        b_packw(rec_ptr->mo_for_fch_recs[i].mo_for_fch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_for_fch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_for_fch);

        b_packb(rec_ptr->mo_for_fch_recs[i].for_rates_fch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, for_rates_fch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, for_rates_fch);
      }

      b_packb(rec_ptr->num_mo_rev_fch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_fch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_fch);

      for (i=0; i<rec_ptr->num_mo_rev_fch && i<CAI_MAX_MULT_OPT_FCH_DCCH; i++)
      {
        b_packw(rec_ptr->mo_rev_fch_recs[i].mo_rev_fch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_rev_fch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_rev_fch);

        b_packb(rec_ptr->mo_rev_fch_recs[i].rev_rates_fch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, rev_rates_fch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, rev_rates_fch);
      }

      b_packb(rec_ptr->num_mo_for_dcch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_for_dcch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_for_dcch);

      for (i=0; i<rec_ptr->num_mo_for_dcch && i<CAI_MAX_MULT_OPT_FCH_DCCH; i++)
      {
        b_packw(rec_ptr->mo_for_dcch[i], x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_for_dcch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_for_dcch);
      }

      b_packb(rec_ptr->num_mo_rev_dcch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_dcch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_dcch);

      for (i=0; i<rec_ptr->num_mo_rev_dcch && i<CAI_MAX_MULT_OPT_FCH_DCCH; i++)
      {
        b_packw(rec_ptr->mo_rev_dcch[i], x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_rev_dcch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_rev_dcch);
      }

      b_packb(rec_ptr->num_mo_for_sch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_for_sch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_for_sch);

      for (i=0; i<rec_ptr->num_mo_for_sch && i<CAI_MAX_MULT_OPT_SCH; i++)
      {
        b_packb(rec_ptr->mo_for_sch_recs[i].for_sch_id, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, for_sch_id));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, for_sch_id);

        b_packw(rec_ptr->mo_for_sch_recs[i].mo_for_sch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_for_sch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_for_sch);
      }

      b_packb(rec_ptr->num_mo_rev_sch, x_ptr, x_pos,
        FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_sch));
      x_pos += FSIZ(cai_ext_mult_opt_info_type, num_mo_rev_sch);

      *ilen_ptr = FENDPOS(caii_ext_mult_opt_info_type, num_mo_rev_sch);

      for (i=0; i<rec_ptr->num_mo_rev_sch && i<CAI_MAX_MULT_OPT_SCH; i++)
      {
        b_packb(rec_ptr->mo_rev_sch_recs[i].rev_sch_id, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, rev_sch_id));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, rev_sch_id);

        b_packw(rec_ptr->mo_rev_sch_recs[i].mo_rev_sch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_type, mo_rev_sch));
        x_pos += FSIZ(cai_ext_mult_opt_info_type, mo_rev_sch);

        *ilen_ptr = FENDPOS(caii_ext_mult_opt_info_type,
          mo_rev_sch_recs[i].mo_rev_sch);
      }

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb(rec_ptr->num_mo_for_pdch, x_ptr, x_pos,
          FSIZ(cai_ext_mult_opt_info_is2000_rel_c_type, num_mo_for_pdch));
        x_pos += FSIZ(cai_ext_mult_opt_info_is2000_rel_c_type, num_mo_for_pdch);

        *ilen_ptr = FENDPOS(caii_ext_mult_opt_info_type, num_mo_for_pdch);

        for (i=0; i<rec_ptr->num_mo_for_pdch && i<CAI_MAX_MULT_OPT_PDCH; i++)
        {
          b_packw(rec_ptr->mo_for_pdch[i], x_ptr, x_pos,
            FSIZ(cai_ext_mult_opt_info_is2000_rel_c_type, mo_for_pdch));
          x_pos += FSIZ(cai_ext_mult_opt_info_is2000_rel_c_type, mo_for_pdch);

          *ilen_ptr = FENDPOS(caii_ext_mult_opt_info_type, mo_for_pdch[i]);
        }
      }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      rec_num_bits = x_pos-rec_start_pos;
      rec_num_bytes = (rec_num_bits / 8);
      rec_num_reserved = 8 - (rec_num_bits % 8);

      if (rec_num_reserved != 8)
      {
        rec_num_bytes += 1;
        b_packb (0,x_ptr,x_pos,rec_num_reserved);
        x_pos += rec_num_reserved;
      }

      b_packb(rec_num_bytes,x_ptr,rec_len_pos,
        FSIZ(cai_rec_hdr_type, record_len));

      *xlen_ptr = rec_num_bytes*8 + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_EXT_MULT_OPT_INFO_REC */

    /* ----------------------------
    ** User Zone Update Request
    ** ---------------------------- */
    case CAI_USER_ZONE_UPDATE_REQ_REC:
    {
      caii_user_zone_update_req_type *rec_ptr =
        (caii_user_zone_update_req_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_user_zone_update_req_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packw( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packw( rec_ptr->uzid,
               x_ptr, x_pos, FSIZ( cai_user_zone_update_req_type, uzid ));
      x_pos += FSIZ( cai_user_zone_update_req_type, uzid );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_user_zone_update_req_type);

      break;
    } /* case CAI_USER_ZONE_UPDATE_REQ_REC */

    case CAI_GEO_LOC_INFO_REC:
    {
      caii_geo_loc_info_type *rec_ptr =
        (caii_geo_loc_info_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_geo_loc_info_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packb( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->geo_loc,
               x_ptr, x_pos, FSIZ( cai_geo_loc_info_type, geo_loc ));
      x_pos += FSIZ( cai_geo_loc_info_type, geo_loc );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_geo_loc_info_type);

      break;
    } /* case CAI_GEO_LOC_INFO_REC */


#ifdef FEATURE_IS2000_REL_A
    case CAI_HOOK_STATUS_REC:
    {
      caii_hook_status_type *rec_ptr =
        (caii_hook_status_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_hook_status_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packb( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->hook_status,
               x_ptr, x_pos, FSIZ( cai_hook_status_type, hook_status ));
      x_pos += FSIZ( cai_hook_status_type, hook_status );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_hook_status_type);

      break;
    }

    case CAI_ENC_CAP_REC:
    {
      caii_enc_cap_type *rec_ptr =
        (caii_enc_cap_type *) i_ptr;
        /* Convenient helper pointer of correct type to avoid casting */

      rec_len = sizeof(cai_enc_cap_type);

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packb( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      b_packb( rec_ptr->sig_enc_sup,
               x_ptr, x_pos, FSIZ( cai_enc_cap_type, sig_enc_sup ));
      x_pos += FSIZ( cai_enc_cap_type, sig_enc_sup );

      b_packb( rec_ptr->ui_enc_sup,
               x_ptr, x_pos, FSIZ( cai_enc_cap_type, ui_enc_sup ));
      x_pos += FSIZ( cai_enc_cap_type, ui_enc_sup );

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_hook_status_type);

      break;
    }

    case CAI_QOS_PARAM_REC:
    {
      caii_qos_parms_type  *rec_ptr = (caii_qos_parms_type *) i_ptr;

      rec_len = rec_ptr->qos_parms_len * 8; // bits

      if ( sizeof(cai_rec_hdr_type) + rec_len > max_xlen )
      {
        return ( CAIX_INV_LEN_S ); /* Rec won't fit */
      }

      b_packb( rec_len / 8,
               x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
                 /* Put in record len */
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      /* Add other record fields */

      for (i=0; i< rec_ptr->qos_parms_len; i++)
      {
        b_packb( rec_ptr->qos_parms[i],
                 x_ptr, x_pos, FSIZ( cai_qos_parms_type, qos_parms ));
        x_pos += FSIZ( cai_qos_parms_type, qos_parms );
      }

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = FENDPOS( caii_qos_parms_type, qos_parms[rec_ptr->qos_parms_len - 1] );

      break;
    } /* case CAI_QOS_PARAM_REC */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    case CAI_SIG_MSG_INT_CAP_REC:
    {
      caii_sig_msg_int_info_type *rec_ptr = (caii_sig_msg_int_info_type *) i_ptr;

      rec_len = sizeof(cai_sig_msg_int_info_type);

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return (CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */

      b_packb(rec_ptr->sig_integrity_sup, x_ptr, x_pos,
        FSIZ(cai_sig_msg_int_info_type, sig_integrity_sup));
      x_pos += FSIZ(cai_sig_msg_int_info_type, sig_integrity_sup);

      /* Set external info rec length, and internal rec length */

      *ilen_ptr = FENDPOS(caii_sig_msg_int_info_type, sig_integrity_sup);

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_SIG_MSG_INT_CAP_REC */

    case CAI_UIM_ID_REC:
    {
      caii_uim_id_info_type *rec_ptr = (caii_uim_id_info_type *) i_ptr;

      rec_len = FSIZ(cai_uim_id_info_type, uim_id_len) + 
        rec_ptr->uim_id_len * 8 + FSIZ(cai_uim_id_info_type, reserved); 

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return (CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */

      b_packb(rec_ptr->uim_id_len, x_ptr, x_pos,
        FSIZ(cai_uim_id_info_type, uim_id_len));
      x_pos += FSIZ(cai_uim_id_info_type, uim_id_len);

      *ilen_ptr = FENDPOS(caii_uim_id_info_type, uim_id_len);

      if (rec_ptr->uim_id_len > 0)
      {
        b_packd(rec_ptr->uim_id, x_ptr, x_pos, rec_ptr->uim_id_len * 8);
        x_pos += rec_ptr->uim_id_len * 8;

        *ilen_ptr = FENDPOS(caii_uim_id_info_type, uim_id);
      }

      b_packb(0, x_ptr, x_pos, FSIZ(cai_uim_id_info_type, reserved));
      x_pos += FSIZ(cai_uim_id_info_type, reserved);

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_UIM_ID_REC */
#endif /* FEATURE_IS2000_REL_C */

#if defined(FEATURE_IS2000_REL_C) || defined(FEATURE_HWID_SUPPORT)
    case CAI_ESN_ME_REC:
    {
      caii_esn_me_info_type *rec_ptr = (caii_esn_me_info_type *) i_ptr;

      rec_len = FSIZ(cai_esn_me_info_type, esn_me_len) + 
        rec_ptr->esn_me_len * 8 + FSIZ(cai_esn_me_info_type, reserved); 

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return (CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */

      b_packb(rec_ptr->esn_me_len, x_ptr, x_pos,
        FSIZ(cai_esn_me_info_type, esn_me_len));
      x_pos += FSIZ(cai_esn_me_info_type, esn_me_len);

      *ilen_ptr = FENDPOS(caii_esn_me_info_type, esn_me_len);

      if (rec_ptr->esn_me_len > 0)
      {
        b_packd(rec_ptr->esn_me, x_ptr, x_pos, rec_ptr->esn_me_len * 8);
        x_pos += rec_ptr->esn_me_len * 8;

        *ilen_ptr = FENDPOS(caii_esn_me_info_type, esn_me);
      }

      b_packb(0, x_ptr, x_pos, FSIZ(cai_esn_me_info_type, reserved));
      x_pos += FSIZ(cai_esn_me_info_type, reserved);

      /* Set external info rec length, and internal rec length */

      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      break;
    } /* case CAI_ESN_ME_REC */
#endif /* FEATURE_IS2000_REL_C || FEATURE_HWID_SUPPORT  */

#if defined(FEATURE_IS2000_REL_D) || defined(FEATURE_MEID_SUPPORT)
    /* -------------------------------------------
    ** MEID Information Record
    ** ------------------------------------------- */
    case CAI_MEID_REC:
      {
        caii_meid_info_type *rec_ptr = (caii_meid_info_type *) i_ptr;

        rec_len = FSIZ(cai_meid_info_type, meid_len) + 
                  rec_ptr->meid_len * 8 + FSIZ(cai_meid_info_type, reserved); 

        if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
        {
          return(CAIX_INV_LEN_S); /* Rec won't fit */
        }

        /* Put in record len */
        b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
        x_pos += FSIZ(cai_rec_hdr_type, record_len);

        /* Add other record fields */

        b_packb(rec_ptr->meid_len, x_ptr, x_pos,
                FSIZ(cai_meid_info_type, meid_len));
        x_pos += FSIZ(cai_meid_info_type, meid_len);

        *ilen_ptr = FENDPOS(caii_meid_info_type, meid_len);

        if (rec_ptr->meid_len > 0)
        {
          b_packq(rec_ptr->meid, x_ptr, x_pos, rec_ptr->meid_len * 8);
          x_pos += rec_ptr->meid_len * 8;

          *ilen_ptr = FENDPOS(caii_meid_info_type, meid);
        }

        b_packb(0, x_ptr, x_pos, FSIZ(cai_meid_info_type, reserved));
        x_pos += FSIZ(cai_meid_info_type, reserved);

        *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

        break;
      } /* CAI_MEID_REC */
#endif /* FEATURE_IS2000_REL_D || FEATURE_MEID_SUPPORT */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    /* -------------------------------------------
    ** Called Party Subaddress Informatin Record
    ** Calling Party Subaddress Informatin Record
    ** Connected Subaddress Informatin Record
    ** ------------------------------------------- */
    case CAI_REV_CALLED_SUB_REC:
    case CAI_REV_CALLING_SUB_REC:
    case CAI_REV_CONN_SUB_REC:
    {
      caii_subaddr_rec_type * rec_ptr = (caii_subaddr_rec_type *) i_ptr;
      *ilen_ptr = 0;
      /* ----------------------------------------------------
      ** RECORD_LEN = Number of CHARI fields + 1 (8 bits)
      ** ---------------------------------------------------- */
      b_packb(
        (byte) (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char + 1),
        x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
      x_pos += FSIZ( cai_rec_hdr_type, record_len);

      if ((x_pos + sizeof( cai_subaddr_fix_type ) +
              (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_subaddr_var_type, chari ))) >
                     CAI_REV_TC_MSG_BODY_SIZE)
      {
        status = CAIX_INV_LEN_S;
      }
      else 
      {
        b_packb( ((caii_subaddr_rec_type *) rec_ptr)->fix.extension_bit,
                 x_ptr, x_pos,
                 FSIZ( cai_subaddr_fix_type, extension_bit ));
        x_pos += FSIZ(cai_subaddr_fix_type, extension_bit);

        b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.subadd_type,
                    x_ptr, x_pos,
                    FSIZ( cai_subaddr_fix_type, subadd_type));
        x_pos += FSIZ( cai_subaddr_fix_type, subadd_type);

        b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.odd_even_ind,
                    x_ptr, x_pos,
                    FSIZ( cai_subaddr_fix_type, odd_even_ind));
        x_pos += FSIZ( cai_subaddr_fix_type, odd_even_ind);

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
        b_packb( 0, x_ptr, x_pos, 3 );
        x_pos += 3;

        for (j=0;
               j < ((caii_subaddr_rec_type *) rec_ptr)->fix.num_char; j++)
        {
          b_packb( ((caii_subaddr_rec_type *) rec_ptr)->var[j], x_ptr,
                    x_pos, FSIZ( cai_subaddr_var_type, chari ));
          x_pos += FSIZ( cai_subaddr_var_type, chari ); /*lint !e662 */
        }

        /* Set external info rec length, and internal rec length */
        if (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char == 0)
        {
           *ilen_ptr += FSIZ( caii_subaddr_rec_type, fix ); /*lint !e662 */
        }
        else 
        {
          *ilen_ptr += FENDPOS( caii_subaddr_rec_type,
               var[((caii_subaddr_rec_type *) rec_ptr)->fix.num_char - 1]);
        }
        *xlen_ptr =  sizeof(cai_subaddr_fix_type) +  sizeof(cai_rec_hdr_type)+
          rec_ptr->fix.num_char * sizeof(cai_subaddr_var_type) ;

      }
      break;
    }

    /* -----------------------------------------------------------
     ** Calling Party Number or Connected Number Information Record
     ** ----------------------------------------------------------- */
    case CAI_REV_CALLING_REC:
    {
      caii_calling_rec_type * rec_ptr = (caii_calling_rec_type *) i_ptr;
      *ilen_ptr = 0;
      /* -----------------------------------------------------
      ** RECORD_LEN = Number of CHARI fields + 2 (16 bits) for
      ** NUMBER_TYPE, NUMBER_PLAN, PI, SI and RESERVED fields
      ** ----------------------------------------------------- */
      b_packb(
        (byte) ( rec_ptr->fix.num_char + 2),
        x_ptr, x_pos, FSIZ( cai_rec_hdr_type, record_len ));
      x_pos += FSIZ( cai_rec_hdr_type, record_len );

      if ((x_pos + sizeof( cai_calling_fix_type ) +
          ( rec_ptr->fix.num_char *
               FSIZ( cai_calling_var_type, chari )) + 5) >
                 CAI_REV_TC_MSG_BODY_SIZE)
      {
        status = CAIX_INV_LEN_S;
      }
      else 
      {
        b_packb( rec_ptr->fix.number_type,
                  x_ptr, x_pos,
                  FSIZ( cai_calling_fix_type, number_type ));
        x_pos += FSIZ( cai_calling_fix_type, number_type );

        b_packb( rec_ptr->fix.number_plan,
                    x_ptr, x_pos, FSIZ( cai_calling_fix_type, number_plan ));
        x_pos += FSIZ(cai_calling_fix_type, number_plan);

        b_packb(  rec_ptr->fix.pi,
                    x_ptr, x_pos, FSIZ( cai_calling_fix_type, pi ));
        x_pos += FSIZ( cai_calling_fix_type, pi );

        b_packb( rec_ptr->fix.si,
                      x_ptr, x_pos, FSIZ( cai_calling_fix_type, si ));
        x_pos += FSIZ( cai_calling_fix_type, si);

        for (j=0; j < rec_ptr->fix.num_char; j++)
        {
          b_packb( rec_ptr->var[j],
                    x_ptr, x_pos, FSIZ( cai_calling_var_type, chari));
          x_pos += FSIZ( cai_calling_var_type, chari );
        }

        /* ------------------------
        ** Pack 0 for reserved bits
        ** ------------------------ */
        b_packb( 0, x_ptr, x_pos, 5 );
        x_pos += 5;

        if ( rec_ptr->fix.num_char == 0) 
        {
          *ilen_ptr += FSIZ( caii_calling_rec_type, fix ); /*lint !e662 */
        }
        else 
        {
          *ilen_ptr += FENDPOS( caii_calling_rec_type,
            var[rec_ptr->fix.num_char - 1] );
        }
        *xlen_ptr =  sizeof(cai_calling_fix_type) +  sizeof(cai_rec_hdr_type)+
          rec_ptr->fix.num_char * sizeof(cai_calling_var_type) + 5 ;
      }
      break;
    }

#ifdef FEATURE_IS2000_REL_A
    case CAI_BAND_SUBCLASS_INFO_REC:
    {
      caii_band_subclass_type *rec_ptr = (caii_band_subclass_type *) i_ptr;
      /* Convenient helper pointer of correct type to avoid casting */
      uint8 num_bytes = 1;
      /* Number of bytes needed for this IR */

#ifndef FEATURE_MSG_PACK_UNIT_TEST
      uint32 band_subclass_mask = 0; 
      /* Band subclasses can go all the way up to 32 */

      /* Construct the mask to reflect how many of the band subclasses
         are supported. This is a bit mask with  LSB 0 representing BSC 0 */
      for (i=0; i<CAI_MAX_BAND_SUBCLASSES; i++)
      {
        if (rec_ptr->subband[i])
        {
          band_subclass_mask |= 1 << i;
        }
      }

      /* Now use the band subclass mask to figure out how many bytes we need
         for representing the band subclasses */
      if (band_subclass_mask > ((1<<24)-1))
      {
        /* Value needs more than 24 bits */
        num_bytes = 4;
      }
      else if (band_subclass_mask > ((1<<16)-1))
      {
        /* Value needs more than 16 bits */
        num_bytes = 3;
      }
      else if (band_subclass_mask > ((1<<8)-1))
      {
        /* Value needs more than 8 bits */
        num_bytes = 2;
      }
#else
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

      /* Convert rec length to bits from bytes */
      rec_len = num_bytes << 3; 

      if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
      {
        return(CAIX_INV_LEN_S); /* Rec won't fit */
      }

      /* Put in record len */
      b_packw(rec_len / 8,
              x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
      x_pos += FSIZ(cai_rec_hdr_type, record_len);

      /* Add other record fields */
      for (i=0 ; i<num_bytes*8 ; i++)
      {
        /* Now pack the band subclass values.  Note number of bits in the
           IR could be more than the array size itself as this accounts
           for reserved bits too, so do a bounds check here */
        if (i < CAI_MAX_BAND_SUBCLASSES)
        {
          b_packb(rec_ptr->subband[i],
                  x_ptr, x_pos, FSIZ( cai_band_subclass_type, subband));
        }
        else
        {
          /* Past the array means we are certainly in reserved bits area, 
             so pack 0's here */
          b_packb(0, x_ptr, x_pos, FSIZ( cai_band_subclass_type, subband));
        }
        x_pos += FSIZ(cai_band_subclass_type, subband);
      }

      /* Set external info rec length, and internal rec length */
      *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

      *ilen_ptr = sizeof(caii_band_subclass_type);
      break;
    }
#endif /* FEATURE_IS2000_REL_A */

#if defined(FEATURE_MEID_SUPPORT) && defined(FEATURE_HWID_SUPPORT)  
    /* -------------------------------------------
    ** MEID ME Information Record
    ** ------------------------------------------- */
    case CAI_MEID_ME_REC:
      {
        caii_meid_me_info_type *rec_ptr = (caii_meid_me_info_type *) i_ptr;

        rec_len = FSIZ(cai_meid_me_info_type, meid_me_len) + 
                  rec_ptr->meid_me_len * 8 + FSIZ(cai_meid_me_info_type, reserved); 

        if (sizeof(cai_rec_hdr_type) + rec_len > max_xlen)
        {
          return(CAIX_INV_LEN_S); /* Rec won't fit */
        }

        /* Put in record len */
        b_packb(rec_len / 8, x_ptr, x_pos, FSIZ(cai_rec_hdr_type, record_len));
        x_pos += FSIZ(cai_rec_hdr_type, record_len);

        /* Add other record fields */

        b_packb(rec_ptr->meid_me_len, x_ptr, x_pos,
                FSIZ(cai_meid_me_info_type, meid_me_len));
        x_pos += FSIZ(cai_meid_me_info_type, meid_me_len);

        *ilen_ptr = FENDPOS(caii_meid_me_info_type, meid_me_len);

        if (rec_ptr->meid_me_len > 0)
        {
          b_packq(rec_ptr->meid_me, x_ptr, x_pos, rec_ptr->meid_me_len * 8);
          x_pos += rec_ptr->meid_me_len * 8;

          *ilen_ptr = FENDPOS(caii_meid_me_info_type, meid_me);
        }

        b_packb(0, x_ptr, x_pos, FSIZ(cai_meid_me_info_type, reserved));
        x_pos += FSIZ(cai_meid_me_info_type, reserved);

        *xlen_ptr = rec_len + sizeof(cai_rec_hdr_type);

        break;
      } /* CAI_MEID_ME_REC */
#endif /* FEATURE_MEID_SUPPORT && FEATURE_HWID_SUPPORT */
    
    default:
      return ( CAIX_INV_MSG_S );
  } /* switch */

  return status;

} /* xlate_int_info_rec() */

/*===========================================================================

FUNCTION CAI_PACK_IMSI

DESCRIPTION
  This function packs the IMSI field from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Status.

SIDE EFFECTS
  None

===========================================================================*/
word cai_pack_imsi
(
    caii_imsi_addr_type  * imsi_ptr,   /* pointer to the imsi structure */
    byte                 * buf_ptr,    /* the translated buffer */
    word                 * buffer_pos  /* the buffer bit position */
)
{
    word   status = CAIX_DONE_S;   /* status */

    b_packb( imsi_ptr->imsi_class,
             buf_ptr, *buffer_pos, FSIZ( cai_ext_msid2_type, imsi_class ));
    *buffer_pos += FSIZ( cai_ext_msid2_type, imsi_class );

    if (imsi_ptr->imsi_class == 0)
    {
      b_packb(
        imsi_ptr->class_type.zero.imsi_class_0_type,
        buf_ptr, *buffer_pos,
        FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
      *buffer_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

      switch (imsi_ptr->class_type.zero.imsi_class_0_type)
      {
        case 0:
          /* -------------------------------------------
          ** Pack IMSI class 0 type 0 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class0_type0_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

          b_packq(
            imsi_ptr->class_type.zero.type.zero.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type0_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
          break;

        case 1:
          /* -------------------------------------------
          ** Pack IMSI class 0 type 1 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class0_type1_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

          b_packb(
            imsi_ptr->class_type.zero.type.one.imsi_11_12,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
          *buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

          b_packq(
            imsi_ptr->class_type.zero.type.one.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type1_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
          break;

        case 2:
          /* -------------------------------------------
          ** Pack IMSI class 0 type 2 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class0_type2_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

          b_packw(
            imsi_ptr->class_type.zero.type.two.mcc,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type2_type, mcc ));
          *buffer_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

          b_packq(
            imsi_ptr->class_type.zero.type.two.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type2_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
          break;

        case 3:
          /* -------------------------------------------
          ** Pack IMSI class 0 type 3 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class0_type3_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

          b_packw(
            imsi_ptr->class_type.zero.type.three.mcc,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type3_type, mcc ));
          *buffer_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

          b_packb(
            imsi_ptr->class_type.zero.type.three.imsi_11_12,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
          *buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

          b_packq(
            imsi_ptr->class_type.zero.type.three.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class0_type3_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
          break;

        default:
          return (CAIX_INV_MSG_S);
      }
    } /* Class 0 IMSI */
    else /* Class 1 IMSI */
    {
      b_packb(
        imsi_ptr->class_type.one.imsi_class_1_type,
        buf_ptr, *buffer_pos,
        FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
      *buffer_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

      switch (
        imsi_ptr->class_type.one.imsi_class_1_type)
      {
        case 0:
          /* -------------------------------------------
          ** Pack IMSI class 1 type 0 specific subfields
          ** ------------------------------------------- */
          b_packb( 0, buf_ptr, *buffer_pos,
                  FSIZ( cai_imsi_class1_type0_type, reserved ));
          *buffer_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

          b_packb(
            imsi_ptr->class_type.one.type.zero.imsi_addr_num,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
          *buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

          b_packb(
            imsi_ptr->class_type.one.type.zero.imsi_11_12,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
          *buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

          b_packq(
            imsi_ptr->class_type.one.type.zero.imsi_s,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type0_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
          break;

        case 1:
          /* -------------------------------------------
          ** Pack IMSI class 1 type 1 specific subfields
          ** ------------------------------------------- */
          b_packb(
            imsi_ptr->class_type.one.type.one.imsi_addr_num,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
          *buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

          b_packw(
            imsi_ptr->class_type.one.type.one.mcc,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class1_type1_type, mcc ));
          *buffer_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

          b_packb(
            imsi_ptr->class_type.one.type.one.imsi_11_12,
            buf_ptr, *buffer_pos,
            FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
          *buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

          b_packq(
            imsi_ptr->class_type.one.type.one.imsi_s,
            buf_ptr, *buffer_pos, FSIZ( cai_imsi_class1_type1_type, imsi_s ));
          *buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
          break;

        default:
          return (CAIX_INV_MSG_S);
      }
    } /* Class 1 IMSI */

    return status;

}  /* CAI_PACK_IMSI */

/*===========================================================================

FUNCTION XLATE_INT_AC_HDR

DESCRIPTION
  This function translates an Access Channel Message header (MSG_TYPE
  field through the MSID field) from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_hdr
(
  word *len_ptr,
    /* Pointer to length of Access Channel header in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* Status returned to calling procedure */
  word buffer_pos = 0;
    /* Position to pack bits in message */

  #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
  #endif

  #ifdef FEATURE_IS2000_REL_D
#error code not present
  #endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------------------------------------
  ** Translate Access Channel header from internal to external format
  ** ---------------------------------------------------------------- */

  #ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    b_packb( 2, buf_ptr, buffer_pos,FSIZ(cai_ac_msg_type_type,prot_disc));
  }
  else
  #endif /* FEATURE_IS2000_REL_A */
  if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
  {
    b_packb( 1, buf_ptr, buffer_pos,FSIZ(cai_ac_msg_type_type,prot_disc));
  }
  else
  {
    b_packb( 0, buf_ptr, buffer_pos,FSIZ(cai_ac_msg_type_type,prot_disc));
  }
  buffer_pos += FSIZ(cai_ac_msg_type_type,prot_disc);
  b_packb( int_ptr->gen_ac.msg_type, buf_ptr, buffer_pos,
           (FSIZ( cai_ac_msg_type_type, msg_type)));
  buffer_pos += (FSIZ( cai_ac_msg_type_type, msg_type));

  if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
  {
    ac_l2_length_pos = buffer_pos;
    ac_l2_start_pos = buffer_pos;
    buffer_pos += AC_L2_LENGTH_NUM_BITS;
  }

  b_packb( int_ptr->gen_ac.hdr.ack_seq, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, ack_seq ));
  buffer_pos += FSIZ( cai_ac_hdr_type, ack_seq );

  b_packb( int_ptr->gen_ac.hdr.msg_seq, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, msg_seq ));
  buffer_pos += FSIZ( cai_ac_hdr_type, msg_seq );

  b_packb( int_ptr->gen_ac.hdr.ack_req, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, ack_req ));
  buffer_pos += FSIZ( cai_ac_hdr_type, ack_req );

  b_packb( int_ptr->gen_ac.hdr.valid_ack, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, valid_ack ));
  buffer_pos += FSIZ( cai_ac_hdr_type, valid_ack );

  b_packb( int_ptr->gen_ac.hdr.ack_type, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, ack_type ));
  buffer_pos += FSIZ( cai_ac_hdr_type, ack_type );

  #ifdef FEATURE_IS2000_REL_D
#error code not present
  #endif // FEATURE_IS2000_REL_D

  b_packb( int_ptr->gen_ac.hdr.msid_type, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, msid_type ));
  buffer_pos += FSIZ( cai_ac_hdr_type, msid_type );

  #ifdef FEATURE_IS2000_REL_D
#error code not present
  #endif // FEATURE_IS2000_REL_D

  #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
  #else
  b_packb( int_ptr->gen_ac.hdr.msid_len, buf_ptr, buffer_pos,
           FSIZ( cai_ac_hdr_type, msid_len ));
  #endif

  buffer_pos += FSIZ( cai_ac_hdr_type, msid_len );

  #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
  #endif

  /* -------------------------------------
  ** Pack mobile station identifier fields
  ** ------------------------------------- */
  switch (int_ptr->gen_ac.hdr.msid_type)
  {
    case CAI_MIN_AND_ESN_ADDR_TYPE:                     /* 0 */
      /* ---------------------------
      ** IMSI_S and ESN address type
      ** --------------------------- */
      b_packd( int_ptr->gen_ac.hdr.msid.type0.min1, buf_ptr, buffer_pos,
               FSIZ( cai_msid0_type, min1 ));
      buffer_pos += FSIZ( cai_msid0_type, min1 );

      b_packw( int_ptr->gen_ac.hdr.msid.type0.min2, buf_ptr, buffer_pos,
               FSIZ( cai_msid0_type, min2 ));
      buffer_pos += FSIZ( cai_msid0_type, min2 );

      b_packd( int_ptr->gen_ac.hdr.msid.type0.esn, buf_ptr, buffer_pos,
             FSIZ( cai_msid0_type, esn ));
      buffer_pos += FSIZ( cai_msid0_type, esn );

      b_packb( 0, buf_ptr, buffer_pos, FSIZ( cai_msid0_type, reserved ));
      buffer_pos += FSIZ( cai_msid0_type, reserved );
      break;

    case CAI_ESN_ADDR_TYPE:                             /* 1 */
      /* ----------------
      ** ESN address type
      ** ---------------- */
      b_packd( int_ptr->gen_ac.hdr.msid.type1.esn, buf_ptr, buffer_pos,
               FSIZ( cai_msid1_type, esn ));
      buffer_pos += FSIZ( cai_msid1_type, esn );
      break;

    case CAI_IMSI_ADDR_TYPE:                            /* 2 */
      /* -----------------
      ** IMSI address type
      ** ----------------- */
      b_packb( int_ptr->gen_ac.hdr.msid.type2.imsi.imsi_class,
               buf_ptr, buffer_pos, FSIZ( cai_msid2_type, imsi_class ));
      buffer_pos += FSIZ( cai_msid2_type, imsi_class );

      if (int_ptr->gen_ac.hdr.msid.type2.imsi.imsi_class == 0)
      {
        b_packb(
          int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.imsi_class_0_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
        buffer_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

        switch ( int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.imsi_class_0_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.zero.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type1_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.one.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
            break;

          case 2:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 2 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                    FSIZ( cai_imsi_class0_type2_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.two.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.two.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
            break;

          case 3:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 3 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type3_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.three.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.three.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.zero.type.three.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);

        }
      } /* Class 0 IMSI */
      else /* Class 1 IMSI */
      {
        b_packb(
          int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.imsi_class_1_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
        buffer_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

        switch ( int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.imsi_class_1_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class1_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.zero.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.zero.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.zero.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.one.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.one.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type2.imsi.class_type.one.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 1 IMSI */
      break;

    case CAI_IMSI_AND_ESN_ADDR_TYPE:                    /* 3 */
      /* -------------------------
      ** IMSI and ESN address type
      ** ------------------------- */
      b_packd( int_ptr->gen_ac.hdr.msid.type3.esn, buf_ptr, buffer_pos,
               FSIZ( cai_msid3_type, esn ));
      buffer_pos += FSIZ( cai_msid3_type, esn );

      b_packb( int_ptr->gen_ac.hdr.msid.type3.imsi.imsi_class,
               buf_ptr, buffer_pos, FSIZ( cai_msid3_type, imsi_class ));
      buffer_pos += FSIZ( cai_msid3_type, imsi_class );

      if (int_ptr->gen_ac.hdr.msid.type3.imsi.imsi_class == 0)
      {
        b_packb(
          int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.imsi_class_0_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class0_type, imsi_class_0_type ));
        buffer_pos += FSIZ( cai_imsi_class0_type, imsi_class_0_type );

        switch ( int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.imsi_class_0_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, reserved );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.zero.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type1_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, reserved );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type1_type, imsi_s );
            break;

          case 2:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 2 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type2_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, reserved );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.two.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, mcc );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.two.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type2_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type2_type, imsi_s );
            break;

          case 3:
            /* -------------------------------------------
            ** Pack IMSI class 0 type 3 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class0_type3_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, reserved );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.three.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, mcc );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.three.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class0_type3_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.zero.type.three.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class0_type3_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class0_type3_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 0 IMSI */
      else /* Class 1 IMSI */
      {
        b_packb(
          int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.imsi_class_1_type,
          buf_ptr, buffer_pos,
          FSIZ( cai_imsi_class1_type, imsi_class_1_type ));
        buffer_pos += FSIZ( cai_imsi_class1_type, imsi_class_1_type );

        switch ( int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.imsi_class_1_type)
        {
          case 0:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 0 specific subfields
            ** ------------------------------------------- */
            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ( cai_imsi_class1_type0_type, reserved ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, reserved );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.zero.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_addr_num );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.zero.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.zero.imsi_s,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type0_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type0_type, imsi_s );
            break;

          case 1:
            /* -------------------------------------------
            ** Pack IMSI class 1 type 1 specific subfields
            ** ------------------------------------------- */
            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.one.imsi_addr_num,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_addr_num ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_addr_num );

            b_packw(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.one.mcc,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, mcc ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, mcc );

            b_packb(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.one.imsi_11_12,
              buf_ptr, buffer_pos,
              FSIZ( cai_imsi_class1_type1_type, imsi_11_12 ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_11_12 );

            b_packq(
              int_ptr->gen_ac.hdr.msid.type3.imsi.class_type.one.type.one.imsi_s,
              buf_ptr, buffer_pos, FSIZ( cai_imsi_class1_type1_type, imsi_s ));
            buffer_pos += FSIZ( cai_imsi_class1_type1_type, imsi_s );
            break;

          default:
            return (CAIX_INV_MSG_S);
        }
      } /* Class 1 IMSI */
      break;

    #ifdef FEATURE_IS2000_REL_D
#error code not present
    #endif /* FEATURE_IS2000_REL_D */

    case CAI_TMSI_AC_MSID_ADDR_TYPE:                    /* 5 */
      /* -------------------------
      ** TMSI address type
      ** ------------------------- */
      /* If MSID length is greater than the maximum size */
      /* of TMSI code, then TMSI zone needs to be sent.  */

      #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
      #endif /* FEATURE_MSG_PACK_UNIT_TEST */

      if ( int_ptr->gen_ac.hdr.msid_len > MAX_TMSI_CODE_LEN )
      {
        /* Bit-pack TMSI zone */
        /* Use only the Assigning Zone Length most significant */
        /* octets of the Assigning TMSI Zone.                  */

        #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
        #else
        b_packq( int_ptr->gen_ac.hdr.msid.type5.tmsi_zone,
          buf_ptr, buffer_pos, (cdma.assigning_tmsi.zone_len << 3) );
        buffer_pos += (cdma.assigning_tmsi.zone_len << 3);
        #endif /* FEATURE_MSG_PACK_UNIT_TEST */

        /* Bit-pack TMSI code */
        b_packd( int_ptr->gen_ac.hdr.msid.type5.tmsi_code,
          buf_ptr, buffer_pos, FSIZ( cai_tmsi_type, tmsi_code ) );
        buffer_pos += FSIZ( cai_tmsi_type, tmsi_code );
      }
      /* Send only the TMSI code.  Determine the */
      /* size of TMSI code to be sent.           */
      else
      {
        /* Bit-pack TMSI code */
        /* Determine size of TMSI code to send by  */
        /* checking if the most significant octets */
        /* of the TMSI code are equal to zero.     */
        if (( int_ptr->gen_ac.hdr.msid.type5.tmsi_code >> 16 ) == 0 )
        {
          /* 16-bit TMSI code */
          b_packw( (word) int_ptr->gen_ac.hdr.msid.type5.tmsi_code,
            buf_ptr, buffer_pos, 16 );
          buffer_pos += 16;
        }
        else if (( int_ptr->gen_ac.hdr.msid.type5.tmsi_code >> 24 ) == 0 )
        {
          /* 24-bit TMSI code */
          b_packd( int_ptr->gen_ac.hdr.msid.type5.tmsi_code,
            buf_ptr, buffer_pos, 24 );
          buffer_pos += 24;
        }
        else
        {
          /* 32-bit TMSI code */
          b_packd( int_ptr->gen_ac.hdr.msid.type5.tmsi_code,
            buf_ptr, buffer_pos, FSIZ( cai_tmsi_type, tmsi_code ) );
          buffer_pos += FSIZ( cai_tmsi_type, tmsi_code );
        }
      }

      break;

    default:
      #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
      #else
      return (CAIX_INV_MSG_S);
      #endif /* FEATURE_MSG_PACK_UNIT_TEST */
  }

  #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
  #endif /* FEATURE_MSG_PACK_UNIT_TEST */

  *len_ptr = buffer_pos;

  status = CAIX_DONE_S;

  return (status );

} /* xlate_int_ac_hdr */

#ifdef FEATURE_GPSONE
#error code not present
#endif /* FEATURE_GPSONE */

/*===========================================================================

FUNCTION XLATE_INT_AC_AUTH_MSG_INT

DESCRIPTION
  This function translates Authentication fields and message integrity fields
   from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_ac_auth_msg_int
(
  word *len_ptr,
    /* Pointer to length of Access Channel header in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  byte msg_type,
    /* Message type */ 
  caii_ac_hdr_type *hdr_ptr,
    /* Pointer to the internal format of layer2 fields */
  caii_ac_auth_msg_int_type *int_ptr
    /* Pointer to the internal format of authentication and message integrity
       fields */ 
)
{
  byte auth_mode_len;

  /* ----------------------------
  ** Pack the rest of the message
  ** ---------------------------- */

  #define FTYPE cai_ac_auth_msg_int_type
 
  auth_mode_len = FSIZ(FTYPE, auth_mode);

  #ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    auth_mode_len -= FSIZ(FTYPE, maci_incl);
    b_packb(int_ptr->maci_incl, buf_ptr, *len_ptr, 
      FSIZ(FTYPE, maci_incl));
    *len_ptr += FSIZ(FTYPE, maci_incl);
  }
  #endif /* FEATURE_IS2000_REL_C */

  b_packb(int_ptr->auth_mode, buf_ptr, *len_ptr, auth_mode_len);
  *len_ptr += auth_mode_len;

  if (int_ptr->auth_mode == CAI_AUTH)
  {
    b_packd(int_ptr->authr, buf_ptr, *len_ptr, FSIZ(FTYPE, authr));
    *len_ptr += FSIZ(FTYPE, authr);
  }

  if ( (int_ptr->auth_mode == CAI_AUTH)
       #ifdef FEATURE_IS2000_REL_C
       || ( (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C) &&
            (int_ptr->maci_incl) )
       #endif /* FEATURE_IS2000_REL_C */
     )
  {
    b_packb(int_ptr->randc, buf_ptr, *len_ptr, FSIZ(FTYPE, randc));
    *len_ptr += FSIZ(FTYPE, randc);
  }

  if (int_ptr->auth_mode == CAI_AUTH)
  {
    b_packb(int_ptr->count, buf_ptr, *len_ptr, FSIZ(FTYPE, count));
    *len_ptr += FSIZ(FTYPE, count);
  }

  #ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    if (int_ptr->maci_incl)
    {
      b_packb(int_ptr->sdu_key_id, buf_ptr, *len_ptr, FSIZ(FTYPE, sdu_key_id));
      *len_ptr += FSIZ(FTYPE, sdu_key_id);

      b_packb(int_ptr->sdu_integrity_algo, buf_ptr, *len_ptr,
        FSIZ(FTYPE, sdu_integrity_algo));
      *len_ptr += FSIZ(FTYPE, sdu_integrity_algo);

      b_packb(int_ptr->sdu_sseq_or_sseqh, buf_ptr, *len_ptr,
        FSIZ(FTYPE, sdu_sseq_or_sseqh));
      *len_ptr += FSIZ(FTYPE, sdu_sseq_or_sseqh);

      if (!int_ptr->sdu_sseq_or_sseqh)
      {
        b_packb(int_ptr->sdu_sseq, buf_ptr, *len_ptr, FSIZ(FTYPE, sdu_sseq));
        *len_ptr += FSIZ(FTYPE, sdu_sseq);
      }
      else
      {
        b_packd(int_ptr->sdu_sseq_h, buf_ptr, *len_ptr, FSIZ(FTYPE, sdu_sseq_h));
        *len_ptr += FSIZ(FTYPE, sdu_sseq_h);
      }
    }
  }
  #endif /* FEATURE_IS2000_REL_C */

  #undef FTYPE

} /* xlate_int_ac_auth_msg_int */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_INT_MACI

DESCRIPTION
  This function translates MACI field from internal to external format.

DEPENDENCIES
  None
RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_maci
(
  /* Pointer to length of message in bits */
  word *len_ptr,

  /* Pointer to where translated message should be placed */
  byte *buf_ptr,

  /* Length of CRC */
  word crc_len,

  /* whether ack is required or not */
  boolean ack_req,

  /* Physical Channel this message is to be transmitted on */
  word phy_chan,
  
  /* Key id of the integrity key to be used to compute the MAC-I value 
     for this PDU. */
  byte sdu_key_id,
  
  byte msg_type,
  
  /* Identity of the message integrity algorithm that is used for the 
     SDU carried by this PDU. */
  byte sdu_integrity_algo,   
   
  #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
  #endif /* FEATURE_IS2000_REL_C_MI */

  /* This holds calculated MACI */
  dword * maci  
  )
{
  /* padding bits to align it at the octet boundary */ 
  byte pdu_padding_bits;
    
  #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
  #else
  /* Make sure the prev is greater than 9 */
  if (caix_p_rev_in_use <= CAIX_P_REV_IS2000_REL_C)
  #endif /* FEATURE_MSG_PACK_UNIT_TEST */
  {
    return;
  }
  
  /* Include the padding bits to align it at the octet boundary */
  pdu_padding_bits =  (*len_ptr + crc_len) % 8;

  if (pdu_padding_bits != 0)
  {
    pdu_padding_bits = 8 - pdu_padding_bits;
    b_packb(0, buf_ptr, *len_ptr, pdu_padding_bits);
    *len_ptr += pdu_padding_bits;
  }

  #define FTYPE cai_msg_int_type

  #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
  #endif
  {
    /* ERROR case.
       just increment the length pointer and let MACI be non-deterministic 
       value.
    */
    #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
    #endif /* FEATURE_MSG_PACK_UNIT_TEST */
    *len_ptr += FSIZ(FTYPE, maci);  
  }

  #undef FTYPE
   
} /* xlate_int_maci */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_INT_AC_ENC

DESCRIPTION
  This function translates Extended Encryption fields from internal to 
  external format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_ac_enc
(
  word *len_ptr,
    /* Pointer to length of Access Channel header in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_ac_enc_type *int_ptr,
    /* Pointer to the internal format of the encryption fields */
  caii_ac_auth_msg_int_type *ami_ptr
    /* Pointer to the internal format of the authentication and message
       integrity fields */
)
{
  word buffer_pos = *len_ptr;
    /* Position to pack bits in message */

  if ( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A ) 
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    b_packb(int_ptr->enc_fields_incl, buf_ptr, buffer_pos,
      FSIZ( cai_ext_enc_type, enc_fields_incl));
    buffer_pos += FSIZ( cai_ext_enc_type, enc_fields_incl);

    if (int_ptr->enc_fields_incl)
    {
      /* ----------------------------------------
      ** Pack extended encryption specific fields
      ** ---------------------------------------- */
      b_packb(int_ptr->sdu_encrypt_mode, buf_ptr, buffer_pos,
        FSIZ(cai_ext_enc_type, sdu_encrypt_mode));
      buffer_pos += FSIZ(cai_ext_enc_type, sdu_encrypt_mode);

      if (((int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_ECMEA)
           || (int_ptr->sdu_encrypt_mode == CAI_ENC_MODE_REA))
#ifdef FEATURE_IS2000_REL_C
          && ((caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C) || 
              (!ami_ptr->maci_incl)
             )
#endif /* FEATURE_IS2000_REL_C */
         )
      {
        b_packb(int_ptr->enc_seq, buf_ptr, buffer_pos,
          FSIZ(cai_ext_enc_type, enc_seq));
        buffer_pos += FSIZ(cai_ext_enc_type, enc_seq);
      }
    }

    *len_ptr = buffer_pos;

  }

  #if defined(FEATURE_IS2000_REL_A_AES) && defined(FEATURE_TREX)
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES && FEATURE_TREX */
  
}  /* xlate_int_ac_enc */

#endif /* FEATURE_IS2000_REL_A */

/*===========================================================================

FUNCTION XLATE_INT_REG

DESCRIPTION
  This function translates a Registration Message from internal
  to external format.

DEPENDENCIES
  p_rev_in_use is required in the internal format.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_reg
(
  word *len_ptr,
    /* Pointer to length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------
  ** Pack Registration Message up through the MSID field
  ** --------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->reg.msg_type,
      &int_ptr->reg.hdr, &int_ptr->reg.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->reg.enc,
                     &int_ptr->reg.ami
                    ); 

#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    /* -----------------------------
    ** Add RER fields for P_REV >= 6
    **------------------------------ */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,&(int_ptr->reg.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    b_packb( int_ptr->reg.reg_type, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, reg_type ));
    buffer_pos += FSIZ( cai_reg_type, reg_type );

    b_packb( int_ptr->reg.slot_cycle_index, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, slot_cycle_index ));
    buffer_pos += FSIZ( cai_reg_type, slot_cycle_index );

    b_packb( int_ptr->reg.mob_p_rev, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, mob_p_rev ));
    buffer_pos += FSIZ( cai_reg_type, mob_p_rev );

    b_packb( int_ptr->reg.scm, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, scm ));
    buffer_pos += FSIZ( cai_reg_type, scm );

    b_packb( int_ptr->reg.mob_term, buf_ptr, buffer_pos,
             FSIZ( cai_reg_type, mob_term ));
    buffer_pos += FSIZ( cai_reg_type, mob_term );


    /* ------------------------------------------------------
    ** This field is new to IS-95B, it is up to the higher
    ** layer to set p_rev_in_use
    ** ------------------------------------------------------ */
    if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      b_packb( int_ptr->reg.return_cause, buf_ptr, buffer_pos,
               FSIZ( cai_reg_type, return_cause ));
      buffer_pos += FSIZ( cai_reg_type, return_cause );

      if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->reg.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }
      else
      {
        b_packb( int_ptr->reg.qpch_supported, buf_ptr, buffer_pos,
                 FSIZ(cai_reg_is2000_type,qpch_supported));
        buffer_pos += FSIZ(cai_reg_is2000_type,qpch_supported);
        b_packb( int_ptr->reg.enhanced_rc, buf_ptr, buffer_pos,
                 FSIZ(cai_reg_is2000_type,enhanced_rc));
        buffer_pos += FSIZ(cai_reg_is2000_type,enhanced_rc);
        b_packb( int_ptr->reg.uzid_incl, buf_ptr, buffer_pos,
                 FSIZ(cai_reg_is2000_type,uzid_incl));
        buffer_pos += FSIZ(cai_reg_is2000_type,uzid_incl);
        if (int_ptr->reg.uzid_incl)
        {
          b_packw( int_ptr->reg.uzid, buf_ptr, buffer_pos,
                   FSIZ(cai_reg_is2000_type,uzid));
          buffer_pos += FSIZ(cai_reg_is2000_type,uzid);
        }
      }
    }

#ifdef FEATURE_IS2000_REL_A
    if(caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      b_packb( int_ptr->reg.geo_loc_incl, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, geo_loc_incl ));
      buffer_pos += FSIZ( cai_reg_is2000_type, geo_loc_incl );

      if( int_ptr->reg.geo_loc_incl)
      {
        b_packb( int_ptr->reg.geo_loc_type, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, geo_loc_type ));
        buffer_pos += FSIZ( cai_reg_is2000_type, geo_loc_type );

      }

      b_packb( int_ptr->reg.otd_supported, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, otd_supported ));
      buffer_pos += FSIZ( cai_reg_is2000_type, otd_supported );

      b_packb( int_ptr->reg.sts_supported, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, sts_supported ));
      buffer_pos += FSIZ( cai_reg_is2000_type, sts_supported );

      b_packb( int_ptr->reg.thx_cch_supported, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, thx_cch_supported ));
      buffer_pos += FSIZ( cai_reg_is2000_type, thx_cch_supported );

      b_packb( int_ptr->reg.wll_incl, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, wll_incl ));
      buffer_pos += FSIZ( cai_reg_is2000_type, wll_incl );

      if (int_ptr->reg.wll_incl)
      {
        b_packb( int_ptr->reg.wll_device_type, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, wll_device_type ));
        buffer_pos += FSIZ( cai_reg_is2000_type, wll_device_type );

        b_packb( int_ptr->reg.hook_status, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, hook_status ));
        buffer_pos += FSIZ( cai_reg_is2000_type, hook_status );
      }

      b_packb( int_ptr->reg.enc_info_incl, buf_ptr, buffer_pos,
               FSIZ( cai_reg_is2000_type, enc_info_incl ));
      buffer_pos += FSIZ( cai_reg_is2000_type, enc_info_incl );

      if (int_ptr->reg.enc_info_incl)
      {
        b_packb( int_ptr->reg.sig_encrypt_sup, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, sig_encrypt_sup ));
        buffer_pos += FSIZ( cai_reg_is2000_type, sig_encrypt_sup );

        b_packb( int_ptr->reg.c_sig_encrypt_req, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, c_sig_encrypt_req ));
        buffer_pos += FSIZ( cai_reg_is2000_type, c_sig_encrypt_req );

        if (((int_ptr->reg.sig_encrypt_sup & CAI_ENC_SUP_ECMEA) != 0)||
            ((int_ptr->reg.sig_encrypt_sup & CAI_ENC_SUP_REA) != 0))
        {
          b_packd( int_ptr->reg.enc_seq_h, buf_ptr, buffer_pos,
                   FSIZ( cai_reg_is2000_type, enc_seq_h ));
          buffer_pos += FSIZ( cai_reg_is2000_type, enc_seq_h );

          b_packb( int_ptr->reg.enc_seq_h_sig, buf_ptr, buffer_pos,
                   FSIZ( cai_reg_is2000_type, enc_seq_h_sig ));
          buffer_pos += FSIZ( cai_reg_is2000_type, enc_seq_h_sig );
        }

        b_packb( int_ptr->reg.ui_encrypt_sup, buf_ptr, buffer_pos,
                 FSIZ( cai_reg_is2000_type, ui_encrypt_sup ));
        buffer_pos += FSIZ( cai_reg_is2000_type, ui_encrypt_sup );
      }

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        b_packb( int_ptr->reg.msg_int_info_incl, buf_ptr, buffer_pos,
                     FSIZ( cai_reg_is2000_type, msg_int_info_incl ));
        buffer_pos += FSIZ( cai_reg_is2000_type, msg_int_info_incl);

        if (int_ptr->reg.msg_int_info_incl)
        {
          b_packb( int_ptr->reg.sig_integrity_sup_incl, buf_ptr, buffer_pos,
                   FSIZ( cai_reg_is2000_type, sig_integrity_sup_incl ));
          buffer_pos += FSIZ( cai_reg_is2000_type, sig_integrity_sup_incl);

          if (int_ptr->reg.sig_integrity_sup_incl)
          {
            b_packb( int_ptr->reg.sig_integrity_sup, buf_ptr, buffer_pos,
                     FSIZ( cai_reg_is2000_type, sig_integrity_sup ));
            buffer_pos += FSIZ( cai_reg_is2000_type, sig_integrity_sup);

            b_packb( int_ptr->reg.sig_integrity_req, buf_ptr, buffer_pos,
                        FSIZ( cai_reg_is2000_type, sig_integrity_req ));
            buffer_pos += FSIZ( cai_reg_is2000_type, sig_integrity_req);
          }
          b_packb( int_ptr->reg.new_key_id, buf_ptr, buffer_pos,
                    FSIZ( cai_reg_is2000_type, new_key_id ));
           buffer_pos += FSIZ( cai_reg_is2000_type, new_key_id);

          b_packb( int_ptr->reg.new_sseq_h_incl, buf_ptr, buffer_pos,
                         FSIZ( cai_reg_is2000_type, new_sseq_h_incl ));
          buffer_pos += FSIZ( cai_reg_is2000_type, new_sseq_h_incl);

          if (int_ptr->reg.new_sseq_h_incl)
          {
            b_packd( int_ptr->reg.new_sseq_h, buf_ptr, buffer_pos,
                      FSIZ( cai_reg_is2000_type, new_sseq_h ));
            buffer_pos += FSIZ( cai_reg_is2000_type, new_sseq_h);

            b_packb( int_ptr->reg.new_sseq_h_sig, buf_ptr, buffer_pos,
                          FSIZ( cai_reg_is2000_type, new_sseq_h_sig ));
            buffer_pos += FSIZ( cai_reg_is2000_type, new_sseq_h_sig);
          }
        }

      }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
      #endif /* FEATURE_IS2000_REL_A_AES */      

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        /* ----------------------------
        ** Pack the MACI field
        ** ---------------------------- */
        if (int_ptr->reg.ami.maci_incl)
        {
          xlate_int_maci(&buffer_pos,
                         buf_ptr,
                         CAI_AC_CRC_SIZE,
                         int_ptr->reg.hdr.ack_req,
                         chn,
                         int_ptr->reg.ami.sdu_key_id,
                          int_ptr->reg.msg_type,
                         int_ptr->reg.ami.sdu_integrity_algo,
                         #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                         #endif /* FEATURE_IS2000_REL_C_MI */
                         &int_ptr->reg.ami.maci
                         );
        }  /* maci_incl */
       } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
    } /* prev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  } /* status DONE_S */
  *len_ptr = buffer_pos;

  return (status );

} /* xlate_int_reg */

/*===========================================================================

FUNCTION XLATE_INT_AC_ORD

DESCRIPTION
  This function translates an Access Channel Order Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_ord
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* -----------------------------------------------------------
  ** Pack Access Channel Order Message up through the MSID field
  ** ----------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    /* The following was needed because we would pack 00 knowing
     * auth_mode is always 0 for ORDER messages but that is now taken 
     * care of */
    //b_packb( 0, buf_ptr, buffer_pos, FSIZ( cai_ac_gen_ord_type, reserved ));
    //buffer_pos += FSIZ( cai_ac_gen_ord_type, reserved );

    /* -----------------------------------------------------------
    ** Pack the authentication fields and message integrity fields
    ** ----------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_ord.gen.msg_type, 
      &int_ptr->ac_ord.gen.hdr, &int_ptr->ac_ord.gen.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->ac_ord.gen.enc,
                     &int_ptr->ac_ord.gen.ami
                    );
#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    /* -----------------------------
    ** Add RER fields for P_REV >= 6 
    **------------------------------ */
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,&(int_ptr->ac_ord.gen.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb( int_ptr->ac_ord.gen.order, buf_ptr, buffer_pos,
             FSIZ( cai_ac_gen_ord_type, order ));
    buffer_pos += FSIZ( cai_ac_gen_ord_type, order );

    switch (int_ptr->ac_ord.gen.order)
    {
      case CAI_BS_CHAL_ORD:
        /* ----------------------------
        ** Base Station Challenge Order
        ** ---------------------------- */
        b_packb( 5, buf_ptr, buffer_pos,
                 FSIZ( cai_ac_bs_chal_type, add_record_len ));
        buffer_pos += FSIZ( cai_ac_bs_chal_type, add_record_len );

        b_packb( 0, buf_ptr, buffer_pos, FSIZ( cai_ac_bs_chal_type, ordq ));
        buffer_pos += FSIZ( cai_ac_bs_chal_type, ordq );

        b_packd( int_ptr->ac_ord.chal.randbs, buf_ptr, buffer_pos,
                 FSIZ( cai_ac_bs_chal_type, randbs ));
        buffer_pos += FSIZ( cai_ac_bs_chal_type, randbs );
        break;

      case CAI_SSD_UPDATE_ORD:
      case CAI_LOCAL_CTL_RESP_ORD:
      case CAI_RELEASE_ORD:
        /* -------------------------------------------------
        ** Messages with potential order qualification codes
        ** ------------------------------------------------- */
        if (int_ptr->ac_ord.ordq.ordq == 0)
        {
          /* ----------------------------------------
          ** No need to pack order qualification code
          ** ---------------------------------------- */
          b_packb( 0, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_gen_ord_type, add_record_len ));
          buffer_pos += FSIZ( cai_ac_gen_ord_type, add_record_len );
        }
        else
        {
          b_packb( 1, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_ordq_type, add_record_len ));
          buffer_pos += FSIZ( cai_ac_ordq_type, add_record_len );

          b_packb( int_ptr->ac_ord.ordq.ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_ordq_type, ordq ));
          buffer_pos += FSIZ( cai_ac_ordq_type, ordq );
        }
        break;

      case CAI_MS_REJECT_ORD:

        if (int_ptr->ac_ord.rej.rej_msg_type == CAI_PC_ORD_MSG)
        {
          byte my_record_len = 4;
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            my_record_len++;
          }
          b_packb( my_record_len, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, add_record_len ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, add_record_len );
          b_packb( int_ptr->ac_ord.rej.ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, ordq ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, ordq );

          b_packb( int_ptr->ac_ord.rej.rej_msg_type, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, rej_msg_type ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, rej_msg_type );

          b_packb( int_ptr->ac_ord.rej_ord.rej_order, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, rej_order ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, rej_order );

          b_packb( int_ptr->ac_ord.rej_ord.rej_ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_ord_type, rej_ordq ));
          buffer_pos += FSIZ( cai_ac_rej_ord_type, rej_ordq );

          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            b_packb( int_ptr->ac_ord.rej_ord.rejected_pdu_type, buf_ptr,
                     buffer_pos,
                     FSIZ(cai_ac_rej_ord_is2000_type,rejected_pdu_type));
            buffer_pos += FSIZ(cai_ac_rej_ord_is2000_type,rejected_pdu_type);

            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ(cai_ac_rej_ord_is2000_type,reserved));
            buffer_pos += FSIZ(cai_ac_rej_ord_is2000_type,reserved);
          }
          break;
        }
        else if (int_ptr->ac_ord.rej.rej_msg_type == CAI_FEATURE_MSG)
        {
          byte my_record_len = 3;
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            my_record_len++;
          }
          b_packb( my_record_len, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_rec_type, add_record_len ));
          buffer_pos +=  FSIZ( cai_ac_rej_rec_type, add_record_len );
          b_packb( int_ptr->ac_ord.rej.ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_rec_type, ordq ));
          buffer_pos += FSIZ( cai_ac_rej_rec_type, ordq );

          b_packb( int_ptr->ac_ord.rej.rej_msg_type, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_rec_type, rej_msg_type ));
          buffer_pos += FSIZ( cai_ac_rej_rec_type, rej_msg_type );

          b_packb( int_ptr->ac_ord.rej_rec.rej_record, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_rec_type, rej_record ));
          buffer_pos += FSIZ( cai_ac_rej_rec_type, rej_record );
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            b_packb( int_ptr->ac_ord.rej_ord.rejected_pdu_type, buf_ptr,
                     buffer_pos,
                     FSIZ(cai_ac_rej_rec_is2000_type,rejected_pdu_type));
            buffer_pos += FSIZ(cai_ac_rej_rec_is2000_type,rejected_pdu_type);

            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ(cai_ac_rej_rec_is2000_type,reserved));
            buffer_pos += FSIZ(cai_ac_rej_rec_is2000_type,reserved);
          }
        }
        else
        {
          byte my_record_len = 2;
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            my_record_len++;
          }
          b_packb( my_record_len, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_type, add_record_len ));
          buffer_pos +=  FSIZ( cai_ac_rej_type, add_record_len );
          b_packb( int_ptr->ac_ord.rej.ordq, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_type, ordq ));
          buffer_pos += FSIZ( cai_ac_rej_type, ordq );

          b_packb( int_ptr->ac_ord.rej.rej_msg_type, buf_ptr, buffer_pos,
                   FSIZ( cai_ac_rej_type, rej_msg_type ));
          buffer_pos += FSIZ( cai_ac_rej_type, rej_msg_type );
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
          {
            b_packb( int_ptr->ac_ord.rej_ord.rejected_pdu_type, buf_ptr,
                     buffer_pos,
                     FSIZ(cai_ac_rej_is2000_type,rejected_pdu_type));
            buffer_pos += FSIZ(cai_ac_rej_is2000_type,rejected_pdu_type);

            b_packb( 0, buf_ptr, buffer_pos,
                     FSIZ(cai_ac_rej_is2000_type,reserved));
            buffer_pos += FSIZ(cai_ac_rej_is2000_type,reserved);
          }
        }
        break;

#ifdef FEATURE_IS2000_REL_C
      case CAI_SEC_MODE_CMP_ORD:
#endif /* FEATURE_IS2000_REL_C */
      case CAI_MS_ACK_ORD:
        /* -------------------------------------
        ** No order qualification code necessary
        ** ------------------------------------- */
        b_packb( 0, buf_ptr, buffer_pos,
                 FSIZ( cai_ac_gen_ord_type, add_record_len ));
        buffer_pos += FSIZ( cai_ac_gen_ord_type, add_record_len );
        break;

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      default:
        /* ---------------------------------
        ** Invalid Access Channel Order Code
        ** --------------------------------- */
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
        status = CAIX_INV_MSG_S;
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
        break;
    } /* end switch */

    if (status == CAIX_DONE_S)
    {
      if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
      {
        if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
        {
          (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                            buf_ptr,buffer_pos,&(int_ptr->ac_ord.gen.pilot_rpt));
          buffer_pos += ac_plt_rpt_len;
        }
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
        #endif /* FEATURE_IS2000_REL_A_AES */   

#ifdef FEATURE_IS2000_REL_C
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
        {
          /* ----------------------------
           ** Pack the MACI field
           ** ---------------------------- */
          if (int_ptr->ac_ord.gen.ami.maci_incl)
          {
            xlate_int_maci(&buffer_pos,
                           buf_ptr,
                           CAI_AC_CRC_SIZE,
                           int_ptr->ac_ord.gen.hdr.ack_req,
                           chn,
                           int_ptr->ac_ord.gen.ami.sdu_key_id,
                          int_ptr->ac_ord.gen.msg_type,
                           int_ptr->ac_ord.gen.ami.sdu_integrity_algo,
                           #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                           #endif /* FEATURE_IS2000_REL_C_MI */
                           &int_ptr->ac_ord.gen.ami.maci
                           );
          } /* maci_incl */
        } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
      } /* prev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

    } /* status DONE_S */
  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_ac_ord */

/*===========================================================================

FUNCTION XLATE_INT_AC_TMSI_CMP

DESCRIPTION
  This function translates an Access Channel TMSI Assignment Completion
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_tmsi_cmp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------------------------------------
  ** Pack Access Channel Data Burst Message up through the MSID field
  ** ---------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_tmsi_cmp.msg_type,
      &int_ptr->ac_tmsi_cmp.hdr, &int_ptr->ac_tmsi_cmp.ami);

    #ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->ac_tmsi_cmp.enc,
                     &int_ptr->ac_tmsi_cmp.ami
                    );
    #endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    if (caix_p_rev_in_use >= CAIX_P_REV_IS95B)
    {
      /* -----------------------------
      ** Add RER fields for P_REV >= 4
      **------------------------------ */
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,
                        &(int_ptr->ac_tmsi_cmp.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      /* ---------------------------------------
      ** L3 SDU Fields
      **---------------------------------------- */

      #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
      #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {

        /* ----------------------------
        ** Pack the MACI field
        ** ---------------------------- */
        if (int_ptr->ac_tmsi_cmp.ami.maci_incl)
        {
          xlate_int_maci(&buffer_pos,
                         buf_ptr,
                         CAI_AC_CRC_SIZE,
                         int_ptr->ac_tmsi_cmp.hdr.ack_req,
                         chn,
                         int_ptr->ac_tmsi_cmp.ami.sdu_key_id,
                         int_ptr->ac_tmsi_cmp.msg_type,
                         int_ptr->ac_tmsi_cmp.ami.sdu_integrity_algo,
                         #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                         #endif /* FEATURE_IS2000_REL_C_MI */
                         &int_ptr->ac_tmsi_cmp.ami.maci
                         );

        } /* maci_incl */
      } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
    } /* prev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_ac_tmsi_cmp */

/*===========================================================================

FUNCTION XLATE_INT_AC_PACA_CAN

DESCRIPTION
  This function translates an Access Channel PACA Cancel
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_paca_can
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /* ---------------------------------------------------
  ** Pack PACA Cancel Message up through the MSID field
  ** --------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_paca_can.msg_type,
      &int_ptr->ac_paca_can.hdr, &int_ptr->ac_paca_can.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    #ifndef FEATURE_MSG_PACK_UNIT_TEST
    /* Since this message has no L3 fields, to parse LAC field correctly,
     * we sent enc_fields_incl to be FALSE
     */
    int_ptr->ac_paca_can.enc.enc_fields_incl = FALSE;
    #endif /* !FEATURE_MSG_PACK_UNIT_TEST */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->ac_paca_can.enc,
                     &int_ptr->ac_paca_can.ami
                    );
#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    /* -----------------------------
    ** Add RER fields for P_REV >= 4
    **------------------------------ */
    if (caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,
                        &(int_ptr->ac_paca_can.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      /* ---------------------------------------
      ** L3 SDU Fields
      **---------------------------------------- */

      #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
      #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        /* ----------------------------
        ** Pack the MACI field
        ** ---------------------------- */
        if (int_ptr->ac_paca_can.ami.maci_incl)
        {
          xlate_int_maci(&buffer_pos,
                         buf_ptr,
                         CAI_AC_CRC_SIZE,
                         int_ptr->ac_paca_can.hdr.ack_req,
                         chn,
                         int_ptr->ac_paca_can.ami.sdu_key_id,
                         int_ptr->ac_paca_can.msg_type,
                         int_ptr->ac_paca_can.ami.sdu_integrity_algo,
                         #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                         #endif /* FEATURE_IS2000_REL_C_MI */
                         &int_ptr->ac_paca_can.ami.maci
                         );
        } /* maci_incl */
      } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
    } /* p_rev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  }

  *len_ptr = buffer_pos;

  return (status );

} /* xlate_int_ac_paca_can */

/*===========================================================================

FUNCTION XLATE_INT_AC_EXT_STRSP

DESCRIPTION
  This function translates an Access Channel Extended Status Response
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_ext_strsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */

)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack bits in message */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------------------------
  ** Pack Extended Status Response Message up through the MSID field
  ** ------------------------------------------------------ */
  status = xlate_int_ac_hdr( &msg_pos, buf_ptr, int_ptr );
 
  if ( status != CAIX_DONE_S )
  {
    return ( status ); /* Header translation failed */
  }

  /* ----------------------------
  ** Pack the rest of the message
  ** ---------------------------- */

  /* ------------------------------------------------------------
  ** Pack the authentication fields and message intergrity fields
  ** ------------------------------------------------------------ */
  xlate_int_ac_auth_msg_int(&msg_pos, buf_ptr, int_ptr->ac_ext_strsp.msg_type,
    &int_ptr->ac_ext_strsp.hdr, &int_ptr->ac_ext_strsp.ami);

#ifdef FEATURE_IS2000_REL_A
  /* -------------------------------
  ** Pack Extended Encryption fields
  ** ------------------------------- */
  xlate_int_ac_enc(&msg_pos, buf_ptr, 
                   &int_ptr->ac_ext_strsp.enc,
                   &int_ptr->ac_ext_strsp.ami
                  );
#endif /* FEATURE_IS2000_REL_A */

  if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
  {
    ac_l2_num_bits = msg_pos-ac_l2_start_pos;
    ac_l2_num_bytes = (ac_l2_num_bits/8);
    ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
    if (ac_l2_num_reserved != 8)
    {
      ac_l2_num_bytes += 1;
      b_packb (0,buf_ptr,msg_pos,ac_l2_num_reserved);
      msg_pos += ac_l2_num_reserved;
    }
    b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
  }

  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
  {
    /* -----------------------------
    ** Add RER fields for P_REV >= 6
    **------------------------------_ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,msg_pos,
                      &(int_ptr->ac_ext_strsp.pilot_rpt));
    msg_pos += ac_plt_rpt_len;
  }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->ac_ext_strsp.qual,
           buf_ptr, msg_pos, FSIZ( cai_ac_ext_strsp_fix_type, qual_info_type));
  msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, qual_info_type );

  if ( int_ptr->ac_ext_strsp.qual == CAI_NO_QUAL ) /* No qual info */
  {
    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_ac_ext_strsp_fix_type,
              qual_info_len ) );
    msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, qual_info_len );
  }
  else if ( int_ptr->ac_ext_strsp.qual == CAI_BAND_QUAL )
  {
    /* Band qual info */
    b_packb( sizeof(cai_qual_info1_type) / 8,
             buf_ptr, msg_pos, FSIZ(cai_ac_ext_strsp_fix_type, qual_info_len));
    msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, qual_info_len );

    b_packb( int_ptr->ac_ext_strsp.band,
             buf_ptr, msg_pos, FSIZ( cai_qual_info1_type, band ) );
    msg_pos += FSIZ( cai_qual_info1_type, band );

    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_qual_info1_type, reserved ) );
    msg_pos += FSIZ( cai_qual_info1_type, reserved );
  }
  else if ( int_ptr->ac_ext_strsp.qual == CAI_BAND_OP_MODE_QUAL )
  {
    b_packb( sizeof(cai_qual_info2_type) / 8,
             buf_ptr, msg_pos, FSIZ(cai_ac_ext_strsp_fix_type, qual_info_len));
    msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, qual_info_len );

    b_packb( int_ptr->ac_ext_strsp.band,
             buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, band ) );
    msg_pos += FSIZ( cai_qual_info2_type, band );

    b_packb( int_ptr->ac_ext_strsp.op_mode,
             buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, op_mode ) );
    msg_pos += FSIZ( cai_qual_info2_type, op_mode );

    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, reserved ) );
    msg_pos += FSIZ( cai_qual_info2_type, reserved );
  }
  else
  {
    return ( CAIX_INV_MSG_S ); /* Unknown qual info type */
  }

  b_packb( int_ptr->ac_ext_strsp.num_recs, buf_ptr, msg_pos,
           FSIZ( cai_ac_ext_strsp_fix_type, num_info_rec ) );
  msg_pos += FSIZ( cai_ac_ext_strsp_fix_type, num_info_rec );

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /* Translate the information records */
  for ( i = irec_pos = 0; i < int_ptr->ac_ext_strsp.num_recs; i++ )
  {

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
    status =
    xlate_int_info_rec(
                      (byte*)(&int_ptr->ac_ext_strsp.recs[irec_pos/4]),
                      &irec_len,
                      CAI_AC_BODY_SIZE - msg_pos,
                      buf_ptr,
                      msg_pos,
                      &xrec_len );
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    if ( status != CAIX_DONE_S )
    {
      return ( status ); /* Problem translating info rec */
    }

    msg_pos  += xrec_len;  /* Advance external msg buf position */
    irec_pos += irec_len;  /* Advance internal msg buf position */
    /* The next record will start only on a dword boundary, so move positions accordingly */
    irec_pos = (irec_pos%4)?(irec_pos+(sizeof(dword))-irec_pos%4):irec_pos;
  } /* for */

  if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
  {
    if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,msg_pos,&(int_ptr->ac_ext_strsp.pilot_rpt));
      msg_pos += ac_plt_rpt_len;
    }
  }

#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
      if (int_ptr->ac_ext_strsp.ami.maci_incl)
      {
        xlate_int_maci(&msg_pos,
                       buf_ptr,
                       CAI_AC_CRC_SIZE,
                       int_ptr->ac_ext_strsp.hdr.ack_req,
                       chn,
                       int_ptr->ac_ext_strsp.ami.sdu_key_id,
                       int_ptr->ac_ext_strsp.msg_type,
                       int_ptr->ac_ext_strsp.ami.sdu_integrity_algo,
                       #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                       #endif /* FEATURE_IS2000_REL_C_MI */
                       &int_ptr->ac_ext_strsp.ami.maci
                      );
      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */

  } /* P_REV >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  *len_ptr = msg_pos; /* Set length of message */

  return ( status );

} /* xlate_int_ac_ext_strsp */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_INT_AC_DIM

DESCRIPTION
  This function translates Device Information
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_dim
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(caix_p_rev_in_use <= CAIX_P_REV_IS2000)
  {
    MSG_ERROR( "Msg not supported by P_REV", 0, 0, 0);
    return CAIX_INV_MSG_S;
  }

  /* ---------------------------------------------------
  ** Pack Message up through the MSID field
  ** --------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->dim.msg_type,
      &int_ptr->dim.hdr, &int_ptr->dim.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    #ifndef FEATURE_MSG_PACK_UNIT_TEST
    /* for some reason, there is no message building function for Device
     * Information Message at Layer 3. This means that the LAC field setting
     * is un-predictable.
     *
     * To make sure the parsing goes correctly with AES, we call a function
     * to set encryption fields as messages built in mccsa.c
     */
    int_ptr->dim.enc.enc_fields_incl = FALSE;

    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

    #endif /* !FEATURE_MSG_PACK_UNIT_TEST */

    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->dim.enc,
                     &int_ptr->dim.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->dim.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;


    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packb (int_ptr->dim.wll_device_type, buf_ptr, buffer_pos,
             FSIZ( cai_ac_dim_type, wll_device_type));
    buffer_pos += FSIZ( cai_ac_dim_type, wll_device_type);


    b_packb (int_ptr->dim.num_recs, buf_ptr, buffer_pos,
             FSIZ( cai_ac_dim_type, num_recs));
    buffer_pos += FSIZ( cai_ac_dim_type, num_recs);

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    /* Translate the information records */
    for ( i = irec_pos = 0; i < int_ptr->dim.num_recs; i++ )
    {

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
      status =
      xlate_int_info_rec(
                        (byte*)(&int_ptr->dim.recs[irec_pos/4]),
                        &irec_len,
                        CAI_AC_BODY_SIZE - buffer_pos,
                        buf_ptr,
                        buffer_pos,
                        &xrec_len );
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

      if ( status != CAIX_DONE_S )
      {
        return ( status ); /* Problem translating info rec */
      }

      buffer_pos  += xrec_len;  /* Advance external msg buf position */
      irec_pos += irec_len;  /* Advance internal msg buf position */
      /* The next record will start only on a dword boundary, so move positions accordingly */
      irec_pos = (irec_pos%4)?(irec_pos+(sizeof(dword))-irec_pos%4):irec_pos;

    } /* for */

    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
    if (int_ptr->dim.ami.maci_incl)
    {
      xlate_int_maci(&buffer_pos,
                     buf_ptr,
                     CAI_AC_CRC_SIZE,
                     int_ptr->dim.hdr.ack_req,
                     chn,
                     int_ptr->dim.ami.sdu_key_id,
                       int_ptr->dim.msg_type,
                     int_ptr->dim.ami.sdu_integrity_algo,
                     #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                     #endif /* FEATURE_IS2000_REL_C_MI */
                     &int_ptr->dim.ami.maci
                     );
      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
  } /* status == CAIX_DONE */

  *len_ptr = buffer_pos;

  return (status );

} /* xlate_int_ac_dim */

/*===========================================================================

FUNCTION XLATE_INT_AC_SMRM

DESCRIPTION
  This function translates Security Mode Request
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_smrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(caix_p_rev_in_use <= CAIX_P_REV_IS2000)
  {
    MSG_ERROR( "Msg not supported by P_REV", 0, 0, 0);
    return CAIX_INV_MSG_S;
  }

  /* ---------------------------------------------------
  ** Pack Message up through the MSID field
  ** --------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->smrm.msg_type,
      &int_ptr->smrm.hdr, &int_ptr->smrm.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->smrm.enc,
                     &int_ptr->smrm.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->smrm.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;


    /* ---------------------------------------
    ** L3 SDU Fields
    **---------------------------------------- */
    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packb (int_ptr->smrm.ui_enc_incl, buf_ptr, buffer_pos,
             FSIZ( cai_ac_smrm_type, ui_enc_incl));
    buffer_pos += FSIZ( cai_ac_smrm_type, ui_enc_incl);

    if(int_ptr->smrm.ui_enc_incl)
    {
      b_packb (int_ptr->smrm.ui_encrypt_sup, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, ui_encrypt_sup));
      buffer_pos += FSIZ( cai_ac_smrm_type, ui_encrypt_sup);

    }

    b_packb (int_ptr->smrm.sig_enc_incl, buf_ptr, buffer_pos,
             FSIZ( cai_ac_smrm_type, sig_enc_incl));
    buffer_pos += FSIZ( cai_ac_smrm_type, sig_enc_incl);

    if(int_ptr->smrm.sig_enc_incl)
    {
      b_packb (int_ptr->smrm.sig_encrypt_sup, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, sig_encrypt_sup));
      buffer_pos += FSIZ( cai_ac_smrm_type, sig_encrypt_sup);

      b_packb (int_ptr->smrm.c_sig_encrypt_req, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, c_sig_encrypt_req));
      buffer_pos += FSIZ( cai_ac_smrm_type, c_sig_encrypt_req);

    }

    b_packb (int_ptr->smrm.enc_seq_h_incl, buf_ptr, buffer_pos,
             FSIZ( cai_ac_smrm_type, enc_seq_h_incl));
    buffer_pos += FSIZ( cai_ac_smrm_type, enc_seq_h_incl);

    if (int_ptr->smrm.enc_seq_h_incl)
    {
      b_packd (int_ptr->smrm.enc_seq_h, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, enc_seq_h));
      buffer_pos += FSIZ( cai_ac_smrm_type, enc_seq_h);

      b_packb (int_ptr->smrm.enc_seq_h_sig, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, enc_seq_h_sig));
      buffer_pos += FSIZ( cai_ac_smrm_type, enc_seq_h_sig);

    }

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      b_packb( int_ptr->smrm.msg_int_info_incl, buf_ptr, buffer_pos,
           FSIZ( cai_ac_smrm_type, msg_int_info_incl));
      buffer_pos += FSIZ( cai_ac_smrm_type, msg_int_info_incl);
      if (int_ptr->smrm.msg_int_info_incl)
      {
        b_packb( int_ptr->smrm.sig_integrity_sup_incl, buf_ptr, buffer_pos,
             FSIZ( cai_ac_smrm_type, sig_integrity_sup_incl));
        buffer_pos += FSIZ( cai_ac_smrm_type, sig_integrity_sup_incl);

        if (int_ptr->smrm.sig_integrity_sup_incl)
        {
          b_packb( int_ptr->smrm.sig_integrity_sup, buf_ptr, buffer_pos,
               FSIZ( cai_ac_smrm_type, sig_integrity_sup));
          buffer_pos += FSIZ( cai_ac_smrm_type, sig_integrity_sup);
          b_packb( int_ptr->smrm.sig_integrity_req, buf_ptr, buffer_pos,
                 FSIZ( cai_ac_smrm_type, sig_integrity_req));
          buffer_pos += FSIZ( cai_ac_smrm_type, sig_integrity_req);
        }
      }

    }
#endif /* FEATURE_IS2000_REL_C */


    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
    if (int_ptr->smrm.ami.maci_incl)
    {
      xlate_int_maci(&buffer_pos,
                     buf_ptr,
                     CAI_AC_CRC_SIZE,
                     int_ptr->smrm.hdr.ack_req,
                     chn,
                     int_ptr->smrm.ami.sdu_key_id,
                       int_ptr->smrm.msg_type,
                     int_ptr->smrm.ami.sdu_integrity_algo,
                     #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                     #endif /* FEATURE_IS2000_REL_C_MI */
                     &int_ptr->smrm.ami.maci
                     );
      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
  } /* status = CAIX_DONE */

  *len_ptr = buffer_pos;

  return (status );

} /* xlate_int_ac_smrm */
#endif /* FEATURE_IS2000_REL_A */

/*===========================================================================

FUNCTION XLATE_INT_PLT_RPT

DESCRIPTION
  This function translates an Access Channel Pilot Report from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_plt_rpt
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  word buffer_offset,
    /* offset into buffer to start placing the message */
  caii_plt_rpt_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position to pack bits in message */
  byte i;
    /* Temporary loop counter */
#ifdef FEATURE_IS2000_REL_A
  word rec_len_pos;
  word rec_start_pos;
    /* temporary positions */
  byte reserve_bits;
    /* number of reserve bits */
#endif /* FEATURE_IS2000_REL_A */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  buffer_pos = buffer_offset;

  /* --------------------------------
  ** Pack the fix part of the message
  ** -------------------------------- */
  b_packb( int_ptr->fix.act_plt_str, buf_ptr, buffer_pos,
           FSIZ( cai_plt_rpt_fix_type, act_plt_str));
  buffer_pos += FSIZ( cai_plt_rpt_fix_type, act_plt_str );

  b_packb( int_ptr->fix.first_is_act, buf_ptr, buffer_pos,
           FSIZ( cai_plt_rpt_fix_type, first_is_act));
  buffer_pos += FSIZ( cai_plt_rpt_fix_type, first_is_act );

  b_packb( int_ptr->fix.first_is_pta, buf_ptr, buffer_pos,
           FSIZ( cai_plt_rpt_fix_type, first_is_pta));
  buffer_pos += FSIZ( cai_plt_rpt_fix_type, first_is_pta );

  b_packb( int_ptr->fix.num_add_plt, buf_ptr, buffer_pos,
           FSIZ( cai_plt_rpt_fix_type, num_add_plt));
  buffer_pos += FSIZ( cai_plt_rpt_fix_type, num_add_plt );

  /* -------------------------------------
  ** Pack the variable part of the message
  ** ------------------------------------- */
  for (i=0; i<int_ptr->fix.num_add_plt; i++)
  {
    b_packw( int_ptr->var[i].plt_pn_phase, buf_ptr, buffer_pos,
             FSIZ( cai_plt_rpt_var_type, plt_pn_phase));
    buffer_pos += FSIZ( cai_plt_rpt_var_type, plt_pn_phase );

    b_packb( int_ptr->var[i].plt_strength, buf_ptr, buffer_pos,
             FSIZ( cai_plt_rpt_var_type, plt_strength));
    buffer_pos += FSIZ( cai_plt_rpt_var_type, plt_strength );

    b_packb( int_ptr->var[i].acc_ho_en, buf_ptr, buffer_pos,
             FSIZ( cai_plt_rpt_var_type, acc_ho_en));
    buffer_pos += FSIZ( cai_plt_rpt_var_type, acc_ho_en );

    b_packb( int_ptr->var[i].acc_attempted, buf_ptr, buffer_pos,
             FSIZ( cai_plt_rpt_var_type, acc_attempted));
    buffer_pos += FSIZ( cai_plt_rpt_var_type, acc_attempted );
  }

#ifdef FEATURE_IS2000_REL_A
  if( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
  {
    b_packb( int_ptr->aux_fix.num_aux_plt, buf_ptr, buffer_pos,
             FSIZ( cai_aux_plt_rpt_fix_type, num_aux_plt));
    buffer_pos += FSIZ( cai_aux_plt_rpt_fix_type, num_aux_plt );

    for(i=0; i<int_ptr->aux_fix.num_aux_plt; i++)
    {
      b_packw( int_ptr->aux_var[i].plt_pn_phase, buf_ptr, buffer_pos,
               FSIZ( cai_aux_plt_rpt_var_type, plt_pn_phase));
      buffer_pos += FSIZ( cai_aux_plt_rpt_var_type, plt_pn_phase );

      b_packb( int_ptr->aux_var[i].plt_strength, buf_ptr, buffer_pos,
               FSIZ( cai_aux_plt_rpt_var_type, plt_strength));
      buffer_pos += FSIZ( cai_aux_plt_rpt_var_type, plt_strength );

      b_packb( int_ptr->aux_var[i].plt_rec_type, buf_ptr, buffer_pos,
               FSIZ( cai_aux_plt_rpt_var_type, plt_rec_type));
      buffer_pos += FSIZ( cai_aux_plt_rpt_var_type, plt_rec_type );

      rec_len_pos = buffer_pos;

      /* Skip record length and come back later */
      buffer_pos += FSIZ( cai_aux_plt_rpt_var_type, plt_rec_len );

          rec_start_pos = buffer_pos;

      switch (int_ptr->aux_var[i].plt_rec_type)
      {
        case CAI_AUX_PILOT_TYPE_0:
          b_packb( int_ptr->aux_var[i].rec0.qof, buf_ptr, buffer_pos,
                   FSIZ( cai_aux_plt_rec0_fix_type, qof));
          buffer_pos += FSIZ( cai_aux_plt_rec0_fix_type, qof );

          b_packb( int_ptr->aux_var[i].rec0.walsh_length, buf_ptr,
                   buffer_pos,
                   FSIZ( cai_aux_plt_rec0_fix_type, walsh_length));
          buffer_pos += FSIZ( cai_aux_plt_rec0_fix_type, walsh_length );

          b_packw( int_ptr->aux_var[i].rec0.pilot_walsh, buf_ptr,
                   buffer_pos,
                   int_ptr->aux_var[i].rec0.walsh_length+6);
          buffer_pos += int_ptr->aux_var[i].rec0.walsh_length+6;

          /* Calculate the length of reserved bits */
          reserve_bits = (sizeof(cai_aux_plt_rec0_fix_type) +
                              int_ptr->aux_var[i].rec0.walsh_length+6)
                             %8;

          if( reserve_bits != 0 )
          {
            reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
            b_packb( 0, buf_ptr, buffer_pos, reserve_bits );
            buffer_pos += reserve_bits;
          }


          /* Pack the record length fields */
          b_packb( (buffer_pos-rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
                   FSIZ( cai_aux_plt_rpt_var_type, plt_rec_len));


          break;
        default:
          MSG_ERROR("Unknown aux pilot type", 0, 0, 0);
          status = CAIX_INV_MSG_S;
          break;
      }
    }
  }
#endif /* FEATURE_IS2000_REL_A */

  *len_ptr = buffer_pos - buffer_offset;

  return (status );

} /* xlate_int_plt_rpt */

/*===========================================================================

FUNCTION XLATE_INT_AC_BURST

DESCRIPTION
  This function translates an Access Channel Data Burst Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_burst
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through characters */
  word buffer_pos;
    /* Position to pack bits in message */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (int_ptr->ac_burst.num_fields > CAI_AC_BURST_MAX)  /*lint !e685 */
  {
#ifndef FEATURE_MSG_PACK_UNIT_TEST
    mcc_burst_overflow_size = int_ptr->ac_burst.num_fields - CAI_AC_BURST_MAX;
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
    return (CAIX_INV_LEN_S);
  }

  /* ----------------------------------------------------------------
  ** Pack Access Channel Data Burst Message up through the MSID field
  ** ---------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_burst.msg_type,
      &int_ptr->ac_burst.hdr, &int_ptr->ac_burst.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->ac_burst.enc,
                     &int_ptr->ac_burst.ami
                    );
#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,&(int_ptr->ac_burst.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb( int_ptr->ac_burst.msg_number, buf_ptr, buffer_pos,
             FSIZ( cai_burst_ac_fix_type, msg_number ));
    buffer_pos += FSIZ( cai_burst_ac_fix_type, msg_number );

    b_packb( int_ptr->ac_burst.burst_type, buf_ptr, buffer_pos,
             FSIZ( cai_burst_ac_fix_type, burst_type ));
    buffer_pos += FSIZ( cai_burst_ac_fix_type, burst_type );

    b_packb( int_ptr->ac_burst.num_msgs, buf_ptr, buffer_pos,
             FSIZ( cai_burst_ac_fix_type, num_msgs ));
    buffer_pos += FSIZ( cai_burst_ac_fix_type, num_msgs );

    b_packb( int_ptr->ac_burst.num_fields, buf_ptr, buffer_pos,
             FSIZ( cai_burst_ac_fix_type, num_fields ));
    buffer_pos += FSIZ( cai_burst_ac_fix_type, num_fields );

    for (i=0; i < int_ptr->ac_burst.num_fields; i++)
    {
      b_packb( int_ptr->ac_burst.chari[i], buf_ptr, buffer_pos,
               sizeof( cai_burst_ac_var_type ));
      buffer_pos += sizeof( cai_burst_ac_var_type );
    }

    if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->ac_burst.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }
    }

#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
      #endif /* FEATURE_IS2000_REL_A_AES */   
#ifdef FEATURE_IS2000_REL_C
      /* ----------------------------
       ** Pack the MACI field
       ** ---------------------------- */
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        if (int_ptr->ac_burst.ami.maci_incl)
        {
          xlate_int_maci(&buffer_pos,
                         buf_ptr,
                         CAI_AC_CRC_SIZE,
                         int_ptr->ac_burst.hdr.ack_req,
                         chn,
                         int_ptr->ac_burst.ami.sdu_key_id,
                         int_ptr->ac_burst.msg_type,
                         int_ptr->ac_burst.ami.sdu_integrity_algo,
                         #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                         #endif /* FEATURE_IS2000_REL_C_MI */
                         &int_ptr->ac_burst.ami.maci
                        );
        } /* maci_incl */
      } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
    } /* prev >= 7 */
#endif /* FEATURE_IS2000_REL_A */

  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_ac_burst */

/*===========================================================================

FUNCTION XLATE_INT_ORIG

DESCRIPTION
  This function translates an Origination Message from internal to
  external format.

DEPENDENCIES
  p_rev_in_use must be set correctly in the internal format.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_orig
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason,
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */

   boolean is_voip_1x_handoff
  /* Indicates if this is a VOIP-1X handoff */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  byte i;
    /* Index to looped through dialed digits */
  word buffer_pos;
    /* Position in buffer to pack next field */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (int_ptr->orig.num_fields > CAI_AC_ORIG_MAX)
  {
    return (CAIX_INV_LEN_S);
  }

  /* --------------------------------------------------
  ** Pack Origination Message up through the MSID field
  ** -------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->orig.msg_type,
      &int_ptr->orig.hdr, &int_ptr->orig.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->orig.enc,
                     &int_ptr->orig.ami
                    );

#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */

    if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000)
        && !is_voip_1x_handoff
       )
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,&(int_ptr->orig.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    b_packb( int_ptr->orig.mob_term, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, mob_term ));
    buffer_pos += FSIZ( cai_orig_fix1_type, mob_term );

    b_packb( int_ptr->orig.slot_cycle_index, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, slot_cycle_index ));
    buffer_pos += FSIZ( cai_orig_fix1_type, slot_cycle_index );

    b_packb( int_ptr->orig.mob_p_rev, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, mob_p_rev ));
    buffer_pos += FSIZ( cai_orig_fix1_type, mob_p_rev );

    b_packb( int_ptr->orig.scm, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, scm ));
    buffer_pos += FSIZ( cai_orig_fix1_type, scm );

    b_packb( int_ptr->orig.request_mode, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, request_mode ));
    buffer_pos += FSIZ( cai_orig_fix1_type, request_mode );

    b_packb( int_ptr->orig.special_service, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, special_service ));
    buffer_pos += FSIZ( cai_orig_fix1_type, special_service );

    if (int_ptr->orig.special_service) {
      b_packw( int_ptr->orig.service_option, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix1_type, service_option ));
      buffer_pos += FSIZ( cai_orig_fix1_type, service_option );
    }

    b_packb( int_ptr->orig.pm, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, pm ));
    buffer_pos += FSIZ( cai_orig_fix1_type, pm );

    b_packb( int_ptr->orig.digit_mode, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, digit_mode ));
    buffer_pos += FSIZ( cai_orig_fix1_type, digit_mode );

    if (int_ptr->orig.digit_mode 
#ifdef FEATURE_IS2000_REL_C
        || (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
#endif /* FEATURE_IS2000_REL_C */
       ) 
    {
      b_packb( int_ptr->orig.number_type, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix1_type, number_type ));
      buffer_pos += FSIZ( cai_orig_fix1_type, number_type );

#ifdef FEATURE_IS2000_REL_C
      if (int_ptr->orig.digit_mode)
#endif /* FEATURE_IS2000_REL_C */
      {
        b_packb( int_ptr->orig.number_plan, buf_ptr, buffer_pos,
                 FSIZ( cai_orig_fix1_type, number_plan ));
        buffer_pos += FSIZ( cai_orig_fix1_type, number_plan );
      }
    }

    b_packb( int_ptr->orig.more_fields, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, more_fields ));
    buffer_pos += FSIZ( cai_orig_fix1_type, more_fields );

    b_packb( int_ptr->orig.num_fields, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix1_type, num_fields ));
    buffer_pos += FSIZ( cai_orig_fix1_type, num_fields );

    for (i=0; i < int_ptr->orig.num_fields; i++) {
      if (int_ptr->orig.digit_mode) {
        b_packb( int_ptr->orig.chari[i], buf_ptr, buffer_pos,
                 FSIZ( cai_orig_var_type, char8 ));
        buffer_pos += FSIZ( cai_orig_var_type, char8 );
      }
      else {
        b_packb( int_ptr->orig.chari[i], buf_ptr, buffer_pos,
                 FSIZ( cai_orig_var_type, char4 ));
        buffer_pos += FSIZ( cai_orig_var_type, char4 );
      }
    }

    b_packb( int_ptr->orig.nar_an_cap, buf_ptr, buffer_pos,
             FSIZ( cai_orig_fix2_type, nar_an_cap ));
    buffer_pos += FSIZ( cai_orig_fix2_type, nar_an_cap );

// Note: for special MDR, p_rev_in_use will be set to 4 to use the IS95B format.
    if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      b_packb( int_ptr->orig.paca_reorig, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, paca_reorig ));
      buffer_pos += FSIZ( cai_orig_fix2_type, paca_reorig );

      b_packb( int_ptr->orig.return_cause, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, return_cause ));
      buffer_pos += FSIZ( cai_orig_fix2_type, return_cause );

      b_packb( int_ptr->orig.more_records, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, more_records ));
      buffer_pos += FSIZ( cai_orig_fix2_type, more_records );

      if (
#ifdef FEATURE_IS2000_REL_A
           caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_A &&
#endif /* FEATURE_IS2000_REL_A */
           int_ptr->orig.ami.auth_mode != CAI_NO_AUTH)
      {
        /* -----------------------------------
        ** Pack authentication specific fields
        ** ----------------------------------- */
        b_packb( int_ptr->orig.encry_sup, buf_ptr, buffer_pos,
                 FSIZ( cai_orig_fix2_type, encry_sup ));
        buffer_pos += FSIZ( cai_orig_fix2_type, encry_sup );
      }

      b_packb( int_ptr->orig.paca_sup, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, paca_sup ));
      buffer_pos += FSIZ( cai_orig_fix2_type, paca_sup );

      b_packb( int_ptr->orig.num_alt_so, buf_ptr, buffer_pos,
               FSIZ( cai_orig_fix2_type, num_alt_so ));
      buffer_pos += FSIZ( cai_orig_fix2_type, num_alt_so );

      for( i=0; i<int_ptr->orig.num_alt_so && i<CAI_AC_ALT_SO_MAX; i++ )
      {
        b_packw( int_ptr->orig.alt_so[i], buf_ptr, buffer_pos,
                 FSIZ( cai_alt_so_type, alt_so ));
        buffer_pos += FSIZ( cai_alt_so_type, alt_so );
      }

#define FTYPE cai_orig_fix_is2000_type
#define VTYPE cai_orig_var_is2000_type
      if ((caix_p_rev_in_use < CAIX_P_REV_IS2000)
          && !is_voip_1x_handoff
         )
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->orig.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }
      else
      {
        b_packb( int_ptr->orig.drs, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,drs));
        buffer_pos += FSIZ(FTYPE,drs);

        b_packb( int_ptr->orig.uzid_incl, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,uzid_incl));
        buffer_pos += FSIZ(FTYPE,uzid_incl);

        if( int_ptr->orig.uzid_incl )
        {
          b_packw( int_ptr->orig.uzid, buf_ptr, buffer_pos,
                   FSIZ(VTYPE,uzid));
          buffer_pos += FSIZ(VTYPE,uzid);
        }

        b_packb( int_ptr->orig.ch_ind, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,ch_ind));
        buffer_pos += FSIZ(FTYPE,ch_ind);

        b_packb( int_ptr->orig.sr_id, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,sr_id));
        buffer_pos += FSIZ(FTYPE,sr_id);
        b_packb( int_ptr->orig.otd_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,otd_supported));
        buffer_pos += FSIZ(FTYPE,otd_supported);

        b_packb( int_ptr->orig.qpch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,qpch_supported));
        buffer_pos += FSIZ(FTYPE,qpch_supported);

        b_packb( int_ptr->orig.enhanced_rc, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,enhanced_rc));
        buffer_pos += FSIZ(FTYPE,enhanced_rc);

        b_packb( int_ptr->orig.for_rc_pref, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,for_rc_pref));
        buffer_pos += FSIZ(FTYPE,for_rc_pref);

        b_packb( int_ptr->orig.rev_rc_pref, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_rc_pref));
        buffer_pos += FSIZ(FTYPE,rev_rc_pref);

        b_packb( int_ptr->orig.fch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,fch_supported));
        buffer_pos += FSIZ(FTYPE,fch_supported);

        if ( int_ptr->orig.fch_supported )
        {
          b_packb( int_ptr->orig.fch_fields.fch_frame_size,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,fch_frame_size));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,fch_frame_size);

          b_packb( int_ptr->orig.fch_fields.for_fch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,for_fch_len));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,for_fch_len);

          if (int_ptr->orig.fch_fields.for_fch_len)
          {
            b_packw ( int_ptr->orig.fch_fields.for_fch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->orig.fch_fields.for_fch_len*
                       FSIZ(cai_fch_spec_fields_type,for_fch_rc_map)));
            buffer_pos += (int_ptr->orig.fch_fields.for_fch_len*
                           FSIZ(cai_fch_spec_fields_type,for_fch_rc_map));
          }

          b_packb( int_ptr->orig.fch_fields.rev_fch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,rev_fch_len));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,rev_fch_len);

          if (int_ptr->orig.fch_fields.rev_fch_len)
          {
            b_packb ( int_ptr->orig.fch_fields.rev_fch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->orig.fch_fields.rev_fch_len*
                       FSIZ(cai_fch_spec_fields_type,rev_fch_rc_map)));
            buffer_pos += (int_ptr->orig.fch_fields.rev_fch_len*
                           FSIZ(cai_fch_spec_fields_type,rev_fch_rc_map));
          }
        }

        b_packb( int_ptr->orig.dcch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,dcch_supported));
        buffer_pos += FSIZ(FTYPE,dcch_supported);

        if ( int_ptr->orig.dcch_supported )
        {
          b_packb( int_ptr->orig.dcch_fields.dcch_frame_size,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,dcch_frame_size));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,dcch_frame_size);

          b_packb( int_ptr->orig.dcch_fields.for_dcch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,for_dcch_len));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,for_dcch_len);

          if (int_ptr->orig.dcch_fields.for_dcch_len)
          {
            b_packw ( int_ptr->orig.dcch_fields.for_dcch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->orig.dcch_fields.for_dcch_len*
                       FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map)));
            buffer_pos += (int_ptr->orig.dcch_fields.for_dcch_len*
                           FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map));
          }

          b_packb( int_ptr->orig.dcch_fields.rev_dcch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,rev_dcch_len));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,rev_dcch_len);

          if (int_ptr->orig.dcch_fields.rev_dcch_len)
          {
            b_packb ( int_ptr->orig.dcch_fields.rev_dcch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->orig.dcch_fields.rev_dcch_len*
                       FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map)));
            buffer_pos += (int_ptr->orig.dcch_fields.rev_dcch_len*
                           FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map));
          }
        }

#ifndef FEATURE_IS2000_REL_A
        b_packb(0, buf_ptr, buffer_pos, FSIZ(FTYPE,reserved));
        buffer_pos += FSIZ(FTYPE,reserved);
        b_packb( int_ptr->orig.rev_fch_gating_req, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_fch_gating_req));
        buffer_pos += FSIZ(FTYPE,rev_fch_gating_req);
#endif /* !FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A
        if (int_ptr->orig.geo_loc_incl &&
            (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A))
        {
          b_packb( 1, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,geo_loc_incl));
          buffer_pos += FSIZ(FTYPE,geo_loc_incl);

          b_packb( int_ptr->orig.geo_loc_type, buf_ptr, buffer_pos,
           FSIZ(FTYPE,geo_loc_type));
          buffer_pos += FSIZ(FTYPE, geo_loc_type);

        }
        else
        {
          b_packb( 0, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,geo_loc_incl));
          buffer_pos += FSIZ(FTYPE,geo_loc_incl);
        }

        b_packb( int_ptr->orig.rev_fch_gating_req, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_fch_gating_req));
        buffer_pos += FSIZ(FTYPE,rev_fch_gating_req);

        /* Now starts the fields defined for P_REV 7 only */
        if ( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
        {
          b_packb( int_ptr->orig.orig_reason, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,orig_reason));
          buffer_pos += FSIZ(FTYPE,orig_reason);

          b_packb( int_ptr->orig.orig_count, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,orig_count));
          buffer_pos += FSIZ(FTYPE,orig_count);

          b_packb( int_ptr->orig.sts_supported, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,sts_supported));
          buffer_pos += FSIZ(FTYPE,sts_supported);

          b_packb( int_ptr->orig.thx_cch_supported, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,thx_cch_supported));
          buffer_pos += FSIZ(FTYPE,thx_cch_supported);

          b_packb( int_ptr->orig.wll_incl, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,wll_incl));
          buffer_pos += FSIZ(FTYPE,wll_incl);

          if (int_ptr->orig.wll_incl)
          {
            b_packb( int_ptr->orig.wll_device_type, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,wll_device_type));
            buffer_pos += FSIZ(FTYPE,wll_device_type);

          }

          b_packb( int_ptr->orig.global_emergency_call, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,global_emergency_call));
          buffer_pos += FSIZ(FTYPE,global_emergency_call);

          if (int_ptr->orig.global_emergency_call)
          {
            b_packb( int_ptr->orig.ms_init_pos_loc_ind, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,ms_init_pos_loc_ind));
            buffer_pos += FSIZ(FTYPE,ms_init_pos_loc_ind);
          }

          b_packb( int_ptr->orig.qos_parms_incl, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,qos_parms_incl));
          buffer_pos += FSIZ(FTYPE,qos_parms_incl);

          if (int_ptr->orig.qos_parms_incl)
          {
            b_packb( int_ptr->orig.qos_parms_len, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,qos_parms_len));
            buffer_pos += FSIZ(FTYPE,qos_parms_len);

            for (i=0; i<int_ptr->orig.qos_parms_len; i++)
            {
              b_packb( int_ptr->orig.qos_parms[i], buf_ptr, buffer_pos,
                       FSIZ(FTYPE,qos_parms));
              buffer_pos += FSIZ(FTYPE,qos_parms);
            }

            // The standard specifies a reserved field here. We don't need
            // to pack it because of the following:
            // The qos_parms_len above is in units of 'bytes' and so
            // qos_parms field is guaranteed to be of length an integer number
            // of octets.
          }

          b_packb( int_ptr->orig.enc_info_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, enc_info_incl ));
          buffer_pos += FSIZ( FTYPE, enc_info_incl );

          if (int_ptr->orig.enc_info_incl)
          {
            b_packb( int_ptr->orig.sig_encrypt_sup, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, sig_encrypt_sup ));
            buffer_pos += FSIZ( FTYPE, sig_encrypt_sup );

            b_packb( int_ptr->orig.d_sig_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, d_sig_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, d_sig_encrypt_req );

            b_packb( int_ptr->orig.c_sig_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, c_sig_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, c_sig_encrypt_req );

            if (((int_ptr->orig.sig_encrypt_sup & CAI_ENC_SUP_ECMEA) != 0)||
                ((int_ptr->orig.sig_encrypt_sup & CAI_ENC_SUP_REA) != 0)
               )
            {
              b_packd( int_ptr->orig.enc_seq_h, buf_ptr, buffer_pos,
                       FSIZ( FTYPE, enc_seq_h ));
              buffer_pos += FSIZ( FTYPE, enc_seq_h );

              b_packb( int_ptr->orig.enc_seq_h_sig, buf_ptr, buffer_pos,
                       FSIZ( FTYPE, enc_seq_h_sig ));
              buffer_pos += FSIZ( FTYPE, enc_seq_h_sig );
            }

            b_packb( int_ptr->orig.ui_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, ui_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, ui_encrypt_req );

            b_packb( int_ptr->orig.ui_encrypt_sup, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, ui_encrypt_sup ));
            buffer_pos += FSIZ( FTYPE, ui_encrypt_sup );
          }

          b_packb( int_ptr->orig.sync_id_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, sync_id_incl ));
          buffer_pos += FSIZ( FTYPE, sync_id_incl );

          if (int_ptr->orig.sync_id_incl)
          {
            b_packb( int_ptr->orig.sync_id_len, buf_ptr, buffer_pos,
                    FSIZ( FTYPE, sync_id_len ));
             buffer_pos += FSIZ( FTYPE, sync_id_len );

            for (i=0; i<int_ptr->orig.sync_id_len; i++)
            {
              b_packb( int_ptr->orig.sync_id[i],
                       buf_ptr, buffer_pos,
                       FSIZ( FTYPE, sync_id ));

              buffer_pos += FSIZ( FTYPE, sync_id );
            }
          }

          b_packb( int_ptr->orig.prev_sid_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, prev_sid_incl ));
          buffer_pos += FSIZ( FTYPE, prev_sid_incl );

          if (int_ptr->orig.prev_sid_incl)
          {
            b_packw( int_ptr->orig.prev_sid, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, prev_sid ));
            buffer_pos += FSIZ( FTYPE, prev_sid );

          }

          b_packb( int_ptr->orig.prev_nid_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, prev_nid_incl ));
          buffer_pos += FSIZ( FTYPE, prev_nid_incl );

          if (int_ptr->orig.prev_nid_incl)
          {
            b_packw( int_ptr->orig.prev_nid, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, prev_nid ));
            buffer_pos += FSIZ( FTYPE, prev_nid );

          }

          b_packb( int_ptr->orig.prev_pzid_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, prev_pzid_incl ));
          buffer_pos += FSIZ( FTYPE, prev_pzid_incl );

          if (int_ptr->orig.prev_pzid_incl)
          {
            b_packb( int_ptr->orig.prev_pzid, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, prev_pzid ));
            buffer_pos += FSIZ( FTYPE, prev_pzid );

          }

          b_packb( int_ptr->orig.so_bitmap_ind, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, so_bitmap_ind ));
          buffer_pos += FSIZ( FTYPE, so_bitmap_ind );

          if (int_ptr->orig.so_bitmap_ind != SO_BITMAP_SIZE_0)
          {
            b_packb( int_ptr->orig.so_group_num, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, so_group_num ));
            buffer_pos += FSIZ( FTYPE, so_group_num );

            b_packw( int_ptr->orig.so_bitmap, buf_ptr, buffer_pos,
                     (1 << (int_ptr->orig.so_bitmap_ind + 1)));
            buffer_pos += (1 << (int_ptr->orig.so_bitmap_ind + 1));

          }

#ifdef FEATURE_IS2000_REL_B
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
          {
            b_packb( int_ptr->orig.sdb_desired_only, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, sdb_desired_only ));
            buffer_pos += FSIZ( FTYPE, sdb_desired_only);

            b_packb( int_ptr->orig.alt_band_class_sup , buf_ptr, buffer_pos,
                     FSIZ( FTYPE, alt_band_class_sup  ));
            buffer_pos += FSIZ( FTYPE, alt_band_class_sup);

#ifdef FEATURE_IS2000_REL_C
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              b_packb( int_ptr->orig.msg_int_info_incl, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, msg_int_info_incl ));
              buffer_pos += FSIZ( FTYPE, msg_int_info_incl);

              if (int_ptr->orig.msg_int_info_incl)
              {
                b_packb( int_ptr->orig.sig_integrity_sup_incl, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, sig_integrity_sup_incl ));
                buffer_pos += FSIZ( FTYPE, sig_integrity_sup_incl);

                if (int_ptr->orig.sig_integrity_sup_incl)
                {
                  b_packb( int_ptr->orig.sig_integrity_sup, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, sig_integrity_sup ));
                  buffer_pos += FSIZ( FTYPE, sig_integrity_sup);

                  b_packb( int_ptr->orig.sig_integrity_req, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, sig_integrity_req ));
                  buffer_pos += FSIZ( FTYPE, sig_integrity_req);
                }
                b_packb( int_ptr->orig.new_key_id, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, new_key_id ));
                buffer_pos += FSIZ( FTYPE, new_key_id);

                b_packb( int_ptr->orig.new_sseq_h_incl, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, new_sseq_h_incl ));
                buffer_pos += FSIZ( FTYPE, new_sseq_h_incl);

                if (int_ptr->orig.new_sseq_h_incl)
                {
                  b_packd( int_ptr->orig.new_sseq_h, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, new_sseq_h ));
                  buffer_pos += FSIZ( FTYPE, new_sseq_h);

                  b_packb( int_ptr->orig.new_sseq_h_sig, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, new_sseq_h_sig ));
                  buffer_pos += FSIZ( FTYPE, new_sseq_h_sig);
                }
              }

              b_packb( int_ptr->orig.for_pdch_supported, buf_ptr, buffer_pos,
                         FSIZ( FTYPE,for_pdch_supported ));
              buffer_pos += FSIZ( FTYPE, for_pdch_supported);

              if (int_ptr->orig.for_pdch_supported)
              {
                b_packb( int_ptr->orig.for_pdch_fields.ack_delay, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ack_delay ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, ack_delay);

                b_packb( int_ptr->orig.for_pdch_fields.num_arq_chan, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, num_arq_chan ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, num_arq_chan);

                b_packb( int_ptr->orig.for_pdch_fields.for_pdch_len, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, for_pdch_len ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, for_pdch_len);

                b_packw( int_ptr->orig.for_pdch_fields.for_pdch_rc_map, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, for_pdch_rc_map )*
                         (int_ptr->orig.for_pdch_fields.for_pdch_len+1));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type,
                              for_pdch_rc_map) * (int_ptr->orig.for_pdch_fields.for_pdch_len+1);

                b_packb( int_ptr->orig.for_pdch_fields.ch_config_sup_map_len, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map_len ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map_len);

                b_packw( int_ptr->orig.for_pdch_fields.ch_config_sup_map, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map )*
                         (int_ptr->orig.for_pdch_fields.ch_config_sup_map_len+1));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type,
                              ch_config_sup_map) * (int_ptr->orig.for_pdch_fields.ch_config_sup_map_len+1);
              }

              if (int_ptr->orig.ch_ind == 0)
              {
                b_packb( int_ptr->orig.ext_ch_ind, buf_ptr, buffer_pos,
                         FSIZ( FTYPE,ext_ch_ind ));
                buffer_pos += FSIZ( FTYPE, ext_ch_ind);
              }
            }
#endif /* FEATURE_IS2000_REL_C */
          }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
          #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
          {
             /* ----------------------------
              ** Pack the MACI field
              ** ---------------------------- */
             if (int_ptr->orig.ami.maci_incl)
             {
                xlate_int_maci(&buffer_pos,
                               buf_ptr,
                               CAI_AC_CRC_SIZE,
                               int_ptr->orig.hdr.ack_req,
                               chn,
                               int_ptr->orig.ami.sdu_key_id,
                               int_ptr->orig.msg_type,
                               int_ptr->orig.ami.sdu_integrity_algo,
                               #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                               #endif /* FEATURE_IS2000_REL_C_MI */
                               &int_ptr->orig.ami.maci
                              );
             } /* maci_incl */
          } /* p_rev >= P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
        } /* If p_rev_in_use > = 7 */
#endif /* FEATURE_IS2000_REL_A */

      } /* p_rev_in_use > = 6 */

#undef VTYPE
#undef FTYPE

    } /* p_rev_in_use > = 5 */

    /* ------------------------------
    ** Calculate total message length
    ** ------------------------------ */
    *len_ptr = buffer_pos;

    if (*len_ptr > CAI_AC_BODY_SIZE)
    {
      status = CAIX_INV_LEN_S;
    }
  }

  return (status);

} /* xlate_int_orig */

/*===========================================================================

FUNCTION XLATE_INT_PAGE_RESP

DESCRIPTION
  This function translates a Page Response Message from internal to
  external format.

DEPENDENCIES
  p_rev_in_use in the internal format is required.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_page_resp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position in buffer to pack bits */
  int i;
    /* Loop variable */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ----------------------------------------------------
  ** Pack Page Response Message up through the MSID field
  ** ---------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->page_resp.msg_type,
      &int_ptr->page_resp.hdr, &int_ptr->page_resp.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->page_resp.enc,
                     &int_ptr->page_resp.ami
                    );

#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);

    }

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,&(int_ptr->page_resp.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb( int_ptr->page_resp.mob_term, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, mob_term ));
    buffer_pos += FSIZ( cai_page_resp_type, mob_term );

    b_packb( int_ptr->page_resp.slot_cycle_index, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, slot_cycle_index ));
    buffer_pos += FSIZ( cai_page_resp_type, slot_cycle_index );

    b_packb( int_ptr->page_resp.mob_p_rev, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, mob_p_rev ));
    buffer_pos += FSIZ( cai_page_resp_type, mob_p_rev );

    b_packb( int_ptr->page_resp.scm, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, scm ));
    buffer_pos += FSIZ( cai_page_resp_type, scm );

    b_packb( int_ptr->page_resp.request_mode, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, request_mode ));
    buffer_pos += FSIZ( cai_page_resp_type, request_mode );

    b_packw( int_ptr->page_resp.service_option, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, service_option ));
    buffer_pos += FSIZ( cai_page_resp_type, service_option );

    b_packb( int_ptr->page_resp.pm, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, pm ));
    buffer_pos += FSIZ( cai_page_resp_type, pm );

    b_packb( int_ptr->page_resp.nar_an_cap, buf_ptr, buffer_pos,
             FSIZ( cai_page_resp_type, nar_an_cap ));
    buffer_pos += FSIZ( cai_page_resp_type, nar_an_cap );

// Note: for special MDR, p_rev_in_use will be set to 4 to use the IS95B format.
    /* ------------------------------------------------
    ** The following is for IS-95B only
    ** ------------------------------------------------ */
    if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      if (
#ifdef FEATURE_IS2000_REL_A
          caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_A &&
#endif /* FEATURE_IS2000_REL_A */
          int_ptr->page_resp.ami.auth_mode != CAI_NO_AUTH)
      {
        /* -----------------------------------
        ** Pack authentication specific fields
        ** ----------------------------------- */
        b_packb( int_ptr->page_resp.encry_sup, buf_ptr, buffer_pos,
                 FSIZ( cai_page_resp_type, encry_sup ));
        buffer_pos += FSIZ( cai_page_resp_type, encry_sup );
      }

      b_packb( int_ptr->page_resp.num_alt_so, buf_ptr, buffer_pos,
               FSIZ( cai_page_resp_type, num_alt_so ));
      buffer_pos += FSIZ( cai_page_resp_type, num_alt_so );

      for( i=0; i<int_ptr->page_resp.num_alt_so && i<CAI_AC_ALT_SO_MAX ; i++ )
      {
        b_packw( int_ptr->page_resp.alt_so[i], buf_ptr, buffer_pos,
                 FSIZ( cai_alt_so_type, alt_so ));
        buffer_pos += FSIZ( cai_alt_so_type, alt_so );
      }
#define FTYPE cai_page_resp_fix_is2000_type
#define VTYPE cai_page_resp_var_is2000_type
      if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->page_resp.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }
      else
      {
        b_packb( int_ptr->page_resp.uzid_incl, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,uzid_incl));
        buffer_pos += FSIZ(FTYPE,uzid_incl);

        if( int_ptr->page_resp.uzid_incl )
        {
          b_packw( int_ptr->page_resp.uzid, buf_ptr, buffer_pos,
                   FSIZ(VTYPE,uzid));
          buffer_pos += FSIZ(VTYPE,uzid);
        }

        b_packb( int_ptr->page_resp.ch_ind, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,ch_ind));
        buffer_pos += FSIZ(FTYPE,ch_ind);

        b_packb( int_ptr->page_resp.otd_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,otd_supported));
        buffer_pos += FSIZ(FTYPE,otd_supported);

        b_packb( int_ptr->page_resp.qpch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,qpch_supported));
        buffer_pos += FSIZ(FTYPE,qpch_supported);

        b_packb( int_ptr->page_resp.enhanced_rc, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,enhanced_rc));
        buffer_pos += FSIZ(FTYPE,enhanced_rc);

        b_packb( int_ptr->page_resp.for_rc_pref, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,for_rc_pref));
        buffer_pos += FSIZ(FTYPE,for_rc_pref);

        b_packb( int_ptr->page_resp.rev_rc_pref, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_rc_pref));
        buffer_pos += FSIZ(FTYPE,rev_rc_pref);

        b_packb( int_ptr->page_resp.fch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,fch_supported));
        buffer_pos += FSIZ(FTYPE,fch_supported);

        if ( int_ptr->page_resp.fch_supported )
        {
          b_packb( int_ptr->page_resp.fch_fields.fch_frame_size,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,fch_frame_size));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,fch_frame_size);

          b_packb( int_ptr->page_resp.fch_fields.for_fch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,for_fch_len));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,for_fch_len);

          if (int_ptr->page_resp.fch_fields.for_fch_len)
          {
            b_packw ( int_ptr->page_resp.fch_fields.for_fch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->page_resp.fch_fields.for_fch_len*
                       FSIZ(cai_fch_spec_fields_type,for_fch_rc_map)));
            buffer_pos += (int_ptr->page_resp.fch_fields.for_fch_len*
                           FSIZ(cai_fch_spec_fields_type,for_fch_rc_map));
          }

          b_packb( int_ptr->page_resp.fch_fields.rev_fch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_fch_spec_fields_type,rev_fch_len));
          buffer_pos += FSIZ(cai_fch_spec_fields_type,rev_fch_len);

          if (int_ptr->page_resp.fch_fields.rev_fch_len)
          {
            b_packb ( int_ptr->page_resp.fch_fields.rev_fch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->page_resp.fch_fields.rev_fch_len*
                       FSIZ(cai_fch_spec_fields_type,rev_fch_rc_map)));
            buffer_pos += (int_ptr->page_resp.fch_fields.rev_fch_len*
                           FSIZ(cai_fch_spec_fields_type,rev_fch_rc_map));
          }
        }

        b_packb( int_ptr->page_resp.dcch_supported, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,dcch_supported));
        buffer_pos += FSIZ(FTYPE,dcch_supported);

        if ( int_ptr->page_resp.dcch_supported )
        {
          b_packb( int_ptr->page_resp.dcch_fields.dcch_frame_size,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,dcch_frame_size));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,dcch_frame_size);

          b_packb( int_ptr->page_resp.dcch_fields.for_dcch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,for_dcch_len));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,for_dcch_len);

          if (int_ptr->page_resp.dcch_fields.for_dcch_len)
          {
            b_packw ( int_ptr->page_resp.dcch_fields.for_dcch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->page_resp.dcch_fields.for_dcch_len*
                       FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map)));
            buffer_pos += (int_ptr->page_resp.dcch_fields.for_dcch_len*
                           FSIZ(cai_dcch_spec_fields_type,for_dcch_rc_map));
          }

          b_packb( int_ptr->page_resp.dcch_fields.rev_dcch_len,
                   buf_ptr, buffer_pos,
                   FSIZ(cai_dcch_spec_fields_type,rev_dcch_len));
          buffer_pos += FSIZ(cai_dcch_spec_fields_type,rev_dcch_len);

          if (int_ptr->page_resp.dcch_fields.rev_dcch_len)
          {
            b_packb ( int_ptr->page_resp.dcch_fields.rev_dcch_rc_map,
                      buf_ptr, buffer_pos,
                      (int_ptr->page_resp.dcch_fields.rev_dcch_len*
                       FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map)));
            buffer_pos += (int_ptr->page_resp.dcch_fields.rev_dcch_len*
                           FSIZ(cai_dcch_spec_fields_type,rev_dcch_rc_map));
          }
        }

        b_packb( int_ptr->page_resp.rev_fch_gating_req, buf_ptr, buffer_pos,
                 FSIZ(FTYPE,rev_fch_gating_req));
        buffer_pos += FSIZ(FTYPE,rev_fch_gating_req);

#ifdef FEATURE_IS2000_REL_A
        /* Now starts the fields defined for P_REV 7 only */
        if ( caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A )
        {
          b_packb( int_ptr->page_resp.sts_supported, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,sts_supported));
          buffer_pos += FSIZ(FTYPE,sts_supported);

          b_packb( int_ptr->page_resp.thx_cch_supported, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,thx_cch_supported));
          buffer_pos += FSIZ(FTYPE,thx_cch_supported);

          b_packb( int_ptr->page_resp.wll_incl, buf_ptr, buffer_pos,
                   FSIZ(FTYPE,wll_incl));
          buffer_pos += FSIZ(FTYPE,wll_incl);

          if (int_ptr->page_resp.wll_incl)
          {
            b_packb( int_ptr->page_resp.wll_device_type, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,wll_device_type));
            buffer_pos += FSIZ(FTYPE,wll_device_type);

            b_packb( int_ptr->page_resp.hook_status, buf_ptr, buffer_pos,
                     FSIZ(FTYPE,hook_status));
            buffer_pos += FSIZ(FTYPE,hook_status);
          }

          b_packb( int_ptr->page_resp.enc_info_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, enc_info_incl ));
          buffer_pos += FSIZ( FTYPE, enc_info_incl );

          if (int_ptr->page_resp.enc_info_incl)
          {
            b_packb( int_ptr->page_resp.sig_encrypt_sup, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, sig_encrypt_sup ));
            buffer_pos += FSIZ( FTYPE, sig_encrypt_sup );

            b_packb( int_ptr->page_resp.d_sig_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, d_sig_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, d_sig_encrypt_req );

            b_packb( int_ptr->page_resp.c_sig_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, c_sig_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, c_sig_encrypt_req );

            if(((int_ptr->page_resp.sig_encrypt_sup & CAI_ENC_SUP_ECMEA) != 0)||
                ((int_ptr->page_resp.sig_encrypt_sup & CAI_ENC_SUP_REA) != 0)
              )
            {
              b_packd( int_ptr->page_resp.enc_seq_h, buf_ptr, buffer_pos,
                       FSIZ( FTYPE, enc_seq_h ));
              buffer_pos += FSIZ( FTYPE, enc_seq_h );

              b_packb( int_ptr->page_resp.enc_seq_h_sig, buf_ptr, buffer_pos,
                       FSIZ( FTYPE, enc_seq_h_sig ));
              buffer_pos += FSIZ( FTYPE, enc_seq_h_sig );
            }

            b_packb( int_ptr->page_resp.ui_encrypt_req, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, ui_encrypt_req ));
            buffer_pos += FSIZ( FTYPE, ui_encrypt_req );

            b_packb( int_ptr->page_resp.ui_encrypt_sup, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, ui_encrypt_sup ));
            buffer_pos += FSIZ( FTYPE, ui_encrypt_sup );
          }

          b_packb( int_ptr->page_resp.sync_id_incl, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, sync_id_incl ));
          buffer_pos += FSIZ( FTYPE, sync_id_incl );

          if (int_ptr->page_resp.sync_id_incl)
          {
            b_packb( int_ptr->page_resp.sync_id_len, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, sync_id_len ));
            buffer_pos += FSIZ( FTYPE, sync_id_len );

            for (i=0; i<int_ptr->page_resp.sync_id_len; i++)
            {
              b_packb( int_ptr->page_resp.sync_id[i], buf_ptr, buffer_pos,
                       FSIZ( FTYPE, sync_id ));
              buffer_pos += FSIZ( FTYPE, sync_id );
            }
          }

          b_packb( int_ptr->page_resp.so_bitmap_ind, buf_ptr, buffer_pos,
                   FSIZ( FTYPE, so_bitmap_ind ));
          buffer_pos += FSIZ( FTYPE, so_bitmap_ind );

          if (int_ptr->page_resp.so_bitmap_ind != SO_BITMAP_SIZE_0)
          {
            b_packb( int_ptr->page_resp.so_group_num, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, so_group_num ));
            buffer_pos += FSIZ( FTYPE, so_group_num );

            b_packw( int_ptr->page_resp.so_bitmap, buf_ptr, buffer_pos,
                     (1 << (int_ptr->page_resp.so_bitmap_ind + 1)));
            buffer_pos += (1 << (int_ptr->page_resp.so_bitmap_ind + 1));

          }
#ifdef FEATURE_IS2000_REL_B
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
          {
            b_packb( int_ptr->page_resp.alt_band_class_sup , buf_ptr, buffer_pos,
                     FSIZ( FTYPE, alt_band_class_sup  ));
            buffer_pos += FSIZ( FTYPE, alt_band_class_sup);

#ifdef FEATURE_IS2000_REL_C
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              b_packb( int_ptr->page_resp.msg_int_info_incl, buf_ptr, buffer_pos,
                     FSIZ( FTYPE, msg_int_info_incl ));
              buffer_pos += FSIZ( FTYPE, msg_int_info_incl);

              if (int_ptr->page_resp.msg_int_info_incl)
              {
                b_packb( int_ptr->page_resp.sig_integrity_sup_incl, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, sig_integrity_sup_incl ));
                buffer_pos += FSIZ( FTYPE, sig_integrity_sup_incl);

                if (int_ptr->page_resp.sig_integrity_sup_incl)
                {
                  b_packb( int_ptr->page_resp.sig_integrity_sup, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, sig_integrity_sup ));
                  buffer_pos += FSIZ( FTYPE, sig_integrity_sup);

                  b_packb( int_ptr->page_resp.sig_integrity_req, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, sig_integrity_req ));
                  buffer_pos += FSIZ( FTYPE, sig_integrity_req);
                }
                b_packb( int_ptr->page_resp.new_key_id, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, new_key_id ));
                buffer_pos += FSIZ( FTYPE, new_key_id);

                b_packb( int_ptr->page_resp.new_sseq_h_incl, buf_ptr, buffer_pos,
                         FSIZ( FTYPE, new_sseq_h_incl ));
                buffer_pos += FSIZ( FTYPE, new_sseq_h_incl);

                if (int_ptr->page_resp.new_sseq_h_incl)
                {
                  b_packd( int_ptr->page_resp.new_sseq_h, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, new_sseq_h ));
                  buffer_pos += FSIZ( FTYPE, new_sseq_h);

                  b_packb( int_ptr->page_resp.new_sseq_h_sig, buf_ptr, buffer_pos,
                           FSIZ( FTYPE, new_sseq_h_sig ));
                  buffer_pos += FSIZ( FTYPE, new_sseq_h_sig);
                }
              }

              b_packb( int_ptr->page_resp.for_pdch_supported, buf_ptr, buffer_pos,
                         FSIZ( FTYPE,for_pdch_supported ));
              buffer_pos += FSIZ( FTYPE, for_pdch_supported);

              if (int_ptr->page_resp.for_pdch_supported)
              {
                b_packb( int_ptr->page_resp.for_pdch_fields.ack_delay, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ack_delay ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, ack_delay);

                b_packb( int_ptr->page_resp.for_pdch_fields.num_arq_chan, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, num_arq_chan ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, num_arq_chan);

                b_packb( int_ptr->page_resp.for_pdch_fields.for_pdch_len, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, for_pdch_len ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, for_pdch_len);

                b_packw( int_ptr->page_resp.for_pdch_fields.for_pdch_rc_map, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, for_pdch_rc_map )*
                         (int_ptr->page_resp.for_pdch_fields.for_pdch_len+1));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type,
                              for_pdch_rc_map) * (int_ptr->page_resp.for_pdch_fields.for_pdch_len+1);

                b_packb( int_ptr->page_resp.for_pdch_fields.ch_config_sup_map_len, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map_len ));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map_len);

                b_packw( int_ptr->page_resp.for_pdch_fields.ch_config_sup_map, buf_ptr, buffer_pos,
                         FSIZ( cai_for_pdch_spec_fields_type, ch_config_sup_map )*
                         (int_ptr->page_resp.for_pdch_fields.ch_config_sup_map_len+1));
                buffer_pos += FSIZ( cai_for_pdch_spec_fields_type,
                              ch_config_sup_map) * (int_ptr->page_resp.for_pdch_fields.ch_config_sup_map_len+1);
              }

              if (int_ptr->page_resp.ch_ind == 0)
              {
                b_packb( int_ptr->page_resp.ext_ch_ind, buf_ptr, buffer_pos,
                         FSIZ( FTYPE,ext_ch_ind ));
                buffer_pos += FSIZ( FTYPE, ext_ch_ind);
              }
            }
#endif /* FEATURE_IS2000_REL_C */

          }
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

          #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
          #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
          {
            if (int_ptr->page_resp.ami.maci_incl)
            {
              xlate_int_maci(&buffer_pos,
                             buf_ptr,
                             CAI_AC_CRC_SIZE,
                             int_ptr->page_resp.hdr.ack_req,
                             chn,
                             int_ptr->page_resp.ami.sdu_key_id,
                             int_ptr->page_resp.msg_type,
                             int_ptr->page_resp.ami.sdu_integrity_algo,
                             #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                             #endif /* FEATURE_IS2000_REL_C_MI */
                             &int_ptr->page_resp.ami.maci
                            );
            } /* maci_incl */
          } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
        } /* p_rev_in_use >= 7 */
#endif /* FEATURE_IS2000_REL_A */

      } /* p_rev_in_use > = 6 */

#undef VTYPE
#undef FTYPE

    } /* p_rev_in_use >=5 */
  } /* if status is DONE */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_page_resp */

/*===========================================================================

FUNCTION XLATE_INT_AUTH_CH

DESCRIPTION
  This function translates an Authentication Challenge Response Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_auth_ch
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position in buffer to pack bits */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------------------------------
  ** Pack Authentication Challenge Response Msg up through the MSID field
  ** -------------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->auth_ch.msg_type,
      &int_ptr->auth_ch.hdr, &int_ptr->auth_ch.ami);

#ifdef FEATURE_IS2000_REL_A
    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->auth_ch.enc,
                     &int_ptr->auth_ch.ami
                    );

#endif /* FEATURE_IS2000_REL_A */

    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = buffer_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,buffer_pos,ac_l2_num_reserved);
        buffer_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      /* -----------------------------
      ** Add RER fields for P_REV >= 6 
      **------------------------------ */
      (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                        buf_ptr,buffer_pos,
                        &(int_ptr->auth_ch.pilot_rpt));
      buffer_pos += ac_plt_rpt_len;
    }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packd( int_ptr->auth_ch.authu, buf_ptr, buffer_pos,
             FSIZ( cai_auth_ch_resp_type, authu ));
    buffer_pos += FSIZ( cai_auth_ch_resp_type, authu );

    if( caix_p_rev_in_use >= CAIX_P_REV_IS95B )
    {
      if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
      {
        (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                          buf_ptr,buffer_pos,&(int_ptr->auth_ch.pilot_rpt));
        buffer_pos += ac_plt_rpt_len;
      }
    }

#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
      #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
      {
        /* ----------------------------
        ** Pack the MACI field
        ** ---------------------------- */
        if (int_ptr->auth_ch.ami.maci_incl)
        {
          xlate_int_maci(&buffer_pos,
                         buf_ptr,
                         CAI_AC_CRC_SIZE,
                         int_ptr->auth_ch.hdr.ack_req,
                         chn,
                         int_ptr->auth_ch.ami.sdu_key_id,
                         int_ptr->auth_ch.msg_type,
                         int_ptr->auth_ch.ami.sdu_integrity_algo,
                         #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                         #endif /* FEATURE_IS2000_REL_C_MI */
                         &int_ptr->auth_ch.ami.maci
                        );
        } /* maci_incl */
      } /* p_rev > CAIX_P_REV_IS2000_REL_C */
#endif /* FEATURE_IS2000_REL_C */
    } /* p_rev >= 7 */
#endif /* FEATURE_IS2000_REL_A */
  } /* status = CAIX_DONE */

  *len_ptr = buffer_pos;

  return (status);

} /* xlate_int_auth_ch */

/*===========================================================================

FUNCTION XLATE_INT_AC_STRSP

DESCRIPTION
  This function translates an Access Channel Status Response Message from
  internal to external format. This message is only for pre-IS95B.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_strsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */
  caix_l2_fields_pack_type l2_fields_pack_ind
    /* Indicates if L2 fields are to be packed */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack bits in message */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( l2_fields_pack_ind == CAIX_L2_FIELDS_PACK )
  {
    /* ------------------------------------------------------
    ** Pack Status Response Message up through the MSID field
    ** ------------------------------------------------------ */
    status = xlate_int_ac_hdr( &msg_pos, buf_ptr, int_ptr );
  
    if ( status != CAIX_DONE_S )
    {
      return ( status ); /* Header translation failed */
    }
  
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */
    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, auth_mode ) );
    msg_pos += FSIZ( cai_ac_strsp_fix_type, auth_mode );
  
    if (caix_p_rev_in_use == CAIX_P_REV_IS2000)
    {
      ac_l2_num_bits = msg_pos-ac_l2_start_pos;
      ac_l2_num_bytes = (ac_l2_num_bits/8);
      ac_l2_num_reserved = 8 - (ac_l2_num_bits % 8);
      if (ac_l2_num_reserved != 8)
      {
        ac_l2_num_bytes += 1;
        b_packb (0,buf_ptr,msg_pos,ac_l2_num_reserved);
        msg_pos += ac_l2_num_reserved;
      }
      b_packb (ac_l2_num_bytes,buf_ptr,ac_l2_length_pos,AC_L2_LENGTH_NUM_BITS);
    }
  }

  b_packb( int_ptr->ac_strsp.qual,
           buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, qual_typ ) );
  msg_pos += FSIZ( cai_ac_strsp_fix_type, qual_typ );

  if ( int_ptr->ac_strsp.qual == CAI_NO_QUAL ) /* No qual info */
  {
    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, qual_len ) );
    msg_pos += FSIZ( cai_ac_strsp_fix_type, qual_len );
  }
  else if ( int_ptr->ac_strsp.qual == CAI_BAND_QUAL ) /* Band qual info */
  {
    b_packb( sizeof(cai_qual_info1_type) / 8,
             buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, qual_len ) );
    msg_pos += FSIZ( cai_ac_strsp_fix_type, qual_len );

    b_packb( int_ptr->ac_strsp.band,
             buf_ptr, msg_pos, FSIZ( cai_qual_info1_type, band ) );
    msg_pos += FSIZ( cai_qual_info1_type, band );

    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_qual_info1_type, reserved ) );
    msg_pos += FSIZ( cai_qual_info1_type, reserved );
  }
  else if ( int_ptr->ac_strsp.qual == CAI_BAND_OP_MODE_QUAL )
  {
    b_packb( sizeof(cai_qual_info2_type) / 8,
             buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, qual_len ) );
    msg_pos += FSIZ( cai_ac_strsp_fix_type, qual_len );

    b_packb( int_ptr->ac_strsp.band,
             buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, band ) );
    msg_pos += FSIZ( cai_qual_info2_type, band );

    b_packb( int_ptr->ac_strsp.op_mode,
             buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, op_mode ) );
    msg_pos += FSIZ( cai_qual_info2_type, op_mode );

    b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_qual_info2_type, reserved ) );
    msg_pos += FSIZ( cai_qual_info2_type, reserved );
  }
  else
  {
    return ( CAIX_INV_MSG_S ); /* Unknown qual info type */
  }

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /* Translate the information records */
  for ( i = irec_pos = 0; i < int_ptr->ac_strsp.num_recs; i++ )
  {

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
    status =
    xlate_int_info_rec(
                      (byte*)(&int_ptr->ac_strsp.recs[irec_pos/4]),
                      &irec_len,
                      CAI_AC_BODY_SIZE - msg_pos - FSIZ( cai_ac_strsp_fix_type,
                                                         reserved2 ),
                      buf_ptr,
                      msg_pos,
                      &xrec_len );

    if ( status != CAIX_DONE_S )
    {
      return ( status ); /* Problem translating info rec */
    }
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    msg_pos  += xrec_len;  /* Advance external msg buf position */
    irec_pos += irec_len;  /* Advance internal msg buf position */
    /* The next record will start only on a dword boundary, so move positions accordingly */
    irec_pos = (irec_pos%4)?(irec_pos+(sizeof(dword))-irec_pos%4):irec_pos;
  } /* for */

  if ( l2_fields_pack_ind == CAIX_L2_FIELDS_PACK )
  {
    if (caix_p_rev_in_use < CAIX_P_REV_IS2000)
    {
      b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_ac_strsp_fix_type, reserved2 ) );
      msg_pos += FSIZ( cai_ac_strsp_fix_type, reserved2 );
    }
  }

  *len_ptr = msg_pos; /* Set length of message */

  return ( CAIX_DONE_S );

} /* xlate_int_ac_strsp */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_INT_AC_AURSPM

DESCRIPTION
  This function translates an Authentication Response Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_aurspm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position in buffer to pack bits */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------------------------------
  ** Pack Authentication Response Msg up through the MSID field
  ** -------------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_aurspm.msg_type,
      &int_ptr->ac_aurspm.hdr, &int_ptr->ac_aurspm.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->ac_aurspm.enc,
                     &int_ptr->ac_aurspm.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->ac_aurspm.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;

    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packq(int_ptr->ac_aurspm.res_hi, buf_ptr, buffer_pos,
              FSIZ(cai_ac_aurspm_type,  res )/2);
    buffer_pos += FSIZ(cai_ac_aurspm_type,  res )/2;
    b_packq(int_ptr->ac_aurspm.res_lo, buf_ptr, buffer_pos,
              FSIZ(cai_ac_aurspm_type,  res )/2);
    buffer_pos += FSIZ(cai_ac_aurspm_type,  res )/2;

    b_packb(int_ptr->ac_aurspm.sig_integrity_sup_incl, buf_ptr, buffer_pos,
            FSIZ(cai_ac_aurspm_type,sig_integrity_sup_incl));
    buffer_pos += FSIZ(cai_ac_aurspm_type,sig_integrity_sup_incl);
    if (int_ptr->ac_aurspm.sig_integrity_sup_incl)
    {
      b_packb(int_ptr->ac_aurspm.sig_integrity_sup, buf_ptr, buffer_pos,
              FSIZ(cai_ac_aurspm_type ,sig_integrity_sup));
      buffer_pos += FSIZ(cai_ac_aurspm_type,sig_integrity_sup);
      b_packb(int_ptr->ac_aurspm.sig_integrity_req, buf_ptr, buffer_pos,
              FSIZ(cai_ac_aurspm_type,sig_integrity_req));
      buffer_pos += FSIZ(cai_ac_aurspm_type,sig_integrity_req);
    }
    b_packb(int_ptr->ac_aurspm.new_key_id, buf_ptr, buffer_pos,
            FSIZ(cai_ac_aurspm_type,new_key_id));
    buffer_pos += FSIZ(cai_ac_aurspm_type,new_key_id);

    b_packd(int_ptr->ac_aurspm.new_sseq_h, buf_ptr, buffer_pos,
            FSIZ(cai_ac_aurspm_type,new_sseq_h));
    buffer_pos += FSIZ(cai_ac_aurspm_type,new_sseq_h);


    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */
      
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
      if (int_ptr->ac_aurspm.ami.maci_incl)
      {
        xlate_int_maci(&buffer_pos,
                       buf_ptr,
                       CAI_AC_CRC_SIZE,
                       int_ptr->ac_aurspm.hdr.ack_req,
                       chn,
                       int_ptr->ac_aurspm.ami.sdu_key_id,
                       int_ptr->ac_aurspm.msg_type,
                       int_ptr->ac_aurspm.ami.sdu_integrity_algo,
                       #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                       #endif /* FEATURE_IS2000_REL_C_MI */
                       &int_ptr->ac_aurspm.ami.maci
                       );
      } /* maci_incl */
    } /* p_rex >= CAIX_P_REV_IS2000_REL_C */
  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

}

/*===========================================================================

FUNCTION XLATE_INT_AC_AURSYNM

DESCRIPTION
  This function translates an Authentication Resync Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_aursynm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position in buffer to pack bits */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------------------------------
  ** Pack Authentication Resync Msg up through the MSID field
  ** -------------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->ac_aursynm.msg_type,
      &int_ptr->ac_aursynm.hdr, &int_ptr->ac_aursynm.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->ac_aursynm.enc,
                     &int_ptr->ac_aursynm.ami
                    );

    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->ac_aursynm.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;

    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packq(int_ptr->ac_aursynm.con_ms_sqn, buf_ptr, buffer_pos,
              FSIZ(cai_aursynm_type,  con_ms_sqn ));
    buffer_pos += FSIZ(cai_aursynm_type,  con_ms_sqn );
    b_packq(int_ptr->ac_aursynm.mac_s, buf_ptr, buffer_pos,
              FSIZ(cai_aursynm_type,  mac_s ));
    buffer_pos += FSIZ(cai_aursynm_type,  mac_s );

    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */
    
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
      if (int_ptr->ac_aursynm.ami.maci_incl)
      {
        xlate_int_maci(&buffer_pos,
                       buf_ptr,
                       CAI_AC_CRC_SIZE,
                       int_ptr->ac_aursynm.hdr.ack_req,
                       chn,
                       int_ptr->ac_aursynm.ami.sdu_key_id,
                       int_ptr->ac_aursynm.msg_type,
                       int_ptr->ac_aursynm.ami.sdu_integrity_algo,
                       #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                       #endif /* FEATURE_IS2000_REL_C_MI */
                       &int_ptr->ac_aursynm.ami.maci
                       );
      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

}

/*===========================================================================

FUNCTION XLATE_INT_AC_RCNM

DESCRIPTION
  This function translates a Reconnect Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_rcnm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word buffer_pos;
    /* Position in buffer to pack bits */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  uint8 i;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* --------------------------------------------------------------------
  ** Pack a Recoonect Msg up through the MSID field
  ** -------------------------------------------------------------------- */
  status = xlate_int_ac_hdr( &buffer_pos, buf_ptr, int_ptr );

  if (status == CAIX_DONE_S)
  {
    /* ----------------------------
    ** Pack the rest of the message
    ** ---------------------------- */

    /* -------------------------------------------------------
    ** Pack authentication fields and message integrity fields
    ** ------------------------------------------------------- */
    xlate_int_ac_auth_msg_int(&buffer_pos, buf_ptr, int_ptr->rcnm.msg_type,
      &int_ptr->rcnm.hdr, &int_ptr->rcnm.ami);

    /* -------------------------------
    ** Pack Extended Encryption fields
    ** ------------------------------- */
    xlate_int_ac_enc(&buffer_pos, buf_ptr, 
                     &int_ptr->rcnm.enc,
                     &int_ptr->rcnm.ami
                    );
 
    /* -----------------------------------------------
    ** Add RER fields for P_REV 6 & 7
    **------------------------------------------------ */
    (void)xlate_int_plt_rpt(&ac_plt_rpt_len,
                      buf_ptr,buffer_pos,
                      &(int_ptr->rcnm.pilot_rpt));
    buffer_pos += ac_plt_rpt_len;

    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */

    b_packb(int_ptr->rcnm.orig_ind, buf_ptr, buffer_pos,
              FSIZ(cai_ac_rcnm_type,  orig_ind ));
    buffer_pos += FSIZ(cai_ac_rcnm_type,  orig_ind );

    b_packb(int_ptr->rcnm.sync_id_incl, buf_ptr, buffer_pos,
              FSIZ(cai_ac_rcnm_type, sync_id_incl  ));
    buffer_pos += FSIZ(cai_ac_rcnm_type, sync_id_incl  );

    if (int_ptr->rcnm.sync_id_incl)
    {
      b_packb( int_ptr->rcnm.sync_id_len, buf_ptr, buffer_pos,
             FSIZ( cai_ac_rcnm_type, sync_id_len ));
      buffer_pos += FSIZ( cai_ac_rcnm_type, sync_id_len );
      for (i=0; i < int_ptr->rcnm.sync_id_len; i++)
      {
        b_packb( int_ptr->rcnm.sync_id[i], buf_ptr, buffer_pos,
               FSIZ( cai_ac_rcnm_type, sync_id ));
        buffer_pos += FSIZ( cai_ac_rcnm_type, sync_id );
      }
    }
    else
    {
      b_packw( int_ptr->rcnm.service_option, buf_ptr, buffer_pos,
             FSIZ( cai_ac_rcnm_type, service_option ));
      buffer_pos += FSIZ( cai_ac_rcnm_type, service_option );
    }

    if (int_ptr->rcnm.orig_ind)
    {
      b_packb( int_ptr->rcnm.sr_id, buf_ptr, buffer_pos,
             FSIZ( cai_ac_rcnm_type, sr_id ));
      buffer_pos += FSIZ( cai_ac_rcnm_type, sr_id );
    }

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */
    
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
    {  
      /* ----------------------------
      ** Pack the MACI field
      ** ---------------------------- */
      if (int_ptr->rcnm.ami.maci_incl)
      {
        xlate_int_maci(&buffer_pos,
                       buf_ptr,
                       CAI_AC_CRC_SIZE,
                       int_ptr->rcnm.hdr.ack_req,
                       chn,
                       int_ptr->rcnm.ami.sdu_key_id,
                       int_ptr->rcnm.msg_type,
                       int_ptr->rcnm.ami.sdu_integrity_algo,
                       #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                       #endif /* FEATURE_IS2000_REL_C_MI */
                       &int_ptr->rcnm.ami.maci);

      } /* maci_incl */
    } /* p_rev >= CAIX_P_REV_IS2000_REL_C */
  } /* status DONE_S */

  *len_ptr = buffer_pos;

  return (status);

}
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*===========================================================================

FUNCTION XLATE_INT_AC_MSG

DESCRIPTION
  This function translates an Access Channel message to be transmitted
  to the base station from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_ac_msg
(
  word *len_ptr,
    /* Length of message in bits */
  byte *ac_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr,
    /* Pointer to internal message to be transmitted */
  word chn,
    /* Channel message is to be transmitted on */

  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status;
    /* Status to be returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (int_ptr->gen_ac.msg_type) {
    case CAI_REG_MSG:
      status = xlate_int_reg( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_ORD_MSG:
      status = xlate_int_ac_ord( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_BURST_MSG:
      status = xlate_int_ac_burst( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_ORIG_MSG:
      status = xlate_int_orig( len_ptr, ac_ptr, int_ptr, chn, parsing_reason, FALSE );
      break;

    case CAI_PAGE_RESP_MSG:
      status = xlate_int_page_resp( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_AUTH_RESP_MSG:
      status = xlate_int_auth_ch( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_STRSP_MSG:
      /* REL A does not apply to Status Response Message */
      status = xlate_int_ac_strsp( len_ptr, ac_ptr, int_ptr, chn, 
                 CAIX_L2_FIELDS_PACK );
      break;

    case CAI_AC_TMSI_CMP_MSG:
      status = xlate_int_ac_tmsi_cmp( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_PACA_CAN_MSG:
      status = xlate_int_ac_paca_can( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_EXT_STRSP_MSG:
      status = xlate_int_ac_ext_strsp( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;


#ifdef FEATURE_IS2000_REL_A
    case CAI_AC_DIM_MSG:
      status = xlate_int_ac_dim( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_SMRM_MSG:
      status = xlate_int_ac_smrm( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
    case CAI_AC_AUTH_RSP_MSG:
      status = xlate_int_ac_aurspm( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_AUTH_RESYNC_MSG:
      status = xlate_int_ac_aursynm( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;

    case CAI_AC_RECONNECT_MSG:
      status = xlate_int_ac_rcnm( len_ptr, ac_ptr, int_ptr, chn, parsing_reason );
      break;
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

  return (status);

} /* xlate_int_ac_msg */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION XLATE_INT_MSG_INT_TC

DESCRIPTION
  This function translates message integrity fields from internal to external
  format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_msg_int_tc
(
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_gen_tc_type *int_ptr
    /* Pointer to the internal format of the message integrity fields */  
)
{
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    #define FTYPE cai_msg_int_type

    #ifndef FEATURE_MSG_PACK_UNIT_TEST
    MSG_LOW("rdsch msg. key id: %d", int_ptr->hdr.msg_int.sdu_key_id, 0, 0);
    #endif /* !FEATURE_MSG_PACK_UNIT_TEST */

    b_packb(int_ptr->hdr.msg_int.maci_incl, buf_ptr, *pos_ptr, FSIZ(FTYPE, maci_incl));
    *pos_ptr += FSIZ(FTYPE, maci_incl);

    if (int_ptr->hdr.msg_int.maci_incl)
    {
      b_packb(int_ptr->hdr.msg_int.randc, buf_ptr, *pos_ptr, FSIZ(FTYPE, randc));
      *pos_ptr += FSIZ(FTYPE, randc);

      b_packb(int_ptr->hdr.msg_int.sdu_key_id, buf_ptr, *pos_ptr, FSIZ(FTYPE, sdu_key_id));
      *pos_ptr += FSIZ(FTYPE, sdu_key_id);

      b_packb(int_ptr->hdr.msg_int.sdu_integrity_algo, buf_ptr, *pos_ptr,
        FSIZ(FTYPE, sdu_integrity_algo));
      *pos_ptr += FSIZ(FTYPE, sdu_integrity_algo);

      b_packb(int_ptr->hdr.msg_int.sdu_sseq_or_sseqh, buf_ptr, *pos_ptr,
        FSIZ(FTYPE, sdu_sseq_or_sseqh));
      *pos_ptr += FSIZ(FTYPE, sdu_sseq_or_sseqh);

      if (!int_ptr->hdr.msg_int.sdu_sseq_or_sseqh)
      {
        b_packb(int_ptr->hdr.msg_int.sdu_sseq, buf_ptr, *pos_ptr, FSIZ(FTYPE, sdu_sseq));
        *pos_ptr += FSIZ(FTYPE, sdu_sseq);
      }
      else
      {
        b_packd(int_ptr->hdr.msg_int.sdu_sseq_h, buf_ptr, *pos_ptr, FSIZ(FTYPE, sdu_sseq_h));
        *pos_ptr += FSIZ(FTYPE, sdu_sseq_h);
      }
    }

    #undef FTYPE
    
  }

}  /* xlate_int_msg_int_tc */
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION XLATE_INT_EXT_ENC_TC

DESCRIPTION
  This function translate extended encryption fields from internal to external
  format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_ext_enc_tc
(
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_gen_tc_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  /* This part should only be packed when PREV is less than 7 )*/
  if ((caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A))
  {

    if (int_ptr->hdr.encryption == CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG)
    {
      b_packb(int_ptr->hdr.sdu_encrypt_mode, buf_ptr, *pos_ptr,
        FSIZ(cai_tc_hdr_ext_enc_type, sdu_encrypt_mode));
      *pos_ptr +=  FSIZ(cai_tc_hdr_ext_enc_type, sdu_encrypt_mode);

      /* If the SDU_ENCRYPT_MODE field is set to '001' or '010' and if MACI_INCL
       * field is not present in the PDU or it is present, but it is eaqual to '0',
       * the mobile station shall include the ENC_SEQ field and shall it to the value
       * provided by Layer 3; otherwise, the mobile station shall omit the ENC_SEQ field
       *
       *
       * The understanding here is: if the condition is met, the ENC_SEQ field should be
       * set to the specified value. if the condition is not met, this field should still
       * be there but ignore the value.
       *
       */
      if (((int_ptr->hdr.sdu_encrypt_mode == CAI_ENC_MODE_ECMEA) ||
           (int_ptr->hdr.sdu_encrypt_mode == CAI_ENC_MODE_REA))
#ifdef FEATURE_IS2000_REL_C
          && ((caix_p_rev_in_use < CAIX_P_REV_IS2000_REL_C) ||
              !int_ptr->hdr.msg_int.maci_incl)
#endif /* FEATURE_IS2000_REL_C */
         )
      {
        b_packb(int_ptr->hdr.enc_seq, buf_ptr, *pos_ptr,
           FSIZ(cai_tc_hdr_ext_enc_type, enc_seq));
        *pos_ptr +=  FSIZ(cai_tc_hdr_ext_enc_type, enc_seq);
      }  /* CAI_ENC_MODE_ECMEA || CAI_ENC_MODE_REA */
    }  /* CAI_EXTENDED_ENCRYPT_CALL_CTL_MSG */
  }
} /* xlate_int_ext_enc_tc */
#endif /* FEATURE_IS2000_REL_A */

/*===========================================================================

FUNCTION XLATE_INT_TC_HDR

DESCRIPTION
  This function translates a Traffic Channel Message header from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void xlate_int_tc_hdr
(
  word *pos_ptr,
    /* Pointer to the bit position of received message to be translated */
  byte *buf_ptr,
    /* Pointer to received message to be translated */
  caii_gen_tc_type *int_ptr
    /* Pointer to place where translated message should be placed */
)
{
  *pos_ptr = FPOS(cai_gen_tc_type, msg_type);

  b_packb(int_ptr->msg_type, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, msg_type));
  *pos_ptr += FSIZ(cai_gen_tc_type, msg_type);

  b_packb(int_ptr->hdr.ack_seq, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, hdr.ack_seq));
  *pos_ptr += FSIZ(cai_gen_tc_type, hdr.ack_seq);

  b_packb(int_ptr->hdr.msg_seq, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, hdr.msg_seq));
  *pos_ptr += FSIZ(cai_gen_tc_type, hdr.msg_seq);

  b_packb(int_ptr->hdr.ack_req, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, hdr.ack_req));
  *pos_ptr += FSIZ(cai_gen_tc_type, hdr.ack_req);

  b_packb(int_ptr->hdr.encryption, buf_ptr, *pos_ptr,
    FSIZ(cai_gen_tc_type, hdr.encryption));
  *pos_ptr += FSIZ(cai_gen_tc_type, hdr.encryption);

#ifdef FEATURE_IS2000_REL_C
  /* Pack message integrity fields */
  xlate_int_msg_int_tc(pos_ptr, buf_ptr, (caii_gen_tc_type *)int_ptr);
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_A
  /* Pack extended encryption fields */
  xlate_int_ext_enc_tc(pos_ptr, buf_ptr, int_ptr);
#endif /* FEATURE_IS2000_REL_A */

  #if defined(FEATURE_IS2000_REL_A_AES) && defined(FEATURE_TREX)
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES && FEATURE_TREX */
} /* xlate_int_tc_hdr() */

/*===========================================================================

FUNCTION XLATE_INT_TC_ORD

DESCRIPTION
  This function translates a Traffic Channel Order Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_ord
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  word add_rec_len_pos;
    /* the point where we will pack additional record length */

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_rtc_ord_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tc_ord.gen);

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->tc_ord.gen.order, buf_ptr, msg_pos,
          FSIZ( cai_rtc_gen_ord_type, order ));
  msg_pos += FSIZ( cai_rtc_gen_ord_type, order );

  switch (int_ptr->tc_ord.gen.order) 
  {
    case CAI_BS_CHAL_ORD:
      /* ----------------------------
      ** Base Station Challenge Order
      ** ---------------------------- */
      b_packb( 5, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, gen.add_record_len ));
      msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );
      b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, ordq.ordq ));
      msg_pos += FSIZ( cai_rtc_ord_type, ordq.ordq );
      b_packd( int_ptr->tc_ord.chal.randbs, buf_ptr, msg_pos,
               FSIZ( cai_rtc_ord_type, chal.randbs ));
      msg_pos += FSIZ( cai_rtc_ord_type, chal.randbs );
      break;

    case CAI_DTMF_ORD:  /* Call Control Order so con_ref can be filled */

      if (int_ptr->tc_ord.ordq.ordq != 0)
      {
        /* move msg_pos */
        b_packb( 1, buf_ptr, msg_pos ,
          FSIZ( cai_rtc_ord_type, gen.add_record_len ));
        msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );

        b_packb( int_ptr->tc_ord.ordq.ordq, buf_ptr, msg_pos,
          FSIZ( cai_rtc_ord_type, ordq.ordq ));
        msg_pos += FSIZ( cai_rtc_ord_type, ordq.ordq );
      }
      else
      {
        b_packb( 0, buf_ptr, msg_pos ,
          FSIZ( cai_rtc_ord_type, gen.add_record_len ));
        msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        if (int_ptr->tc_ord.ordq.con_ref_incl)
        {
          b_packb( int_ptr->tc_ord.ordq.con_ref_incl, buf_ptr,
               msg_pos,
               FSIZ( cai_rtc_ord_var_type, con_ref_incl ));
          msg_pos += FSIZ(cai_rtc_ord_var_type, con_ref_incl);

          b_packb( int_ptr->tc_ord.ordq.con_ref, buf_ptr,
               msg_pos,
               FSIZ( cai_rtc_ord_var_type, con_ref ));
          msg_pos += FSIZ(cai_rtc_ord_var_type, con_ref);
        }
      }
#endif /* FEATURE_IS2000_REL_A */
      break;

    case CAI_SSD_UPDATE_ORD:
    case CAI_PARAM_UPDATE_CONF_ORD:
    case CAI_PLC_ORD:
    case CAI_SO_CTL_ORD:
    case CAI_LOCAL_CTL_RESP_ORD:
    case CAI_FM_REQUEST_ORD:
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
      if (int_ptr->tc_ord.ordq.ordq == 0)
      {
        /* ----------------------------------------
        ** No need to pack order qualification code
        ** ---------------------------------------- */
        b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, gen.add_record_len ));
          msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );
      }
      else
      {
        b_packb( 1, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, gen.add_record_len ));
        msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );
        b_packb( int_ptr->tc_ord.ordq.ordq, buf_ptr, msg_pos,
           FSIZ( cai_rtc_ord_type, ordq.ordq ));
        msg_pos += FSIZ( cai_rtc_ord_type, ordq.ordq );
      }
      break;

    case CAI_SO_REQ_ORD:
    case CAI_SO_RESP_ORD:
      b_packb( 3, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, so.add_record_len ));
      msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );
      b_packb( int_ptr->tc_ord.so.ordq, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, so.ordq ));
      msg_pos += FSIZ( cai_rtc_ord_type, so.ordq );
      b_packw( int_ptr->tc_ord.so.service_option, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, so.service_option ));
      msg_pos += FSIZ( cai_rtc_ord_type, so.service_option );
      break;

    case CAI_MS_REJECT_ORD:

      /* ---------------------------
      ** Mobile Station Reject Order
      ** --------------------------- */
      /* length will be packed after packing all order specific fields */
      add_rec_len_pos = msg_pos;
      msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );

      b_packb( int_ptr->tc_ord.rej.fix.ordq, buf_ptr, msg_pos,
               FSIZ( cai_rtc_ord_type, rej.fix.ordq ));
      msg_pos += FSIZ( cai_rtc_ord_type, rej.fix.ordq );

      b_packb( int_ptr->tc_ord.rej.fix.rej_msg_type, buf_ptr, msg_pos,
               FSIZ( cai_rtc_ord_type, rej.fix.rej_msg_type ));
      msg_pos += FSIZ( cai_rtc_ord_type, rej.fix.rej_msg_type );

      /* type is 00000001 or 00000111 */
      if (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_TC_FWD_ORD_MSG)
      {
        /* ---------------------------------------------
        ** Order Message -> must pack rejected_order and
        **                  rejected_ordq fields
        ** --------------------------------------------- */

        b_packb( int_ptr->tc_ord.rej.var.order.rej_order, buf_ptr, msg_pos,
                 FSIZ( cai_rtc_ord_type, rej.var.order.rej_order ));
        msg_pos += FSIZ( cai_rtc_ord_type, rej.var.order.rej_order );
        b_packb( int_ptr->tc_ord.rej.var.order.rej_ordq, buf_ptr, msg_pos,
                 FSIZ( cai_rtc_ord_type, rej.var.order.rej_ordq ));
        msg_pos += FSIZ( cai_rtc_ord_type, rej.var.order.rej_ordq );
      }

      else if (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_SET_PARMS_MSG)
      {
        /* --------------------------------------------------
  ** Pack rejected_param_id for Set Parameters Message.
        ** -------------------------------------------------- */
        b_packw( int_ptr->tc_ord.rej.var.param.rej_param_id,
                 buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, rej.var.param.rej_param_id ));
        msg_pos += FSIZ( cai_rtc_ord_type, rej.var.param.rej_param_id );
      }

      else if ((int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_ALERT_MSG) ||
               (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_FWD_FLASH_MSG) 
#ifdef FEATURE_IS2000_REL_A
               || (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_EXT_ALERT_W_INFO_MSG) 
               || (int_ptr->tc_ord.rej.fix.rej_msg_type == CAI_EXT_FLASH_W_INFO_MSG)
#endif /* FEATURE_IS2000_REL_A */
              )
      {
        /* -----------------------------------------------------------
        ** Alert with Information or Flash with Information Message ->
        **   must pack rejected_record field
        ** ----------------------------------------------------------- */

        b_packb( int_ptr->tc_ord.rej.var.rec.rej_record,
                 buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, rej.var.rec.rej_record ));
        msg_pos += FSIZ( cai_rtc_ord_type, rej.var.rec.rej_record );
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        switch (int_ptr->tc_ord.rej.fix.ordq)
        {
          case  CAI_REJ_NO_CC_INST :
          case  CAI_REJ_CALL_ASSIGN_REJ  :
          case  CAI_REJ_CC_ALREADY_PRESENT :

            b_packb( int_ptr->tc_ord.rej.con_ref, buf_ptr,
                msg_pos, FSIZ(cai_rtc_rej_ord_is2000_relA_type,con_ref));
            msg_pos += FSIZ(cai_rtc_rej_ord_is2000_relA_type,con_ref);

            break;

          case CAI_REJ_CC_TAG_MISMATCH:

            b_packb( int_ptr->tc_ord.rej.con_ref, buf_ptr,
                 msg_pos, FSIZ(cai_rtc_rej_ord_is2000_relA_type,con_ref));
              msg_pos += FSIZ(cai_rtc_rej_ord_is2000_relA_type,con_ref);

            b_packb( int_ptr->tc_ord.rej.tag, buf_ptr,
              msg_pos, FSIZ(cai_rtc_rej_ord_is2000_relA_type,tag));
            msg_pos += FSIZ(cai_rtc_rej_ord_is2000_relA_type,tag);
            break;

          default:
            break;
        }
      }
#endif /* FEATURE_IS2000_REL_A */

      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
      {
        b_packb( int_ptr->tc_ord.rej.rejected_pdu_type, buf_ptr,
                 msg_pos,
                 FSIZ(cai_rtc_rej_ord_is2000_type,rejected_pdu_type));
        msg_pos += FSIZ(cai_rtc_rej_ord_is2000_type,rejected_pdu_type);

        /* Now reserved part needs to be packed */

        /* if we've packed the tag pack only two bits of zeros
          otherwise pack 6 bits of zeros */
        #ifdef FEATURE_IS2000_REL_A
        if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
        {
          /* if tag is packed above */
          if (int_ptr->tc_ord.rej.fix.ordq == CAI_REJ_CC_TAG_MISMATCH)
          {
            b_packb( 0, buf_ptr, msg_pos, 2);
            msg_pos += 2;
          }
          else
          {
            b_packb( 0, buf_ptr, msg_pos, 6);
            msg_pos += 6;
          }
        }
        else
        #endif /* FEATURE_IS2000_REL_A */
        {
          b_packb( 0, buf_ptr, msg_pos, 6);
          msg_pos += 6;
        }
      }

      /* now that we have packed all Order specific fields, put the length info to the
      saved address. Note that the length should be in octets

      add_rec_len_pos:  position where order specific length must be packed into
      msg_pos: where we are now

      ((msg_pos - add_rec_len_pos - 1) >> 3) + 1 : Number of octets packed in the mean time
      i.e
      msg_pos = 10, add_rec_len_pos = 2 ===>  1 Octet
      msg_pos = 10, add_rec_len_pos = 3 ===>  1 Octet
      msg_pos = 15, add_rec_len_pos = 6 ===>  2 Octets
      */

      b_packb( ((msg_pos - add_rec_len_pos - 1) >> 3), /*lint !e702*/
               buf_ptr, add_rec_len_pos, FSIZ( cai_rtc_ord_type, gen.add_record_len ));
      break;

   case CAI_MS_ACK_ORD:
     /* -----------------
     ** No order qualifer
     ** ----------------- */
     b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, so.add_record_len ));
     msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );
     break;

  case CAI_MS_CONNECT_ORD: /* Call Control Order so con_ref can be filled */
     /* -----------------
     ** No order qualifer
     ** ----------------- */
     b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, gen.add_record_len ));
     msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );

#ifdef FEATURE_IS2000_REL_A
     if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
     {
       b_packb( int_ptr->tc_ord.gen.con_ref_incl, buf_ptr,
         msg_pos, FSIZ( cai_rtc_ord_var_type, con_ref_incl ));
       msg_pos += FSIZ(cai_rtc_ord_var_type, con_ref_incl);

       if (int_ptr->tc_ord.gen.con_ref_incl)
       {
         b_packb( int_ptr->tc_ord.gen.con_ref, buf_ptr,
              msg_pos, FSIZ( cai_rtc_ord_var_type, con_ref ));
         msg_pos += FSIZ(cai_rtc_ord_var_type, con_ref);
       }
     }
#endif /* FEATURE_IS2000_REL_A */

     break;

#ifdef FEATURE_IS2000_REL_B
#ifdef FEATURE_IS2000_REL_C
    case CAI_SEC_MODE_CMP_ORD:
#endif /* FEATURE_IS2000_REL_C */
    case CAI_CALL_RESQ_CANCEL_ORD:
      /* -----------------
      ** No order qualifer
      ** ----------------- */
      b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_rtc_ord_type, gen.add_record_len ));
      msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );
      break;
#endif /* FEATURE_IS2000_REL_B */

    case CAI_RELEASE_ORD:
      if (int_ptr->tc_ord.ordq.ordq == CAI_REL_NORMAL)
      {
        b_packb( 0, buf_ptr, msg_pos ,
                 FSIZ( cai_rtc_ord_type, gen.add_record_len ));
        msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );
      }
      else if (int_ptr->tc_ord.ordq.ordq == CAI_REL_PWDN
               || int_ptr->tc_ord.ordq.ordq == CAI_REL_SO)
      {
        b_packb( 1, buf_ptr, msg_pos ,
                 FSIZ( cai_rtc_ord_type, gen.add_record_len ));
        msg_pos += FSIZ( cai_rtc_ord_type, gen.add_record_len );

        b_packb( int_ptr->tc_ord.ordq.ordq, buf_ptr, msg_pos,
                 FSIZ( cai_rtc_ord_type, ordq.ordq ));
        msg_pos += FSIZ( cai_rtc_ord_type, ordq.ordq );
      }
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
      break;

   default:
     /* -------------------------------------
     ** Invalid Reverse Traffic Channel Order
     ** ------------------------------------- */
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else 
     status = CAIX_INV_MSG_S;
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
     break;
  } /* end switch (int_ptr->tc_ord.gen.order) */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->tc_ord.gen.hdr.msg_int.maci_incl)
  {
  /* Pack MACI field */
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tc_ord.gen.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tc_ord.gen.hdr.msg_int.sdu_key_id,
                   int_ptr->tc_ord.gen.msg_type,
                   int_ptr->tc_ord.gen.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->tc_ord.gen.hdr.msg_int.maci
                   );
  }
 #endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;

  #undef MTYPE
  
  return (status);

} /* xlate_int_tc_ord */

/*===========================================================================

FUNCTION XLATE_INT_AUTH_RESP

DESCRIPTION
  This function translates an Authentication Challenge Response Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_auth_resp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* Status to be returned to calling procedure */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_auth_type

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->auth_resp);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packd(int_ptr->auth_resp.authu, buf_ptr, msg_pos, FSIZ( MTYPE, authu));
  msg_pos += FSIZ( MTYPE, authu);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->auth_resp.hdr.msg_int.maci_incl)
  {
  /* Pack MACI field */
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->auth_resp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->auth_resp.hdr.msg_int.sdu_key_id,
                   int_ptr->auth_resp.msg_type,
                   int_ptr->auth_resp.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->auth_resp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

  #undef MTYPE

  return (status);
} /* xlate_int_auth_resp */

/*===========================================================================

FUNCTION XLATE_INT_FLASH

DESCRIPTION
  This function translates a Flash With Information Message from internal
  to external format.

DEPENDENCIES
  Depends on the internal message type having the correct number of variable
  record parts.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None.

===========================================================================*/

word xlate_int_flash
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through records */
  word j;
    /* Index to loop through characters */
  byte *rec_ptr;
    /* Pointer to internal format information record */
  word msg_pos = 0;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  #ifdef FEATURE_IS2000_REL_A
  word rec_len_pos = 0;
  word reserv_len = 0;
  #endif /* FEATURE_IS2000_REL_A */
  #ifdef FEATURE_IS2000_REL_C
  word rec_len;
  /* Size of record in bits */
  #endif /* FEATURE_IS2000_REL_C */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->flash);

  rec_ptr = (byte*)&int_ptr->flash.recs[0];

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  for (i=0; (i < int_ptr->flash.num_recs) && (status == CAIX_DONE_S); i++)
  {
    /* ----------------------------------------------------
    ** Check to make sure that there is room for the header
    ** ---------------------------------------------------- */
    if ((msg_pos + sizeof( cai_rec_hdr_type )) > CAI_REV_TC_MSG_BODY_SIZE) 
    {
      status = CAIX_INV_LEN_S;
    }
    else 
    {
      b_packb( ((caii_rec_hdr_type *) rec_ptr)->record_type,
                 buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_type ));
      msg_pos += FSIZ( cai_rec_hdr_type, record_type );

      switch (((caii_rec_hdr_type *) rec_ptr)->record_type) 
      {
        /* ------------------------------------
        ** Feature Indicator Information Record
        ** ------------------------------------ */
        case CAI_FEAT_REC:
          /* -------------------------------------------------------
          ** Feature Indicator Info Record length = 1 octet (8 bits)
          ** ------------------------------------------------------- */
          b_packb( 1, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos + sizeof( cai_feat_type )) > CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_feat_rec_type *) rec_ptr)->feature,
                       buf_ptr, msg_pos, FSIZ( cai_feat_type, feature ));
            msg_pos += FSIZ( cai_feat_type, feature );

            /* -----------------------
            ** Pack reserved bits as 0
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_feat_type, reserved ));
            msg_pos += FSIZ( cai_feat_type, reserved );
            rec_ptr += FENDPOS( caii_feat_rec_type, feature );
          }
          break;

        /* ----------------------------------
        ** Keypad Facility Information Record
        ** ---------------------------------- */
        case CAI_KEYPAD_REC:
          if ((((caii_key_rec_type *) rec_ptr)->fix.num_char) == 0) 
          {
            /* --------------------------------------------------------
            ** There must be at least one occurrence of the chari field
            ** -------------------------------------------------------- */
            return (CAIX_INV_LEN_S);
          }

          b_packb( ((caii_key_rec_type *) rec_ptr)->fix.num_char, buf_ptr,
                   msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos +
              (((caii_key_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_keypad_type, chari ))) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            /* --------------------------------------------
            ** Not enough room to pack keypad facility type
            ** -------------------------------------------- */
            status = CAIX_INV_LEN_S;
          }
          else 
          {
            for (j=0; j < ((caii_key_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_key_rec_type *) rec_ptr)->var[j], buf_ptr,
                       msg_pos, FSIZ(cai_keypad_type, chari) );
              msg_pos += FSIZ( cai_keypad_type, chari );
            }

            rec_ptr += FENDPOS( caii_key_rec_type,
              var[((caii_key_rec_type *) rec_ptr)->fix.num_char - 1] );
          }
          break;

        /* --------------------------------------
        ** Called Party Number Information Record
        ** -------------------------------------- */
        case CAI_REV_CALLED_REC:
          /* ----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 1 (8 bits) for
          ** NUMBER_TYPE, NUMBER_PLAN and RESERVED fields
          ** ---------------------------------------------------- */
          b_packb(
            (byte) (((caii_called_rec_type *) rec_ptr)->fix.num_char + 1),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len);

          if ((msg_pos + sizeof( cai_called_fix_type ) +
              (((caii_called_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_called_var_type, chari )) + 1) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else 
          {
            b_packb( ((caii_called_rec_type *) rec_ptr)->fix.number_type,
                     buf_ptr, msg_pos,
                     FSIZ( cai_called_fix_type, number_type ));
            msg_pos += FSIZ(cai_called_fix_type, number_type);

            b_packb( ((caii_called_rec_type *)rec_ptr)->fix.number_plan,
                     buf_ptr, msg_pos,
                     FSIZ( cai_called_fix_type, number_plan));
            msg_pos += FSIZ( cai_called_fix_type, number_plan);

            for (j=0;
                 j < ((caii_called_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_called_rec_type *) rec_ptr)->var[j], buf_ptr,
                        msg_pos, FSIZ( cai_called_var_type, chari ));
              msg_pos += FSIZ( cai_called_var_type, chari );
            }

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, 1 );
            msg_pos += 1;

            if (((caii_called_rec_type *) rec_ptr)->fix.num_char == 0) 
            {
              rec_ptr += FSIZ( caii_called_rec_type, fix );
            }
            else 
            {
              rec_ptr += FENDPOS( caii_called_rec_type,
                   var[((caii_called_rec_type *) rec_ptr)->fix.num_char - 1] );
            }
          }
          break;

        /* -----------------------------------------------------------
        ** Calling Party Number or Connected Number Information Record
        ** ----------------------------------------------------------- */
        case CAI_REV_CALLING_REC:
        case CAI_REV_CONN_REC:
          /* -----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 2 (16 bits) for
          ** NUMBER_TYPE, NUMBER_PLAN, PI, SI and RESERVED fields
          ** ----------------------------------------------------- */
          b_packb(
            (byte) (((caii_calling_rec_type *) rec_ptr)->fix.num_char + 2),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos + sizeof( cai_calling_fix_type ) +
              (((caii_calling_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_calling_var_type, chari )) + 5) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }
          else 
          {
            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.number_type,
                      buf_ptr, msg_pos,
                      FSIZ( cai_calling_fix_type, number_type ));
            msg_pos += FSIZ( cai_calling_fix_type, number_type );

            b_packb( (( caii_calling_rec_type *) rec_ptr)->fix.number_plan,
                     buf_ptr, msg_pos,
                     FSIZ( cai_calling_fix_type, number_plan ));
            msg_pos += FSIZ(cai_calling_fix_type, number_plan);

            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.pi,
                     buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, pi ));
            msg_pos += FSIZ( cai_calling_fix_type, pi );

            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.si,
                      buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, si ));
            msg_pos += FSIZ( cai_calling_fix_type, si);

            for (j=0;
                 j < ((caii_calling_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_calling_rec_type *) rec_ptr)->var[j],
                        buf_ptr, msg_pos, FSIZ( cai_calling_var_type, chari));
              msg_pos += FSIZ( cai_calling_var_type, chari );
            }

            /* ------------------------
            ** Pack 0 for reserved bits
            ** ------------------------ */
            b_packb( 0, buf_ptr, msg_pos, 5 );
            msg_pos += 5;

            if (((caii_calling_rec_type *) rec_ptr)->fix.num_char == 0) 
            {
              rec_ptr += FSIZ( caii_calling_rec_type, fix ); /*lint !e662 */
            }
            else {
              rec_ptr += FENDPOS( caii_calling_rec_type,
                var[((caii_calling_rec_type *) rec_ptr)->fix.num_char - 1] );
            }
          }
          break;

        /* -------------------------------------------
        ** Called Party Subaddress Informatin Record
        ** Calling Party Subaddress Informatin Record
        ** Connected Subaddress Informatin Record
        ** ------------------------------------------- */
        case CAI_REV_CALLED_SUB_REC:
        case CAI_REV_CALLING_SUB_REC:
        case CAI_REV_CONN_SUB_REC:
          /* ----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 1 (8 bits)
          ** ---------------------------------------------------- */
          b_packb(
            (byte) (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char + 1),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len);

          if ((msg_pos + sizeof( cai_subaddr_fix_type ) +
              (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_subaddr_var_type, chari ))) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }
          else 
          {
            b_packb( ((caii_subaddr_rec_type *) rec_ptr)->fix.extension_bit,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, extension_bit ));
            msg_pos += FSIZ(cai_subaddr_fix_type, extension_bit);

            b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.subadd_type,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, subadd_type));
            msg_pos += FSIZ( cai_subaddr_fix_type, subadd_type);

            b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.odd_even_ind,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, odd_even_ind));
            msg_pos += FSIZ( cai_subaddr_fix_type, odd_even_ind);

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, 3 );
            msg_pos += 3;

            for (j=0;
                 j < ((caii_subaddr_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_subaddr_rec_type *) rec_ptr)->var[j], buf_ptr,
                        msg_pos, FSIZ( cai_subaddr_var_type, chari ));
              msg_pos += FSIZ( cai_subaddr_var_type, chari ); /*lint !e662 */
            }

            if (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char == 0) {
              rec_ptr += FSIZ( caii_subaddr_rec_type, fix ); /*lint !e662 */
            }
            else 
            {
              rec_ptr += FENDPOS( caii_subaddr_rec_type,
                   var[((caii_subaddr_rec_type *) rec_ptr)->fix.num_char - 1]);
            }
          }
          break;

#ifdef FEATURE_IS2000_REL_A
        case CAI_GLOB_EM_CALL_REC:
          if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
          {
             if (  !((caii_global_emerg_type *) rec_ptr)->num_incl  )
             {
               b_packb(1, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
               msg_pos += FSIZ( cai_rec_hdr_type, record_len);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_incl,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix1_type, num_incl ));
               msg_pos += FSIZ(cai_global_emerg_fix1_type, num_incl);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->ms_orig_pos_loc_ind,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_var2_type, ms_orig_pos_loc_ind ));
               msg_pos += FSIZ(cai_global_emerg_var2_type, ms_orig_pos_loc_ind);

               b_packb( 0, buf_ptr, msg_pos, 6 );
               msg_pos += 6;

               /* that's all */
             }
             else /* digits included */
             {
               rec_len_pos = msg_pos;

               /* save the space for record length */
               msg_pos += FSIZ( cai_rec_hdr_type, record_len);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_incl,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix1_type, num_incl ));
                 msg_pos += FSIZ(cai_global_emerg_fix1_type, num_incl);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->digit_mode,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, digit_mode ));
                 msg_pos += FSIZ(cai_global_emerg_fix2_type, digit_mode);

               if (((caii_global_emerg_type *) rec_ptr)->digit_mode)
               {
                 b_packb( ((caii_global_emerg_type *) rec_ptr)->number_type,
                     buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, number_type ));
                   msg_pos += FSIZ(cai_global_emerg_fix2_type, number_type);

                 b_packb( ((caii_global_emerg_type *) rec_ptr)->number_plan,
                     buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, number_plan ));
                   msg_pos += FSIZ(cai_global_emerg_fix2_type, number_plan);
               }

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_char,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, num_char ));
                 msg_pos += FSIZ(cai_global_emerg_fix2_type, num_char);

               for (j=0;
                    j < ((caii_global_emerg_type *) rec_ptr)->num_char; j++)
               {
                   if (((caii_global_emerg_type *) rec_ptr)->digit_mode)
                   {
                     b_packb( ((caii_global_emerg_type *) rec_ptr)->chari[j], buf_ptr,
                              msg_pos, FSIZ( cai_orig_var_type, char8 ));
                     msg_pos += FSIZ( cai_orig_var_type, char8 );
                   }
                   else
                   {
                     b_packb( ((caii_global_emerg_type *) rec_ptr)->chari[j], buf_ptr,
                              msg_pos, 4);
                     msg_pos += 4;
                   }
               }

               b_packb( ((caii_global_emerg_type *) rec_ptr)->ms_orig_pos_loc_ind,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_var2_type, ms_orig_pos_loc_ind ));
               msg_pos += FSIZ(cai_global_emerg_var2_type, ms_orig_pos_loc_ind);

               reserv_len = (msg_pos - rec_len_pos ) % 8;
               if (reserv_len != 0)
               {
                 reserv_len = 8 - reserv_len;
                 b_packb( 0, buf_ptr, msg_pos, reserv_len );
                 msg_pos += reserv_len;
               }

               /* put length (byte)(msg_pos - rec_len_pos) */
               b_packb( (int)(((msg_pos - rec_len_pos ) / 8) - 1) ,
                 buf_ptr, rec_len_pos, FSIZ( cai_rec_hdr_type, record_len ));

             } /* digits included */
          } /* REL A */
          rec_ptr += sizeof (caii_global_emerg_type); /*lint !e662 */
          break;
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_C
        /* -------------------------------------------
        ** Extended Keypad Facility Information Record
        ** ------------------------------------------- */
        case CAI_EXT_KEYPAD_REC:
          {
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              /* Compute record length, add in reserved bits */
              if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
              {
                rec_len = sizeof(cai_ext_keypad_facility_info_fix_type) +
                          (sizeof(cai_ext_keypad_facility_info_var_type) * 
                           ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields) + 2;
              }
              else
              {
                rec_len = FSIZ(cai_ext_keypad_facility_info_fix_type, number_info_incl) +
                          FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields) +
                          (sizeof(cai_ext_keypad_facility_info_var_type) * 
                           ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields) + 1;
              }

              if ( msg_pos + rec_len > CAI_REV_TC_MSG_BODY_SIZE )
              {
                status = CAIX_INV_LEN_S;
              }
              else
              {
                /* Pack record length */
                b_packb(rec_len / 8, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));     
                msg_pos += FSIZ( cai_rec_hdr_type, record_len); 

                /* Add other record fields */
                b_packb( ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl,
                         buf_ptr, msg_pos,
                         FSIZ( cai_ext_keypad_facility_info_fix_type, number_info_incl ));
                msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, number_info_incl);   

                if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
                {
                  b_packb( ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_type,
                           buf_ptr, msg_pos,
                           FSIZ(cai_ext_keypad_facility_info_fix_type , number_type ));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, number_type);

                  b_packb( ((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.number_plan,
                           buf_ptr, msg_pos,
                           FSIZ(cai_ext_keypad_facility_info_fix_type , number_plan));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type , number_plan);
                }

                b_packb(((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.num_fields, 
                        buf_ptr, msg_pos,
                        FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields));
                msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields);

                for (j=0; j < ((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.num_fields; j++)
                {
                  b_packb(((caii_ext_keypad_facility_info_type *)rec_ptr)->var[j].chari, 
                          buf_ptr, msg_pos,
                          FSIZ(cai_ext_keypad_facility_info_var_type, chari));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_var_type, chari);
                }

                if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
                {
                  /* There are two reserved bits if number_info_incl is 1 */
                  b_packb(0, buf_ptr, msg_pos, 2);
                  msg_pos += 2;
                }
                else
                {
                  /* Otherwise, there is 1 */
                  b_packb(0, buf_ptr, msg_pos, 1);
                  msg_pos += 1;
                }

              }
            } /* REL C*/

            rec_ptr += sizeof(caii_ext_keypad_facility_info_fix_type) +
                       (sizeof(caii_ext_keypad_facility_info_var_type) * 
                        ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields);

            break;
          } /* CAI_EXT_KEYPAD_REC */

#endif /* FEATURE_IS2000_REL_C */ 

        default:
          status = CAIX_INV_MSG_S;
          break;
      } /* end switch (((caii_rec_hdr_type *) rec_ptr)->record_type) */

      rec_ptr = (byte*)ALIGN_DWORD(((dword)rec_ptr));
    }
  } /* end for loop */

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->flash.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->flash.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->flash.hdr.msg_int.sdu_key_id,
                   int_ptr->flash.msg_type,
                   int_ptr->flash.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->flash.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;

  return (status);

} /* xlate_int_flash */

/*===========================================================================

FUNCTION XLATE_INT_TC_TMSI_CMP

DESCRIPTION
  This function translates a Reverse Traffic Channel TMSI Assignment
  Completion Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_tmsi_cmp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos = 0;
  /* Position to pack message in */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_rtc_tmsi_cmp_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tc_tmsi_cmp);

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->tc_tmsi_cmp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tc_tmsi_cmp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tc_tmsi_cmp.hdr.msg_int.sdu_key_id,
                   int_ptr->tc_tmsi_cmp.msg_type,
                   int_ptr->tc_tmsi_cmp.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->tc_tmsi_cmp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
#ifdef FEATURE_IS2000_REL_A
  *len_ptr = msg_pos;
#else 
  *len_ptr = FENDPOS(cai_rtc_tmsi_cmp_type, reserved);
#endif /* FEATURE_IS2000_REL_A */

  #undef MTYPE

  return (status);

} /* xlate_int_tc_tmsi_cmp */

/*===========================================================================

FUNCTION XLATE_INT_TC_BURST

DESCRIPTION
  This function translates a Traffic Channel Data Burst Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_burst
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
   /* Index to loop through character fields */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_rev_tc_burst_type

  if (int_ptr->tc_burst.num_fields > CAI_REV_TC_BURST_MAX)
  {
    status = CAIX_INV_LEN_S;
  }
  else 
  {
   /* ------------
   ** Pack message
   ** ------------ */

   /* ---------------------------------------------------------
   ** Pack message type, ARQ, encryption, message integrity and 
   ** extended-encryption fields.
   ** --------------------------------------------------------- */
   xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tc_burst );

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

   b_packb(int_ptr->tc_burst.msg_number, buf_ptr, msg_pos,
     FSIZ(MTYPE, fix.msg_number));
   msg_pos += FSIZ(MTYPE, fix.msg_number);

   b_packb(int_ptr->tc_burst.burst_type, buf_ptr, msg_pos,
     FSIZ(MTYPE, fix.burst_type));
   msg_pos += FSIZ( MTYPE, fix.burst_type);

   b_packb(int_ptr->tc_burst.num_msgs, buf_ptr, msg_pos,
     FSIZ(MTYPE, fix.num_msgs));
   msg_pos += FSIZ(MTYPE, fix.num_msgs);

   b_packb(int_ptr->tc_burst.num_fields, buf_ptr, msg_pos,
     FSIZ( MTYPE, fix.num_fields));
   msg_pos += FSIZ(MTYPE, fix.num_fields);

   for (i=0; i < int_ptr->tc_burst.num_fields; i++)
   { 
     b_packb(int_ptr->tc_burst.chari[i], buf_ptr, msg_pos, FSIZ(MTYPE, var[i]));
     msg_pos += FSIZ(MTYPE, var[i]);
   }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
   /* Pack MACI field */
   if (int_ptr->tc_burst.hdr.msg_int.maci_incl)
   {
     xlate_int_maci(&msg_pos,
                    buf_ptr,
                    CAI_TC_CRC_SIZE,
                    int_ptr->tc_burst.hdr.ack_req,
                    CAIX_TC,
                    int_ptr->tc_burst.hdr.msg_int.sdu_key_id,
                    int_ptr->tc_burst.msg_type,
                    int_ptr->tc_burst.hdr.msg_int.sdu_integrity_algo,
                    #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                    #endif /* FEATURE_IS2000_REL_C_MI */
                    &int_ptr->tc_burst.hdr.msg_int.maci
                    );
   }
#endif /* FEATURE_IS2000_REL_C */

   /* Set message length */
   *len_ptr = msg_pos;
  }

  #undef MTYPE

  return (status);

} /* xlate_int_tc_burst */

/*===========================================================================

FUNCTION XLATE_INT_PIL_STR

DESCRIPTION
  This function translates a Traffic Channel Pilot Strength Measurement
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_pil_str
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through pn pilots */
  word msg_pos = 0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_pil_str_type

  if (int_ptr->pil_str.num_msr > CAI_PIL_STR_MAX)
  {
    status = CAIX_INV_LEN_S;
  }
  else 
  {
    /* ------------
    ** Pack message
    ** ------------ */

    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and 
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->pil_str);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packw( int_ptr->pil_str.ref_pn, buf_ptr, msg_pos,
             FSIZ(cai_pil_str_type, fix.ref_pn));
    msg_pos += FSIZ(cai_pil_str_type, fix.ref_pn) ;

    b_packb( int_ptr->pil_str.pilot_strength, buf_ptr, msg_pos,
             FSIZ(cai_pil_str_type, fix.pilot_strength));
    msg_pos += FSIZ(cai_pil_str_type, fix.pilot_strength) ;

    b_packb( int_ptr->pil_str.keep, buf_ptr, msg_pos,
             FSIZ(cai_pil_str_type, fix.keep));
    msg_pos += FSIZ(cai_pil_str_type, fix.keep) ;

    for (i=0; i < int_ptr->pil_str.num_msr; i++)
    {
      b_packw( int_ptr->pil_str.meas[i].pilot_pn_phase, buf_ptr, msg_pos,
               FSIZ( cai_pil_str_type, var[i].pilot_pn_phase ));
      msg_pos += FSIZ(cai_pil_str_type, var[i].pilot_pn_phase) ;

      b_packb( int_ptr->pil_str.meas[i].pilot_strength, buf_ptr, msg_pos,
               FSIZ( cai_pil_str_type, var[i].pilot_strength ));
      msg_pos += FSIZ(cai_pil_str_type, var[i].pilot_strength) ;

      b_packb( int_ptr->pil_str.meas[i].keep, buf_ptr, msg_pos,
               FSIZ( cai_pil_str_type, var[i].keep ));
      msg_pos += FSIZ(cai_pil_str_type, var[i].keep) ;

    }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->pil_str.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&msg_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->pil_str.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->pil_str.hdr.msg_int.sdu_key_id,
                     int_ptr->pil_str.msg_type,
                     int_ptr->pil_str.hdr.msg_int.sdu_integrity_algo,
                     #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                     #endif /* FEATURE_IS2000_REL_C_MI */
                     &int_ptr->pil_str.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */
  
    /* Set message length */
    *len_ptr = msg_pos;
  }

  #undef MTYPE

  return (status);

} /* xlate_int_pil_str */

/*===========================================================================

FUNCTION XLATE_INT_PWR_MSR

DESCRIPTION
  This function translates a Traffic Channel Power Measurement Report
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_pwr_msr
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_pwr_rpt_type

  #define MTYPE_2000 cai_pwr_rpt_2000_type

  if (int_ptr->pwr_rpt.num_pilots > CAI_PWR_MAX) 
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------
    ** Pack message
    ** ------------ */

    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and 
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->pwr_rpt);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb(int_ptr->pwr_rpt.errors_detected, buf_ptr, msg_pos, 
      FSIZ(MTYPE, fix.errors_detected));
    msg_pos += FSIZ(MTYPE, fix.errors_detected);

    b_packw(int_ptr->pwr_rpt.pwr_meas_frames, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.pwr_meas_frames));
    msg_pos += FSIZ(MTYPE, fix.pwr_meas_frames);

    b_packb(int_ptr->pwr_rpt.last_hdm_seq, buf_ptr, msg_pos, 
      FSIZ(MTYPE, fix.last_hdm_seq));
    msg_pos += FSIZ(MTYPE, fix.last_hdm_seq);

    b_packb(int_ptr->pwr_rpt.num_pilots, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.num_pilots));
    msg_pos += FSIZ(MTYPE, fix.num_pilots);

    for (i=0; i < int_ptr->pwr_rpt.num_pilots;i++)
    {
      b_packb(int_ptr->pwr_rpt.pilot_strength[i], buf_ptr, msg_pos,
        FSIZ(MTYPE, var[i].pilot_strength));
      msg_pos += FSIZ(MTYPE, var[i].pilot_strength);
    }

    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
    {
      b_packb(int_ptr->pwr_rpt.dcch_pwr_meas_incl, buf_ptr, msg_pos, 
        FSIZ(MTYPE_2000, dcch_pwr_meas_incl));
      msg_pos += FSIZ(MTYPE_2000, dcch_pwr_meas_incl);

      if (int_ptr->pwr_rpt.dcch_pwr_meas_incl)
      {
        b_packw(int_ptr->pwr_rpt.dcch_pwr_meas_frames, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, dcch_pwr_meas_frames));
        msg_pos += FSIZ(MTYPE_2000, dcch_pwr_meas_frames);

        b_packb(int_ptr->pwr_rpt.dcch_errors_detected, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, dcch_errors_detected) );
        msg_pos += FSIZ(MTYPE_2000, dcch_errors_detected);
      }

      b_packb(int_ptr->pwr_rpt.sch_pwr_meas_incl, buf_ptr, msg_pos,
        FSIZ(MTYPE_2000, sch_pwr_meas_incl));
      msg_pos += FSIZ(MTYPE_2000, sch_pwr_meas_incl);

      if (int_ptr->pwr_rpt.sch_pwr_meas_incl)
      {
        b_packb(int_ptr->pwr_rpt.sch_id, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, sch_id) );
        msg_pos += FSIZ(MTYPE_2000, sch_id);

        b_packw(int_ptr->pwr_rpt.sch_pwr_meas_frames, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, sch_pwr_meas_frames));
        msg_pos += FSIZ(MTYPE_2000, sch_pwr_meas_frames);

        b_packw(int_ptr->pwr_rpt.sch_errors_detected, buf_ptr, msg_pos,
          FSIZ(MTYPE_2000, sch_errors_detected));
        msg_pos += FSIZ(MTYPE_2000, sch_errors_detected);
      }
    } // if (caix_p_rev_ ..)

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->pwr_rpt.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&msg_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->pwr_rpt.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->pwr_rpt.hdr.msg_int.sdu_key_id,
                     int_ptr->pwr_rpt.msg_type,
                     int_ptr->pwr_rpt.hdr.msg_int.sdu_integrity_algo,
                     #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                     #endif /* FEATURE_IS2000_REL_C_MI */
                     &int_ptr->pwr_rpt.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */
      
    /* Set message length */
    *len_ptr = msg_pos;
  }  /* else pilot num > ... */

  #undef MTYPE
  #undef MTYPE_2000

  return (status);

} /* xlate_int_pwr_msr */

/*===========================================================================

FUNCTION XLATE_INT_SEND_DTMF

DESCRIPTION
  This function translates a Traffic Channel Send Burst DTMF Message
  from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_send_dtmf
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through dtmf digits */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_sbdtmf_type

  if (int_ptr->sbdtmf.num_digits > CAI_SBDTMF_MAX)  /*lint !e685 */
  {
    status = CAIX_INV_LEN_S;
  }
  else 
  {
    /* ------------
    ** Pack message
    ** ------------ */

    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and 
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->sbdtmf);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb(int_ptr->sbdtmf.num_digits, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.num_digits));
    msg_pos += FSIZ(MTYPE, fix.num_digits);

    b_packb(int_ptr->sbdtmf.dtmf_on_length, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.dtmf_on_length));
    msg_pos += FSIZ(MTYPE, fix.dtmf_on_length);

    b_packb(int_ptr->sbdtmf.dtmf_off_length, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.dtmf_off_length));
    msg_pos += FSIZ(MTYPE, fix.dtmf_off_length);

    for (i=0; i < int_ptr->sbdtmf.num_digits; i++)
    {
      b_packb(int_ptr->sbdtmf.digit[i], buf_ptr, msg_pos, FSIZ( MTYPE, var[i]));
      msg_pos += FSIZ( MTYPE, var[i] );
    }
#ifdef FEATURE_IS2000_REL_A
    if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
    {
      b_packb(int_ptr->sbdtmf.con_ref_incl, buf_ptr, msg_pos,
        FSIZ(MTYPE, fix2.con_ref_incl));
      msg_pos += FSIZ(MTYPE, fix2.con_ref_incl);

      if (int_ptr->sbdtmf.con_ref_incl)
      {
        b_packb(int_ptr->sbdtmf.con_ref, buf_ptr, msg_pos,
          FSIZ(MTYPE, fix2.con_ref));
        msg_pos +=  FSIZ(MTYPE, fix2.con_ref);
      }
    }

    #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
    #endif /* FEATURE_IS2000_REL_A_AES */
    
#endif /* FEATURE_IS2000_REL_A */
      
#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->sbdtmf.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&msg_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->sbdtmf.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->sbdtmf.hdr.msg_int.sdu_key_id,
                     int_ptr->sbdtmf.msg_type,
                     int_ptr->sbdtmf.hdr.msg_int.sdu_integrity_algo,
                     #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                     #endif /* FEATURE_IS2000_REL_C_MI */
                     &int_ptr->sbdtmf.hdr.msg_int.maci
                     );
    }
 #endif /* FEATURE_IS2000_REL_C */
    
    /* Set message length */
    *len_ptr = msg_pos;
  } /* length check */

  #undef MTYPE

  return (status);

} /* xlate_int_send_dtmf */

/*===========================================================================

FUNCTION XLATE_INT_STATUS

DESCRIPTION
  This function translates a Status Message from internal to external
  format.

DEPENDENCIES
  Depends on the internal message type having the correct number of variable
  record parts.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_status
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word msg_pos = 0;
    /* Position to pack message in */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, of external info rec. */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->status);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */


#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else

  status = xlate_int_info_rec((byte*) int_ptr->status.recs, &irec_len,
                              CAI_REV_TC_MSG_BODY_SIZE - msg_pos - 7, /* 7 reserved bits */
                              buf_ptr, msg_pos, &xrec_len);
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  if (status == CAIX_DONE_S)
  {
    msg_pos += xrec_len; /* Move to end of info rec */
    //b_packb(0, buf_ptr, msg_pos, 7); /* Add 7 reserved bits */
    //msg_pos += 7;
  }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->status.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->status.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->status.hdr.msg_int.sdu_key_id,
                   int_ptr->status.msg_type,
                   int_ptr->status.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->status.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
    
  /* Set message length */
  *len_ptr = msg_pos;

  return (status);

} /* xlate_int_status */

/*===========================================================================

FUNCTION XLATE_INT_ORIG_C

DESCRIPTION
  This function translates an Origination Continuation Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_orig_c
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index through dialed digits */
  word msg_pos = 0;
    /* Position to pack field in buffer */
  word j;
    /* Index to loop through characters */
  byte *rec_ptr;
    /* Pointer to internal format information record */
  #ifdef FEATURE_AUTH
  word start_enc_pos;
    /* Start point of fields that might require encryption using CMEA */
  #endif /* FEATURE_AUTH */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_orig_c_type

  /* -------------------------------------------------------------------
  ** Make sure that number of digits in msg does not exceed valid limits
  ** ------------------------------------------------------------------- */
  if (int_ptr->orig_c.num_fields > CAI_ORIG_C_MAX)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and 
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->orig_c);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

   b_packb(int_ptr->orig_c.digit_mode, buf_ptr, msg_pos,
     FSIZ(MTYPE, fix.digit_mode));
   msg_pos += FSIZ(MTYPE, fix.digit_mode);

   b_packb(int_ptr->orig_c.num_fields, buf_ptr, msg_pos,
     FSIZ(MTYPE, fix.num_fields));
   msg_pos += FSIZ(MTYPE, fix.num_fields);

   for (i=0; i < int_ptr->orig_c.num_fields; i++)
   {
     if (int_ptr->orig_c.digit_mode)
     {
       /* --------------------
       ** Pack digits in ASCII
       ** -------------------- */
       b_packb(int_ptr->orig_c.chari[i], buf_ptr, msg_pos,
         FSIZ(cai_orig_c_var_type, digit8));
       msg_pos += FSIZ(cai_orig_c_var_type, digit8);
     }
     else
     {
       /* ---------------------
       ** Pack digits in 4 bits
       ** --------------------- */
       b_packb(int_ptr->orig_c.chari[i], buf_ptr, msg_pos,
         FSIZ(cai_orig_c_var_type, digit4));
       msg_pos += FSIZ(cai_orig_c_var_type, digit4);
     }
   } /* for */

#ifdef FEATURE_AUTH
   if (int_ptr->orig_c.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS &&
       int_ptr->orig_c.num_fields > 0)
   {
     /* We've finished with digits, now its time to encrypt them */
     auth_encrypt_orig_c(&msg_pos, buf_ptr, int_ptr);
   }
   start_enc_pos = msg_pos;
#endif /* FEATURE_AUTH */


   rec_ptr = (byte*)(&int_ptr->orig_c.recs[0]);

   #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
   #endif /* FEATURE_MSG_PACK_UNIT_TEST */

   for (i=0; (i < int_ptr->orig_c.num_recs) && (status == CAIX_DONE_S); i++)
   {
     /* ----------------------------------------------------
     ** Check to make sure that there is room for the header
     ** ---------------------------------------------------- */
     if ((msg_pos + sizeof( cai_rec_hdr_type )) > CAI_REV_TC_MSG_BODY_SIZE)
     {
       status = CAIX_INV_LEN_S;
     }
     else
     {
       b_packb(((caii_rec_hdr_type *) rec_ptr)->record_type,
         buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_type));
       msg_pos += FSIZ( cai_rec_hdr_type, record_type);

       switch (((caii_rec_hdr_type *) rec_ptr)->record_type)
       {
         /* -------------------------------------------
         ** Called Party Subaddress Informatin Record
         ** Calling Party Subaddress Informatin Record
         ** Connected Subaddress Informatin Record
         ** ------------------------------------------- */
         case CAI_REV_CALLED_SUB_REC:
         case CAI_REV_CALLING_SUB_REC:
           /* ----------------------------------------------------
           ** RECORD_LEN = Number of CHARI fields + 1 (8 bits)
           ** ---------------------------------------------------- */
           b_packb((byte) (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char + 1),
             buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len));
           msg_pos += FSIZ(cai_rec_hdr_type, record_len);

           if ((msg_pos + sizeof( cai_subaddr_fix_type ) +
               (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char *
                FSIZ( cai_subaddr_var_type, chari ))) > CAI_REV_TC_MSG_BODY_SIZE)
           {
             status = CAIX_INV_LEN_S;
           }
           else
           {
             b_packb(((caii_subaddr_rec_type *) rec_ptr)->fix.extension_bit,
               buf_ptr, msg_pos, FSIZ(cai_subaddr_fix_type, extension_bit));
             msg_pos += FSIZ(cai_subaddr_fix_type, extension_bit);

             b_packb(((caii_subaddr_rec_type *)rec_ptr)->fix.subadd_type,
               buf_ptr, msg_pos, FSIZ(cai_subaddr_fix_type, subadd_type));
             msg_pos += FSIZ(cai_subaddr_fix_type, subadd_type);

             b_packb(((caii_subaddr_rec_type *)rec_ptr)->fix.odd_even_ind,
               buf_ptr, msg_pos, FSIZ(cai_subaddr_fix_type, odd_even_ind));
             msg_pos += FSIZ(cai_subaddr_fix_type, odd_even_ind);

             /* -----------------------
             ** Pack 0 for reserved bit
             ** ----------------------- */
             b_packb(0, buf_ptr, msg_pos, 3);
             msg_pos += 3;

             for (j=0; j < ((caii_subaddr_rec_type *) rec_ptr)->fix.num_char; j++)
             {
               b_packb(((caii_subaddr_rec_type *) rec_ptr)->var[j], buf_ptr,
                 msg_pos, FSIZ(cai_subaddr_var_type, chari));
               msg_pos += FSIZ(cai_subaddr_var_type, chari);
             }

             if (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char == 0) 
             {
               rec_ptr += FSIZ(caii_subaddr_rec_type, fix ); /*lint !e662 */
             }
             else 
             {
               rec_ptr += FENDPOS(caii_subaddr_rec_type,
                 var[((caii_subaddr_rec_type *) rec_ptr)->fix.num_char - 1]);
             }
           }
           break;

         case CAI_REV_CALLING_REC:
           /* -----------------------------------------------------
           ** RECORD_LEN = Number of CHARI fields + 2 (16 bits) for
           ** NUMBER_TYPE, NUMBER_PLAN, PI, SI and RESERVED fields
           ** ----------------------------------------------------- */
           b_packb((byte) (((caii_calling_rec_type *) rec_ptr)->fix.num_char + 2),
             buf_ptr, msg_pos, FSIZ(cai_rec_hdr_type, record_len));
           msg_pos += FSIZ(cai_rec_hdr_type, record_len);

           if ((msg_pos + sizeof( cai_calling_fix_type ) +
               (((caii_calling_rec_type *) rec_ptr)->fix.num_char *
                FSIZ( cai_calling_var_type, chari )) + 5) > CAI_REV_TC_MSG_BODY_SIZE)
           {
             status = CAIX_INV_LEN_S;
           }
           else 
           {
             b_packb(((caii_calling_rec_type *) rec_ptr)->fix.number_type,
               buf_ptr, msg_pos, FSIZ(cai_calling_fix_type, number_type));
             msg_pos += FSIZ(cai_calling_fix_type, number_type);

             b_packb(((caii_calling_rec_type *) rec_ptr)->fix.number_plan,
               buf_ptr, msg_pos, FSIZ(cai_calling_fix_type, number_plan));
             msg_pos += FSIZ(cai_calling_fix_type, number_plan);

             b_packb(((caii_calling_rec_type *) rec_ptr)->fix.pi,
               buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, pi));
             msg_pos += FSIZ(cai_calling_fix_type, pi);

             b_packb(((caii_calling_rec_type *) rec_ptr)->fix.si,
               buf_ptr, msg_pos, FSIZ(cai_calling_fix_type, si));
             msg_pos += FSIZ(cai_calling_fix_type, si);

             for (j=0; j < ((caii_calling_rec_type *) rec_ptr)->fix.num_char; j++)
             {
               b_packb(((caii_calling_rec_type *) rec_ptr)->var[j],
                 buf_ptr, msg_pos, FSIZ( cai_calling_var_type, chari));
                msg_pos += FSIZ(cai_calling_var_type, chari);
             }

             /* ------------------------
             ** Pack 0 for reserved bits
             ** ------------------------ */
             b_packb(0, buf_ptr, msg_pos, 5);
             msg_pos += 5;

             if (((caii_calling_rec_type *) rec_ptr)->fix.num_char == 0) 
             {
               rec_ptr += FSIZ(caii_calling_rec_type, fix); /*lint !e662 */
             }
             else
             {
               rec_ptr += FENDPOS(caii_calling_rec_type,
                 var[((caii_calling_rec_type *) rec_ptr)->fix.num_char - 1]);
             }
           }
           break;

         default:
           status = CAIX_INV_MSG_S;
           break;
       } /* end switch (((caii_rec_hdr_type *) rec_ptr)->record_type) */

       rec_ptr = (byte*)ALIGN_DWORD(((dword)rec_ptr));
     }
   } /* end for loop */

#ifdef FEATURE_AUTH
   /* This is the encryption of the info record part. */
   if (int_ptr->orig_c.num_recs > 0 &&
       int_ptr->orig_c.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS)
   {
     auth_encrypt_info_recs(&msg_pos, buf_ptr, int_ptr,
       start_enc_pos, int_ptr->orig_c.num_recs );
   }
#endif /* FEATURE_AUTH */

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
   /* Pack MACI field */
   if (int_ptr->orig_c.hdr.msg_int.maci_incl)
   {
     xlate_int_maci(&msg_pos,
                    buf_ptr,
                    CAI_TC_CRC_SIZE,
                    int_ptr->orig_c.hdr.ack_req,
                    CAIX_TC,
                    int_ptr->orig_c.hdr.msg_int.sdu_key_id,
                    int_ptr->orig_c.msg_type,
                    int_ptr->orig_c.hdr.msg_int.sdu_integrity_algo,
                    #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                    #endif /* FEATURE_IS2000_REL_C_MI */
                    &int_ptr->orig_c.hdr.msg_int.maci
                    );
   }
#endif /* FEATURE_IS2000_REL_C */

   /* -------------------------
   ** Fill in length of message
   ** ------------------------- */
   *len_ptr = msg_pos;

  }

  #undef MTYPE 
  
  return (status);

} /*xlate_int_orig_c */

/*===========================================================================

FUNCTION XLATE_INT_COMP

DESCRIPTION
  This function translates a Handoff Completion Message from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_comp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through pilots */
  word msg_pos = 0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_comp_type

  /* --------------------------------------
  ** Make sure message is of minimum length
  ** -------------------------------------- */
  if (int_ptr->comp.num_pilots == 0) 
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ------------
    ** Pack message
    ** ------------ */

    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and 
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->comp);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb(int_ptr->comp.last_hdm_seq, buf_ptr, msg_pos,
      FSIZ(MTYPE, fix.last_hdm_seq));
    msg_pos += FSIZ(MTYPE, fix.last_hdm_seq);

    for (i=0; i < int_ptr->comp.num_pilots; i++)
    {
      b_packw(int_ptr->comp.pilot_pn[i], buf_ptr, msg_pos,
        FSIZ(MTYPE, var[i].pilot_pn));
      msg_pos += FSIZ(MTYPE, var[i].pilot_pn);
    } 

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->comp.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&msg_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->comp.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->comp.hdr.msg_int.sdu_key_id,
                     int_ptr->comp.msg_type,
                     int_ptr->comp.hdr.msg_int.sdu_integrity_algo,
                     #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                     #endif /* FEATURE_IS2000_REL_C_MI */
                     &int_ptr->comp.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */

    /* Set message length */
    *len_ptr = msg_pos;

  } /* else for the length check */

  #undef MTYPE
  
  return (status);

} /* xlate_int_comp */

/*===========================================================================

FUNCTION XLATE_INT_PARM_RSP

DESCRIPTION
  This function translates a Parameters Response Message from internal to
  external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_parm_rsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word i;
    /* Index to loop through parameters */
  word buf_pos = 0;
    /* Position in message in which to pack next field */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_parm_rsp_type

  /* --------------------------------------
  ** Make sure message is of minimum length
  ** -------------------------------------- */
  if (int_ptr->parm_rsp.num_parms == 0)
  {
    status = CAIX_INV_LEN_S;
  }
  else
  {
    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and 
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&buf_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->parm_rsp);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    /* ------------------------
    ** Pack array of parameters
    ** ------------------------ */
    for (i=0; i < int_ptr->parm_rsp.num_parms; i++)
    {
      b_packw(int_ptr->parm_rsp.parms[i].parameter_id, buf_ptr,
        buf_pos, FSIZ(MTYPE, var.parameter_id));
      buf_pos += FSIZ(MTYPE, var.parameter_id);

      b_packw(int_ptr->parm_rsp.parms[i].parameter_len, buf_ptr,
        buf_pos, FSIZ(MTYPE, var.parameter_len));
      buf_pos += FSIZ(MTYPE, var.parameter_len);

      /* ---------------------------------------------------------
      ** If parameter_len = '11 1111 1111' this is an unsupported
      ** or unrecognized parameter, so we omit the PARAMETER field
      ** (See IS-95A 6.7.2.3.2.11).
      ** --------------------------------------------------------- */
      if (int_ptr->parm_rsp.parms[i].parameter_len != 0x3ff)
      {
        if (int_ptr->parm_rsp.parms[i].parameter_len > 31)
        {
          b_packq(int_ptr->parm_rsp.parms[i].parameter.parm_q,
            buf_ptr, buf_pos, int_ptr->parm_rsp.parms[i].parameter_len + 1);
        }
        else if (int_ptr->parm_rsp.parms[i].parameter_len > 15)
        {
          b_packd(int_ptr->parm_rsp.parms[i].parameter.parm_d,
            buf_ptr, buf_pos, int_ptr->parm_rsp.parms[i].parameter_len + 1);
        }
        else if (int_ptr->parm_rsp.parms[i].parameter_len > 7)
        {
          b_packw(int_ptr->parm_rsp.parms[i].parameter.parm_w,
            buf_ptr, buf_pos, int_ptr->parm_rsp.parms[i].parameter_len + 1);
        }
        else
        {
          b_packb(int_ptr->parm_rsp.parms[i].parameter.parm_b,
            buf_ptr, buf_pos, int_ptr->parm_rsp.parms[i].parameter_len + 1);
        }

        /* -----------------------------------------
        ** Adjust buffer position for next parameter
        ** ----------------------------------------- */
        buf_pos += int_ptr->parm_rsp.parms[i].parameter_len + 1;

      } /* end if (supported parameter) */
    } /* for */

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->parm_rsp.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&buf_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->parm_rsp.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->parm_rsp.hdr.msg_int.sdu_key_id,
                     int_ptr->parm_rsp.msg_type,
                     int_ptr->parm_rsp.hdr.msg_int.sdu_integrity_algo,
                     #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                     #endif /* FEATURE_IS2000_REL_C_MI */
                     &int_ptr->parm_rsp.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */

  }  /* else for the message length check */

  *len_ptr = buf_pos;

  #undef MTYPE
  
  return (status);

} /* xlate_int_parm_rsp */

/*===========================================================================

FUNCTION XLATE_INT_SRV_REQ

DESCRIPTION
  This function translates a Service Request Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_req
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word cfg_len;
    /* To receive length of imbedded service config record. */
  word msg_pos = 0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_rtc_srv_req_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->srv_req);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->srv_req.req_seq, buf_ptr, msg_pos, FSIZ(MTYPE, req_seq));
  msg_pos += FSIZ(MTYPE, req_seq);

  b_packb(int_ptr->srv_req.purp, buf_ptr, msg_pos, FSIZ(MTYPE, purp));
  msg_pos += FSIZ(MTYPE, purp);

  if (int_ptr->srv_req.purp == CAI_SRV_PRO_PURP)
  {
    status = xlate_int_srv_cfg(&cfg_len, buf_ptr, msg_pos, &int_ptr->srv_req.cfg);
    if ( status == CAIX_DONE_S )
    {
      msg_pos += cfg_len;
    }
  }
  
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->srv_req.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->srv_req.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->srv_req.hdr.msg_int.sdu_key_id,
                   int_ptr->srv_req.msg_type,
                   int_ptr->srv_req.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->srv_req.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE
  
  return (status);

} /* xlate_int_srv_req */

/*===========================================================================

FUNCTION XLATE_INT_SRV_RSP

DESCRIPTION
  This function translates a Service Response Message from internal
  to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_rsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be translated */
)
{
  word status = CAIX_DONE_S;
    /* Status to be returned to calling procedure */
  word cfg_len;
    /* To receive length of imbedded service config record. */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_rtc_srv_rsp_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->srv_rsp);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->srv_rsp.req_seq, buf_ptr, msg_pos, FSIZ(MTYPE,  req_seq));
  msg_pos += FSIZ(MTYPE, req_seq);
    
  b_packb(int_ptr->srv_rsp.purp, buf_ptr, msg_pos, FSIZ( MTYPE,  purp));
  msg_pos += FSIZ(MTYPE, purp);

  if (int_ptr->srv_rsp.purp == CAI_SRV_PRO_PURP)
  {
    status = xlate_int_srv_cfg(&cfg_len, buf_ptr, msg_pos, &int_ptr->srv_rsp.cfg);

    if ( status == CAIX_DONE_S )
    {
      msg_pos += cfg_len;
      /* If service config record translation successful, add in
         length of configuration record */
    }
  }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->srv_rsp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->srv_rsp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->srv_rsp.hdr.msg_int.sdu_key_id,
                   int_ptr->srv_rsp.msg_type,
                   int_ptr->srv_rsp.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->srv_rsp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_srv_rsp */

/*===========================================================================

FUNCTION XLATE_INT_SRV_CMP

DESCRIPTION
  This function translates a Service Connect Completion Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_cmp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
  /* Status to be returned to calling procedure */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_srv_cmp_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->srv_cmp);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(0, buf_ptr, msg_pos, FSIZ( cai_srv_cmp_type, reserved1));
  msg_pos += FSIZ(cai_srv_cmp_type, reserved1);

  b_packb(int_ptr->srv_cmp.con_seq, buf_ptr, msg_pos, 
    FSIZ(cai_srv_cmp_type, con_seq));
  msg_pos += FSIZ(cai_srv_cmp_type, con_seq);

  /* No need to pad here, it is done in TXC or in int_maci as needed */
  //b_packb(0, buf_ptr, msg_pos, FSIZ(cai_srv_cmp_type, reserved));
  //msg_pos += FSIZ(cai_srv_cmp_type, reserved);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->srv_cmp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->srv_cmp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->srv_cmp.hdr.msg_int.sdu_key_id,
                   int_ptr->srv_cmp.msg_type,
                   int_ptr->srv_cmp.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->srv_cmp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
   
  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

return (status);

} /* xlate_int_srv_cmp */

/*===========================================================================

FUNCTION XLATE_INT_SRV_CTL

DESCRIPTION
  This function translates a Service Option Control Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_srv_ctl
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word  status = CAIX_DONE_S;
    /* For returning status to caller */
  word  i;
    /* For indexing through type specific fields */
  word msg_pos=0;
  /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_rtc_srv_ctl_type

  if (int_ptr->srv_ctl.tsf_len > CAI_RTC_SRV_CTL_MAX)
  {
    status = CAIX_INV_MSG_S;
      /* Type specific field is too big. */
  }
  else
  {
    /* ---------------------------------------------------------
    ** Pack message type, ARQ, encryption, message integrity and 
    ** extended-encryption fields.
    ** --------------------------------------------------------- */
    xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->srv_ctl);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

    b_packb(int_ptr->srv_ctl.con_ref, buf_ptr, msg_pos, FSIZ(MTYPE, fix.con_ref));
    msg_pos += FSIZ(MTYPE, fix.con_ref);

    b_packw(int_ptr->srv_ctl.so, buf_ptr, msg_pos, FSIZ(MTYPE, fix.so));
    msg_pos += FSIZ(MTYPE, fix.so);

    b_packb(0, buf_ptr, msg_pos, FSIZ(MTYPE, fix.reserved));
    msg_pos += FSIZ(MTYPE, fix.reserved);

    b_packb(int_ptr->srv_ctl.tsf_len, buf_ptr, msg_pos, FSIZ(MTYPE, fix.tsf_len));
    msg_pos += FSIZ(MTYPE, fix.tsf_len);

    /* Translate type specific fields portion of message */
    for (i = 0; i < int_ptr->srv_ctl.tsf_len; i++)
    {
      b_packb(int_ptr->srv_ctl.tsf[i],
        buf_ptr, msg_pos, FSIZ(MTYPE, var[i].tsf));
      msg_pos += FSIZ(MTYPE, var[i].tsf);
    }

    *len_ptr = msg_pos; /* Compute message length */
    
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
    /* Pack MACI field */
    if (int_ptr->srv_ctl.hdr.msg_int.maci_incl)
    {
      xlate_int_maci(&msg_pos,
                     buf_ptr,
                     CAI_TC_CRC_SIZE,
                     int_ptr->srv_ctl.hdr.ack_req,
                     CAIX_TC,
                     int_ptr->srv_ctl.hdr.msg_int.sdu_key_id,
                     int_ptr->srv_ctl.msg_type,
                     int_ptr->srv_ctl.hdr.msg_int.sdu_integrity_algo,
                     #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                     #endif /* FEATURE_IS2000_REL_C_MI */
                     &int_ptr->srv_ctl.hdr.msg_int.maci
                     );
    }
#endif /* FEATURE_IS2000_REL_C */

    /* Set message length */
    *len_ptr = msg_pos;
  } /* else */

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_srv_ctl */

/*===========================================================================

FUNCTION XLATE_INT_TC_STRSP

DESCRIPTION
  This function translates a Reverse Traffic Channel Status Response Message
  from internal to external format.

DEPENDENCIES
  Depends on the internal message type having the correct number of variable
  record parts.

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_strsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tc_strsp);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  /* Translate other message fields */
  b_packb(int_ptr->tc_strsp.qual, buf_ptr, msg_pos,
    FSIZ(cai_tc_strsp_fix_type, qual_typ));
  msg_pos += FSIZ(cai_tc_strsp_fix_type, qual_typ);

  if (int_ptr->tc_strsp.qual == CAI_NO_QUAL)
  {
    b_packb(0, buf_ptr, msg_pos, FSIZ(cai_tc_strsp_fix_type, qual_len));
    msg_pos += FSIZ(cai_tc_strsp_fix_type, qual_len);
  }
  else if (int_ptr->tc_strsp.qual == CAI_BAND_QUAL)
  {
    b_packb(sizeof(cai_qual_info1_type) / 8,
      buf_ptr, msg_pos, FSIZ(cai_tc_strsp_fix_type, qual_len));
    msg_pos += FSIZ(cai_tc_strsp_fix_type, qual_len);

    b_packb(int_ptr->tc_strsp.band, buf_ptr, msg_pos, 
    FSIZ(cai_qual_info1_type, band));
    msg_pos += FSIZ(cai_qual_info1_type, band);

    b_packb(0, buf_ptr, msg_pos, FSIZ(cai_qual_info1_type, reserved));
    msg_pos += FSIZ(cai_qual_info1_type, reserved);
  }
  else if (int_ptr->tc_strsp.qual == CAI_BAND_OP_MODE_QUAL)
  {
    b_packb(sizeof(cai_qual_info2_type) / 8, buf_ptr, msg_pos, 
    FSIZ(cai_tc_strsp_fix_type, qual_len));
    msg_pos += FSIZ(cai_tc_strsp_fix_type, qual_len);

    b_packb(int_ptr->tc_strsp.band, buf_ptr, msg_pos,
    FSIZ(cai_qual_info2_type, band));
    msg_pos += FSIZ(cai_qual_info2_type, band);

    b_packb(int_ptr->tc_strsp.op_mode, buf_ptr, msg_pos, 
    FSIZ(cai_qual_info2_type, op_mode));
    msg_pos += FSIZ(cai_qual_info2_type, op_mode);

    b_packb(0, buf_ptr, msg_pos, FSIZ(cai_qual_info2_type, reserved));
    msg_pos += FSIZ(cai_qual_info2_type, reserved);
  }
  else
  {
    return (CAIX_INV_MSG_S); /* Unknown qual info type */
  }

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /* Translate info recs */
  for (i = irec_pos = 0; i < int_ptr->tc_strsp.num_recs; i++)
  {

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
    status = xlate_int_info_rec((byte*) (&int_ptr->tc_strsp.recs[irec_pos/4]), &irec_len, 
                                (word) (CAI_REV_TC_MSG_BODY_SIZE - msg_pos - FSIZ( cai_tc_strsp_fix_type, reserved)),
                                buf_ptr, msg_pos, &xrec_len );
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    if (status != CAIX_DONE_S)
    {
      return (status);
    }

    msg_pos  += xrec_len; /* Advance external message position */
    irec_pos += irec_len; /* Advance internal message position */
    /* The next record will start only on a dword boundary, so move positions accordingly */

    irec_pos = (irec_pos%4) ? (irec_pos+(sizeof(dword))-irec_pos%4) : irec_pos;

  } /* for */


#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->tc_strsp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tc_strsp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tc_strsp.hdr.msg_int.sdu_key_id,
                   int_ptr->tc_strsp.msg_type,
                   int_ptr->tc_strsp.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->tc_strsp.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  *len_ptr = msg_pos; /* Set length of message */

  return (status);

} /* xlate_int_tc_strsp() */

/*===========================================================================

FUNCTION XLATE_INT_TC_SC_REQ

DESCRIPTION
  This function translates a Supplemental Channel Request Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_sc_req
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word i;
    /* For indexing through info recs */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_A
  byte reserve_bits;
  word rec_len_pos;
  word rec_start_pos;
#endif /* FEATURE_IS2000_REL_A */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_scrm_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->scrm );

  b_packb(int_ptr->scrm.sz_req_blob, buf_ptr, msg_pos, FSIZ(MTYPE, sz_req_blob));
  msg_pos += FSIZ(MTYPE, sz_req_blob);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  for (i=0; i<int_ptr->scrm.sz_req_blob; i++)
  {
    b_packb(int_ptr->scrm.req_blob[i],buf_ptr, msg_pos, 
    FSIZ(cai_scrm_var1_type, req_blob_data));
    msg_pos += FSIZ(cai_scrm_var1_type, req_blob_data);
  }

  b_packb(int_ptr->scrm.use_scrm_seq_num, buf_ptr, msg_pos,
    FSIZ(cai_scrm_fix_type, use_scrm_seq_num));
  msg_pos += FSIZ(cai_scrm_fix_type, use_scrm_seq_num);

  if ( int_ptr->scrm.use_scrm_seq_num )
  {
    b_packb(int_ptr->scrm.scrm_seq_num, buf_ptr, msg_pos, 
    FSIZ(cai_scrm_fix_type, scrm_seq_num));
    msg_pos += FSIZ(cai_scrm_fix_type, scrm_seq_num);
  }

  if ((int_ptr->scrm.use_scrm_seq_num != 0 ) ||
       (int_ptr->scrm.sz_req_blob != 0))
  {
    b_packw(int_ptr->scrm.ref_pn, buf_ptr, msg_pos, 
    FSIZ(cai_scrm_fix_type, ref_pn));
    msg_pos += FSIZ(cai_scrm_fix_type, ref_pn);

    b_packb(int_ptr->scrm.pilot_str, buf_ptr, msg_pos, 
    FSIZ(cai_scrm_fix_type, pilot_str));
    msg_pos += FSIZ(cai_scrm_fix_type, pilot_str);

    b_packb(int_ptr->scrm.num_act_pn, buf_ptr, msg_pos, 
    FSIZ(cai_scrm_fix_type, num_act_pn));
    msg_pos += FSIZ(cai_scrm_fix_type, num_act_pn);

    for (i=0; i<int_ptr->scrm.num_act_pn; i++)
    {
      b_packw(int_ptr->scrm.act_pn[i].pn_phase, buf_ptr, msg_pos, 
      FSIZ(cai_scrm_var2_type, act_pn_phase));
      msg_pos += FSIZ(cai_scrm_var2_type, act_pn_phase);

      b_packb(int_ptr->scrm.act_pn[i].pn_strength, buf_ptr, msg_pos, 
      FSIZ(cai_scrm_var2_type, act_pn_str));
      msg_pos += FSIZ(cai_scrm_var2_type, act_pn_str);
    }

    b_packb(int_ptr->scrm.num_nghbr_pn, buf_ptr, msg_pos, 
    FSIZ(cai_scrm_fix_type, num_nghbr_pn));
    msg_pos += FSIZ(cai_scrm_fix_type, num_nghbr_pn);

    for (i=0; i<int_ptr->scrm.num_nghbr_pn; i++)
    {
      b_packw(int_ptr->scrm.nghbr_pn[i].pn_phase, buf_ptr, msg_pos,
      FSIZ(cai_scrm_var3_type, nghbr_pn_phase));
      msg_pos += FSIZ(cai_scrm_var3_type, nghbr_pn_phase);

      b_packb(int_ptr->scrm.nghbr_pn[i].pn_strength, buf_ptr, msg_pos, 
        FSIZ(cai_scrm_var3_type, nghbr_pn_str));
      msg_pos += FSIZ(cai_scrm_var3_type, nghbr_pn_str);
    }
  }

  #ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    if ((int_ptr->scrm.use_scrm_seq_num != 0 ) ||
        (int_ptr->scrm.sz_req_blob != 0))
    {
      b_packb(int_ptr->scrm.ref_pil_rec.pilot_rec_incl, buf_ptr, msg_pos,
        FSIZ(cai_scrm_fix2_type, ref_pilot_rec_incl));
      msg_pos += FSIZ(cai_scrm_fix2_type, ref_pilot_rec_incl);

      if (int_ptr->scrm.ref_pil_rec.pilot_rec_incl)
      {
        /* at this point we can only pack auxilary pilot */
        /* note that Auxiliary pilot rec type is defined as 1 in caii.h
           but here it needs to be packed as 0 */

        b_packb(0, buf_ptr, msg_pos,
          FSIZ(cai_scrm_fix2_type, ref_pilot_rec_type));
        msg_pos += FSIZ(cai_scrm_fix2_type, ref_pilot_rec_type);

        rec_len_pos = msg_pos;

        msg_pos += FSIZ(cai_scrm_fix2_type, ref_record_len);

        rec_start_pos = msg_pos;

        /*  pack the reference pilot if it's auxiliary */
        if (int_ptr->scrm.ref_pil_rec.pilot_rec_type == 0)
        {
          b_packb(int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.qof, buf_ptr, msg_pos, 
            FSIZ(cai_add_pilot_rec1_type, qof));
          msg_pos += FSIZ(cai_add_pilot_rec1_type, qof);

          b_packb(int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.walsh_length, buf_ptr, msg_pos, 
            FSIZ(cai_add_pilot_rec1_type, walsh_length));
          msg_pos += FSIZ(cai_add_pilot_rec1_type, walsh_length);

          /* if the aux walsh is less than 3, pack a byte */
          b_packw(int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.aux_pilot_walsh, buf_ptr, msg_pos,
            int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.walsh_length + 6);
          msg_pos += int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.walsh_length + 6;

          /* length of reserved bits */
          reserve_bits = (sizeof(cai_add_pilot_rec1_type ) +
            int_ptr->scrm.ref_pil_rec.aux_pil_rec.pilot.walsh_length) %8;
          if (reserve_bits != 0)
          {
            reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
            b_packb(0, buf_ptr, msg_pos, reserve_bits);
            msg_pos += reserve_bits;
          }

          b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
            FSIZ(cai_scrm_fix2_type, ref_record_len));
        }
      }
      /* now pack num act pn pilots */
      for (i=0; i < int_ptr->scrm.num_act_pn ; i++)
      {
        b_packb(int_ptr->scrm.act_pil_rec[i].pilot_rec_incl, buf_ptr, msg_pos, 
          FSIZ(cai_scrm_fix0_type, pilot_rec_incl));
        msg_pos += FSIZ(cai_scrm_fix0_type, pilot_rec_incl);

        if (int_ptr->scrm.act_pil_rec[i].pilot_rec_incl)
        {
          b_packb(0, buf_ptr, msg_pos, FSIZ(cai_scrm_fix1_type, pilot_rec_type));
          msg_pos += FSIZ(cai_scrm_fix1_type, pilot_rec_type);

          rec_len_pos = msg_pos;

          msg_pos += FSIZ(cai_scrm_fix1_type, record_len);

          rec_start_pos = msg_pos;

          if (int_ptr->scrm.act_pil_rec[i].pilot_rec_type == 0)
          {
            b_packb(int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.qof, buf_ptr, msg_pos, 
              FSIZ(cai_add_pilot_rec1_type,qof));
            msg_pos += FSIZ(cai_add_pilot_rec1_type, qof);

            b_packb(int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.walsh_length, buf_ptr, msg_pos,
              FSIZ(cai_add_pilot_rec1_type,walsh_length));
            msg_pos += FSIZ(cai_add_pilot_rec1_type, walsh_length);

            /* if the aux walsh is less than 3, pack a byte */
            b_packw(int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.aux_pilot_walsh, buf_ptr,
              msg_pos, int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.walsh_length + 6);
            msg_pos += int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.walsh_length + 6;

            /* length of reserved bits */
            reserve_bits = (sizeof(cai_add_pilot_rec1_type) +
              int_ptr->scrm.act_pil_rec[i].aux_pil_rec.pilot.walsh_length) %8;

            if (reserve_bits != 0)
            {
              reserve_bits = 8 - reserve_bits;

              /* Pack reserved bits */
              b_packb(0, buf_ptr, msg_pos, reserve_bits);
              msg_pos += reserve_bits;
            }

            b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
              FSIZ(cai_scrm_fix1_type, record_len));
          }
        }
      }
      /* finally pack num nghbr pilots */
      for (i=0; i<int_ptr->scrm.num_nghbr_pn ; i++)
      {
        b_packb(int_ptr->scrm.nghbr_pil_rec[i].pilot_rec_incl,
          buf_ptr, msg_pos, FSIZ(cai_scrm_fix0_type, pilot_rec_incl));
        msg_pos += FSIZ(cai_scrm_fix0_type, pilot_rec_incl);

        if (int_ptr->scrm.nghbr_pil_rec[i].pilot_rec_incl)
        {
          b_packb(0, buf_ptr, msg_pos, FSIZ(cai_scrm_fix1_type, pilot_rec_type));
          msg_pos += FSIZ(cai_scrm_fix1_type, pilot_rec_type);

          rec_len_pos = msg_pos;

          msg_pos += FSIZ(cai_scrm_fix1_type, record_len);

          rec_start_pos = msg_pos;

          if (int_ptr->scrm.nghbr_pil_rec[i].pilot_rec_type == 0)
          {
            b_packb(int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.qof,
              buf_ptr, msg_pos, FSIZ(cai_add_pilot_rec1_type,qof));
            msg_pos += FSIZ(cai_add_pilot_rec1_type, qof);

            b_packb(int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.walsh_length, buf_ptr, 
              msg_pos, FSIZ(cai_add_pilot_rec1_type,walsh_length));
            msg_pos += FSIZ(cai_add_pilot_rec1_type,walsh_length);

            /* if the aux walsh is less than 3, pack a byte */
            b_packw(int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.aux_pilot_walsh, buf_ptr,
              msg_pos, int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.walsh_length + 6);
            msg_pos += int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.walsh_length + 6;

            /* length of reserved bits */
            reserve_bits = (sizeof(cai_add_pilot_rec1_type) +
              int_ptr->scrm.nghbr_pil_rec[i].aux_pil_rec.pilot.walsh_length) %8;

            if( reserve_bits != 0 )
            {
              reserve_bits = 8 - reserve_bits;

              /* Pack reserved bits */
              b_packb(0, buf_ptr, msg_pos, reserve_bits);
              msg_pos += reserve_bits;
            }

            b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
              FSIZ(cai_scrm_fix1_type, record_len));
          }
        }
      }
    }
  } /* prev >=7 ... */
  #endif /* FEATURE_IS2000_REL_A */


  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  #ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->scrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->scrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->scrm.hdr.msg_int.sdu_key_id,
                   int_ptr->scrm.msg_type,
                   int_ptr->scrm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->scrm.hdr.msg_int.maci
                   );
  }
  #endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_sc_req */

/*===========================================================================

FUNCTION XLATE_INT_TC_CFS_RSP

DESCRIPTION
  This function translates a Candidate Frequency Search Response Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_cfs_rsp
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
   /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_cfs_rsp_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->cfs_rsp);

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->cfs_rsp.last_cfsrm_seq, buf_ptr, msg_pos, FSIZ(MTYPE, last_cfsrm_seq));
  msg_pos += FSIZ(MTYPE, last_cfsrm_seq);

  b_packb(int_ptr->cfs_rsp.tot_off_tm_fwd, buf_ptr, msg_pos, FSIZ(MTYPE, tot_off_tm_fwd));
  msg_pos += FSIZ(MTYPE, tot_off_tm_fwd );

  b_packb(int_ptr->cfs_rsp.max_off_tm_fwd, buf_ptr, msg_pos, FSIZ(MTYPE, max_off_tm_fwd));
  msg_pos += FSIZ(MTYPE, max_off_tm_fwd );

  b_packb(int_ptr->cfs_rsp.tot_off_tm_rev, buf_ptr, msg_pos, FSIZ(MTYPE, tot_off_tm_rev));
  msg_pos += FSIZ(MTYPE, tot_off_tm_rev );

  b_packb(int_ptr->cfs_rsp.max_off_tm_rev, buf_ptr, msg_pos, FSIZ(MTYPE, max_off_tm_rev));
  msg_pos += FSIZ(MTYPE, max_off_tm_rev );

  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000)
  {
    #define IS2K_MTYPE cai_cfs_rsp_is2000_type

    #ifdef FEATURE_IS2000_REL_A
    /* at this point because of the encryption fields FPOS (mytpe ) may not
    give the right position, set it to msg_pos */
    byte fpos = msg_pos;
    #else
    byte fpos = FPOS(MTYPE, reserved);
    #endif /* FEATURE_IS2000_REL_A */

    b_packb(int_ptr->cfs_rsp.pcg_off_times, buf_ptr, 
      fpos + FPOS(IS2K_MTYPE, pcg_off_times), FSIZ(IS2K_MTYPE, pcg_off_times));

    b_packb(int_ptr->cfs_rsp.align_timing_used, buf_ptr,
      fpos + FPOS(IS2K_MTYPE, align_timing_used), FSIZ(IS2K_MTYPE, align_timing_used));

    *len_ptr = fpos + FPOS(IS2K_MTYPE, max_num_visits);

    if (int_ptr->cfs_rsp.align_timing_used)
    {
      b_packb(int_ptr->cfs_rsp.max_num_visits, buf_ptr, 
        fpos + FPOS(IS2K_MTYPE, max_num_visits), FSIZ(IS2K_MTYPE, max_num_visits));

      if (int_ptr->cfs_rsp.max_num_visits)
      {
        b_packb(int_ptr->cfs_rsp.inter_visit_time, buf_ptr,
          fpos + FPOS(IS2K_MTYPE, inter_visit_time), FSIZ(IS2K_MTYPE, inter_visit_time));
        *len_ptr = fpos + sizeof(IS2K_MTYPE);
      }
      else
      {
        *len_ptr = fpos + FPOS(IS2K_MTYPE, inter_visit_time);
      }
    }

    #undef IS2K_MTYPE
  
  }
  else
  {
    /* backward compatible */
    b_packb(0, PARAMS(reserved));
    /* Set message length */
    *len_ptr = sizeof(MTYPE);
  }

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  #ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->cfs_rsp.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(len_ptr,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->cfs_rsp.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->cfs_rsp.hdr.msg_int.sdu_key_id,
                   int_ptr->cfs_rsp.msg_type,
                   int_ptr->cfs_rsp.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->cfs_rsp.hdr.msg_int.maci
                   );
  }
  #endif /* FEATURE_IS2000_REL_C */

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_cfs_rsp */

/*===========================================================================

FUNCTION xlate_int_tc_cfs_rpt

DESCRIPTION
  This function translates a Candidate Frequency Search Response Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_cfs_rpt
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word rec_pos;
    /* For indexing through info rec bytes */
  word info_rec_len_pos;
    /* where the length info is written for recs */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_A
  word rec_len_pos;
  /* position where the length info needs to be packed */
  word rec_start_pos;
  /* starting position for the pilot record to be packed */
  byte reserve_bits;
  /* used for packing the zeros at the end for pilot recs */
#endif /* FEATURE_IS2000_REL_A */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_cfs_rpt_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->cfs_rpt.fix);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->cfs_rpt.fix.last_srch_msg, buf_ptr, msg_pos, FSIZ(MTYPE, last_srch_msg));
  msg_pos += FSIZ(MTYPE, last_srch_msg);
    
  b_packb(int_ptr->cfs_rpt.fix.last_srch_seq, buf_ptr, msg_pos, FSIZ(MTYPE, last_srch_seq));
  msg_pos += FSIZ(MTYPE, last_srch_seq);
    
  b_packb(int_ptr->cfs_rpt.fix.srch_mode, buf_ptr, msg_pos, FSIZ( MTYPE, srch_mode));
  msg_pos += FSIZ(MTYPE, srch_mode);
    
  info_rec_len_pos = msg_pos;
  msg_pos += FSIZ(MTYPE, mode_sp_len); /* len will be packed later */
  
  rec_pos = msg_pos;

  switch (int_ptr->cfs_rpt.fix.srch_mode)
  {
    case CAI_CF_SRCH_TYPE_CDMA:
      b_packb(int_ptr->cfs_rpt.var.mod0.band_class,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type, band_class));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, band_class);

      b_packw(int_ptr->cfs_rpt.var.mod0.cdma_freq,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type, cdma_freq));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, cdma_freq);

      b_packb(int_ptr->cfs_rpt.var.mod0.sf_tot_rx_pwr,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type, sf_tot_rx_pwr));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, sf_tot_rx_pwr);

      b_packb(int_ptr->cfs_rpt.var.mod0.cf_tot_rx_pwr,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type,
        cf_tot_rx_pwr));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, cf_tot_rx_pwr);

      b_packb(int_ptr->cfs_rpt.var.mod0.num_pilots,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_fix_type, num_pilots));
      msg_pos += FSIZ(cai_cfs_rpt_mod0_fix_type, num_pilots);

      for (i=0; i<int_ptr->cfs_rpt.var.mod0.num_pilots; i++)
      {
        b_packw(int_ptr->cfs_rpt.var.mod0.pilot[i].plt_pn_phase,
          buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_var_type, plt_pn_phase));
        msg_pos += FSIZ(cai_cfs_rpt_mod0_var_type, plt_pn_phase);

        b_packb(int_ptr->cfs_rpt.var.mod0.pilot[i].plt_str,
          buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_var_type, plt_str));
        msg_pos += FSIZ(cai_cfs_rpt_mod0_var_type, plt_str);

        b_packb(0, buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_var_type,
          reserved));
        msg_pos += FSIZ(cai_cfs_rpt_mod0_var_type, reserved);
      }

#ifdef FEATURE_IS2000_REL_A
      if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
      {
        for (i=0; i<int_ptr->cfs_rpt.var.mod0.num_pilots; i++)
        {
          b_packb(int_ptr->cfs_rpt.var.mod0.pilot2[i].pilot_rec_incl,
            buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod0_var2_type,pilot_rec_incl));
          msg_pos += FSIZ(cai_cfs_rpt_mod0_var2_type, pilot_rec_incl);

          if (int_ptr->cfs_rpt.var.mod0.pilot2[i].pilot_rec_incl)
          {
            b_packb(int_ptr->cfs_rpt.var.mod0.pilot2[i].pilot_rec_type, buf_ptr, msg_pos,
              FSIZ(cai_cfs_rpt_mod0_var2_type, pilot_rec_type));
            msg_pos += FSIZ(cai_cfs_rpt_mod0_var2_type, pilot_rec_type);

            rec_len_pos = msg_pos;

            msg_pos += FSIZ(cai_cfs_rpt_mod0_var2_type, record_len);

            rec_start_pos = msg_pos;

            /*  pack the reference pilot if it's auxiliary
                see table 2.7.2.3.2.34-1*/
            if (int_ptr->cfs_rpt.var.mod0.pilot2[i].pilot_rec_type == 0)
            {
              b_packb(int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.qof,
                buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,qof));
              msg_pos += FSIZ(cai_add_pilot_rec1_type,qof);

              b_packb(int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.walsh_length,
                buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,walsh_length));
              msg_pos += FSIZ(cai_add_pilot_rec1_type,walsh_length);

              b_packw(int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.aux_pilot_walsh, buf_ptr,
                msg_pos, int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.walsh_length + 6);
              msg_pos += int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.walsh_length + 6;

              /* length of reserved bits */
              reserve_bits = (sizeof(cai_add_pilot_rec1_type ) +
                int_ptr->cfs_rpt.var.mod0.pilot2[i].rec.walsh_length) %8;

              if (reserve_bits != 0)
              {
                reserve_bits = 8 - reserve_bits;

                /* Pack reserved bits */
                b_packb(0, buf_ptr, msg_pos, reserve_bits);
                msg_pos += reserve_bits;
              }

              b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
                FSIZ(cai_cfs_rpt_mod0_var2_type, record_len));
            }
          }
        }
      }
#endif /* FEATURE_IS2000_REL_A */

      /* Calculate MODE_SPECIFIC_LEN */
      xrec_len = msg_pos - rec_pos;

#ifdef FEATURE_IS2000_REL_A
      if (xrec_len%8 == 0)
#endif /* FEATURE_IS2000_REL_A */
      {
        b_packb((byte) (xrec_len/8), buf_ptr, info_rec_len_pos, 
          FSIZ(MTYPE, mode_sp_len));
      }
#ifdef FEATURE_IS2000_REL_A
      else
      {
        b_packb(0, buf_ptr, msg_pos, (word)(8-(xrec_len%8)));
        b_packb((byte) (xrec_len/8) + 1, buf_ptr, info_rec_len_pos, 
          FSIZ(MTYPE, mode_sp_len));
        msg_pos += 8 - xrec_len%8;
      }
#endif  /* FEATURE_IS2000_REL_A */

      break;

    case CAI_CF_SRCH_TYPE_ANALOG:
      b_packb(int_ptr->cfs_rpt.var.mod1.band_class,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod1_fix_type, band_class));
      msg_pos += FSIZ(cai_cfs_rpt_mod1_fix_type, band_class);

      b_packb(int_ptr->cfs_rpt.var.mod1.sf_tot_rx_pwr,
        buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod1_fix_type, sf_tot_rx_pwr));
      msg_pos += FSIZ(cai_cfs_rpt_mod1_fix_type, sf_tot_rx_pwr);

      b_packb(int_ptr->cfs_rpt.var.mod1.num_analog_freqs, buf_ptr, msg_pos,
        FSIZ(cai_cfs_rpt_mod1_fix_type, num_analog_freqs));
      msg_pos += FSIZ(cai_cfs_rpt_mod1_fix_type, num_analog_freqs);

      b_packb(0, buf_ptr, msg_pos, FSIZ(cai_cfs_rpt_mod1_fix_type, reserved));
      msg_pos += FSIZ(cai_cfs_rpt_mod1_fix_type, reserved);

      for (i=0; i<int_ptr->cfs_rpt.var.mod1.num_analog_freqs; i++)
      {
        b_packw(int_ptr->cfs_rpt.var.mod1.analog[i].analog_freq,
          buf_ptr, msg_pos, FSIZ( cai_cfs_rpt_mod1_var_type, analog_freq));
        msg_pos += FSIZ(cai_cfs_rpt_mod1_var_type, analog_freq);

        b_packb(int_ptr->cfs_rpt.var.mod1.analog[i].sig_str, buf_ptr, 
          msg_pos, FSIZ(cai_cfs_rpt_mod1_var_type, sig_str));
        msg_pos += FSIZ(cai_cfs_rpt_mod1_var_type, sig_str);
      }

      /* Calculate MODE_SPECIFIC_LEN */
      xrec_len = msg_pos - rec_pos;

      /* Append necessary reserved bits */
      if (xrec_len%8)
      {
        b_packb(0, buf_ptr, msg_pos, (word)(8-(xrec_len%8)));
        msg_pos += 8 - xrec_len%8;
        xrec_len += 8 - xrec_len%8;
      }


      b_packb((byte)(xrec_len/8), buf_ptr,
        info_rec_len_pos, FSIZ( MTYPE, mode_sp_len ));
      break;

    default:
      MSG_ERROR("Invalid CF SRCH MODE %d", int_ptr->cfs_rpt.fix.srch_mode,
                 0, 0);

      status = CAIX_INV_MSG_S;
  }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->cfs_rpt.fix.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->cfs_rpt.fix.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->cfs_rpt.fix.hdr.msg_int.sdu_key_id,
                   int_ptr->cfs_rpt.fix.msg_type,
                   int_ptr->cfs_rpt.fix.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->cfs_rpt.fix.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;
    /* Set message length */

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_cfs_rpt */

/*===========================================================================

FUNCTION xlate_int_tc_per_plt

DESCRIPTION
  This function translates a Periodic Pilot Strength Measurement Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_per_plt
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word i;
    /* For indexing through info recs */ 
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  #ifdef FEATURE_IS2000_REL_A
  byte reserve_bits;
  word rec_len_pos;
  word rec_start_pos;
  #endif /* FEATURE_IS2000_REL_A */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_plt_str_meas_fix_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->per_plt);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packw(int_ptr->per_plt.fix.ref_pn, buf_ptr, msg_pos, FSIZ(MTYPE, ref_pn));
  msg_pos += FSIZ(MTYPE, ref_pn);
  b_packb(int_ptr->per_plt.fix.pilot_str, buf_ptr, msg_pos, FSIZ(MTYPE, pilot_str));
  msg_pos += FSIZ(MTYPE, pilot_str);
  b_packb(int_ptr->per_plt.fix.keep, buf_ptr, msg_pos, FSIZ(MTYPE, keep));
  msg_pos += FSIZ(MTYPE, keep);
  b_packb(int_ptr->per_plt.fix.sf_rx_pwr, buf_ptr, msg_pos, FSIZ(MTYPE, sf_rx_pwr));
  msg_pos += FSIZ(MTYPE, sf_rx_pwr);
  b_packb(int_ptr->per_plt.fix.num_pilot, buf_ptr, msg_pos, FSIZ(MTYPE, num_pilot));
  msg_pos += FSIZ(MTYPE, num_pilot);

  for (i=0; i<int_ptr->per_plt.fix.num_pilot; i++)
  {
    b_packw(int_ptr->per_plt.var[i].plt_pn_phase,
      buf_ptr, msg_pos, FSIZ(cai_plt_str_meas_var_type, plt_pn_phase));
    msg_pos += FSIZ(cai_plt_str_meas_var_type, plt_pn_phase);

    b_packb(int_ptr->per_plt.var[i].plt_str,
      buf_ptr, msg_pos, FSIZ(cai_plt_str_meas_var_type, plt_str));
    msg_pos += FSIZ(cai_plt_str_meas_var_type, plt_str);

    b_packb(int_ptr->per_plt.var[i].keep,
      buf_ptr, msg_pos, FSIZ(cai_plt_str_meas_var_type, keep));
    msg_pos += FSIZ(cai_plt_str_meas_var_type, keep);
  }

#ifdef FEATURE_IS2000_REL_A
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_A)
  {
    for (i=0; i<int_ptr->per_plt.fix.num_pilot; i++)
    {
      b_packb(int_ptr->per_plt.var2[i].pilot_rec_incl, buf_ptr, msg_pos,
        FSIZ(cai_plt_str_meas_var2_type, pilot_rec_incl));
      msg_pos += FSIZ(cai_plt_str_meas_var2_type, pilot_rec_incl);

      if (int_ptr->per_plt.var2[i].pilot_rec_incl)
      {
        b_packb(int_ptr->per_plt.var2[i].pilot_rec_type, buf_ptr, msg_pos,
          FSIZ(cai_plt_str_meas_var2_type, pilot_rec_type));
        msg_pos += FSIZ(cai_plt_str_meas_var2_type, pilot_rec_type);

        rec_len_pos = msg_pos;

        msg_pos += FSIZ(cai_plt_str_meas_var2_type, record_len);

        rec_start_pos = msg_pos;

        /*  pack the reference pilot if it's auxiliary
          see table 2.7.2.3.2.34-1*/
        if (int_ptr->per_plt.var2[i].pilot_rec_type == 0)
        {
          b_packb(int_ptr->per_plt.var2[i].rec.qof,
          buf_ptr, msg_pos, FSIZ(cai_add_pilot_rec1_type,qof));
          msg_pos += FSIZ(cai_add_pilot_rec1_type,qof);

          b_packb(int_ptr->per_plt.var2[i].rec.walsh_length,
          buf_ptr, msg_pos, FSIZ(cai_add_pilot_rec1_type,walsh_length));
          msg_pos += FSIZ(cai_add_pilot_rec1_type,walsh_length);

          b_packw(int_ptr->per_plt.var2[i].rec.aux_pilot_walsh, buf_ptr,
          msg_pos, int_ptr->per_plt.var2[i].rec.walsh_length + 6);
          msg_pos += int_ptr->per_plt.var2[i].rec.walsh_length + 6;

          /* length of reserved bits */
          reserve_bits = (sizeof(cai_add_pilot_rec1_type) +
                               int_ptr->per_plt.var2[i].rec.walsh_length) %8;
          if (reserve_bits != 0)
          {
            reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
            b_packb(0, buf_ptr, msg_pos, reserve_bits);
            msg_pos += reserve_bits;
          }

          b_packb((msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
            FSIZ(cai_plt_str_meas_var2_type, record_len));
        }
      }
    }

  #undef MTYPE
  
  #define MTYPE cai_plt_str_meas_fix2_type
  
    b_packb(int_ptr->per_plt.fix2.setpt_incl,
      buf_ptr, msg_pos, FSIZ( MTYPE, setpt_incl));
    msg_pos +=  FSIZ(MTYPE, setpt_incl);

    if (int_ptr->per_plt.fix2.setpt_incl)
    {
      b_packb(int_ptr->per_plt.fix2.fch_incl,
        buf_ptr, msg_pos, FSIZ(MTYPE, fch_incl));
      msg_pos +=  FSIZ(MTYPE, fch_incl);

      if (int_ptr->per_plt.fix2.fch_incl)
      {
        b_packb(int_ptr->per_plt.fix2.fpc_fch_curr_setpt,
        buf_ptr, msg_pos, FSIZ(MTYPE, fpc_fch_curr_setpt));
        msg_pos +=  FSIZ(MTYPE, fpc_fch_curr_setpt);
      }

      b_packb(int_ptr->per_plt.fix2.dcch_incl,
      buf_ptr, msg_pos, FSIZ(MTYPE, dcch_incl));
      msg_pos +=  FSIZ(MTYPE, dcch_incl);

      if (int_ptr->per_plt.fix2.dcch_incl)
      {
        b_packb(int_ptr->per_plt.fix2.fpc_dcch_curr_setpt,
        buf_ptr, msg_pos, FSIZ(MTYPE, fpc_dcch_curr_setpt));
        msg_pos +=  FSIZ(MTYPE, fpc_dcch_curr_setpt);
      }

      b_packb(int_ptr->per_plt.fix2.num_sup,
        buf_ptr, msg_pos, FSIZ(MTYPE, num_sup));
      msg_pos +=  FSIZ(MTYPE, num_sup);

      for (i=0; i<int_ptr->per_plt.fix2.num_sup; i++)
      {
        b_packb(int_ptr->per_plt.fix2.sup[i].sch_id, buf_ptr, msg_pos,
        FSIZ(cai_plt_str_meas_var3_type, sch_id));
        msg_pos +=  FSIZ(cai_plt_str_meas_var3_type, sch_id);

        b_packb(int_ptr->per_plt.fix2.sup[i].fpc_sch_curr_setpt, buf_ptr, msg_pos,
        FSIZ(cai_plt_str_meas_var3_type, fpc_sch_curr_setpt));
        msg_pos +=  FSIZ(cai_plt_str_meas_var3_type, fpc_sch_curr_setpt);
      }
    }
  }
#endif /* FEATURE_IS2000_REL_A */


#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->per_plt.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->per_plt.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->per_plt.hdr.msg_int.sdu_key_id,
                   int_ptr->per_plt.msg_type,
                   int_ptr->per_plt.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->per_plt.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_per_plt */

/*===========================================================================

FUNCTION xlate_int_tc_outer_rpt

DESCRIPTION
  This function translates a Outer Loop Report Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_outer_rpt
(
  word *len_ptr,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to where translated message should be placed */

  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S; 
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  word i;
    /* For indexing through info recs */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_outer_rpt_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->outer_rpt);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->outer_rpt.fch_incl, buf_ptr, msg_pos, FSIZ(MTYPE, fch_incl) );
  msg_pos += FSIZ(MTYPE, fch_incl);

  if (int_ptr->outer_rpt.fch_incl)
  {
    b_packb(int_ptr->outer_rpt.fpc_fch_curr_setpt, buf_ptr, msg_pos, 
      FSIZ(MTYPE, fpc_fch_curr_setpt));
    msg_pos += FSIZ(MTYPE, fpc_fch_curr_setpt);
  }

  b_packb(int_ptr->outer_rpt.dcch_incl, buf_ptr, msg_pos, 
    FSIZ(MTYPE, dcch_incl));
  msg_pos += FSIZ(MTYPE, dcch_incl);

  if (int_ptr->outer_rpt.dcch_incl)
  {
    b_packb(int_ptr->outer_rpt.fpc_dcch_curr_setpt, buf_ptr, msg_pos,
      FSIZ(MTYPE, fpc_dcch_curr_setpt));
    msg_pos += FSIZ(MTYPE, fpc_dcch_curr_setpt);
  }

  b_packb(int_ptr->outer_rpt.num_sup, buf_ptr, msg_pos, FSIZ(MTYPE, num_sup));
  msg_pos += FSIZ(MTYPE, num_sup);

  for (i=0; i<int_ptr->outer_rpt.num_sup && i<CAI_OUTER_RPT_MAX_SUP; i++)
  {
    b_packb(int_ptr->outer_rpt.sup[i].sch_id, buf_ptr, msg_pos,
      FSIZ(MTYPE, sch_id));
    msg_pos += FSIZ(MTYPE, sch_id);

    b_packb(int_ptr->outer_rpt.sup[i].fpc_sch_curr_setpt, buf_ptr, msg_pos, 
      FSIZ(MTYPE, fpc_sch_curr_setpt));
    msg_pos += FSIZ(MTYPE, fpc_sch_curr_setpt);
  }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->outer_rpt.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->outer_rpt.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->outer_rpt.hdr.msg_int.sdu_key_id,
                   int_ptr->outer_rpt.msg_type,
                   int_ptr->outer_rpt.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->outer_rpt.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  *len_ptr = msg_pos;
    /* Set message length */

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_per_plt */

/* ======== ========== ========= ======== ========= ========= ======== =====

              Release A message coding for Reverse Traffic Channel
                      starts here

  ========= ==========  ========= ========= ========= ======== =========  */

#if defined(FEATURE_IS2000_REL_A) || defined(FEATURE_IS2000_CHS)
/*===========================================================================

FUNCTION xlate_int_tc_rrm

DESCRIPTION
  This function translates a Resource Request Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_rrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_D
#error code not present
  #endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->rrm);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

#define MTYPE cai_rrm_type
  /* Set up MTYPE definition for PARAMS macro */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

#undef MTYPE

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->rrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->rrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->rrm.hdr.msg_int.sdu_key_id,
                   int_ptr->rrm.msg_type,
                   int_ptr->rrm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->rrm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
   
  /* Set message length */
  *len_ptr = msg_pos;

  return (status);
} /* xlate_int_tc_rrm */

/*===========================================================================

FUNCTION xlate_int_tc_errm

DESCRIPTION
  This function translates a Extended Release Response Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_errm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->errm);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

#define MTYPE cai_errm_type
  /* Set up MTYPE definition for PARAMS macro */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

#undef MTYPE

#ifdef FEATURE_IS2000_REL_C   
  /* Pack MACI field */
  if (int_ptr->errm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->errm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->errm.hdr.msg_int.sdu_key_id,
                   int_ptr->errm.msg_type,
                   int_ptr->errm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->errm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  /* Set message length */
  *len_ptr = msg_pos;

  return (status);

} /* xlate_int_tc_errm */

/*===========================================================================

FUNCTION xlate_int_tc_rrrm

DESCRIPTION
  This function translates a Resource Release Request Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_rrrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos=0;
    /* Position to pack message in */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */    

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_rrrm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->rrrm);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->rrrm.gating_disconnect_ind, buf_ptr, msg_pos,
           FSIZ( MTYPE, gating_disconnect_ind));
  msg_pos += FSIZ( MTYPE, gating_disconnect_ind);

  if (!int_ptr->rrrm.gating_disconnect_ind)
  {
    b_packb( int_ptr->rrrm.con_ref, buf_ptr, msg_pos, FSIZ( MTYPE, con_ref));
    msg_pos += FSIZ( MTYPE, con_ref);
    b_packb( int_ptr->rrrm.purge_service, buf_ptr, msg_pos, FSIZ( MTYPE, purge_service));
    msg_pos += FSIZ( MTYPE, purge_service);
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */
  }

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->rrrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->rrrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->rrrm.hdr.msg_int.sdu_key_id,
                   int_ptr->rrrm.msg_type,
                   int_ptr->rrrm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->rrrm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  /* Set message length */
  *len_ptr = msg_pos;

  #undef MTYPE
  /* Deactivate MTYPE definition */

  return (status);

} /* xlate_int_tc_rrrm */
#endif /* REL_A and CHS */

#ifdef FEATURE_IS2000_REL_A
/*===========================================================================

FUNCTION xlate_int_tc_uzurm

DESCRIPTION
  This function translates a Uzer Zone Update Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_uzurm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  #define MTYPE cai_uzurm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->uzurm );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packw( int_ptr->uzurm.uzid, buf_ptr, msg_pos,
           FSIZ( MTYPE, uzid));
  msg_pos += FSIZ( MTYPE, uzid);

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->uzurm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->uzurm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->uzurm.hdr.msg_int.sdu_key_id,
                   int_ptr->uzurm.msg_type,
                   int_ptr->uzurm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->uzurm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  status = CAIX_DONE_S;

  /* Set message length */
  *len_ptr = msg_pos;

  #undef MTYPE
  /* Deactivate MTYPE definition */

  return ( status );

} /* xlate_int_tc_uzurm */

/*===========================================================================

FUNCTION xlate_int_tc_eom

DESCRIPTION
  This function translates a Enhanced Origination Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_eom
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status = CAIX_DONE_S;
    /* For receiving status from called funcs */
  word msg_pos = 0;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, or external info rec. */
  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */
  #ifdef FEATURE_AUTH
  word start_enc_pos;
    /* Start point of fields that might require encryption using CMEA */
  #endif /* FEATURE_AUTH */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* Set up MTYPE definition for PARAMS macro */
  #define MTYPE cai_eom_fix1_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->eom );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->eom.tag, buf_ptr, msg_pos, FSIZ(MTYPE, tag));
  msg_pos += FSIZ( MTYPE, tag);

  b_packb(int_ptr->eom.ch_ind, buf_ptr, msg_pos, FSIZ(MTYPE, ch_ind));
  msg_pos += FSIZ(MTYPE, ch_ind);

#ifdef FEATURE_IS2000_REL_C
  if (int_ptr->eom.ch_ind == 0x07)
  {
    b_packb(int_ptr->eom.ext_ch_ind, buf_ptr, msg_pos, FSIZ( MTYPE, ext_ch_ind));
    msg_pos += FSIZ(MTYPE, ext_ch_ind);
  }
#endif /* FEATURE_IS2000_REL_C */

  b_packb(int_ptr->eom.sr_id, buf_ptr, msg_pos, FSIZ(MTYPE, sr_id));
  msg_pos += FSIZ(MTYPE, sr_id);

  b_packb(int_ptr->eom.global_em_flag, buf_ptr, msg_pos,
    FSIZ(MTYPE, global_emergency_call));
  msg_pos += FSIZ(MTYPE, global_emergency_call);

  if (int_ptr->eom.global_em_flag)
  {
    b_packb(int_ptr->eom.ms_init_pos_loc_ind, buf_ptr, msg_pos,
      FSIZ(MTYPE, ms_init_pos_loc_ind));
    msg_pos += FSIZ(MTYPE, ms_init_pos_loc_ind);
  }

  b_packb(int_ptr->eom.enc_info_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, enc_info_inc));
  msg_pos += FSIZ(MTYPE, enc_info_inc);

  if (int_ptr->eom.enc_info_incl)
  {
    b_packb(int_ptr->eom.ui_enc_req, buf_ptr, msg_pos,
      FSIZ(MTYPE, ui_encrypt_req));
    msg_pos += FSIZ(MTYPE, ui_encrypt_req);

    b_packb(int_ptr->eom.ui_enc_sup, buf_ptr, msg_pos,
      FSIZ(MTYPE, ui_encrypt_sup));
    msg_pos += FSIZ(MTYPE, ui_encrypt_sup);
  }

  b_packw(int_ptr->eom.service_option, buf_ptr, msg_pos,
    FSIZ(MTYPE, service_option));
  msg_pos += FSIZ(MTYPE, service_option);

  b_packb(int_ptr->eom.more_so_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, more_so_info_incl));
  msg_pos += FSIZ(MTYPE, more_so_info_incl);

  if (int_ptr->eom.more_so_incl)
  {
    b_packb(int_ptr->eom.num_alt_so, buf_ptr, msg_pos, FSIZ(MTYPE, num_alt_so));
    msg_pos += FSIZ(MTYPE, num_alt_so);

    for (i=0; i<int_ptr->eom.num_alt_so && i<CAI_AC_ALT_SO_MAX; i++)
    {
      b_packw(int_ptr->eom.alt_so[i], buf_ptr, msg_pos,
        FSIZ(cai_alt_so_type, alt_so ));
      msg_pos += FSIZ(cai_alt_so_type, alt_so);
    }

    b_packb(int_ptr->eom.so_bitmap_ind, buf_ptr, msg_pos,
      FSIZ(cai_eom_var_type, so_bitmap_ind));
    msg_pos += FSIZ(cai_eom_var_type, so_bitmap_ind);

    if (int_ptr->eom.so_bitmap_ind != SO_BITMAP_SIZE_0)
    {
      b_packb(int_ptr->eom.so_group_num, buf_ptr, msg_pos,
        FSIZ(cai_eom_var_type, so_group_num));
      msg_pos += FSIZ(cai_eom_var_type, so_group_num);

      /* so_bitmap is 2^(1+so_bitmap_ind) long */
      b_packw(int_ptr->eom.so_bitmap, buf_ptr, msg_pos,
        ( (byte)1 << (1+int_ptr->eom.so_bitmap_ind) ) );
      msg_pos += ( (byte)1 << (1+int_ptr->eom.so_bitmap_ind) );
    }
  }

  #undef MTYPE

  #define MTYPE cai_eom_fix2_type

  b_packb(int_ptr->eom.drs, buf_ptr, msg_pos, FSIZ(MTYPE, drs));
  msg_pos += FSIZ(MTYPE, drs);

  b_packb(int_ptr->eom.prev_sid_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, prev_sid_incl));
  msg_pos += FSIZ(MTYPE, prev_sid_incl);

  if (int_ptr->eom.prev_sid_incl)
  {
    b_packw(int_ptr->eom.prev_sid, buf_ptr, msg_pos,
      FSIZ(MTYPE, prev_sid));
    msg_pos += FSIZ(MTYPE, prev_sid);
  }

  b_packb(int_ptr->eom.prev_nid_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, prev_nid_incl));
  msg_pos += FSIZ(MTYPE, prev_nid_incl);

  if (int_ptr->eom.prev_nid_incl)
  {
    b_packw(int_ptr->eom.prev_nid, buf_ptr, msg_pos,
      FSIZ(MTYPE, prev_nid));
    msg_pos += FSIZ(MTYPE, prev_nid);
  }

  b_packb(int_ptr->eom.prev_pzid_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, prev_pzid_incl));
  msg_pos += FSIZ(MTYPE, prev_pzid_incl);

  if (int_ptr->eom.prev_pzid_incl)
  {
    b_packw(int_ptr->eom.prev_pzid, buf_ptr, msg_pos,
      FSIZ(MTYPE, prev_pzid));
    msg_pos += FSIZ(MTYPE, prev_pzid);
  }

  b_packb(int_ptr->eom.dialed_digs_incl, buf_ptr, msg_pos,
    FSIZ(MTYPE, dialed_digs_incl));
  msg_pos += FSIZ(MTYPE, dialed_digs_incl);

  if (int_ptr->eom.dialed_digs_incl)
  {
    b_packb( int_ptr->eom.digit_mode, buf_ptr, msg_pos,
             FSIZ( MTYPE, digit_mode ));
    msg_pos += FSIZ( MTYPE, digit_mode );

    if (int_ptr->eom.digit_mode
#ifdef FEATURE_IS2000_REL_C
        || (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
#endif /* FEATURE_IS2000_REL_C */
       )
    {
      b_packb(int_ptr->eom.number_type, buf_ptr, msg_pos,
        FSIZ(MTYPE, number_type));
      msg_pos += FSIZ(MTYPE, number_type);

#ifdef FEATURE_IS2000_REL_C
      if (int_ptr->eom.digit_mode)
#endif /* FEATURE_IS2000_REL_C */
      {
        b_packb(int_ptr->eom.number_plan, buf_ptr, msg_pos,
          FSIZ(MTYPE, number_plan));
        msg_pos += FSIZ(MTYPE, number_plan);
      }
    }

    b_packb(int_ptr->eom.num_fields, buf_ptr, msg_pos,
      FSIZ(MTYPE, num_fields));
    msg_pos += FSIZ(MTYPE, num_fields);

    #ifdef FEATURE_AUTH
    start_enc_pos = msg_pos;
    #endif /* FEATURE_AUTH */

    for (i=0; i < int_ptr->eom.num_fields; i++)
    {
      if (int_ptr->eom.digit_mode)
      {
        b_packb(int_ptr->eom.chari[i], buf_ptr, msg_pos,
          FSIZ(cai_orig_var_type, char8));
        /* ca use cai_orig_var_type here */
        msg_pos += FSIZ(cai_orig_var_type, char8);
      }
      else
      {
        b_packb(int_ptr->eom.chari[i], buf_ptr, msg_pos,
          FSIZ(cai_orig_var_type, char4));
        msg_pos += FSIZ(cai_orig_var_type, char4);
      }
    }

#ifdef FEATURE_AUTH
    /* EOM has two portions might need to be encrypted. Digits and Info Recs.
    ** Encryption function can pad to the digits. So calling encryption function
    ** here is much simpler.
    */
    if ((int_ptr->eom.num_fields > 0) &&
        (int_ptr->eom.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS))
    {
      auth_encrypt_eom_digits(&msg_pos, buf_ptr, int_ptr, start_enc_pos);
    }
#endif /* FEATURE_AUTH */
  }

  b_packb(int_ptr->eom.num_recs, buf_ptr, msg_pos,
    FSIZ(cai_eom_fix3_type, num_recs));
  msg_pos += FSIZ(cai_eom_fix3_type, num_recs);

  #ifdef FEATURE_AUTH
  start_enc_pos = msg_pos;
  #endif /* FEATURE_AUTH */

  if (int_ptr->eom.num_recs)
  {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

    for (i = irec_pos = 0; i < int_ptr->eom.num_recs; i++)
    {
#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#else
      status = xlate_int_info_rec((byte*) &int_ptr->eom.recs[irec_pos/4],
                                  &irec_len, (word) (CAI_REV_TC_MSG_BODY_SIZE - msg_pos),
                                  buf_ptr, msg_pos, &xrec_len);
#endif /* FEATURE_MSG_PACK_UNIT_TEST */

      if (status != CAIX_DONE_S)
      {
        return (status);
      }
      msg_pos  += xrec_len;  /* Advance external msg buf position */
      irec_pos += irec_len;  /* Advance internal msg buf position */
      /* The next record will start only on a dword boundary, so move positions accordingly */
      irec_pos = (irec_pos%4)?(irec_pos+(sizeof(dword))-irec_pos%4):irec_pos;
    }

#ifdef FEATURE_AUTH
    /* This is the encryption of the info record part. */
    if (int_ptr->eom.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS)
    {
      auth_encrypt_info_recs(&msg_pos, buf_ptr, int_ptr,
        start_enc_pos, int_ptr->eom.num_recs);
    }
#endif /* FEATURE_AUTH */
  } /* if int_ptr->eom.num_recs */

#ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  { 
    b_packb(int_ptr->eom.sync_id_incl, buf_ptr, msg_pos,
      FSIZ(cai_eom_fix4_type, sync_id_incl));
    msg_pos += FSIZ(cai_eom_fix4_type, sync_id_incl);

    if (int_ptr->eom.sync_id_incl)
    {
      b_packb(int_ptr->eom.sync_id_len, buf_ptr, msg_pos,
        FSIZ(cai_eom_fix4_type, sync_id_len));
      msg_pos += FSIZ(cai_eom_fix4_type, sync_id_len);

      for (i=0; i < int_ptr->eom.sync_id_len; i++)
      {
        b_packb(int_ptr->eom.sync_id[i], buf_ptr, msg_pos,
          FSIZ(cai_eom_fix4_type, sync_id));
        msg_pos += FSIZ(cai_eom_fix4_type, sync_id);
      }
    }
  }
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->eom.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->eom.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->eom.hdr.msg_int.sdu_key_id,
                   int_ptr->eom.msg_type,
                   int_ptr->eom.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->eom.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  /* Set message length */
  *len_ptr = msg_pos;

  /* Deactivate MTYPE definition */
  #undef MTYPE

  return (status);

} /* xlate_int_tc_eom */

/*===========================================================================

FUNCTION xlate_int_tc_efwim

DESCRIPTION
  This function translates a Extended Flash with Info Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_efwim
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  word i;
    /* Index to loop through records */
  word j;
    /* Index to loop through characters */
  byte *rec_ptr;
    /* Pointer to internal format information record */
  word rec_len_pos = 0;
  word reserv_len = 0;
#ifdef FEATURE_IS2000_REL_C
  word rec_len;
  /* Size of record in bits */
#endif /* FEATURE_IS2000_REL_C */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_efwim_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->efwim );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  rec_ptr = (byte*)&int_ptr->efwim.recs[0];

#ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
#endif /* FEATURE_MSG_PACK_UNIT_TEST */
  
  b_packb( int_ptr->efwim.con_ref_incl, buf_ptr, msg_pos, FSIZ( MTYPE, con_ref_incl));
  msg_pos += FSIZ( MTYPE, con_ref_incl);

  status = CAIX_DONE_S;

  if (int_ptr->efwim.con_ref_incl)
  {
    b_packb( int_ptr->efwim.con_ref, buf_ptr, msg_pos, FSIZ( MTYPE, con_ref));
    msg_pos += FSIZ( MTYPE, con_ref);
  }

  b_packb( int_ptr->efwim.num_rec, buf_ptr, msg_pos, FSIZ( MTYPE, num_rec));
  msg_pos += FSIZ( MTYPE, num_rec);

  for (i=0; (i < int_ptr->efwim.num_rec) && (status == CAIX_DONE_S); i++)
  {
    /* ----------------------------------------------------
    ** Check to make sure that there is room for the header
    ** ---------------------------------------------------- */
    if ((msg_pos + sizeof( cai_rec_hdr_type )) > CAI_REV_TC_MSG_BODY_SIZE)
    {
      status = CAIX_INV_LEN_S;
    }

    else
    {
      b_packb( ((caii_rec_hdr_type *) rec_ptr)->record_type,
               buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_type ));
      msg_pos += FSIZ( cai_rec_hdr_type, record_type );

      switch (((caii_rec_hdr_type *) rec_ptr)->record_type)
      {
        /* ------------------------------------
        ** Feature Indicator Information Record
        ** ------------------------------------ */
        case CAI_FEAT_REC:
          /* -------------------------------------------------------
          ** Feature Indicator Info Record length = 1 octet (8 bits)
          ** ------------------------------------------------------- */
          b_packb( 1, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos + sizeof( cai_feat_type )) > CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_feat_rec_type *) rec_ptr)->feature,
                     buf_ptr, msg_pos, FSIZ( cai_feat_type, feature ));
            msg_pos += FSIZ( cai_feat_type, feature );

            /* -----------------------
            ** Pack reserved bits as 0
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, FSIZ( cai_feat_type, reserved ));
            msg_pos += FSIZ( cai_feat_type, reserved );
            rec_ptr += FENDPOS( caii_feat_rec_type, feature );
          }
          break;

        /* ----------------------------------
        ** Keypad Facility Information Record
        ** ---------------------------------- */
        case CAI_KEYPAD_REC:
          if ((((caii_key_rec_type *) rec_ptr)->fix.num_char) == 0) {
            /* --------------------------------------------------------
            ** There must be at least one occurrence of the chari field
            ** -------------------------------------------------------- */
            return (CAIX_INV_LEN_S);
          }

          b_packb( ((caii_key_rec_type *) rec_ptr)->fix.num_char, buf_ptr,
                 msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos +
              (((caii_key_rec_type *) rec_ptr)->fix.num_char *
                 FSIZ( cai_keypad_type, chari ))) >
                   CAI_REV_TC_MSG_BODY_SIZE)
          {
            /* --------------------------------------------
            ** Not enough room to pack keypad facility type
            ** -------------------------------------------- */
            status = CAIX_INV_LEN_S;
          }

          else {
            for (j=0; j < ((caii_key_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_key_rec_type *) rec_ptr)->var[j], buf_ptr,
                     msg_pos, FSIZ(cai_keypad_type, chari) );
              msg_pos += FSIZ( cai_keypad_type, chari );
            }

            rec_ptr += FENDPOS( caii_key_rec_type,
            var[((caii_key_rec_type *) rec_ptr)->fix.num_char - 1] );
          }
          break;

        /* --------------------------------------
        ** Called Party Number Information Record
        ** -------------------------------------- */
        case CAI_REV_CALLED_REC:
          /* ----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 1 (8 bits) for
          ** NUMBER_TYPE, NUMBER_PLAN and RESERVED fields
          ** ---------------------------------------------------- */
          b_packb(
            (byte) (((caii_called_rec_type *) rec_ptr)->fix.num_char + 1),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len);

          if ((msg_pos + sizeof( cai_called_fix_type ) +
              (((caii_called_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_called_var_type, chari )) + 1) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_called_rec_type *) rec_ptr)->fix.number_type,
                     buf_ptr, msg_pos,
                     FSIZ( cai_called_fix_type, number_type ));
            msg_pos += FSIZ(cai_called_fix_type, number_type);

            b_packb( ((caii_called_rec_type *)rec_ptr)->fix.number_plan,
                   buf_ptr, msg_pos,
                   FSIZ( cai_called_fix_type, number_plan));
            msg_pos += FSIZ( cai_called_fix_type, number_plan);
  
            for (j=0;
                 j < ((caii_called_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_called_rec_type *) rec_ptr)->var[j], buf_ptr,
                        msg_pos, FSIZ( cai_called_var_type, chari ));
              msg_pos += FSIZ( cai_called_var_type, chari );
            }

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, 1 );
            msg_pos += 1;

            if (((caii_called_rec_type *) rec_ptr)->fix.num_char == 0) {
              rec_ptr += FSIZ( caii_called_rec_type, fix );
            }

            else {
              rec_ptr += FENDPOS( caii_called_rec_type,
                   var[((caii_called_rec_type *) rec_ptr)->fix.num_char - 1] );
            }
          }
          break;

        /* -----------------------------------------------------------
        ** Calling Party Number or Connected Number Information Record
        ** ----------------------------------------------------------- */
        case CAI_REV_CALLING_REC:
        case CAI_REV_CONN_REC:
          /* -----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 2 (16 bits) for
          ** NUMBER_TYPE, NUMBER_PLAN, PI, SI and RESERVED fields
          ** ----------------------------------------------------- */
          b_packb(
            (byte) (((caii_calling_rec_type *) rec_ptr)->fix.num_char + 2),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len );

          if ((msg_pos + sizeof( cai_calling_fix_type ) +
              (((caii_calling_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_calling_var_type, chari )) + 5) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.number_type,
                      buf_ptr, msg_pos,
                      FSIZ( cai_calling_fix_type, number_type ));
            msg_pos += FSIZ( cai_calling_fix_type, number_type );

            b_packb( (( caii_calling_rec_type *) rec_ptr)->fix.number_plan,
                     buf_ptr, msg_pos,
                     FSIZ( cai_calling_fix_type, number_plan ));
            msg_pos += FSIZ(cai_calling_fix_type, number_plan);

            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.pi,
                   buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, pi ));
            msg_pos += FSIZ( cai_calling_fix_type, pi );

            b_packb( ((caii_calling_rec_type *) rec_ptr)->fix.si,
                    buf_ptr, msg_pos, FSIZ( cai_calling_fix_type, si ));
            msg_pos += FSIZ( cai_calling_fix_type, si);

            for (j=0;
                 j < ((caii_calling_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_calling_rec_type *) rec_ptr)->var[j],
                        buf_ptr, msg_pos, FSIZ( cai_calling_var_type, chari));
              msg_pos += FSIZ( cai_calling_var_type, chari );
            }

            /* ------------------------
            ** Pack 0 for reserved bits
            ** ------------------------ */
            b_packb( 0, buf_ptr, msg_pos, 5 );
            msg_pos += 5;

            if (((caii_calling_rec_type *) rec_ptr)->fix.num_char == 0) {
              rec_ptr += FSIZ( caii_calling_rec_type, fix ); /*lint !e662 */
            }
            else {
              rec_ptr += FENDPOS( caii_calling_rec_type,
              var[((caii_calling_rec_type *) rec_ptr)->fix.num_char - 1] );
            }
          }
          break;

        /* -------------------------------------------
        ** Called Party Subaddress Informatin Record
        ** Calling Party Subaddress Informatin Record
        ** Connected Subaddress Informatin Record
        ** ------------------------------------------- */
        case CAI_REV_CALLED_SUB_REC:
        case CAI_REV_CALLING_SUB_REC:
        case CAI_REV_CONN_SUB_REC:
          /* ----------------------------------------------------
          ** RECORD_LEN = Number of CHARI fields + 1 (8 bits)
          ** ---------------------------------------------------- */
          b_packb(
            (byte) (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char + 1),
            buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
          msg_pos += FSIZ( cai_rec_hdr_type, record_len);

          if ((msg_pos + sizeof( cai_subaddr_fix_type ) +
              (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char *
                   FSIZ( cai_subaddr_var_type, chari ))) >
                     CAI_REV_TC_MSG_BODY_SIZE)
          {
            status = CAIX_INV_LEN_S;
          }

          else {
            b_packb( ((caii_subaddr_rec_type *) rec_ptr)->fix.extension_bit,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, extension_bit ));
            msg_pos += FSIZ(cai_subaddr_fix_type, extension_bit);

            b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.subadd_type,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, subadd_type));
            msg_pos += FSIZ( cai_subaddr_fix_type, subadd_type);

            b_packb( ((caii_subaddr_rec_type *)rec_ptr)->fix.odd_even_ind,
                     buf_ptr, msg_pos,
                     FSIZ( cai_subaddr_fix_type, odd_even_ind));
            msg_pos += FSIZ( cai_subaddr_fix_type, odd_even_ind);

            /* -----------------------
            ** Pack 0 for reserved bit
            ** ----------------------- */
            b_packb( 0, buf_ptr, msg_pos, 3 );
            msg_pos += 3;

            for (j=0;
                 j < ((caii_subaddr_rec_type *) rec_ptr)->fix.num_char; j++)
            {
              b_packb( ((caii_subaddr_rec_type *) rec_ptr)->var[j], buf_ptr,
                      msg_pos, FSIZ( cai_subaddr_var_type, chari ));
              msg_pos += FSIZ( cai_subaddr_var_type, chari );
            }

            if (((caii_subaddr_rec_type *) rec_ptr)->fix.num_char == 0) {
              rec_ptr += FSIZ( caii_subaddr_rec_type, fix ); /*lint !e662 */
            }

            else {
              rec_ptr += FENDPOS( caii_subaddr_rec_type,
                   var[((caii_subaddr_rec_type *) rec_ptr)->fix.num_char - 1]);
            }
          }
          break;

        case CAI_GLOB_EM_CALL_REC:
        {

           if (  !((caii_global_emerg_type *) rec_ptr)->num_incl  )
             {
               b_packb(1, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));
               msg_pos += FSIZ( cai_rec_hdr_type, record_len);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_incl,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix1_type, num_incl ));
               msg_pos += FSIZ(cai_global_emerg_fix1_type, num_incl);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->ms_orig_pos_loc_ind,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_var2_type, ms_orig_pos_loc_ind ));
               msg_pos += FSIZ(cai_global_emerg_var2_type, ms_orig_pos_loc_ind);

               b_packb( 0, buf_ptr, msg_pos, 6 );
               msg_pos += 6;

               /* that's all */
             }
             else /* digits included */
             {
               rec_len_pos = msg_pos;

               /* save the space for record length */
               msg_pos += FSIZ( cai_rec_hdr_type, record_len);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_incl,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix1_type, num_incl ));
                 msg_pos += FSIZ(cai_global_emerg_fix1_type, num_incl);

               b_packb( ((caii_global_emerg_type *) rec_ptr)->digit_mode,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, digit_mode ));
                 msg_pos += FSIZ(cai_global_emerg_fix2_type, digit_mode);

               if (((caii_global_emerg_type *) rec_ptr)->digit_mode)
               {
                 b_packb( ((caii_global_emerg_type *) rec_ptr)->number_type,
                     buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, number_type ));
                   msg_pos += FSIZ(cai_global_emerg_fix2_type, number_type);

                 b_packb( ((caii_global_emerg_type *) rec_ptr)->number_plan,
                     buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, number_plan ));
                   msg_pos += FSIZ(cai_global_emerg_fix2_type, number_plan);
               }
               b_packb( ((caii_global_emerg_type *) rec_ptr)->num_char,
                   buf_ptr, msg_pos, FSIZ( cai_global_emerg_fix2_type, num_char ));
                 msg_pos += FSIZ(cai_global_emerg_fix2_type, num_char);

               for (j=0;
                    j < ((caii_global_emerg_type *) rec_ptr)->num_char; j++)
               {
                   if (((caii_global_emerg_type *) rec_ptr)->digit_mode)
                   {
                     b_packb( ((caii_global_emerg_type *) rec_ptr)->chari[j], buf_ptr,
                              msg_pos, FSIZ( cai_orig_var_type, char8 ));
                     msg_pos += FSIZ( cai_orig_var_type, char8 );
                   }
                   else
                   {
                     b_packb( ((caii_global_emerg_type *) rec_ptr)->chari[j], buf_ptr,
                              msg_pos, 4);
                     msg_pos += 4;
                   }
               }
               b_packb( ((caii_global_emerg_type *) rec_ptr)->ms_orig_pos_loc_ind,
                  buf_ptr, msg_pos, FSIZ( cai_global_emerg_var2_type, ms_orig_pos_loc_ind ));
               msg_pos += FSIZ(cai_global_emerg_var2_type, ms_orig_pos_loc_ind);

               reserv_len = (msg_pos - rec_len_pos ) % 8;
               if (reserv_len != 0)
               {
                 reserv_len = 8 - reserv_len;
                 b_packb( 0, buf_ptr, msg_pos, reserv_len );
                 msg_pos += reserv_len;
               }

               /* put length (byte)(msg_pos - rec_len_pos) */
               b_packb( (int)(((msg_pos - rec_len_pos ) / 8) - 1) ,
                 buf_ptr, rec_len_pos, FSIZ( cai_rec_hdr_type, record_len ));

             } /* digits included */
          }
        rec_ptr += sizeof (caii_global_emerg_type); /*lint !e662 */
        break;

#ifdef FEATURE_IS2000_REL_C
        /* -------------------------------------------
        ** Extended Keypad Facility Information Record
        ** ------------------------------------------- */
        case CAI_EXT_KEYPAD_REC:
          {
            if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
            {
              /* Compute record length, add in reserved bits */
              if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
              {
                rec_len = sizeof(cai_ext_keypad_facility_info_fix_type) +
                          (sizeof(cai_ext_keypad_facility_info_var_type) * 
                           ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields) + 2;
              }
              else
              {
                rec_len = FSIZ(cai_ext_keypad_facility_info_fix_type, number_info_incl) +
                          FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields) +
                          (sizeof(cai_ext_keypad_facility_info_var_type) * 
                           ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields) + 1;
              }

              if ( msg_pos + rec_len > CAI_REV_TC_MSG_BODY_SIZE )
              {
                status = CAIX_INV_LEN_S;
              }
              else
              {
                /* Pack record length */
                b_packb(rec_len / 8, buf_ptr, msg_pos, FSIZ( cai_rec_hdr_type, record_len ));     
                msg_pos += FSIZ( cai_rec_hdr_type, record_len); 

                /* Add other record fields */
                b_packb( ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl,
                         buf_ptr, msg_pos,
                         FSIZ( cai_ext_keypad_facility_info_fix_type, number_info_incl ));
                msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, number_info_incl);   

                if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
                {
                  b_packb( ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_type,
                           buf_ptr, msg_pos,
                           FSIZ(cai_ext_keypad_facility_info_fix_type , number_type ));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, number_type);

                  b_packb( ((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.number_plan,
                           buf_ptr, msg_pos,
                           FSIZ(cai_ext_keypad_facility_info_fix_type , number_plan));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type , number_plan);
                }

                b_packb(((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.num_fields, 
                        buf_ptr, msg_pos,
                        FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields));
                msg_pos += FSIZ(cai_ext_keypad_facility_info_fix_type, num_fields);

                for (j=0; j < ((caii_ext_keypad_facility_info_type *)rec_ptr)->fix.num_fields; j++)
                {
                  b_packb(((caii_ext_keypad_facility_info_type *)rec_ptr)->var[j].chari, 
                          buf_ptr, msg_pos,
                          FSIZ(cai_ext_keypad_facility_info_var_type, chari));
                  msg_pos += FSIZ(cai_ext_keypad_facility_info_var_type, chari);
                }

                if (((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.number_info_incl)
                {
                  /* There are two reserved bits if number_info_incl is 1 */
                  b_packb(0, buf_ptr, msg_pos, 2);
                  msg_pos += 2;
                }
                else
                {
                  /* Otherwise, there is 1 */
                  b_packb(0, buf_ptr, msg_pos, 1);
                  msg_pos += 1;
                }

              }
            } /* REL C*/

            rec_ptr += sizeof(caii_ext_keypad_facility_info_fix_type) +
                       (sizeof(caii_ext_keypad_facility_info_var_type) * 
                        ((caii_ext_keypad_facility_info_type *) rec_ptr)->fix.num_fields);

            break;
          } /* CAI_EXT_KEYPAD_REC */

#endif /* FEATURE_IS2000_REL_C */ 

         default:
          status = CAIX_INV_MSG_S;
          break;
      } /* end switch (((caii_rec_hdr_type *) rec_ptr)->record_type) */
      rec_ptr = (byte*)ALIGN_DWORD(((dword)rec_ptr));
    }  /* end for else */
  } /* end for loop */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->efwim.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->efwim.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->efwim.hdr.msg_int.sdu_key_id,
                   int_ptr->efwim.msg_type,
                   int_ptr->efwim.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->efwim.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  /* Set message length */
  *len_ptr = msg_pos;

status = CAIX_DONE_S;

#undef MTYPE
  /* Deactivate MTYPE definition */

  return ( status );

} /* xlate_int_tc_efwim */

/*===========================================================================

FUNCTION xlate_int_tc_epsmm

DESCRIPTION
  This function translates a Extended Pilot Strength Meas Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_epsmm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  word i;
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  
  byte reserve_bits;
  word rec_len_pos;
  word rec_start_pos;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_epsm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->epsmm );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  

  b_packw( int_ptr->epsmm.ref_pn, buf_ptr, msg_pos,
           FSIZ(MTYPE, fix1.ref_pn));
  msg_pos += FSIZ(MTYPE, fix1.ref_pn) ;
  b_packb( int_ptr->epsmm.pilot_strength, buf_ptr, msg_pos,
           FSIZ(MTYPE, fix1.pilot_strength));
  msg_pos += FSIZ(MTYPE, fix1.pilot_strength) ;
  b_packb( int_ptr->epsmm.keep, buf_ptr, msg_pos,
           FSIZ(MTYPE, fix1.keep));
  msg_pos += FSIZ(MTYPE, fix1.keep) ;

  b_packb( int_ptr->epsmm.ref_pilot_rec_incl,
    buf_ptr, msg_pos, FSIZ( cai_epsm_var1_type, ref_pilot_rec_incl));
  msg_pos += FSIZ( cai_epsm_var1_type, ref_pilot_rec_incl );

  if (int_ptr->epsmm.ref_pilot_rec_incl)
  {

    /* at this point we can only pack auxilary pilot */
    /* note that Auxiliary pilot rec type is defined as 1 in caii.h
     but here it needs to be packed as 0 */

    b_packb( 0, buf_ptr, msg_pos,
      FSIZ( cai_epsm_var1_type, ref_pilot_rec_type));
    msg_pos += FSIZ( cai_epsm_var1_type, ref_pilot_rec_type );

    rec_len_pos = msg_pos;

    msg_pos += FSIZ( cai_epsm_var1_type, ref_record_len );

    rec_start_pos = msg_pos;

    /*  pack the reference pilot if it's auxiliary */
    if (int_ptr->epsmm.ref_pilot_rec_type == 0)
    {

      b_packb( int_ptr->epsmm.ref_rec.qof,
              buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,qof));
      msg_pos += FSIZ( cai_add_pilot_rec1_type,qof );

      b_packb( int_ptr->epsmm.ref_rec.walsh_length,
              buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,walsh_length));
      msg_pos += FSIZ( cai_add_pilot_rec1_type,walsh_length );

      b_packw( int_ptr->epsmm.ref_rec.aux_pilot_walsh,
               buf_ptr, msg_pos,
               int_ptr->epsmm.ref_rec.walsh_length + 6);

      msg_pos += int_ptr->epsmm.ref_rec.walsh_length + 6;

            /* length of reserved bits */
      reserve_bits = (sizeof( cai_add_pilot_rec1_type ) +
                                int_ptr->epsmm.ref_rec.walsh_length) %8;
      if( reserve_bits != 0 )
      {
        reserve_bits = 8 - reserve_bits;

         /* Pack reserved bits */
        b_packb( 0, buf_ptr, msg_pos, reserve_bits );
        msg_pos += reserve_bits;
      }
      /* Now pack the record length */

      b_packb( (msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
        FSIZ( cai_epsm_var1_type, ref_record_len ));
    }
  }


  b_packb( int_ptr->epsmm.sf_rx_power, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix2.sf_rx_pwr));
  msg_pos += FSIZ(MTYPE, fix2.sf_rx_pwr);

  b_packb( int_ptr->epsmm.num_pilots, buf_ptr, msg_pos,
    FSIZ(MTYPE, fix2.num_pilots));
  msg_pos += FSIZ(MTYPE, fix2.num_pilots) ;

  for (i=0; i < int_ptr->epsmm.num_pilots; i++)
  {
    b_packw( int_ptr->epsmm.meas[i].pilot_pn_phase, buf_ptr,
      msg_pos, FSIZ( cai_epsm_var2_type, pilot_pn_phase ));
    msg_pos += FSIZ(cai_epsm_var2_type, pilot_pn_phase) ;

    b_packb( int_ptr->epsmm.meas[i].pilot_strength, buf_ptr,
      msg_pos, FSIZ( cai_epsm_var2_type, pilot_strength ));
    msg_pos += FSIZ(cai_epsm_var2_type, pilot_strength) ;

    b_packb( int_ptr->epsmm.meas[i].keep,
      buf_ptr, msg_pos, FSIZ( cai_epsm_var2_type, keep));
    msg_pos += FSIZ( cai_epsm_var2_type,  keep );

    b_packb( int_ptr->epsmm.meas[i].pilot_rec_incl,
      buf_ptr, msg_pos, FSIZ( cai_epsm_var2_type, pilot_rec_incl));
    msg_pos += FSIZ( cai_epsm_var2_type, pilot_rec_incl );

    if (int_ptr->epsmm.meas[i].pilot_rec_incl)
    {
      b_packb( 0,
          buf_ptr, msg_pos, FSIZ( cai_epsm_var2_type, pilot_rec_type));
          msg_pos += FSIZ( cai_epsm_var2_type, pilot_rec_type );

      rec_len_pos = msg_pos;

      msg_pos += FSIZ( cai_epsm_var2_type, record_len );

      rec_start_pos = msg_pos;

      if (int_ptr->epsmm.meas[i].pilot_rec_type == 0)
      {

        b_packb( int_ptr->epsmm.meas[i].rec.qof,
            buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,qof));
        msg_pos += FSIZ( cai_add_pilot_rec1_type,qof );

        b_packb( int_ptr->epsmm.meas[i].rec.walsh_length,
            buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,walsh_length));
        msg_pos += FSIZ( cai_add_pilot_rec1_type,walsh_length );

          /* if the aux walsh is less than 3, pack a byte */
        b_packw( int_ptr->epsmm.meas[i].rec.aux_pilot_walsh, buf_ptr,
                   msg_pos,
                   int_ptr->epsmm.meas[i].rec.walsh_length + 6);

        msg_pos += int_ptr->epsmm.meas[i].rec.walsh_length + 6;

          /* length of reserved bits */
        reserve_bits = (sizeof( cai_add_pilot_rec1_type ) +
                       int_ptr->epsmm.meas[i].rec.walsh_length ) %8;
        if( reserve_bits != 0 )
        {
          reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
          b_packb( 0, buf_ptr, msg_pos, reserve_bits );
          msg_pos += reserve_bits;
        }

        b_packb( (msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
                 FSIZ( cai_epsm_var2_type, record_len ));

      }
    }
  }

#ifdef FEATURE_IS2000_REL_B
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_B)
  {
    b_packb( int_ptr->epsmm.resq_ind_incl, buf_ptr, msg_pos,
       FSIZ(MTYPE, fix3.resq_ind_incl));
    msg_pos += FSIZ(MTYPE, fix3.resq_ind_incl);

    if (int_ptr->epsmm.resq_ind_incl)
    {
      for (i=0; i < int_ptr->epsmm.num_pilots; i++)
      {
        b_packb( int_ptr->epsmm.resq[i].resq_ind, buf_ptr, msg_pos,
                 FSIZ(cai_epsm_var3_type, resq_ind));
        msg_pos += FSIZ(cai_epsm_var3_type, resq_ind);
      }
    }
  }
#endif /* FEATURE_IS2000_REL_B */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->epsmm.hdr.msg_int.maci_incl)
  {
    MSG_MED("EPSMM using key ID %d", int_ptr->epsmm.hdr.msg_int.sdu_key_id, 0, 0);
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->epsmm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->epsmm.hdr.msg_int.sdu_key_id,
                   int_ptr->epsmm.msg_type,
                   int_ptr->epsmm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->epsmm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

#undef MTYPE
  /* Deactivate MTYPE definition */

  status = CAIX_DONE_S;
  
  /* Set message length */
  *len_ptr = msg_pos;

  return ( status );

} /* xlate_int_tc_epsmm */

/*===========================================================================

FUNCTION xlate_int_tc_ehcm

DESCRIPTION
  This function translates a Extended Handoff Completion Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_ehcm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  word i;
    /* counter for active pilot loop */
  word rec_len_pos;
    /* position where the length info needs to be packed */
  word rec_start_pos;
    /* starting position for the pilot record to be packed */
  byte reserve_bits;
    /* used for packing the zeros at the end for pilot recs */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->ehcm );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->ehcm.last_hdm_seq, buf_ptr, msg_pos,
           FSIZ( cai_ehcm_fix_type, last_hdm_seq));
  msg_pos += FSIZ( cai_ehcm_fix_type, last_hdm_seq);

  b_packb( int_ptr->ehcm.num_pilots, buf_ptr, msg_pos,
           FSIZ( cai_ehcm_fix_type, num_pilots));
  msg_pos += FSIZ( cai_ehcm_fix_type, num_pilots);

  for (i=0; i < int_ptr->ehcm.num_pilots; i++)
  {
    b_packw( int_ptr->ehcm.act_pil_rec[i].pilot_pn, buf_ptr, msg_pos,
      FSIZ( cai_ehcm_fix1_type, pilot_pn ));
    msg_pos += FSIZ( cai_ehcm_fix1_type, pilot_pn);

    b_packb( int_ptr->ehcm.act_pil_rec[i].pilot_rec_incl, buf_ptr, msg_pos,
      FSIZ( cai_ehcm_fix1_type, pilot_rec_incl ));
    msg_pos += FSIZ( cai_ehcm_fix1_type, pilot_rec_incl);

    if (int_ptr->ehcm.act_pil_rec[i].pilot_rec_incl)
    {

      b_packb( int_ptr->ehcm.act_pil_rec[i].pilot_rec_type, buf_ptr, msg_pos,
          FSIZ( cai_ehcm_var_type, pilot_rec_type));
      msg_pos += FSIZ( cai_ehcm_var_type, pilot_rec_type );

      rec_len_pos = msg_pos;

      msg_pos += FSIZ( cai_ehcm_var_type, record_len );

      rec_start_pos = msg_pos;

      /*  pack the reference pilot if it's auxiliary
          see table 2.7.2.3.2.34-1*/
      if (int_ptr->ehcm.act_pil_rec[i].pilot_rec_type == 0)
      {
        b_packb( int_ptr->ehcm.act_pil_rec[i].rec.qof,
            buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,qof));
        msg_pos += FSIZ( cai_add_pilot_rec1_type,qof );

        b_packb( int_ptr->ehcm.act_pil_rec[i].rec.walsh_length,
            buf_ptr, msg_pos, FSIZ( cai_add_pilot_rec1_type,walsh_length));
        msg_pos += FSIZ( cai_add_pilot_rec1_type,walsh_length );

        b_packw( int_ptr->ehcm.act_pil_rec[i].rec.aux_pilot_walsh, buf_ptr,
                   msg_pos,
                   int_ptr->ehcm.act_pil_rec[i].rec.walsh_length + 6);

        msg_pos += int_ptr->ehcm.act_pil_rec[i].rec.walsh_length + 6;

        /* length of reserved bits */
        reserve_bits = (sizeof( cai_add_pilot_rec1_type ) +
                              int_ptr->ehcm.act_pil_rec[i].rec.walsh_length ) %8;
        if( reserve_bits != 0 )
        {
          reserve_bits = 8 - reserve_bits;

            /* Pack reserved bits */
          b_packb( 0, buf_ptr, msg_pos, reserve_bits );
          msg_pos += reserve_bits;
        }

        b_packb( (msg_pos - rec_start_pos)>>3, buf_ptr, rec_len_pos,/*lint !e702*/
                 FSIZ( cai_ehcm_var_type, record_len ));

      }
    }
  }

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  
#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->ehcm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->ehcm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->ehcm.hdr.msg_int.sdu_key_id,
                   int_ptr->ehcm.msg_type,
                   int_ptr->ehcm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->ehcm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  status = CAIX_DONE_S;
  
  /* Set message length */
  *len_ptr = msg_pos;

  return ( status );

  /* Deactivate MTYPE definition */
} /* xlate_int_tc_ehcm */

/*===========================================================================

FUNCTION xlate_int_tc_smrm

DESCRIPTION
  This function translates a Security Mode Request Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_smrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  word i;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_smrm_fix1_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->tsmrm );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->tsmrm.ui_enc_incl, buf_ptr, msg_pos, FSIZ( MTYPE, ui_enc_incl));
  msg_pos += FSIZ( MTYPE, ui_enc_incl);

  if (int_ptr->tsmrm.ui_enc_incl)
  {
    b_packb( int_ptr->tsmrm.ui_encrypt_sup, buf_ptr, msg_pos, FSIZ( MTYPE, ui_encrypt_sup));
    msg_pos += FSIZ( MTYPE, ui_encrypt_sup);
    b_packb( int_ptr->tsmrm.num_recs, buf_ptr, msg_pos, FSIZ( MTYPE, num_recs));
    msg_pos += FSIZ( MTYPE, num_recs);

    for (i=0; i < int_ptr->tsmrm.num_recs+1; i++)
    {
      b_packb( int_ptr->tsmrm.recs[i].con_ref, buf_ptr, msg_pos,
               FSIZ( cai_smrm_var_type, con_ref));
      msg_pos += FSIZ(cai_smrm_var_type, con_ref);
      b_packb( int_ptr->tsmrm.recs[i].ui_encrypt_req, buf_ptr, msg_pos,
               FSIZ( cai_smrm_var_type, ui_encrypt_req));
      msg_pos += FSIZ(cai_smrm_var_type, ui_encrypt_req);
    }
  }

  b_packb( int_ptr->tsmrm.sig_enc_incl, buf_ptr, msg_pos,
           FSIZ( cai_smrm_fix2_type, sig_enc_incl));
  msg_pos += FSIZ( cai_smrm_fix2_type, sig_enc_incl);

  if (int_ptr->tsmrm.sig_enc_incl)
  {
    b_packb( int_ptr->tsmrm.sig_encrypt_sup, buf_ptr, msg_pos,
         FSIZ( cai_smrm_fix2_type, sig_encrypt_sup));
    msg_pos += FSIZ( cai_smrm_fix2_type, sig_encrypt_sup);

    b_packb( int_ptr->tsmrm.d_sig_encrypt_req, buf_ptr, msg_pos,
           FSIZ( cai_smrm_fix2_type, d_sig_encrypt_req));
    msg_pos += FSIZ( cai_smrm_fix2_type, d_sig_encrypt_req);

  }

  b_packb( int_ptr->tsmrm.enc_seq_h_incl, buf_ptr, msg_pos,
         FSIZ( cai_smrm_fix2_type, enc_seq_h_incl));
  msg_pos += FSIZ( cai_smrm_fix2_type, enc_seq_h_incl);

  if (int_ptr->tsmrm.enc_seq_h_incl)
  {
      b_packd( int_ptr->tsmrm.enc_seq_h, buf_ptr, msg_pos,
            FSIZ( cai_smrm_fix2_type, enc_seq_h));
      msg_pos += FSIZ( cai_smrm_fix2_type, enc_seq_h);

      b_packb( int_ptr->tsmrm.enc_seq_h_sig, buf_ptr, msg_pos,
          FSIZ( cai_smrm_fix2_type, enc_seq_h_sig));
      msg_pos += FSIZ( cai_smrm_fix2_type, enc_seq_h_sig);

  }
#ifdef FEATURE_IS2000_REL_C
  if (caix_p_rev_in_use >= CAIX_P_REV_IS2000_REL_C)
  {
    b_packb( int_ptr->tsmrm.msg_int_info_incl, buf_ptr, msg_pos,
           FSIZ( cai_smrm_fix2_type, msg_int_info_incl));
    msg_pos += FSIZ( cai_smrm_fix2_type, msg_int_info_incl);
    if (int_ptr->tsmrm.msg_int_info_incl)
    {
      b_packb( int_ptr->tsmrm.sig_integrity_sup_incl, buf_ptr, msg_pos,
             FSIZ( cai_smrm_fix2_type, sig_integrity_sup_incl));
      msg_pos += FSIZ( cai_smrm_fix2_type, sig_integrity_sup_incl);

      if (int_ptr->tsmrm.sig_integrity_sup_incl)
      {
        b_packb( int_ptr->tsmrm.sig_integrity_sup, buf_ptr, msg_pos,
               FSIZ( cai_smrm_fix2_type, sig_integrity_sup));
        msg_pos += FSIZ( cai_smrm_fix2_type, sig_integrity_sup);
        b_packb( int_ptr->tsmrm.sig_integrity_req, buf_ptr, msg_pos,
               FSIZ( cai_smrm_fix2_type, sig_integrity_req));
        msg_pos += FSIZ( cai_smrm_fix2_type, sig_integrity_req);
      }
    }

  }
#endif /* FEATURE_IS2000_REL_C */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->tsmrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->tsmrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->tsmrm.hdr.msg_int.sdu_key_id,
                   int_ptr->tsmrm.msg_type,
                   int_ptr->tsmrm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->tsmrm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

  #undef MTYPE
  /* Deactivate MTYPE definition */

return ( status );

} /* xlate_int_tc_smrm */

/*===========================================================================

FUNCTION xlate_int_tc_ccm

DESCRIPTION
  This function translates a Call Cancel Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_ccm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_ccm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->ccm );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->ccm.tag, buf_ptr, msg_pos, FSIZ( MTYPE, tag));
  msg_pos += FSIZ( MTYPE, tag);

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
  
#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->ccm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->ccm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->ccm.hdr.msg_int.sdu_key_id,
                   int_ptr->ccm.msg_type,
                   int_ptr->ccm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->ccm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

#undef MTYPE
  /* Deactivate MTYPE definition */

return ( status );

} /* xlate_int_tc_ccm */

/*===========================================================================

FUNCTION xlate_int_tc_dim

DESCRIPTION
  This function translates a Device Information Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_dim
(
  word *len_ptr,
    /* Length of message in bits */

  byte *buf_ptr,
    /* Pointer to where translated message should be placed */

  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  word i;
    /* For indexing through info recs */
  word irec_pos;
    /* For indexing through info rec bytes */
  word irec_len;
    /* For receiving length, in bytes, of internal info rec processed. */
  word xrec_len;
    /* For receiving length, in bits, of external info rec. */

  #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
  #endif /* FEATURE_MSG_PACK_UNIT_TEST */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_dim_fix_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->rdim );

  /* Translate remainder of fields for message */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->rdim.wll_device_type,
           buf_ptr, msg_pos, FSIZ( MTYPE, wll_device_type));
  msg_pos += FSIZ( MTYPE, wll_device_type);

  b_packb( int_ptr->rdim.num_recs,
           buf_ptr, msg_pos, FSIZ( MTYPE, num_info_records));
  msg_pos += FSIZ( MTYPE, num_info_records);

  #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
  #endif /* FEATURE_MSG_PACK_UNIT_TEST */

  /* Translate info recs */
  for (i = irec_pos = 0; i < int_ptr->rdim.num_recs; i++)
  {

    #ifdef FEATURE_MSG_PACK_UNIT_TEST
#error code not present
    #else
    status = xlate_int_info_rec((byte*) (&int_ptr->rdim.recs[irec_pos/4]), &irec_len, 
                                (word) (CAI_REV_TC_MSG_BODY_SIZE - msg_pos - FSIZ( cai_tc_strsp_fix_type, reserved)),
                                buf_ptr, msg_pos, &xrec_len );
    #endif /* FEATURE_MSG_PACK_UNIT_TEST */

    if (status != CAIX_DONE_S)
    {
      return (status);
    }

    msg_pos  += xrec_len; /* Advance external message position */
    irec_pos += irec_len; /* Advance internal message position */
    /* The next record will start only on a dword boundary, so move positions accordingly */

    irec_pos = (irec_pos%4) ? (irec_pos+(sizeof(dword))-irec_pos%4) : irec_pos;

  } /* for */

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->rdim.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->rdim.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->rdim.hdr.msg_int.sdu_key_id,
                   int_ptr->rdim.msg_type,
                   int_ptr->rdim.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->rdim.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  *len_ptr = msg_pos;
    /* Set message length */

  status = CAIX_DONE_S;

#undef MTYPE
  /* Deactivate MTYPE definition */

  return ( status );

} /* xlate_int_tc_dim */
#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A_BSID
/*===========================================================================

FUNCTION XLATE_INT_BS_STATUS_REQ

DESCRIPTION
  This function translates a Traffic Channel Base Station Status Request
  Message from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_bs_status_req
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* Status to be returned to calling procedure */
  word i, j;
   /* Index to loop through character fields */
  word msg_pos=0;
  /* Position to pack message in */
  word record_len;
  /* Record length */
  word record_pos;
  /* Position of the record */
  word reserved_bits;
  /* Number of reserved bits to be packed */
  word qual_info_len;
  /* Qualinficaton Information Length */
#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* ------------------------------------
  ** Set up MTYPE for use in PARAMS macro
  ** ------------------------------------ */
  #define MTYPE cai_bs_status_req_type

  /* ------------
  ** Pack message
  ** ------------ */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->bssreq);

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

  b_packb( int_ptr->bssreq.qual, buf_ptr, msg_pos,
           FSIZ( MTYPE, bss_fix.qual_info_type));
  msg_pos += FSIZ( MTYPE, bss_fix.qual_info_type);

  switch ( int_ptr->bssreq.qual )
  {
    case CAI_NO_QUAL:
      qual_info_len = 0;
      b_packb( qual_info_len, buf_ptr, msg_pos,
               FSIZ( MTYPE, bss_fix.qual_info_len ));
      msg_pos += FSIZ( MTYPE, bss_fix.qual_info_len);
      break;

    case CAI_BAND_QUAL:
      qual_info_len = sizeof(cai_qual_info1_type)/8;
      b_packb( qual_info_len, buf_ptr, msg_pos,
               FSIZ( MTYPE, bss_fix.qual_info_len ));
      msg_pos += FSIZ( MTYPE, bss_fix.qual_info_len);

      b_packb( int_ptr->bssreq.band, buf_ptr, msg_pos,
               FSIZ( MTYPE, qi.qi1.band ));
      msg_pos += FSIZ( MTYPE, qi.qi1.band );

      b_packb( 0, buf_ptr, msg_pos,
               FSIZ( MTYPE, qi.qi1.reserved ));
      msg_pos += FSIZ( MTYPE, qi.qi1.reserved );
      break;

    case CAI_BAND_OP_MODE_QUAL:
      qual_info_len = sizeof(cai_qual_info2_type)/8;
      b_packb( qual_info_len, buf_ptr, msg_pos,
               FSIZ( MTYPE, bss_fix.qual_info_len ));
      msg_pos += FSIZ( MTYPE, bss_fix.qual_info_len);

      b_packb( int_ptr->bssreq.band, buf_ptr, msg_pos,
               FSIZ(MTYPE, qi.qi2.band ));
      msg_pos += FSIZ(MTYPE, qi.qi2.band);
      b_packb( int_ptr->bssreq.op_mode, buf_ptr, msg_pos,
               FSIZ(MTYPE, qi.qi2.op_mode ));
      msg_pos += FSIZ(MTYPE, qi.qi2.op_mode );

      b_packb( 0, buf_ptr, msg_pos,
               FSIZ(MTYPE, qi.qi2.reserved ));
      msg_pos += FSIZ(MTYPE, qi.qi2.reserved );
      break;

    default:
      MSG_ERROR( "BSSREQ: Qual_info_type %d unsupported",
                 int_ptr->bssreq.qual, 0, 0 );
      return CAIX_INV_MSG_S;
  }

  b_packb( int_ptr->bssreq.num_record, buf_ptr, msg_pos,
           FSIZ( MTYPE, bss_fix.num_record ));
  msg_pos += FSIZ( MTYPE, bss_fix.num_record);

  if ( CAI_BSS_NUM_RECORDS < int_ptr->bssreq.num_record )
  {
    MSG_ERROR( "BSSREQ: num_record %d overflow",
               int_ptr->bssreq.num_record, 0, 0);
    return CAIX_INV_MSG_S;
  }

  for ( i = 0; i < int_ptr->bssreq.num_record; i++ )
  {
    if (int_ptr->bssreq.bss_rec[i].record_type != CAI_BSS_PILOT_INFO_REQ)
    {
      MSG_ERROR( "BSSREQ: Record_type %d unsupported",
                 int_ptr->bssreq.bss_rec[i].record_type, 0, 0 );
      return CAIX_INV_MSG_S;
    }
    else
    {
      b_packb( int_ptr->bssreq.bss_rec[i].record_type, buf_ptr, msg_pos,
               FSIZ( MTYPE, rec_fix.record_type ));
      msg_pos += FSIZ( MTYPE, rec_fix.record_type );

      /* Skip the record_length for now */
      msg_pos += FSIZ( MTYPE, rec_fix.record_length );

      /* Record Type 0. Set the record position here for the   */
      /* record type 0 specific fields.                        */
      record_pos = msg_pos;

      b_packb( int_ptr->bssreq.bss_rec[i].pi.num_pilots, buf_ptr, msg_pos,
               FSIZ( MTYPE, rec0.fix.num_pilots ));
      msg_pos += FSIZ( MTYPE, rec0.fix.num_pilots );
      b_packb( int_ptr->bssreq.bss_rec[i].pi.sid_nid_req, buf_ptr, msg_pos,
               FSIZ( MTYPE, rec0.fix.sid_nid_req ));
      msg_pos += FSIZ( MTYPE, rec0.fix.sid_nid_req );

      if (CAI_BSS_NUM_PILOTS < int_ptr->bssreq.bss_rec[i].pi.num_pilots)
      {
        MSG_ERROR( "BSSREQ: num_pilots %d overflow",
                   int_ptr->bssreq.bss_rec[i].pi.num_pilots, 0, 0);
        return CAIX_INV_MSG_S;
      }

      for (j = 0; j < int_ptr->bssreq.bss_rec[i].pi.num_pilots; j++ )
      {
        b_packw( int_ptr->bssreq.bss_rec[i].pi.pilot_pn[j], buf_ptr, msg_pos,
                 FSIZ( MTYPE, rec0.var.pilot_pn ));
        msg_pos += FSIZ( MTYPE, rec0.var.pilot_pn );
      }
#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

      /* Pack the reserved bits */
      reserved_bits = 8 - ((msg_pos - record_pos) % 8);
      if (reserved_bits != 8)
      {
        b_packb( 0, buf_ptr, msg_pos, reserved_bits );
        msg_pos += reserved_bits;
      }

      /* Pack the record_length, in octets */
      record_len = ( msg_pos - record_pos ) / 8;
      b_packb( record_len, buf_ptr,
               record_pos - FSIZ(MTYPE, rec_fix.record_length),
               FSIZ( MTYPE, rec_fix.record_length ));
    }
  } /* for num_record */

#ifdef FEATURE_IS2000_REL_A_AES
#error code not present
#endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->bssreq.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->bssreq.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->bssreq.hdr.msg_int.sdu_key_id,
                   int_ptr->bssreq.msg_type,
                   int_ptr->bssreq.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->bssreq.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;
  
  #undef MTYPE
  
  return (status);

} /* xlate_int_bs_status_req */
#endif /* FEATURE_IS2000_REL_A_BSID */

#ifdef FEATURE_IS2000_REL_B
/*===========================================================================

FUNCTION xlate_int_tc_cotrm

DESCRIPTION
  This function translates a CDMA Off Time Report Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_cotrm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_cotrm_type

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr(&msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->cotrm);

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packb(int_ptr->cotrm.cdma_off_time_enable, buf_ptr, msg_pos,
    FSIZ(MTYPE, cdma_off_time_enable));
  msg_pos += FSIZ(MTYPE, cdma_off_time_enable);

  if (int_ptr->cotrm.cdma_off_time_enable)
  {
    b_packb(int_ptr->cotrm.cdma_off_time_start, buf_ptr, msg_pos,
      FSIZ(MTYPE, cdma_off_time_start));
    msg_pos += FSIZ(MTYPE, cdma_off_time_start);

    b_packb(int_ptr->cotrm.cdma_off_time_unit, buf_ptr, msg_pos,
      FSIZ(MTYPE, cdma_off_time_unit));
    msg_pos += FSIZ(MTYPE, cdma_off_time_unit);

    b_packb(int_ptr->cotrm.cdma_off_time_mode, buf_ptr, msg_pos,
      FSIZ(MTYPE, cdma_off_time_mode));
    msg_pos += FSIZ(MTYPE, cdma_off_time_mode);

    b_packb(int_ptr->cotrm.cdma_off_time, buf_ptr, msg_pos,
      FSIZ(MTYPE, cdma_off_time));
    msg_pos += FSIZ(MTYPE, cdma_off_time);

    if (int_ptr->cotrm.cdma_off_time_mode)
    {
      b_packb(int_ptr->cotrm.cdma_off_time_period, buf_ptr, msg_pos,
        FSIZ(MTYPE, cdma_off_time_period));
      msg_pos += FSIZ(MTYPE, cdma_off_time_period);
    }

  }

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

#ifdef FEATURE_IS2000_REL_C
  /* Pack MACI field */
  if (int_ptr->cotrm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->cotrm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->cotrm.hdr.msg_int.sdu_key_id,
                   int_ptr->cotrm.msg_type,
                   int_ptr->cotrm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->cotrm.hdr.msg_int.maci
                   );
  }
#endif /* FEATURE_IS2000_REL_C */
  
  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

#undef MTYPE

  return ( status );

} /* xlate_int_tc_cotrm */
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
/*===========================================================================

FUNCTION xlate_int_tc_aurspm

DESCRIPTION
  This function translates a Autehntication Response Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_aurspm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_aurspm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->taurspm );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packq(int_ptr->taurspm.res_hi, buf_ptr, msg_pos,
            FSIZ(MTYPE,  res )/2);
  msg_pos += FSIZ(MTYPE,  res )/2;
  b_packq(int_ptr->taurspm.res_lo, buf_ptr, msg_pos,
            FSIZ(MTYPE,  res )/2);
  msg_pos += FSIZ(MTYPE,  res )/2;

  b_packb(int_ptr->taurspm.sig_integrity_sup_incl, buf_ptr, msg_pos,
          FSIZ(MTYPE,sig_integrity_sup_incl));
  msg_pos += FSIZ(MTYPE,sig_integrity_sup_incl);
  if (int_ptr->taurspm.sig_integrity_sup_incl)
  {
    b_packb(int_ptr->taurspm.sig_integrity_sup, buf_ptr, msg_pos,
            FSIZ(MTYPE,sig_integrity_sup));
    msg_pos += FSIZ(MTYPE,sig_integrity_sup);
    b_packb(int_ptr->taurspm.sig_integrity_req, buf_ptr, msg_pos,
            FSIZ(MTYPE,sig_integrity_req));
    msg_pos += FSIZ(MTYPE,sig_integrity_req);
  }
  b_packb(int_ptr->taurspm.new_key_id, buf_ptr, msg_pos,
          FSIZ(MTYPE,new_key_id));
  msg_pos += FSIZ(MTYPE,new_key_id);

  b_packd(int_ptr->taurspm.new_sseq_h, buf_ptr, msg_pos,
          FSIZ(MTYPE,new_sseq_h));
  msg_pos += FSIZ(MTYPE,new_sseq_h);


  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  /* Pack MACI field */
  if (int_ptr->taurspm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->taurspm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->taurspm.hdr.msg_int.sdu_key_id,
                   int_ptr->taurspm.msg_type,
                   int_ptr->taurspm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->taurspm.hdr.msg_int.maci
                   );
  }

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

#undef MTYPE

  return ( status );

}

/*===========================================================================

FUNCTION xlate_int_tc_aursynm

DESCRIPTION
  This function translates a Autehntication ReSync Message from
  internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_aursynm
(
  word *len_ptr,
    /* Length of message in bits */
  byte *buf_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* For receiving status from called funcs */
  word msg_pos;
    /* Position to pack message in */
  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define MTYPE cai_aursynm_type
  /* Set up MTYPE definition for PARAMS macro */

  /* ---------------------------------------------------------
  ** Pack message type, ARQ, encryption, message integrity and 
  ** extended-encryption fields.
  ** --------------------------------------------------------- */
  xlate_int_tc_hdr( &msg_pos, buf_ptr, (caii_gen_tc_type *) &int_ptr->taursynm );

  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  b_packq(int_ptr->taursynm.con_ms_sqn, buf_ptr, msg_pos,
            FSIZ(MTYPE, con_ms_sqn ));
  msg_pos += FSIZ(MTYPE, con_ms_sqn );

  b_packq(int_ptr->taursynm.mac_s, buf_ptr, msg_pos,
          FSIZ(MTYPE,mac_s));
  msg_pos += FSIZ(MTYPE,mac_s);


  #ifdef FEATURE_IS2000_REL_A_AES
#error code not present
  #endif /* FEATURE_IS2000_REL_A_AES */

  /* Pack MACI field */
  if (int_ptr->taursynm.hdr.msg_int.maci_incl)
  {
    xlate_int_maci(&msg_pos,
                   buf_ptr,
                   CAI_TC_CRC_SIZE,
                   int_ptr->taursynm.hdr.ack_req,
                   CAIX_TC,
                   int_ptr->taursynm.hdr.msg_int.sdu_key_id,
                   int_ptr->taursynm.msg_type,
                   int_ptr->taursynm.hdr.msg_int.sdu_integrity_algo,
                   #ifdef FEATURE_IS2000_REL_C_MI
#error code not present
                   #endif /* FEATURE_IS2000_REL_C_MI */
                   &int_ptr->taursynm.hdr.msg_int.maci
                   );
  }

  /* Set message length */
  *len_ptr = msg_pos;

  status = CAIX_DONE_S;

#undef MTYPE

  return ( status );

}
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

/*===========================================================================

FUNCTION XLATE_INT_TC_MSG

DESCRIPTION
  This function translates a Traffic Channel message to be transmitted
  to the base station from internal to external format.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word xlate_int_tc_msg
(
  word *len_ptr,
    /* Length of message in bits */
  byte *tc_ptr,
    /* Pointer to where translated message should be placed */
  caii_tx_msg_type *int_ptr
    /* Pointer to internal message to be transmitted */
)
{
  word status;
    /* Status to be returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (int_ptr->gen_tc.msg_type) {
    case CAI_TC_REV_ORD_MSG:
      status = xlate_int_tc_ord( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX order type 0x%x ack_seq %x msg_seq %x",
                int_ptr->tc_ord.gen.order,
                int_ptr->tc_ord.gen.hdr.ack_seq,
                int_ptr->tc_ord.gen.hdr.msg_seq );
      break;

    case CAI_TC_AUTH_RESP_MSG:
      status = xlate_int_auth_resp( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX auth resp, authu %lx",
                int_ptr->auth_resp.authu, 0, 0 );
      break;

    case CAI_REV_FLASH_MSG:
      status = xlate_int_flash( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX Flash with %x records",
                int_ptr->flash.num_recs, 0, 0 );
      break;

    case CAI_TC_REV_BURST_MSG:
      status = xlate_int_tc_burst( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC burst msg# %x type %x msgs %x",
                int_ptr->tc_burst.msg_number,
                int_ptr->tc_burst.burst_type,
                int_ptr->tc_burst.num_msgs );
      break;

    case CAI_PIL_STR_MSG:
      status = xlate_int_pil_str( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX Pil Str ref %x #pn's %x ",
                int_ptr->pil_str.ref_pn,
                int_ptr->pil_str.num_msr, 0 );
      break;

    case CAI_PWR_MSR_MSG:
      status = xlate_int_pwr_msr( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX PMRM, FCH/DCCH: errs %d frames %d",
                int_ptr->pwr_rpt.errors_detected,
                int_ptr->pwr_rpt.pwr_meas_frames, 0 );
      if (int_ptr->pwr_rpt.sch_pwr_meas_incl)
      {
        MSG_HIGH ( "TX PMRM, SCH: errs %d frames %d",
                  int_ptr->pwr_rpt.sch_errors_detected,
                  int_ptr->pwr_rpt.sch_pwr_meas_frames, 0);
      }
      break;

    case CAI_SEND_DTMF_MSG:
      status = xlate_int_send_dtmf( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX DTMF %x", int_ptr->sbdtmf.digit[0], 0, 0 );
      break;

    case CAI_STATUS_MSG:
      status = xlate_int_status( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX status message ", 0, 0, 0 );
      break;

    case CAI_ORIG_C_MSG:
      status = xlate_int_orig_c( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX Orig Cont with %x digits",
                int_ptr->orig_c.num_fields, 0, 0 );
      break;

    case CAI_HO_COMP_MSG:
      status = xlate_int_comp( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX HO Comp with %x pilots, hdm_seq %x",
                int_ptr->comp.num_pilots,
                int_ptr->comp.last_hdm_seq, 0 );
      break;

    case CAI_PARM_RSP_MSG:
      status = xlate_int_parm_rsp( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "RX Parms Resp with %x parms",
                int_ptr->parm_rsp.num_parms, 0, 0 );
      break;

    case CAI_RTC_SRV_REQ_MSG:
      status = xlate_int_srv_req( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX Srv Req. Purp: %x Num Con: %x",
                int_ptr->srv_req.purp, int_ptr->srv_req.cfg.num_con, 0 );
      break;

    case CAI_RTC_SRV_RSP_MSG:
      status = xlate_int_srv_rsp( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX Srv Rsp. Purp: %x Num Con: %x",
                int_ptr->srv_rsp.purp, int_ptr->srv_rsp.cfg.num_con, 0 );
      break;

    case CAI_SRV_CMP_MSG:
      status = xlate_int_srv_cmp( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX Srv Cmp. Con Seq: %x",
                int_ptr->srv_cmp.con_seq, 0, 0 );
      break;

    case CAI_RTC_SRV_CTL_MSG:
      status = xlate_int_srv_ctl( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX Srv Ctl. Con Ref: %x SO: %x",
                int_ptr->srv_ctl.con_ref, int_ptr->srv_ctl.so, 0 );
      break;

    case CAI_TC_STRSP_MSG:
      status = xlate_int_tc_strsp( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX Stat Rsp", 0, 0, 0 );
      break;

    case CAI_RTC_TMSI_CMP_MSG:
      status = xlate_int_tc_tmsi_cmp( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC TMSI Assignment Completion msg", 0, 0, 0 );
      break;

    case CAI_SUP_CHAN_REQ_MSG:
      status = xlate_int_tc_sc_req( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Supplemental Channel Request msg", 0, 0, 0 );
      break;

    case CAI_CFS_RSP_MSG:
      status = xlate_int_tc_cfs_rsp( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Candidate Frequency Search Response msg", 0, 0, 0 );
      break;

    case CAI_CFS_RPT_MSG:
      status = xlate_int_tc_cfs_rpt( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Candidate Frequency Search Report msg", 0, 0, 0 );
      break;

    case CAI_PER_PLT_STR_MSG:
      status = xlate_int_tc_per_plt( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Periodic Pilot Strength Measurement msg", 0, 0, 0 );
      break;


    case CAI_OUTER_RPT_MSG:
      status = xlate_int_tc_outer_rpt( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Outer Loop Report Message", 0, 0, 0 );
      break;


#if defined(FEATURE_IS2000_CHS)||defined(FEATURE_IS2000_REL_A)
  case CAI_RES_REQ_MSG:
    status = xlate_int_tc_rrm( len_ptr, tc_ptr, int_ptr );
    MSG_MED ( "TX TC Resource Request Message", 0, 0, 0 );
    break;

  case CAI_EXT_REL_RSP_MSG:
    status = xlate_int_tc_errm( len_ptr, tc_ptr, int_ptr );
    MSG_MED ( "TX TC Extended Release Response Message", 0, 0, 0 );
    break;

  case CAI_RES_REL_REQ_MSG:
    status = xlate_int_tc_rrrm( len_ptr, tc_ptr, int_ptr );
    MSG_MED ( "TX TC Resource Release Request Message", 0, 0, 0 );
    break;
#endif /* REL_A || CHS */


#ifdef FEATURE_IS2000_REL_A

      /* Following messages are added in Release A */

    case CAI_EOM_MSG:
      status = xlate_int_tc_eom( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Enhanced Origination Message", 0, 0, 0 );
      break;

    case CAI_EFWIM_MSG:
      status = xlate_int_tc_efwim( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Extended Flash with Info Message", 0, 0, 0 );
      break;

    case CAI_EPSMM_MSG:
      status = xlate_int_tc_epsmm( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Extended Pilot Strength Meas Message", 0, 0, 0 );
      break;

    case CAI_EHOCM_MSG:
      status = xlate_int_tc_ehcm( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Extended Handoff Completion Message", 0, 0, 0 );
      break;

    case CAI_SMRM_MSG:
      status = xlate_int_tc_smrm( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Security Mode Request Message", 0, 0, 0 );
      break;

    case CAI_UZURM_MSG:
      status = xlate_int_tc_uzurm( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Uzer Zone Update Message", 0, 0, 0 );
      break;

    case CAI_CLCM_MSG:
      status = xlate_int_tc_ccm( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Call Cancel Message", 0, 0, 0 );
      break;

    case CAI_DIM_MSG:
      status = xlate_int_tc_dim( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Device Information Message", 0, 0, 0 );
      break;

#endif /* FEATURE_IS2000_REL_A */

#ifdef FEATURE_IS2000_REL_A_BSID
    case CAI_BS_STATUS_REQ_MSG:
      status = xlate_int_bs_status_req( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC BS Status Request Message", 0, 0, 0 );
      break;
#endif /* FEATURE_IS2000_REL_A_BSID */

#ifdef FEATURE_IS2000_REL_B
    case CAI_COTRM_MSG:
      status = xlate_int_tc_cotrm( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC CDMA Off Time Report Message", 0, 0, 0 );
      break;
#endif /* FEATURE_IS2000_REL_B */

#ifdef FEATURE_IS2000_REL_C
    case CAI_AUTH_RESYNC_MSG:
      status = xlate_int_tc_aursynm( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Auth Resync Message", 0, 0, 0 );
      break;
    case CAI_AUTH_RSP_MSG:
      status = xlate_int_tc_aurspm( len_ptr, tc_ptr, int_ptr );
      MSG_MED ( "TX TC Auth Response Message", 0, 0, 0 );
      break;
#endif /* FEATURE_IS2000_REL_C */

#ifdef FEATURE_IS2000_REL_D
#error code not present
#endif /* FEATURE_IS2000_REL_D */

    default:
      status = CAIX_INV_MSG_S;
      break;
  } /* end of switch */

#ifdef FEATURE_AUTH
  if ((int_ptr->gen_tc.hdr.encryption == CAI_ENCRYPT_CALL_CTL_MSGS )
      && ((int_ptr->gen.msg_type != CAI_ORIG_C_MSG)
#ifdef FEATURE_IS2000_REL_A_SVD
      && (int_ptr->gen_tc.msg_type != CAI_EOM_MSG)
#endif /* FEATURE_IS2000_REL_A_SVD */
         )
     )
  {
    auth_encrypt_cdma( len_ptr, tc_ptr, int_ptr );
  }
#endif /* FEATURE_AUTH */

  return (status);

} /* xlate_int_tc_msg */

/*===========================================================================

FUNCTION CAIX_INT_TO_EXT

DESCRIPTION
  This function translates a message from the internal format used by
  the Main Control task to the external format used by the Transmit
  task.

DEPENDENCIES
  None

RETURN VALUE
  Errors that were encountered while translating the message.

SIDE EFFECTS
  None

===========================================================================*/

word caix_int_to_ext
(
  word *len_ptr,
    /* Pointer to where message length, in bits, should be placed */
  word chn,
    /* Channel message is to be transmitted on */
  caii_tx_msg_type *int_msg_ptr,
    /* Pointer to internal mesage to be translated */
  cai_tx_msg_type *tx_msg_ptr,

  /* Pointer to where translated message should be placed */
  uint8 parsing_reason
  /* This flag indicates the true reason of why this function is 
   * getting called. Currently there are two reasons defined:
   *
   * CAIX_CALC_AC_MSG_LENGTH:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to get the message length only
   *
   * CAIX_PARSE_MSG:
   * this reason is used to indicate that the function call
   * of caix_int_to_ext is to really parsing the message before 
   * transmission. This means the binary stream will go through the full
   * AES procedure
   */
)
{
  word status;
    /* Status returned to calling procedure */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#ifndef FEATURE_MSG_PACK_UNIT_TEST
  caix_p_rev_in_use = mc_get_p_rev_in_use();
#endif /* !FEATURE_MSG_PACK_UNIT_TEST */

  switch (chn) 
  {
    case CAIX_AC:
    #ifdef FEATURE_IS2000_REL_A
    case CAIX_REACH:
    case CAIX_RCCCH:
    case CAIX_RCSCH:
    #endif /* FEATURE_IS2000_REL_A */
      status = xlate_int_ac_msg( len_ptr, tx_msg_ptr->ac.body, int_msg_ptr, chn, parsing_reason );
      break;

    case CAIX_TC:
      status = xlate_int_tc_msg( len_ptr, tx_msg_ptr->tc.body, int_msg_ptr );
      break;

    default:
      status = CAIX_INV_CHN_S;
      break;
  } /* end of switch */

  return (status);

} /* cai_int_to_ext */

