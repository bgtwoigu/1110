//-------------------------------------------------------------------------------------
//          Copyright ? 2009-2010 HXCOM                                             
//                All Rights Reserved.                                                 
//   The file is generated by Component Wizard for QUALCOMM Mobile Platform            
// FileName:   CMMITv.h                                                                      
// Author:     pengli                                                                      
// Date:       2006-04-21                                                                      
// Log:   Author             Date             Description                              
// ------------------------------------------------------------------------------------
//        pengli        2006-04-21       Generate source file frame                                
//-------------------------------------------------------------------------------------

#include "OEMFeatures.h"
#include "AEEStdLib.h"
//#include "AppUtil.h"
#include "IMMITv.h"
//#include "MMIClassID.h"
#include "AEEFile.h"
//#include "MMITrace.h"
//#include "FileStr.h"
//#include "FileFunc.h"
//#include "MMIFilePath.h"
//#include "AEEBitmap.h"
//#include "MMIEvents.h"
//#include "UI_Common.h"
#include "AEETv.h"
#include "AEE_OEM.h"

#include "OEMHeap.h"
#ifndef AEE_SIMULATOR
#include "QCamraw.h"
//#include "OEMCameraDMSS.h"
#include "Camsensor.h"
//#include "CBitmapConvert.h"
//#include "IAudioDevice.h"
#include "snd.h"
#endif

#include "AEEEvent.h"
#include "IYCbCr.h"
//#include "MMIMemory.h"
//#include "CMessageBox.h"
//#include "TvUtil_UI.h"
#include "TVApp_priv.h"
#include "MMITvParm.h"


//////////////////////////////////////////////////////////////////////////
// TODO: Add user include files here                                   
//////////////////////////////////////////////////////////////////////////
#define MMITV_FILEPATH_LENGTH 	AEE_MAX_FILE_NAME

#define MMI_SUCCESS(result) (result == SUCCESS? TRUE:FALSE)
#define MMI_FAILURE(result) (result == SUCCESS? FALSE:TRUE)




//#define MMI_CAMERA_UI_LIMIT
#if 1
static const AEESize MMITV_Resolution[] =
{
	{ 320, 240 },   /*QCAM_SIZE_QVGA*/
	{ 640, 480 },   /*QCAM_SIZE_VGA*/
	{ 1024, 768 },  /*QCAM_SIZE_XGA*/
	{ 1280, 960 },  /*QCAM_SIZE_4VGA*/
	{ 1600, 1200 },   /*QCAM_SIZE_4VGA*/
	{ 2048, 1536 }
};
#else
static const AEESize MMITV_Resolution[] =
{
	{ 240, 320 },   /*QCAM_SIZE_QVGA*/
	{ 480, 640 },   /*QCAM_SIZE_VGA*/
	{ 768, 1024},  /*QCAM_SIZE_XGA*/
	{ 960, 1280},  /*QCAM_SIZE_4VGA*/
	{ 1200, 1600},   /*QCAM_SIZE_4VGA*/
	{ 1536, 2048}
};
#endif


static const int32 MMITV_RECQuality[] =
{
	2,  // high quality
	1, // medium quality
	0 // low quality
};
//miaoxiaoming



typedef enum
{
	CAM_READY,
	CAM_STARTPREVIEW,
	CAM_PREVIEW,
	CAM_STOPPREVIEW,
	CAM_PREVIEWPAUSE,
	CAM_STARTSNAPSHOT,
	CAM_SNAPSHOT, // next state ready
	CAM_STARTRECORD,
	CAM_STARTINGRECORD,
	CAM_RECORDING,
	CAM_RECORDPAUSED,
	CAM_STOPRECORD,// next state ready
}T_CAM_STATE;

typedef struct
{
	uint32 RecordStartTime;
	uint32 RecordTotalTime;
	uint32 LastTime;
}MMITV_RecTime_Parm;


typedef struct
{
    uint32 nRefs;
    IShell *pIShell;

    IMMITv    myIMMITv;

    //////////////////////////////////////////////////////////////////////////
    // TODO: Add variables here
    //////////////////////////////////////////////////////////////////////////
	ICBMMITv	*pICBMMITv;
	ITlgAtv			*pITv;
	T_CAM_STATE		Cam_State;
	boolean			b_IsAutoSave;
	uint32 			FileLimit;
    uint16          CurChnIdx; 
    uint8           CountChannel;//一共搜到了多少个台
    boolean         hasChannelFinish;//搜台是否完毕
    ACONTEXT*       pContext;
	boolean 		b_IsUserSetLimit;
	IBitmap			*pIShowFrame; // frame
	boolean			b_FistFrameGet;
	AEERect 		DisplayRect;
	char			*pCurFilepath;
	T_PICTURE_TYPE	Picture_Type;
	T_VIDEO_TYPE	Video_Type;
	boolean 		b_IsNightMode;
	MMIRecordTime  RecordingTime;
	MMITV_RecTime_Parm RecordingTime_parm;
	boolean			b_IsRecAutoStop;
//#ifdef MMI_CAMERA_UI_LIMIT
	int8			RecordingFrame;
//#endif
#ifndef AEE_SIMULATOR
	//IBitmapConvert  *pIBitmapConvert;	
#endif
	boolean			bLandscapeview;
	T_TV_QUALITY QualityValue;
    uint16  ableChannelArray[MAX_CHANNEL_NUMBER];
    uint16  ableChannelIndex;//ableChannel的下标索引

    boolean        b_CamSizeHaveSet;

}CMMITv;

uint32  CMMITv_IBase_AddRef(IMMITv* pIMMITv);
uint32  CMMITv_IBase_Release(IMMITv* pIMMITv);
int     CMMITv_IBase_QueryInterface(IMMITv* pIMMITv, AEECLSID ClsID, void** ppInterface);
static void CMMITv_AtvSetChn_CallBack(void *pUser, ATV_SetChn_Notify_t *pTvNotify);

int CMMITv_IMMITv_CreateTv(IMMITv* pIMMITv, ICBMMITv *pICBMMITv,uint32 region);
int CMMITv_IMMITv_SetDisplaySize(IMMITv* pIMMITv,AEESize *pDisplaySize);
int CMMITv_IMMITv_AutoScanTV(IMMITv* pIMMITv);
int CMMITv_IMMITv_SetTvChannel(IMMITv* pIMMITv, uint16 Channel,boolean fast);
int CMMITv_IMMITv_GetTvChannel(IMMITv* pIMMITv);
int CMMITv_IMMITv_StartPreview(IMMITv* pIMMITv);
int CMMITv_IMMITv_StopPreview(IMMITv* pIMMITv);

int CMMITv_EnableVolPlay(IMMITv *pIMMITv,boolean  bVal);
int CMMITv_IMMITv_SetRegion(IMMITv* pIMMITv, TLG_REGION_CODE region);
uint8 CMMITv_IMMITv_GetChannelCountAble(IMMITv* pIMMITv);//返回搜到了的有信号的台总和
boolean CMMITv_IMMITv_HasChannelFinish(IMMITv* pIMMITv);//搜索完毕返回TRUE，否则返回FALSE
void CMMITv_IMMITv_ReSetScanTag(IMMITv* pIMMITv);//重置搜索标志

static CMMITv* CMMITv_Constructor(IShell* pIShell);

static void CMMITv_OnTvEvent(CMMITv *pThis, MMITVEventType EventType, int16 nEvent);
static void CMMITv_ICBTimer_OnRecordTimeFeedBack(void *pUser);

static void CMMITv_Destructor(CMMITv* pThis);

static void CMMITv_ICBCamera_OnMessage(void *pUser, AEECameraNotify * pCamNotify);

uint16* CMMITv_GetAbleChannelArray(IMMITv* pThis);

int CMMITv_IMMITv_GetTF(IMMITv* pIMMITv);
int CMMITv_IMMITv_GetTG(IMMITv* pIMMITv);
int CMMITv_IMMITv_SetProperty(IMMITv* pIMMITv,TvProperty Property, TTvPropertyValue Value);


uint32 CMMITv_IBase_AddRef(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv* )pIMMITv->pData;

    pThis->nRefs++;

    return pThis->nRefs;

}

uint32 CMMITv_IBase_Release(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv* )pIMMITv->pData;

    pThis->nRefs--;
    if(pThis->nRefs == 0)
    {
        //CMMITv_Destructor(pThis);

    }

    return 0;
}

int CMMITv_IBase_QueryInterface(IMMITv* pIMMITv, AEECLSID ClsID, void** ppInterface)
{

    if(ClsID == AEECLSID_QUERYINTERFACE || ClsID == MMI_CLSID_IMMITV)
    {
        IBASE_COPY_IPTR(*ppInterface,pIMMITv);
    }

    return SUCCESS;
}
//#include "TVApp_priv.h"
// extern CFG_TvSetting_bak	*pTvSetting;
int CMMITv_IMMITv_CreateTv(IMMITv* pIMMITv,ICBMMITv *pICBMMITv,uint32 region)
{

    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
	int result = SUCCESS;
	MSG_FATAL("CMMITv_IMMITv_CreateTv- start",0,0,0);
    //////////////////////////////////////////////////////////////////////////
    // TODO:Add code here.
    /////////////////////////////////////////////////////////////////////////
    rex_sleep(100);
      if(pICBMMITv == NULL)
    {
    MSG_FATAL("CMMITv_IMMITv_CreateTv- ---------return pICBMMITv is null",0,0,0);
		return EBADPARM;
	}
	  
	if(pThis->pITv != NULL)
	{
	 MSG_FATAL("CMMITv_IMMITv_CreateTv- ---------return ENOTALLOWED",0,0,0);
		return ENOTALLOWED;
	}

	rex_sleep(100);
	pThis->pICBMMITv = pICBMMITv;	

#ifdef AEE_SIMULATOR
		return result;
#endif

	MSG_FATAL("ISHELL_CreateInstance- ---------&pThis->pITv---starting",0,0,0);

	if(pThis->pIShell == NULL)
	{
		MSG_FATAL("pThis->pIShell == NULL",0,0,0);
	}
	//rex_sleep(100);
	result = ISHELL_CreateInstance(pThis->pIShell, AEECLSID_TLG_ATV, (void**)&pThis->pITv);
	MSG_FATAL("ISHELL_CreateInstance- ---------AEECLSID_TLG_ATV",0,0,0);

	 rex_sleep(100);
	if(  pThis->pITv != NULL)
	{	

		rex_sleep(100);
#ifdef tv_ver2	     
/*创建电视之前需要设置区域*/ 
		MSG_FATAL("CMMITv_IMMITv_CreateTv- 1111",0,0,0);
        ITV_SetRegion(pThis->pITv, region);
	    result = ITV_Create(pThis->pITv);
		MSG_FATAL("CMMITv_IMMITv_CreateTv- result=%d",result,0,0);
		if( SUCCESS == result)
        {
#endif        
			MSG_FATAL("CMMITv_IMMITv_CreateTv- 2222",0,0,0);
		    ITV_RegisterNotify(pThis->pITv, (PFNATVNOTIFY)CMMITv_ICBCamera_OnMessage, pThis);//如果是创建一个TV，一个camera实例时，干脆用camera的通知机制
		    MSG_FATAL("CMMITv_IMMITv_CreateTv- 3333",0,0,0);
		    ITV_RegisterSetChnNotify(pThis->pITv, (PFNATVNOTIFY)CMMITv_AtvSetChn_CallBack, pThis);//如果是创建一个TV，一个camera实例时，干脆用camera的通知机制
#ifdef tv_ver2		    
        }
#endif        		
	}

	rex_sleep(100);
	MSG_FATAL("CMMITv_IMMITv_CreateTv- End result=%d",result,0,0);
    return result;
}


int CMMITv_IMMITv_SetDisplaySize(IMMITv* pIMMITv,AEESize *pDisplaySize)
{
	CMMITv* pThis = (CMMITv*)pIMMITv->pData;

	if(pDisplaySize == NULL)
	{
		return EBADPARM;
	}	

#ifdef AEE_SIMULATOR
		return SUCCESS;
#endif

	if(pThis->pITv != NULL)
	{		
		ITV_SetDisplaySize(pThis->pITv, pDisplaySize);		
	}
	return SUCCESS;
}


int CMMITv_IMMITv_AutoScanTV(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
    int ChannelTotal;
    
#ifdef AEE_SIMULATOR
	return 0;
#endif   
   
    ITV_GetChnCount(pThis->pITv, &ChannelTotal);
        
    MSG_FATAL("AutoScanTV count=%d",ChannelTotal,0,0);
    MSG_FATAL("AutoScanTV CurChnIdx=%d",pThis->CurChnIdx,0,0);
    if (pThis->CurChnIdx <= ChannelTotal)//&&(pThis->CurChnIdx==0))
    {
        pThis->hasChannelFinish = FALSE;
        ITV_SetChn(pThis->pITv,pThis->CurChnIdx,ATV_AUTO_SCAN);
		MSG_FATAL("ISHELL_PostEvent---------ATV_AUTO_SCAN-----curchnidx=%d",pThis->CurChnIdx,0,0);
    }
    else
    {
      //  MMI_DEBUG(ATV, ("search has finish"));
        pThis->hasChannelFinish = TRUE;
        pThis->CurChnIdx = 1;//表示搜台已完成,当前频道设为第一个搜到的台
        pThis->ableChannelIndex = 0;
		MSG_FATAL("ISHELL_PostEvent---------EVT_ATV_AUTOSCANFINISH",0,0,0);
        ISHELL_SendEvent(pThis->pIShell, AEECLSID_TVAPP,EVT_ATV_AUTOSCANFINISH, NULL, NULL);
    }
    return SUCCESS;
}
    
	int CMMITv_IMMITv_SetTvChannel(IMMITv* pIMMITv, uint16 Channel,boolean fast)
	{
		int result = SUCCESS;
		CMMITv* pThis = (CMMITv*)pIMMITv->pData;
#ifdef AEE_SIMULATOR
		return result;
#endif
	
		if (fast == TRUE)
		{
			ITV_SetChn(pThis->pITv,Channel,ATV_FAST_SET);//返回0表示没搜到台或者错误。其他值都是正常的	
		}
		else
		{
			ITV_SetChn(pThis->pITv,Channel,ATV_SET_AV_STOP);//返回0表示没搜到台或者错误。其他值都是正常的
		}
		return result;
	}


int CMMITv_IMMITv_GetTvChannel(IMMITv* pIMMITv)
{
  //  int count = 0;
   // CMMITv* pThis = (CMMITv*)pIMMITv->pData;
#ifdef AEE_SIMULATOR
    return 5;
#endif    
   // count = ITV_GetTvList(pThis);
}



uint8 CMMITv_IMMITv_GetChannelCountAble(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
    MSG_FATAL("GetChannelCountAble %d channel",pThis->CountChannel,0,0);
    return pThis->CountChannel;
}

boolean CMMITv_IMMITv_HasChannelFinish(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
    return pThis->hasChannelFinish;
}

void CMMITv_IMMITv_ReSetScanTag(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
    //MMI_DEBUG(ATV, ("CMMITv_IMMITv_ReSetScanTag Start"));
    pThis->hasChannelFinish = FALSE;
    pThis->CountChannel= 0;
   // MMI_DEBUG(ATV, ("CMMITv_IMMITv_ReSetScanTag END"));
}

int CMMITv_IMMITv_updateimg(IMMITv* pIMMITv,uint32 dwParam)
{
	CMMITv* pThis = (CMMITv*)pIMMITv->pData;
	
   MSG_FATAL("CMMITv_IMMITv_updateimg------------------",0,0,0);
	ITV_updateimg(pThis->pITv,dwParam);

}

int CMMITv_IMMITv_StopPreview(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
    int result = SUCCESS;
#ifdef AEE_SIMULATOR
    return result;
#endif
    if(pThis->pITv != NULL)
    {
        result = ITV_StopPreview(pThis->pITv);
    }
#ifdef AEE_SIMULATOR
	return result;
#endif
    
	//MMI_DEBUG(ATV, ("[CMMITv] CMMITv_IMMITv_StopPreview %x", pThis->Cam_State));
	
    if(pThis->pITv != NULL)
    {
		if(pThis->Cam_State == CAM_PREVIEW || pThis->Cam_State == CAM_PREVIEWPAUSE)
		{
			result = ITV_StopPreview(pThis->pITv);
			if(MMI_SUCCESS(result))
			{
				pThis->Cam_State = CAM_STOPPREVIEW;
				//MMI_DEBUG(ATV, ("[CMMITv] CMMITv_IMMITv_StopPreview_State CAM_STOPPREVIEW"));
			}		
		}
		else if(pThis->Cam_State != CAM_READY && pThis->Cam_State != CAM_STOPPREVIEW)
		{
			result = EBADSTATE;
		}
	}
	else
	{
		result = ENOTALLOWED;
	}

    return result;    
}


int CMMITv_IMMITv_StartPreview(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
    int result = SUCCESS;

    //////////////////////////////////////////////////////////////////////////
    // TODO:Add code here.
    //////////////////////////////////////////////////////////////////////////  
#ifdef AEE_SIMULATOR
    return result;
#endif

	if(pThis->pITv == NULL)
	{
		MSG_FATAL("pThis->pITv == NULL",0,0,0);
	}
    MSG_FATAL("CMMICamera_IMMICamera_StartPreview pThis->Cam_State = %d",pThis->Cam_State,0,0);
    if(pThis->pITv != NULL)
    {
        if(pThis->Cam_State == CAM_READY)
        {
        MSG_FATAL("------------------ITV_StartPreview",0,0,0);
            result = ITV_StartPreview(pThis->pITv);
         //  if(MMI_SUCCESS(result))
            {
                pThis->Cam_State = CAM_STARTPREVIEW;
            }
        }
        else if(pThis->Cam_State == CAM_STOPPREVIEW)
        {
            pThis->Cam_State = CAM_STARTPREVIEW;
        }
        else if(pThis->Cam_State == CAM_PREVIEW || pThis->Cam_State == CAM_STARTPREVIEW)
        {
            result = SUCCESS;
        }
        else
        {
            result = EBADSTATE;
        }
    
    }
    else
    {
     MSG_FATAL("pThis->pITv-----------------------is null",0,0,0);
        result = ENOTALLOWED;
    }

    return result;
}






static const AEEVTBL(IMMITv) gIMMITvFuncs = 
{
    CMMITv_IBase_AddRef,
    CMMITv_IBase_Release,
    CMMITv_IBase_QueryInterface,
    CMMITv_IMMITv_CreateTv,
    CMMITv_IMMITv_SetDisplaySize,
//    CMMITv_IMMITv_CancelCurJob,
    CMMITv_IMMITv_SetProperty,
  //  CMMITv_IMMITv_GetCapturedFrame,
  //  CMMITv_IMMITv_GetVideoFirstFrame,
    CMMITv_IMMITv_AutoScanTV,
    CMMITv_IMMITv_SetTvChannel,
    CMMITv_IMMITv_GetTvChannel,
    CMMITv_IMMITv_StartPreview,
    CMMITv_IMMITv_updateimg,
    CMMITv_IMMITv_StopPreview,
 //   CMMITv_IMMITv_GetChannelTotal,
    CMMITv_IMMITv_SetRegion,
    CMMITv_IMMITv_GetChannelCountAble,
    CMMITv_IMMITv_HasChannelFinish,
    CMMITv_IMMITv_ReSetScanTag,
    CMMITv_GetAbleChannelArray,
    CMMITv_EnableVolPlay,
    CMMITv_IMMITv_GetTF,
    CMMITv_IMMITv_GetTG,
  //  CMMITv_IMMITv_GetCHRLOCK   
};


//////////////////////////////////////////////////////////////////////////
// CMMITv_New() to create component instance                                  
//////////////////////////////////////////////////////////////////////////
int CMMITv_New(IShell *pIShell,AEECLSID ClsID,void** ppInterface)
{
    IMMITv* pIMMITv = NULL;
    CMMITv* pThis = NULL;
	MSG_FATAL("-----------------------CMMITv_New",0,0,0);

    if(pIShell == NULL || ppInterface == NULL)
    {
    MSG_FATAL("EBADPARM-----------------------CMMITv_New",0,0,0);
        return EBADPARM;
		
    }

    if(ClsID != MMI_CLSID_IMMITV)
    {
    	MSG_FATAL("EUNSUPPORTED-----------------------CMMITv_New",0,0,0);
    
        return EUNSUPPORTED;
		
    }

    pThis = CMMITv_Constructor(pIShell);

    if(pThis == NULL)
    {
    MSG_FATAL("ENOMEMORY-----------------------CMMITv_New",0,0,0);
        return ENOMEMORY;
		
    }

    pIMMITv = &pThis->myIMMITv;
  if(CMMITv_IBase_QueryInterface(pIMMITv,MMI_CLSID_IMMITV,ppInterface))
   {
     CMMITv_Destructor(pThis);
       return EFAILED;
   }
  MSG_FATAL("CMMITV-----------------------return SUCCESS",0,0,0);

    return SUCCESS;
}

static void CMMITv_Destructor(CMMITv* pThis)
{
    //////////////////////////////////////////////////////////////////////////
    // TODO: Add user destructor code here                                    
    //////////////////////////////////////////////////////////////////////////
    if(pThis->pITv != NULL)
    {
		ITV_RegisterNotify(pThis->pITv, NULL, pThis);
    }
	//IBASE_RELEASE_IPTR(pThis->pITv);

	//IBASE_RELEASE_IPTR(pThis->pIShowFrame);
	//MMIFree((void**)&pThis->pCurFilepath);
#ifndef AEE_SIMULATOR
	//IBASE_RELEASE_IPTR(pThis->pIBitmapConvert);
#endif

    //////////////////////////////////////////////////////////////////////////
    //Do not changed the code
   // RELEASEIF(pThis->pIShell);
 //   MMIFree((void**)&pThis);
 	sys_free(pThis);
    //////////////////////////////////////////////////////////////////////////
}


static void CMMITv_OnTvEvent(CMMITv *pThis, MMITVEventType EventType, int16 nEvent)
{
	MSG_FATAL("-----------------------CMMITv_OnTvEvent",0,0,0);

	if(pThis->pICBMMITv->pfnOnEvent != NULL)
	{
		MMITVNotify EventCB;

		EventCB.nEventType = EventType;
		EventCB.nEvent = nEvent;
		
		pThis->pICBMMITv->pfnOnEvent(pThis->pICBMMITv->pUser, &EventCB);
	}

	return;
}
static void CMMITv_ICBTimer_OnRecordTimeFeedBack(void *pUser)
{
	CMMITv *pThis = (CMMITv*)pUser;

	if (pThis->Cam_State == CAM_RECORDING)
	{
		uint32 time = GETTIMESECONDS();
		uint32 elapsedTime = 0;
		JulianType date = {0};

		if (pThis->RecordingTime_parm.RecordStartTime > 0)
		{
			elapsedTime = time - pThis->RecordingTime_parm.RecordStartTime;
		}
		elapsedTime += pThis->RecordingTime_parm.RecordTotalTime;
		
		if (pThis->RecordingTime_parm.LastTime != time)
		{
			// GETJULIANDATE returns the current date/time when seconds == 0
			if (elapsedTime > 0)
			{
				GETJULIANDATE(elapsedTime, &date);
			}
			pThis->RecordingTime.Hour = date.wHour;
			pThis->RecordingTime.Min = date.wMinute;
			pThis->RecordingTime.Sec = date.wSecond;
			if(pThis->pICBMMITv->pfnOnTimeFeedback != NULL)
			{
				pThis->pICBMMITv->pfnOnTimeFeedback(pThis->pICBMMITv->pUser, &pThis->RecordingTime);
			}
			pThis->RecordingTime_parm.LastTime = time;
		}

		ISHELL_SetTimer(pThis->pIShell, 250, (PFNNOTIFY)CMMITv_ICBTimer_OnRecordTimeFeedBack, pThis);
	}
}

static void CMMITv_AtvSetChn_CallBack(void *pUser, ATV_SetChn_Notify_t *pTvNotify)
{
    CMMITv* pThis = (CMMITv*)pUser;
    boolean result = SUCCESS;
    uint32 dwParam;
  //  AEECallback callback;
#ifdef  AEE_SIMULATOR
    return;
#endif
    
 MSG_FATAL("CMMITv_AtvSetChn_CallBack Start",0,0,0);
    dwParam = (uint32)pTvNotify->status;
    switch (pTvNotify->status)
    {
        case ATV_SET_CHN_SUCCESS:
        {
            pThis->CountChannel++;
            pThis->ableChannelArray[pThis->ableChannelIndex++] = pThis->CurChnIdx;
          //  MMI_DEBUG(ATV,("Channelable:%d", pThis->CurChnIdx));
           // MMI_DEBUG(ATV, ("CountChannel:%d", pThis->CountChannel));
        }
        break;
        
        case ATV_SET_CHN_FAILED:        
        {
             
        }
        break;        
    }
  
    pThis->CurChnIdx++;
   // MMI_DEBUG(ATV,("CMMITv_AtvSetChn_CallBack pThis->CurChnIdx=%d ",pThis->CurChnIdx)); 
   MSG_FATAL("ISHELL_SendEvent is starting---------------",0,0,0);
    result = ISHELL_SendEvent(pThis->pIShell, AEECLSID_TVAPP,EVT_ATV_AUTOSCAN , NULL, NULL);
	MSG_FATAL("ISHELL_SendEvent is end---------------",0,0,0);
  // AEE_Event(EVT_ATV_AUTOSCAN,NULL,NULL);
    if (result == TRUE)
    {
       MSG_FATAL("CMMITv_AtvSetChn_CallBack ISHELL_PostEvent success",0,0,0);        
    }
    else
    {
       MSG_FATAL("CMMITv_AtvSetChn_CallBack ISHELL_PostEvent failed",0,0,0);
    }
    //MMI_DEBUG(ATV,("CMMITv_AtvSetChn_CallBack End"));
}


static void CMMITv_ICBCamera_OnMessage(void *pUser, AEECameraNotify * pCamNotify)
{
	CMMITv *pThis = (CMMITv*)pUser;	
    int result = SUCCESS;

  //  ERR("CMMITv_ICBCamera_OnMessage  nCmd %x nStatus %x pThis->Cam_State %x", pCamNotify->nCmd,  pCamNotify->nStatus, pThis->Cam_State);
	if (pCamNotify->nCmd == CAM_CMD_START)
    {
        switch (pCamNotify->nStatus)
    	{
			case CAM_STATUS_START:
			{
				switch(pThis->Cam_State)
				{
					case CAM_STARTPREVIEW:
					{
						pThis->Cam_State = CAM_PREVIEW;
						CMMITv_OnTvEvent(pThis, MMITV_PreView, MMITV_PreView_OnStart);
					}
					break;

					case CAM_READY:
					case CAM_STOPPREVIEW:
					case CAM_STOPRECORD:
					{
                      //  MMI_DEBUG(ATV,("CMMITv_ICBCamera_OnMessage"));
						ITV_Stop(pThis->pITv);
						pThis->Cam_State = CAM_READY;
					}
					break;

					default:
						break;
				}
			}
			break;

            case CAM_STATUS_FRAME:
            {				
				if(pThis->Cam_State == CAM_PREVIEW || pThis->Cam_State == CAM_RECORDING)
				{
					//result = CMMITv_GetFrame(pThis, &pThis->pIShowFrame); 	
					//if(MMI_FAILURE(result))
					//{
					 //  // MMI_DEBUG(ATV,("CMMITv_GetFrame result = %d",result));
					//	return;
					//}

					if(pThis->Cam_State == CAM_RECORDING)
					{	
//#ifdef MMI_CAMERA_UI_LIMIT
						if(!pThis->b_IsNightMode)
						{
							pThis->RecordingFrame++;
							if(pThis->RecordingFrame == 3)
							{
								pThis->RecordingFrame = 0;
							}
						}
//#endif
					}
					//#ifdef MMI_CAMERA_UI_LIMIT
					//if(pThis->RecordingFrame != 0 || pThis->Cam_State == CAM_PREVIEW)
					//#endif
					{
						if(pThis->pICBMMITv->pfnOnPaint != NULL)
						{						   
							pThis->pICBMMITv->pfnOnPaint(pThis->pICBMMITv->pUser, pThis->pIShowFrame);                         
						}
					}				
				}
			}break;

            
			case CAM_STATUS_DONE:
			{
				switch(pThis->Cam_State)
				{
					case CAM_STOPPREVIEW:
					{
						pThis->Cam_State = CAM_READY;
						CMMITv_OnTvEvent(pThis, MMITV_PreView, MMITV_PreView_OnStoped);
					}
					break;
                    
					case CAM_STARTPREVIEW:
					{
						ITV_StartPreview(pThis->pITv);
					}
					break;

					default:
						break;
				}
			}
			break;
#if 1
			//case CAM_STATUS_SPACE_WARNING:
			case CAM_STATUS_SPACE_ERROR:
			{	
				if(pThis->Cam_State == CAM_PREVIEW || pThis->Cam_State == CAM_STARTPREVIEW)
				{
					CMMITv_OnTvEvent(pThis, MMITV_PreView, MMITV_PreView_OnStartFail);
				}
				
				pThis->Cam_State = CAM_READY;
			}
			break;
			
			case CAM_STATUS_ABORT:
			case CAM_STATUS_FAIL:
			case CAM_STATUS_FILE_SIZE_EXCEEDED:
			case CAM_STATUS_IO_ERROR:
			{
				ITV_Stop(pThis->pITv);				
				if(pThis->Cam_State == CAM_PREVIEW)
				{
					CMMITv_OnTvEvent(pThis, MMITV_PreView, MMITV_PreView_OnStartFail);
				}
				pThis->Cam_State = CAM_READY;
			}
			break;
#endif

			default:
				break;
    	}
	}
   // ERR("CMMITv_ICBCamera_OnMessage",0,0,0);
	return;
}



static CMMITv* CMMITv_Constructor(IShell* pIShell)
{
    CMMITv* pThis = NULL;
    int result;

	MSG_FATAL("new--------------------------------1",0,0,0);

	pThis = (CMMITv*)sys_malloc(sizeof(CMMITv));
 
    if(pThis == NULL)
    {
    MSG_FATAL("pThis = MALLOC(sizeof(CMMITv))--------NULL",0,0,0);
        return NULL;
    }

    pThis->nRefs = 0;
    IBASE_COPY_IPTR(pThis->pIShell,pIShell);
    pThis->myIMMITv.pvt = &gIMMITvFuncs;
    pThis->myIMMITv.pData = (void*)pThis;
	MSG_FATAL("new--------------------------------2",0,0,0);
    //////////////////////////////////////////////////////////////////////////
    // TODO: Add user construct code here                                     
    //////////////////////////////////////////////////////////////////////////
	pThis->pITv = NULL;
	pThis->pICBMMITv = NULL;
	pThis->Cam_State = CAM_READY;
	pThis->b_IsAutoSave = TRUE;
	pThis->FileLimit = 0;
    //add by miaoxiaoxiaoming
    pThis->pContext = AEE_GetAppContext();
    pThis->CurChnIdx = 1;
    pThis->hasChannelFinish = FALSE;
    pThis->CountChannel= 0;
	pThis->b_IsUserSetLimit = FALSE;
	MSG_FATAL("new--------------------------------3",0,0,0);

	pThis->b_IsNightMode = FALSE;
//#ifndef AEE_SIMULATOR
//	pThis->pIBitmapConvert = NULL;
//#endif
	pThis->pIShowFrame = NULL;
	pThis->b_FistFrameGet = TRUE;
	pThis->pCurFilepath = NULL;

	pThis->Picture_Type = PICTURE_TYPE_JPEG;
	pThis->Video_Type = VIDEO_TYPE_3GP;

	pThis->RecordingTime.Hour = 0;
	pThis->RecordingTime.Min = 0;
	pThis->RecordingTime.Sec = 0;
	pThis->RecordingTime_parm.RecordStartTime = 0;
	pThis->RecordingTime_parm.RecordTotalTime = 0;
	pThis->RecordingTime_parm.LastTime = 0;
	MSG_FATAL("new--------------------------------4",0,0,0);

//#ifdef MMI_CAMERA_UI_LIMIT
	pThis->RecordingFrame = 1;
//#endif

	pThis->b_IsRecAutoStop = FALSE;

	pThis->bLandscapeview = TRUE;

	pThis->QualityValue = TV_QUALITY_HIGH;
    pThis->ableChannelIndex = 0;
    
    //cam接口的size设置标志，目前进入电视只设置一次，除非完全退出
    pThis->b_CamSizeHaveSet = FALSE;
    
 MSG_FATAL("new--------------------------------end",0,0,0);
   
    return pThis;
}



int CMMITv_IMMITv_GetTF(IMMITv* pIMMITv)
{
    int TF = 0;
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
#ifdef AEE_SIMULATOR
    return 0;
#endif  

#ifdef TLG_TEST_SENSITIVE
    ITV_GetTF(pThis->pITv, &TF);
#endif
    return TF;
}

int CMMITv_IMMITv_GetTG(IMMITv* pIMMITv)
{	
    int Tg = 0;
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;	

#ifdef AEE_SIMULATOR
    return 0;
#endif   

#ifdef TLG_TEST_SENSITIVE
    ITV_GetTG(pThis->pITv, &Tg);
#endif	
    return Tg;	
}


int CMMITv_IMMITv_SetRegion(IMMITv* pIMMITv, TLG_REGION_CODE region)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
    int result = SUCCESS;
    int reset = 0;
    //MMI_DEBUG(ATV,("CMMITv_IMMITv_SetRegion Start",reset));  
#ifdef AEE_SIMULATOR
    return result;
#endif      
   // MMI_DEBUG(ATV,("CMMITv_IMMITv_SetRegion region = %d",region));    
    reset = ITV_SetRegion(pThis->pITv, region);
	//pTvSetting->region = region;

	MSG_FATAL("------------ITV_SetRegion.reset1=%d",reset,0,0);
	
	MSG_FATAL("------------pTvSetting->region = region=%d",region,0,0);
   
    if (reset == 1)  /*制式变化需要重启sensor*/
    {
    MSG_FATAL("------------ITV_SetRegion.reset=%d",reset,0,0);
       // MMI_DEBUG(ATV,("CMMITv_IMMITv_SetRegion reset = %d",reset));    
       #if 0 
	   if(pThis->pITv != NULL)
        {
        
    		ITV_RegisterNotify(pThis->pITv, NULL, pThis);
            result = ITV_StopPreview(pThis->pITv);
            //if (MMI_FAILURE(result))
           // {
              //  MMI_DEBUG(ATV,("CMMITv_IMMITv_SetRegion  CMMITv_IMMITv_StopPreview result= %d",result));   
           // }
          //  IBASE_RELEASE_IPTR(pThis->pITv);
            pThis->b_CamSizeHaveSet = FALSE;    /*sensor size 需要重新设置*/
        }
        
        result = CMMITv_IMMITv_CreateTv(&pThis->myIMMITv,pThis->pICBMMITv);
       // if (MMI_FAILURE(result))
       // {
          //  MMI_DEBUG(ATV,("CMMITv_IMMITv_SetRegion  CMMITv_IMMITv_CreateTv result= %d",result));   
      //  }
        pThis->Cam_State = CAM_READY;
        ITV_SetRegion(pThis->pITv, region);
		#endif
		
        return reset;
    }
    
   // MMI_DEBUG(ATV,("CMMITv_IMMITv_SetRegion reset = %d",reset));    
    return reset;
}

uint16* CMMITv_GetAbleChannelArray(IMMITv* pIMMITv)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
    MSG_FATAL("CMMITv_GetAbleChannelArray-----------------",0,0,0);
    return pThis->ableChannelArray;
}


int CMMITv_EnableVolPlay(IMMITv *pIMMITv,boolean  bVal)
{
    return 0;
}

int CMMITv_IMMITv_SetProperty(IMMITv* pIMMITv,TvProperty Property, TTvPropertyValue Value)
{
    CMMITv* pThis = (CMMITv*)pIMMITv->pData;
	int result = SUCCESS;

#ifdef AEE_SIMULATOR
	return result;
#endif

	if(pThis->pITv == NULL)
	{
		result = ENOTALLOWED;
	}

	switch(Property)
	{

		case TV_PROPERTY_DEFINITION:
		{
			ITV_SetDefinition(pThis->pITv, Value);
		}
		break;

		case TV_PROPERTY_BRIGHT:
		{
			result = ITV_SetBrightness(pThis->pITv, Value);
		}
		break;

		case TV_PROPERTY_CONTRAST:
		{
			result = ITV_SetContrast(pThis->pITv, Value);
        }
		break;

		case TV_PROPERTY_SATURATION:
		{
            result = ITV_SetSaturation(pThis->pITv, Value);
        }
		break;
        case TV_PROPERTY_SOUND:
        {
            result = ITV_SetVolume(pThis->pITv, Value);
        }
        break;

		case TV_PROPERTY_DISPLAY1_OFFSET:
		{
			;//result = ITV_SetDisplay1_Offset(pThis->pITv, Value,0);
		}
		break;

		case TV_PROPERTY_DISPLAY2_OFFSET:
		{
           ;// result = ITV_SetDisplay2_Offset(pThis->pITv, Value,0);
		}
		break;
   #if 0     
        case TV_PROPERTY_RESOLUTION:
		{			
			if(Value >= 0 && Value < MMITV_SIZE_DC_COUNT)
			{

                MSG_FATAL("TV_PROPERTY_RESOLUTION value = %d pThis->bLandscapeview = %d",Value, pThis->bLandscapeview,0);
#ifndef AEE_SIMULATOR
				if(pThis->pIShowFrame == NULL)
				{
					if(!pThis->bLandscapeview)  /*竖屏*/
					{
						result = MMIBitmap16_New(VERTICAL_TV_WIDTH, VERTICAL_TV_HEIGHT, NULL, (IBitmap**)&pThis->pIShowFrame);
					}
					else
					{
						result = MMIBitmap16_New(HORIZONTAL_TV_WIDTH, HORIZONTAL_TV_HEIGHT, NULL, (IBitmap**)&pThis->pIShowFrame);
					}                   
				}
                MSG_FATAL("b_CamSizeHaveSet=%d",pThis->b_CamSizeHaveSet,0,0);
                if(pThis->b_CamSizeHaveSet == FALSE&&MMI_SUCCESS(result))
				{
					result = ITV_SetSize(pThis->pITv, &MMITV_Resolution[Value]); 
                    if(result == SUCCESS)
                    {
                        pThis->b_CamSizeHaveSet = TRUE;
                    }
				}			
#endif
			}
			else
			{
				result = ECLASSNOTSUPPORT;
			}
		}
		break;

        case TV_PROPERTY_DIRECTION:
        {
            if(pThis->bLandscapeview != (boolean) Value)
    		{
    			pThis->bLandscapeview = (boolean) Value;
#ifndef AEE_SIMULATOR
    			IBASE_RELEASE_IPTR(pThis->pIShowFrame);
    
    			if(!pThis->bLandscapeview)
    			{
    				result = MMIBitmap16_New(VERTICAL_TV_WIDTH, VERTICAL_TV_HEIGHT, NULL, (IBitmap**)&pThis->pIShowFrame);
    			}
    			else
    			{
    				result = MMIBitmap16_New(HORIZONTAL_TV_WIDTH, HORIZONTAL_TV_HEIGHT, NULL, (IBitmap**)&pThis->pIShowFrame);
    			}                    

#endif                
    		}
        }break;
    #endif
		default:
			break;
	}
    if(result != SUCCESS)
    {
        return EFAILED;
    }
	return result;
} 


