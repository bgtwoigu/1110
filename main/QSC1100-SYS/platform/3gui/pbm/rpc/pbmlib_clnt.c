/*=============================================================================
                           P B M L I B _ C L N T . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that provides RPC client functionality for the
  pbmlib API.

  ---------------------------------------------------------------------------
  Copyright (c) 2008 QUALCOMM Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
#ifdef FEATURE_HTORPC_METACOMMENTS
/* Generated by following versions of Htorpc modules:
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/htorpc.pl#3
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Start.pm#7
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Htoxdr.pm#3
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/XDR.pm#10
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Output.pm#16
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Parser.pm#8
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Metacomments.pm#6
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/SymbolTable.pm#3  */
#endif
/* $Id: //depot/asic/msmshared/services/pbm/rpc/pbmlib_clnt.c#8 $
=============================================================================*/

#include "customer.h"
#include "target.h"

#ifdef FEATURE_ONCRPC
#ifdef FEATURE_EXPORT_PBMLIB
#define HTORPC_PBMLIB_GLUE

/* Include files */
#include "err.h"
#include "msg.h"
#include "oncrpc.h"

#include "pbmlib.h"
#include "pbmlib_rpc.h"

/* Only one copy needed per API */
static opaque_auth PbmlibCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth PbmlibVerf = { ONCRPC_AUTH_NONE, 0, 0 };

//static opaque_auth PbmlibcbCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth PbmlibcbVerf = { ONCRPC_AUTH_NONE, 0, 0 };


/*=======================================================================
             Prototypes for the API Callbacks RPC Server Functions
=======================================================================*/

static void pbmlibcbprog_0 ( struct svc_req *rqstp, xdr_s_type *srv );

static void pbmlibcb_null_0( xdr_s_type *svc );

static void PBM_EVENT_FUNC_svc_0( xdr_s_type *srv );

static void PBM_WRITE_COMPAT_CB_FUNC_svc_0( xdr_s_type *srv );

static void PBM_WRITE_CB_FUNC_svc_0( xdr_s_type *srv );

static void PBM_NOTIFY_FUNC_svc_0( xdr_s_type *srv );

static void PBM_FILE_INFO_CB_FUNC_svc_0( xdr_s_type *srv );

static void PBM_EXTENDED_FILE_INFO_CB_FUNC_svc_0( xdr_s_type *srv );

static void PBM_FIND_CB_FUNC_svc_0( xdr_s_type *srv );


/*=======================================================================
             API RPC Clients Implementation
=======================================================================*/

void pbmlib_null(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBMLIB_NULL_PROC, &PbmlibCred, &PbmlibVerf );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* pbmlib_null */

pbm_return_type pbm_clear_call_history(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  pbm_return_type pbm_clear_call_history_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_CLEAR_CALL_HISTORY_PROC, &PbmlibCred, &PbmlibVerf );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_clear_call_history_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_clear_call_history_result;
} /* pbm_clear_call_history */

pbm_return_type pbm_enum_rec_init(
  pbm_device_type pb_id,
  uint16 category,
  pbm_field_id_e_type field_id,
  const uint8 *data_ptr,
  uint16 data_size,
  uint32 flags
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint16 length_uint16;
  pbm_return_type pbm_enum_rec_init_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_ENUM_REC_INIT_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    (void) XDR_SEND_UINT16( clnt, &category );

    (void) XDR_SEND_UINT16( clnt, &field_id );

    if ( data_ptr != NULL ) {
      length_uint16 = data_size;

      (void) XDR_SEND_UINT16( clnt, &length_uint16 );

      (void) XDR_SEND_BYTES(clnt, data_ptr, length_uint16);
    } else {
      length_uint16 = 0;

      (void) XDR_SEND_UINT16( clnt, &length_uint16 );
    }

    (void) XDR_SEND_UINT16( clnt, &data_size );

    (void) XDR_SEND_UINT32( clnt, &flags );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_enum_rec_init_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_enum_rec_init_result;
} /* pbm_enum_rec_init */

pbm_return_type pbm_enum_next_rec_id(uint16 *rec_id_ptr)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  pbm_return_type pbm_enum_next_rec_id_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_ENUM_NEXT_REC_ID_PROC, &PbmlibCred, &PbmlibVerf );

    /* Send TRUE if rec_id_ptr is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (rec_id_ptr != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_enum_next_rec_id_result );

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &rec_id_ptr, XDR_RECV_UINT16 );
  /*lint -restore */

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_enum_next_rec_id_result;
} /* pbm_enum_next_rec_id */

pbm_return_type pbm_file_info(pbm_device_type pb_id,  PBM_FILE_INFO_CB_FUNC proc_func)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  pbm_return_type pbm_file_info_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_FILE_INFO_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) proc_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_file_info_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_file_info_result;
} /* pbm_file_info */

pbm_return_type pbm_extended_file_info(pbm_device_type pb_id,  PBM_EXTENDED_FILE_INFO_CB_FUNC proc_func)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  pbm_return_type pbm_extended_file_info_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_EXTENDED_FILE_INFO_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) proc_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_extended_file_info_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_extended_file_info_result;
} /* pbm_extended_file_info */

pbm_return_type pbm_find_location(
  pbm_device_type pb_id,
  int index,
  pbm_record_s_type *data,
  PBM_FIND_CB_FUNC proc_func
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  boolean output_pointer_not_null;
  pbm_return_type pbm_find_location_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_FIND_LOCATION_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    (void) XDR_SEND_INT( clnt, &index );

    /* Send TRUE if data is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (data != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) proc_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_find_location_result );

  XDR_RECV_POINTER_NO_ERRCHK( clnt, &data, xdr_pbmlib_recv_pbm_record_s_type );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_find_location_result;
} /* pbm_find_location */

pbm_return_type pbm_find_name_next(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  pbm_return_type pbm_find_name_next_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_FIND_NAME_NEXT_PROC, &PbmlibCred, &PbmlibVerf );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_find_name_next_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_find_name_next_result;
} /* pbm_find_name_next */

pbm_return_type pbm_find_name(
  pbm_device_type pb_id,
  char *name,
  pbm_record_s_type *data,
  PBM_FIND_CB_FUNC proc_func
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  uint32 length_uint32;
  boolean output_pointer_not_null;
  pbm_return_type pbm_find_name_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_FIND_NAME_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    length_uint32 = 0;

    if ( name != NULL ) {
      length_uint32 = strlen((const char *) name) + 1;

      (void) XDR_SEND_UINT32( clnt, &length_uint32 );

      (void) XDR_SEND_STRING(clnt, name, length_uint32);
    } else {
      (void) XDR_SEND_UINT32( clnt, &length_uint32 );

    }

    /* Send TRUE if data is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (data != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) proc_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_find_name_result );

  XDR_RECV_POINTER_NO_ERRCHK( clnt, &data, xdr_pbmlib_recv_pbm_record_s_type );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_find_name_result;
} /* pbm_find_name */

pbm_return_type pbm_find_number(
  pbm_device_type pb_id,
  const byte *number,
  int loc_number_len,
  pbm_record_s_type *record,
  PBM_FIND_CB_FUNC proc_func
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  int length_int;
  boolean output_pointer_not_null;
  pbm_return_type pbm_find_number_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_FIND_NUMBER_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    if ( number != NULL ) {
      length_int = loc_number_len;

      (void) XDR_SEND_INT( clnt, &length_int );

      (void) XDR_SEND_BYTES(clnt, number, length_int);
    } else {
      length_int = 0;

      (void) XDR_SEND_INT( clnt, &length_int );
    }

    (void) XDR_SEND_INT( clnt, &loc_number_len );

    /* Send TRUE if record is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (record != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) proc_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_find_number_result );

  XDR_RECV_POINTER_NO_ERRCHK( clnt, &record, xdr_pbmlib_recv_pbm_record_s_type );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_find_number_result;
} /* pbm_find_number */

uint16 pbm_get_num_recs(pbm_device_type pb_id)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint16 pbm_get_num_recs_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_GET_NUM_RECS_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_UINT16( clnt, &pbm_get_num_recs_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_get_num_recs_result;
} /* pbm_get_num_recs */

int pbm_calculate_fields_size_from_id(uint16 rec_id)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  int pbm_calculate_fields_size_from_id_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_CALCULATE_FIELDS_SIZE_FROM_ID_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_UINT16( clnt, &rec_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_INT( clnt, &pbm_calculate_fields_size_from_id_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_calculate_fields_size_from_id_result;
} /* pbm_calculate_fields_size_from_id */

pbm_return_type pbm_record_read(
  uint16 rec_id,
  uint16 *category_ptr,
  int *num_fields_ptr,
  uint8 *data_buf,
  uint32 data_buf_size
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  uint32 length_uint32;
  pbm_return_type pbm_record_read_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_RECORD_READ_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_UINT16( clnt, &rec_id );

    /* Send TRUE if category_ptr is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (category_ptr != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    /* Send TRUE if num_fields_ptr is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (num_fields_ptr != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    /* Send TRUE if data_buf is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use. Also since this is
     * a pointer to a variable array, we need to send the maximum size of the
     * array too.
     */
    output_pointer_not_null = (data_buf != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    if ( output_pointer_not_null ) {

      length_uint32 = data_buf_size;

      (void) XDR_SEND_UINT32( clnt, &length_uint32 );

    }

    (void) XDR_SEND_UINT32( clnt, &data_buf_size );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_record_read_result );

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &category_ptr, XDR_RECV_UINT16 );
  /*lint -restore */

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &num_fields_ptr, XDR_RECV_INT );
  /*lint -restore */

  (void) XDR_RECV_UINT32( clnt, &length_uint32 );

  if ( length_uint32 > 0 ) {
    if ( data_buf != NULL ) {
      (void) XDR_RECV_BYTES(clnt, data_buf, length_uint32);
    }
  }

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_record_read_result;
} /* pbm_record_read */

pbm_return_type pbm_record_write(
  pbm_device_type pb_id,
  uint16 *rec_id_ptr,
  uint16 cat,
  int num_fields,
  const uint8 *data_buf,
  int data_buf_size,
  PBM_WRITE_CB_FUNC proc_func,
  void *user_data
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  int length_int;
  pbm_return_type pbm_record_write_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_RECORD_WRITE_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    /*lint -save -e123*/
    XDR_SEND_POINTER_NO_ERRCHK( clnt, &rec_id_ptr, XDR_SEND_UINT16 );
    /*lint -restore */

    (void) XDR_SEND_UINT16( clnt, &cat );

    (void) XDR_SEND_INT( clnt, &num_fields );

    if ( data_buf != NULL ) {
      length_int = data_buf_size;

      (void) XDR_SEND_INT( clnt, &length_int );

      (void) XDR_SEND_BYTES(clnt, data_buf, length_int);
    } else {
      length_int = 0;

      (void) XDR_SEND_INT( clnt, &length_int );
    }

    (void) XDR_SEND_INT( clnt, &data_buf_size );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) proc_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );

    (void) XDR_SEND_HANDLE( clnt, &user_data );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_record_write_result );

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &rec_id_ptr, XDR_RECV_UINT16 );
  /*lint -restore */

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_record_write_result;
} /* pbm_record_write */

pbm_return_type pbm_reg_event_cb(PBM_EVENT_FUNC user_fn)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  pbm_return_type pbm_reg_event_cb_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_REG_EVENT_CB_PROC, &PbmlibCred, &PbmlibVerf );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) user_fn );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_reg_event_cb_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_reg_event_cb_result;
} /* pbm_reg_event_cb */

pbm_return_type pbm_write(pbm_device_type pb_id,  pbm_record_s_type *record,  PBM_WRITE_COMPAT_CB_FUNC proc_func)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  pbm_return_type pbm_write_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_WRITE_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    XDR_SEND_POINTER_NO_ERRCHK( clnt, &record, xdr_pbmlib_send_pbm_record_s_type );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) proc_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_write_result );

  XDR_RECV_POINTER_NO_ERRCHK( clnt, &record, xdr_pbmlib_recv_pbm_record_s_type );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_write_result;
} /* pbm_write */

pbm_return_type pbm_write_lock(pbm_lock_type_e_type type,  void *user_data,  PBM_WRITE_CB_FUNC func)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  pbm_return_type pbm_write_lock_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_WRITE_LOCK_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &type );

    (void) XDR_SEND_HANDLE( clnt, &user_data );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_write_lock_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_write_lock_result;
} /* pbm_write_lock */

pbm_return_type pbm_write_unlock(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  pbm_return_type pbm_write_unlock_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_WRITE_UNLOCK_PROC, &PbmlibCred, &PbmlibVerf );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_write_unlock_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_write_unlock_result;
} /* pbm_write_unlock */

pbm_return_type pbm_get_field_info_count(pbm_device_type pb_id,  pbm_cat_e_type cat,  int *num)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  pbm_return_type pbm_get_field_info_count_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_GET_FIELD_INFO_COUNT_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    (void) XDR_SEND_ENUM( clnt, &cat );

    /* Send TRUE if num is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (num != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_get_field_info_count_result );

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &num, XDR_RECV_INT );
  /*lint -restore */

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_get_field_info_count_result;
} /* pbm_get_field_info_count */

pbm_return_type pbm_get_field_info(
  pbm_device_type pb_id,
  pbm_cat_e_type cat,
  pbm_field_info_s_type *pf,
  int size
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  int i;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  int length_int;
  pbm_return_type pbm_get_field_info_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_GET_FIELD_INFO_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    (void) XDR_SEND_ENUM( clnt, &cat );

    /* Send TRUE if pf is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use. Also since this is
     * a pointer to a variable array, we need to send the maximum size of the
     * array too.
     */
    output_pointer_not_null = (pf != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    if ( output_pointer_not_null ) {

      length_uint32 = (size/sizeof(pbm_field_info_s_type));

      (void) XDR_SEND_UINT32( clnt, &length_uint32 );

    }

    (void) XDR_SEND_INT( clnt, &size );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_get_field_info_result );

  (void) XDR_RECV_INT( clnt, &length_int );

  if ( length_int > 0 ) {
    if ( pf != NULL ) {

      /* Calling array of XDR routines */
      for ( i = 0; i < (length_int); i++ ) {
        /*lint -save -e545*/
        (void) xdr_pbmlib_recv_pbm_field_info_s_type( clnt, &(pf[i]) );
        /*lint -restore */
      }
    }
  }

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_get_field_info_result;
} /* pbm_get_field_info */

pbm_return_type pbm_record_validate(
  pbm_device_type pb_id,
  uint16 rec_id,
  pbm_cat_e_type cat,
  uint8 *data_buf,
  int data_buf_size,
  int num_fields
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  int length_int;
  pbm_return_type pbm_record_validate_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_RECORD_VALIDATE_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    (void) XDR_SEND_UINT16( clnt, &rec_id );

    (void) XDR_SEND_ENUM( clnt, &cat );

    if ( data_buf != NULL ) {
      length_int = data_buf_size;

      (void) XDR_SEND_INT( clnt, &length_int );

      (void) XDR_SEND_BYTES(clnt, data_buf, length_int);
    } else {
      length_int = 0;

      (void) XDR_SEND_INT( clnt, &length_int );
    }

    (void) XDR_SEND_INT( clnt, &data_buf_size );

    (void) XDR_SEND_INT( clnt, &num_fields );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_record_validate_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_record_validate_result;
} /* pbm_record_validate */

pbm_return_type pbm_clear_phonebook(pbm_device_type pb_id)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  pbm_return_type pbm_clear_phonebook_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_CLEAR_PHONEBOOK_PROC, &PbmlibCred, &PbmlibVerf );

    (void) XDR_SEND_ENUM( clnt, &pb_id );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_clear_phonebook_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_clear_phonebook_result;
} /* pbm_clear_phonebook */

boolean pbm_emergency_number(const byte *num,  byte len)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  byte length_byte;
  boolean pbm_emergency_number_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_EMERGENCY_NUMBER_PROC, &PbmlibCred, &PbmlibVerf );

    if ( num != NULL ) {
      length_byte = len;

      (void) XDR_SEND_UINT8( clnt, &length_byte );

      (void) XDR_SEND_BYTES(clnt, num, length_byte);
    } else {
      length_byte = 0;

      (void) XDR_SEND_UINT8( clnt, &length_byte );
    }

    (void) XDR_SEND_UINT8( clnt, &len );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_UINT8( clnt, &pbm_emergency_number_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_emergency_number_result;
} /* pbm_emergency_number */

boolean pbm_emergency_number_cat(const byte *num,  byte len,  uint8 *ecc_category_ptr)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  byte length_byte;
  boolean output_pointer_not_null;
  boolean pbm_emergency_number_cat_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_EMERGENCY_NUMBER_CAT_PROC, &PbmlibCred, &PbmlibVerf );

    if ( num != NULL ) {
      length_byte = len;

      (void) XDR_SEND_UINT8( clnt, &length_byte );

      (void) XDR_SEND_BYTES(clnt, num, length_byte);
    } else {
      length_byte = 0;

      (void) XDR_SEND_UINT8( clnt, &length_byte );
    }

    (void) XDR_SEND_UINT8( clnt, &len );

    /* Send TRUE if ecc_category_ptr is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (ecc_category_ptr != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_UINT8( clnt, &pbm_emergency_number_cat_result );

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &ecc_category_ptr, XDR_RECV_UINT8 );
  /*lint -restore */

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_emergency_number_cat_result;
} /* pbm_emergency_number_cat */

pbm_return_type pbm_notify_register(PBM_NOTIFY_FUNC func,  void *user_data)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  pbm_return_type pbm_notify_register_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_NOTIFY_REGISTER_PROC, &PbmlibCred, &PbmlibVerf );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );

    (void) XDR_SEND_HANDLE( clnt, &user_data );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_notify_register_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_notify_register_result;
} /* pbm_notify_register */

pbm_return_type pbm_notify_unregister(PBM_NOTIFY_FUNC func,  void *user_data)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  pbm_return_type pbm_notify_unregister_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_NOTIFY_UNREGISTER_PROC, &PbmlibCred, &PbmlibVerf );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );

    (void) XDR_SEND_HANDLE( clnt, &user_data );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_notify_unregister_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_notify_unregister_result;
} /* pbm_notify_unregister */

boolean pbm_have_uids_changed(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean pbm_have_uids_changed_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_HAVE_UIDS_CHANGED_PROC, &PbmlibCred, &PbmlibVerf );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_UINT8( clnt, &pbm_have_uids_changed_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_have_uids_changed_result;
} /* pbm_have_uids_changed */

pbm_return_type pbm_validate_uid_changes(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  pbm_return_type pbm_validate_uid_changes_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_VALIDATE_UID_CHANGES_PROC, &PbmlibCred, &PbmlibVerf );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_validate_uid_changes_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_validate_uid_changes_result;
} /* pbm_validate_uid_changes */


/*=======================================================================
             API Callbacks RPC Server Implementation
=======================================================================*/

void pbmlibcb_app_init( void )
{
  xdr_s_type *transp;

#if (defined FEATURE_ONCRPC_SM)
  transp = svcsm_create(0, 0);
  if ( transp == NULL ) {
    XDR_SVC_CREATE_ERROR(0, 0);
  }
  if ( !svc_register_with_plugger(transp, PBMLIBCBPROG, PBMLIBCBVERS,
                                  pbmlibcbprog_0, ONCRPC_SM_PROTOCOL) ) {
    XDR_SVC_REGISTER_ERROR(transp, PBMLIBCBPROG, PBMLIBCBVERS,
                           pbmlibcbprog_0, ONCRPC_SM_PROTOCOL);
  }

#endif /* (defined FEATURE_ONCRPC_SM) */

#if (defined FEATURE_ONCRPC_ROUTER)
  transp = svcrtr_create(0, 0);
  if ( transp == NULL ) {
    XDR_SVC_CREATE_ERROR(0, 0);
  }
  if ( !svc_register_with_plugger(transp, PBMLIBCBPROG, PBMLIBCBVERS,
                                  pbmlibcbprog_0, ONCRPC_RTR_PROTOCOL) ) {
    XDR_SVC_REGISTER_ERROR(transp, PBMLIBCBPROG, PBMLIBCBVERS,
                           pbmlibcbprog_0, ONCRPC_RTR_PROTOCOL);
  }

#endif /* (defined FEATURE_ONCRPC_ROUTER) */
} /* pbmlibcb_app_init */

void pbmlibcb_app_lock( boolean lock )
{
  svc_lock( PBMLIBCBPROG, PBMLIBCBVERS, lock );
} /* pbmlibcb_app_enable */

static void pbmlibcbprog_0( struct svc_req *rqstp, xdr_s_type *srv )
{
  XDR_ERRCHK( srv, ON );

  switch( rqstp->rq_proc ) {
    case ONCRPC_PBMLIBCB_NULL_PROC:
      pbmlibcb_null_0( srv );
      break;
    case ONCRPC_PBM_EVENT_FUNC_PROC:
      PBM_EVENT_FUNC_svc_0( srv );
      break;
    case ONCRPC_PBM_WRITE_COMPAT_CB_FUNC_PROC:
      PBM_WRITE_COMPAT_CB_FUNC_svc_0( srv );
      break;
    case ONCRPC_PBM_WRITE_CB_FUNC_PROC:
      PBM_WRITE_CB_FUNC_svc_0( srv );
      break;
    case ONCRPC_PBM_NOTIFY_FUNC_PROC:
      PBM_NOTIFY_FUNC_svc_0( srv );
      break;
    case ONCRPC_PBM_FILE_INFO_CB_FUNC_PROC:
      PBM_FILE_INFO_CB_FUNC_svc_0( srv );
      break;
    case ONCRPC_PBM_EXTENDED_FILE_INFO_CB_FUNC_PROC:
      PBM_EXTENDED_FILE_INFO_CB_FUNC_svc_0( srv );
      break;
    case ONCRPC_PBM_FIND_CB_FUNC_PROC:
      PBM_FIND_CB_FUNC_svc_0( srv );
      break;
    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_noproc( srv );
      break;
  }

  oncrpcxdr_mem_free( srv );

  XDR_ERRCHK( srv, OFF );
} /* pbmlibcbprog_0 */

static void pbmlibcb_null_0( xdr_s_type *srv )
{
  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg, send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  (void) xdr_reply_msg_start( srv, &PbmlibcbVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbmlibcb_null_0 */


static void PBM_EVENT_FUNC_svc_0( xdr_s_type *srv )
{
  PBM_EVENT_FUNC cmd_cb_func;
  uint32 cb_id;

  boolean ready;
  if ( ! XDR_RECV_UINT32( srv, &cb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  if ( ! XDR_RECV_UINT8( srv, &ready ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  /*lint -save -e611*/
  cmd_cb_func = (PBM_EVENT_FUNC ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    (void) XDR_MSG_DONE( srv );
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  cmd_cb_func(ready);

  (void) xdr_reply_msg_start( srv, &PbmlibcbVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* PBM_EVENT_FUNC_svc_0 */

static void PBM_WRITE_COMPAT_CB_FUNC_svc_0( xdr_s_type *srv )
{
  PBM_WRITE_COMPAT_CB_FUNC cmd_cb_func;
  uint32 cb_id;

  pbm_return_type ret = PBM_SUCCESS;
  if ( ! XDR_RECV_UINT32( srv, &cb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  if ( ! XDR_RECV_ENUM( srv, &ret ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  /*lint -save -e611*/
  cmd_cb_func = (PBM_WRITE_COMPAT_CB_FUNC ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    (void) XDR_MSG_DONE( srv );
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  cmd_cb_func(ret);

  (void) xdr_reply_msg_start( srv, &PbmlibcbVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* PBM_WRITE_COMPAT_CB_FUNC_svc_0 */

static void PBM_WRITE_CB_FUNC_svc_0( xdr_s_type *srv )
{
  PBM_WRITE_CB_FUNC cmd_cb_func;
  uint32 cb_id;

  boolean xdr_pointer_result;
  pbm_writecb_data_s_type *cb_data = NULL;
  if ( ! XDR_RECV_UINT32( srv, &cb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  XDR_RECV_POINTER( srv, &cb_data, xdr_pbmlib_recv_pbm_writecb_data_s_type, xdr_pointer_result );
  if ( ! xdr_pointer_result ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  /*lint -save -e611*/
  cmd_cb_func = (PBM_WRITE_CB_FUNC ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    (void) XDR_MSG_DONE( srv );
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  cmd_cb_func(cb_data);

  (void) xdr_reply_msg_start( srv, &PbmlibcbVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* PBM_WRITE_CB_FUNC_svc_0 */

static void PBM_NOTIFY_FUNC_svc_0( xdr_s_type *srv )
{
  PBM_NOTIFY_FUNC cmd_cb_func;
  uint32 cb_id;

  boolean xdr_pointer_result;
  void *user_data;
  pbm_notify_data_s_type *notify_data = NULL;
  if ( ! XDR_RECV_UINT32( srv, &cb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  if ( ! XDR_RECV_HANDLE( srv, &user_data ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  XDR_RECV_POINTER( srv, &notify_data, xdr_pbmlib_recv_pbm_notify_data_s_type, xdr_pointer_result );
  if ( ! xdr_pointer_result ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  /*lint -save -e611*/
  cmd_cb_func = (PBM_NOTIFY_FUNC ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    (void) XDR_MSG_DONE( srv );
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  cmd_cb_func(user_data, notify_data);

  (void) xdr_reply_msg_start( srv, &PbmlibcbVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* PBM_NOTIFY_FUNC_svc_0 */

static void PBM_FILE_INFO_CB_FUNC_svc_0( xdr_s_type *srv )
{
  PBM_FILE_INFO_CB_FUNC cmd_cb_func;
  uint32 cb_id;

  pbm_return_type ret = PBM_SUCCESS;
  pbm_device_type pb_id = PBM_DEFAULT;
  int records_used;
  int number_of_records;
  int text_len;
  if ( ! XDR_RECV_UINT32( srv, &cb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  if ( ! XDR_RECV_ENUM( srv, &ret ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &records_used ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &number_of_records ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &text_len ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  /*lint -save -e611*/
  cmd_cb_func = (PBM_FILE_INFO_CB_FUNC ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    (void) XDR_MSG_DONE( srv );
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  cmd_cb_func(ret, pb_id, records_used, number_of_records, text_len);

  (void) xdr_reply_msg_start( srv, &PbmlibcbVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* PBM_FILE_INFO_CB_FUNC_svc_0 */

static void PBM_EXTENDED_FILE_INFO_CB_FUNC_svc_0( xdr_s_type *srv )
{
  PBM_EXTENDED_FILE_INFO_CB_FUNC cmd_cb_func;
  uint32 cb_id;

  boolean xdr_pointer_result;
  pbm_return_type ret = PBM_SUCCESS;
  pbm_device_type pb_id = PBM_DEFAULT;
  pbm_extended_fileinfo_s_type *info = NULL;
  if ( ! XDR_RECV_UINT32( srv, &cb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  if ( ! XDR_RECV_ENUM( srv, &ret ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  XDR_RECV_POINTER( srv, &info, xdr_pbmlib_recv_pbm_extended_fileinfo_s_type, xdr_pointer_result );
  if ( ! xdr_pointer_result ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  /*lint -save -e611*/
  cmd_cb_func = (PBM_EXTENDED_FILE_INFO_CB_FUNC ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    (void) XDR_MSG_DONE( srv );
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  cmd_cb_func(ret, pb_id, info);

  (void) xdr_reply_msg_start( srv, &PbmlibcbVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* PBM_EXTENDED_FILE_INFO_CB_FUNC_svc_0 */

static void PBM_FIND_CB_FUNC_svc_0( xdr_s_type *srv )
{
  PBM_FIND_CB_FUNC cmd_cb_func;
  uint32 cb_id;

  boolean xdr_pointer_result;
  pbm_return_type ret = PBM_SUCCESS;
  pbm_record_s_type *rec = NULL;
  if ( ! XDR_RECV_UINT32( srv, &cb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  if ( ! XDR_RECV_ENUM( srv, &ret ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  XDR_RECV_POINTER( srv, &rec, xdr_pbmlib_recv_pbm_record_s_type, xdr_pointer_result );
  if ( ! xdr_pointer_result ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }


  /*lint -save -e611*/
  cmd_cb_func = (PBM_FIND_CB_FUNC ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    (void) XDR_MSG_DONE( srv );
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  cmd_cb_func(ret, rec);

  (void) xdr_reply_msg_start( srv, &PbmlibcbVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* PBM_FIND_CB_FUNC_svc_0 */


/*===========================================================================
FUNCTION PBM_IS_INIT_COMPLETED

DESCRIPTION
will let the client know whether the init process of PBM is comlpeted or not


DEPENDENCIES

SIDE EFFECTS
===========================================================================*/
boolean pbm_is_init_completed(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean pbm_is_init_completed_result;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBPROG, PBMLIBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBPROG, PBMLIBVERS,
                               ONCRPC_PBM_IS_INIT_COMPLETED_PROC, &PbmlibCred, &PbmlibVerf );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &pbm_is_init_completed_result );

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );

  return pbm_is_init_completed_result;
} /* pbm_is_init_completed */


#endif /* FEATURE_EXPORT_PBMLIB */

#endif /* FEATURE_ONCRPC */
