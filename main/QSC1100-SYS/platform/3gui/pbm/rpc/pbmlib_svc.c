/*=============================================================================
                            P B M L I B _ S V C . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that dispatches RPC requests targetting the
  pbmlib api.

  ---------------------------------------------------------------------------
  Copyright (c) 2008 QUALCOMM Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
#ifdef FEATURE_HTORPC_METACOMMENTS
/* Generated by following versions of Htorpc modules:
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/htorpc.pl#3
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Start.pm#7
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Htoxdr.pm#3
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/XDR.pm#10
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Output.pm#16
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Parser.pm#8
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Metacomments.pm#6
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/SymbolTable.pm#3  */
#endif
/* $Id: //depot/asic/msmshared/services/pbm/rpc/pbmlib_svc.c#7 $
=============================================================================*/

#include "customer.h"
#include "target.h"

#ifdef FEATURE_ONCRPC
#ifdef FEATURE_EXPORT_PBMLIB
#define HTORPC_PBMLIB_GLUE

/* Include files */
#include "err.h"
#include "msg.h"
#include "oncrpc.h"

#include "pbmlib.h"
#include "pbmlib_rpc.h"

/* Only one copy needed per API */
//static opaque_auth PbmlibCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth PbmlibVerf = { ONCRPC_AUTH_NONE, 0, 0 };

static opaque_auth PbmlibcbCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth PbmlibcbVerf = { ONCRPC_AUTH_NONE, 0, 0 };


/*=======================================================================
             Prototypes for the API's RPC Server Functions
=======================================================================*/

static void pbmlibprog_0 ( struct svc_req *rqstp, xdr_s_type *srv );

static void pbmlib_null_0( xdr_s_type *svc );

static void pbm_clear_call_history_0( xdr_s_type *srv );

static void pbm_enum_rec_init_0( xdr_s_type *srv );

static void pbm_enum_next_rec_id_0( xdr_s_type *srv );

static void pbm_file_info_0( xdr_s_type *srv );

static void pbm_extended_file_info_0( xdr_s_type *srv );

static void pbm_find_location_0( xdr_s_type *srv );

static void pbm_find_name_next_0( xdr_s_type *srv );

static void pbm_find_name_0( xdr_s_type *srv );

static void pbm_find_number_0( xdr_s_type *srv );

static void pbm_get_num_recs_0( xdr_s_type *srv );

static void pbm_is_init_completed_0( xdr_s_type *srv );

static void pbm_calculate_fields_size_from_id_0( xdr_s_type *srv );

static void pbm_record_read_0( xdr_s_type *srv );

static void pbm_record_write_0( xdr_s_type *srv );

static void pbm_reg_event_cb_0( xdr_s_type *srv );

static void pbm_write_0( xdr_s_type *srv );

static void pbm_write_lock_0( xdr_s_type *srv );

static void pbm_write_unlock_0( xdr_s_type *srv );

static void pbm_get_field_info_count_0( xdr_s_type *srv );

static void pbm_get_field_info_0( xdr_s_type *srv );

static void pbm_record_validate_0( xdr_s_type *srv );

static void pbm_clear_phonebook_0( xdr_s_type *srv );

static void pbm_emergency_number_0( xdr_s_type *srv );

static void pbm_emergency_number_cat_0( xdr_s_type *srv );

static void pbm_notify_register_0( xdr_s_type *srv );

static void pbm_notify_unregister_0( xdr_s_type *srv );

static void pbm_have_uids_changed_0( xdr_s_type *srv );

static void pbm_validate_uid_changes_0( xdr_s_type *srv );


/*=======================================================================
             Prototypes for the API's Callback RPC clients
=======================================================================*/

static void PBM_EVENT_FUNC_clnt_0(boolean ready);

static void PBM_WRITE_COMPAT_CB_FUNC_clnt_0(pbm_return_type ret);

static void PBM_WRITE_CB_FUNC_clnt_0(pbm_writecb_data_s_type *cb_data);

static void PBM_NOTIFY_FUNC_clnt_0(void *user_data,  pbm_notify_data_s_type *notify_data);

static void PBM_FILE_INFO_CB_FUNC_clnt_0(
  pbm_return_type ret,
  pbm_device_type pb_id,
  int records_used,
  int number_of_records,
  int text_len
);

static void PBM_EXTENDED_FILE_INFO_CB_FUNC_clnt_0(pbm_return_type ret,  pbm_device_type pb_id,  pbm_extended_fileinfo_s_type *info);

static void PBM_FIND_CB_FUNC_clnt_0(pbm_return_type ret,  pbm_record_s_type *rec);

/******************************************************************************/
/*=======================================================================
             API RPC Server Implementation
=======================================================================*/

void pbmlib_app_init( void )
{
  xdr_s_type *transp;

#if (defined FEATURE_ONCRPC_SM)
  transp = svcsm_create(0, 0);
  if ( transp == NULL ) {
    XDR_SVC_CREATE_ERROR(0, 0);
  }
  if ( !svc_register(transp, PBMLIBPROG, PBMLIBVERS,
                     pbmlibprog_0, ONCRPC_SM_PROTOCOL) ) {
    XDR_SVC_REGISTER_ERROR(transp, PBMLIBPROG, PBMLIBVERS,
                           pbmlibprog_0, ONCRPC_SM_PROTOCOL);
  }

#endif /* (defined FEATURE_ONCRPC_SM) */

#if (defined FEATURE_ONCRPC_ROUTER)
  transp = svcrtr_create(0, 0);
  if ( transp == NULL ) {
    XDR_SVC_CREATE_ERROR(0, 0);
  }
  if ( !svc_register(transp, PBMLIBPROG, PBMLIBVERS,
                     pbmlibprog_0, ONCRPC_RTR_PROTOCOL) ) {
    XDR_SVC_REGISTER_ERROR(transp, PBMLIBPROG, PBMLIBVERS,
                           pbmlibprog_0, ONCRPC_RTR_PROTOCOL);
  }

#endif /* (defined FEATURE_ONCRPC_ROUTER) */
} /* pbmlib_app_init */

void pbmlib_app_lock( boolean lock )
{
  svc_lock( PBMLIBPROG, PBMLIBVERS, lock );
} /* pbmlib_app_lock */

static void pbmlibprog_0 ( struct svc_req *rqstp, xdr_s_type *srv )
{
  XDR_ERRCHK( srv, ON );

  switch ( rqstp->rq_proc ) {
    case ONCRPC_PBMLIB_NULL_PROC:
      pbmlib_null_0( srv );
      break;
    case ONCRPC_PBM_CLEAR_CALL_HISTORY_PROC:
      pbm_clear_call_history_0( srv );
      break;
    case ONCRPC_PBM_ENUM_REC_INIT_PROC:
      pbm_enum_rec_init_0( srv );
      break;
    case ONCRPC_PBM_ENUM_NEXT_REC_ID_PROC:
      pbm_enum_next_rec_id_0( srv );
      break;
    case ONCRPC_PBM_FILE_INFO_PROC:
      pbm_file_info_0( srv );
      break;
    case ONCRPC_PBM_EXTENDED_FILE_INFO_PROC:
      pbm_extended_file_info_0( srv );
      break;
    case ONCRPC_PBM_FIND_LOCATION_PROC:
      pbm_find_location_0( srv );
      break;
    case ONCRPC_PBM_FIND_NAME_NEXT_PROC:
      pbm_find_name_next_0( srv );
      break;
    case ONCRPC_PBM_FIND_NAME_PROC:
      pbm_find_name_0( srv );
      break;
    case ONCRPC_PBM_FIND_NUMBER_PROC:
      pbm_find_number_0( srv );
      break;
    case ONCRPC_PBM_GET_NUM_RECS_PROC:
      pbm_get_num_recs_0( srv );
      break;
    case ONCRPC_PBM_CALCULATE_FIELDS_SIZE_FROM_ID_PROC:
      pbm_calculate_fields_size_from_id_0( srv );
      break;
    case ONCRPC_PBM_RECORD_READ_PROC:
      pbm_record_read_0( srv );
      break;
    case ONCRPC_PBM_RECORD_WRITE_PROC:
      pbm_record_write_0( srv );
      break;
    case ONCRPC_PBM_REG_EVENT_CB_PROC:
      pbm_reg_event_cb_0( srv );
      break;
    case ONCRPC_PBM_WRITE_PROC:
      pbm_write_0( srv );
      break;
    case ONCRPC_PBM_WRITE_LOCK_PROC:
      pbm_write_lock_0( srv );
      break;
    case ONCRPC_PBM_WRITE_UNLOCK_PROC:
      pbm_write_unlock_0( srv );
      break;
    case ONCRPC_PBM_GET_FIELD_INFO_COUNT_PROC:
      pbm_get_field_info_count_0( srv );
      break;
    case ONCRPC_PBM_GET_FIELD_INFO_PROC:
      pbm_get_field_info_0( srv );
      break;
    case ONCRPC_PBM_RECORD_VALIDATE_PROC:
      pbm_record_validate_0( srv );
      break;
    case ONCRPC_PBM_CLEAR_PHONEBOOK_PROC:
      pbm_clear_phonebook_0( srv );
      break;
    case ONCRPC_PBM_EMERGENCY_NUMBER_PROC:
      pbm_emergency_number_0( srv );
      break;
    case ONCRPC_PBM_EMERGENCY_NUMBER_CAT_PROC:
      pbm_emergency_number_cat_0( srv );
      break;
    case ONCRPC_PBM_NOTIFY_REGISTER_PROC:
      pbm_notify_register_0( srv );
      break;
    case ONCRPC_PBM_NOTIFY_UNREGISTER_PROC:
      pbm_notify_unregister_0( srv );
      break;
    case ONCRPC_PBM_HAVE_UIDS_CHANGED_PROC:
      pbm_have_uids_changed_0( srv );
      break;
    case ONCRPC_PBM_VALIDATE_UID_CHANGES_PROC:
      pbm_validate_uid_changes_0( srv );
      break;
    case ONCRPC_PBM_IS_INIT_COMPLETED_PROC:
      pbm_is_init_completed_0( srv );
      break;

    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_noproc( srv );
      break;
  }

  oncrpcxdr_mem_free( srv );

  XDR_ERRCHK( srv, OFF );
} /* pbmlibprog_0 */

/******************************************************************************/

static void pbmlib_null_0( xdr_s_type *srv )
{

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg, send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbmlib_null */

static void pbm_clear_call_history_0( xdr_s_type *srv )
{
  pbm_return_type pbm_clear_call_history_result;

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_clear_call_history_result = pbm_clear_call_history();

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_clear_call_history_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_clear_call_history_0 */

static void pbm_enum_rec_init_0( xdr_s_type *srv )
{
  void *memset_temp;
  uint16 length_uint16;
  pbm_device_type pb_id = PBM_DEFAULT;
  uint16 category;
  pbm_field_id_e_type field_id;
  uint8 *data_ptr = NULL;
  uint16 data_size;
  uint32 flags;
  pbm_return_type pbm_enum_rec_init_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT16( srv, &category ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT16( srv, &field_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT16( srv, &length_uint16 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( length_uint16 > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( srv, length_uint16 * sizeof( *data_ptr ));
    if ( memset_temp == NULL ) {
      XDR_MALLOC_ERROR( srv, length_uint16 * sizeof( *data_ptr ));
    }
    memset(memset_temp, 0, length_uint16 * sizeof( *data_ptr ));
    data_ptr = memset_temp;

    if ( ! XDR_RECV_BYTES(srv, data_ptr, length_uint16) ) {
      // 1 send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }
  }

  if ( ! XDR_RECV_UINT16( srv, &data_size ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT32( srv, &flags ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_enum_rec_init_result = pbm_enum_rec_init(pb_id, category, field_id, data_ptr, data_size, flags);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_enum_rec_init_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_enum_rec_init_0 */

static void pbm_enum_next_rec_id_0( xdr_s_type *srv )
{
  boolean output_pointer_not_null;
  uint16 *rec_id_ptr = NULL;
  pbm_return_type pbm_enum_next_rec_id_result;

  /* The server must know whether to allocate memory for the output parameter
   * rec_id_ptr or not. A boolean is received to indicate that.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {
    rec_id_ptr = oncrpcxdr_mem_alloc( srv, sizeof(*rec_id_ptr) );
    if ( rec_id_ptr == NULL ) {
      XDR_MALLOC_ERROR( srv, sizeof(*rec_id_ptr) );
    }
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_enum_next_rec_id_result = pbm_enum_next_rec_id(rec_id_ptr);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_enum_next_rec_id_result );

  /*lint -save -e123*/
  XDR_SEND_POINTER_NO_ERRCHK( srv, &rec_id_ptr, XDR_SEND_UINT16 );
  /*lint -restore */

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_enum_next_rec_id_0 */

static void pbm_file_info_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  pbm_device_type pb_id = PBM_DEFAULT;
  PBM_FILE_INFO_CB_FUNC cb1;
  pbm_return_type pbm_file_info_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_FILE_INFO_CB_FUNC) rpc_svc_callback_register( (void *) PBM_FILE_INFO_CB_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_file_info_result = pbm_file_info(pb_id, cb1);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_file_info_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_file_info_0 */

static void pbm_extended_file_info_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  pbm_device_type pb_id = PBM_DEFAULT;
  PBM_EXTENDED_FILE_INFO_CB_FUNC cb1;
  pbm_return_type pbm_extended_file_info_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_EXTENDED_FILE_INFO_CB_FUNC) rpc_svc_callback_register( (void *) PBM_EXTENDED_FILE_INFO_CB_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_extended_file_info_result = pbm_extended_file_info(pb_id, cb1);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_extended_file_info_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_extended_file_info_0 */

static void pbm_find_location_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  boolean output_pointer_not_null;
  pbm_device_type pb_id = PBM_DEFAULT;
  int index;
  pbm_record_s_type *data = NULL;
  PBM_FIND_CB_FUNC cb1;
  pbm_return_type pbm_find_location_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &index ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /* The server must know whether to allocate memory for the output parameter
   * data or not. A boolean is received to indicate that.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {
    data = oncrpcxdr_mem_alloc( srv, sizeof(*data) );
    if ( data == NULL ) {
      XDR_MALLOC_ERROR( srv, sizeof(*data) );
    }
  }

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_FIND_CB_FUNC) rpc_svc_callback_register( (void *) PBM_FIND_CB_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_find_location_result = pbm_find_location(pb_id, index, data, cb1);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_find_location_result );

  XDR_SEND_POINTER_NO_ERRCHK( srv, &data, xdr_pbmlib_send_pbm_record_s_type );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_find_location_0 */

static void pbm_find_name_next_0( xdr_s_type *srv )
{
  pbm_return_type pbm_find_name_next_result;

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_find_name_next_result = pbm_find_name_next();

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_find_name_next_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_find_name_next_0 */

static void pbm_find_name_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  void *memset_temp;
  uint32 length_uint32;
  boolean output_pointer_not_null;
  pbm_device_type pb_id = PBM_DEFAULT;
  char *name = NULL;
  pbm_record_s_type *data = NULL;
  PBM_FIND_CB_FUNC cb1;
  pbm_return_type pbm_find_name_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT32( srv, &length_uint32 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( length_uint32 > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( srv, length_uint32);
    if ( memset_temp == NULL ) {
      XDR_MALLOC_ERROR( srv, length_uint32 );
    }
    memset(memset_temp, 0, length_uint32);
    name = memset_temp;

    if ( ! XDR_RECV_STRING(srv, name, length_uint32) ) {
      // send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }
  }

  /* The server must know whether to allocate memory for the output parameter
   * data or not. A boolean is received to indicate that.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {
    data = oncrpcxdr_mem_alloc( srv, sizeof(*data) );
    if ( data == NULL ) {
      XDR_MALLOC_ERROR( srv, sizeof(*data) );
    }
  }

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_FIND_CB_FUNC) rpc_svc_callback_register( (void *) PBM_FIND_CB_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_find_name_result = pbm_find_name(pb_id, name, data, cb1);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_find_name_result );

  XDR_SEND_POINTER_NO_ERRCHK( srv, &data, xdr_pbmlib_send_pbm_record_s_type );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_find_name_0 */

static void pbm_find_number_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  void *memset_temp;
  int length_int;
  boolean output_pointer_not_null;
  pbm_device_type pb_id = PBM_DEFAULT;
  byte *number = NULL;
  int loc_number_len;
  pbm_record_s_type *record = NULL;
  PBM_FIND_CB_FUNC cb1;
  pbm_return_type pbm_find_number_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &length_int ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( length_int > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( srv, length_int * sizeof( *number ));
    if ( memset_temp == NULL ) {
      XDR_MALLOC_ERROR( srv, length_int * sizeof( *number ));
    }
    memset(memset_temp, 0, length_int * sizeof( *number ));
    number = memset_temp;

    if ( ! XDR_RECV_BYTES(srv, number, length_int) ) {
      // 1 send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }
  }

  if ( ! XDR_RECV_INT( srv, &loc_number_len ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /* The server must know whether to allocate memory for the output parameter
   * record or not. A boolean is received to indicate that.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {
    record = oncrpcxdr_mem_alloc( srv, sizeof(*record) );
    if ( record == NULL ) {
      XDR_MALLOC_ERROR( srv, sizeof(*record) );
    }
  }

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_FIND_CB_FUNC) rpc_svc_callback_register( (void *) PBM_FIND_CB_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_find_number_result = pbm_find_number(pb_id, number, loc_number_len, record, cb1);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_find_number_result );

  XDR_SEND_POINTER_NO_ERRCHK( srv, &record, xdr_pbmlib_send_pbm_record_s_type );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_find_number_0 */

static void pbm_get_num_recs_0( xdr_s_type *srv )
{
  pbm_device_type pb_id = PBM_DEFAULT;
  uint16 pbm_get_num_recs_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_get_num_recs_result = pbm_get_num_recs(pb_id);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_UINT16( srv, &pbm_get_num_recs_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_get_num_recs_0 */

static void pbm_is_init_completed_0( xdr_s_type *srv )
{
  boolean pbm_is_init_completed_result;

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_is_init_completed_result = pbm_is_init_completed();

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_is_init_completed_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_is_init_completed_0 */

static void pbm_calculate_fields_size_from_id_0( xdr_s_type *srv )
{
  uint16 rec_id;
  int pbm_calculate_fields_size_from_id_result;

  if ( ! XDR_RECV_UINT16( srv, &rec_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_calculate_fields_size_from_id_result = pbm_calculate_fields_size_from_id(rec_id);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_INT( srv, &pbm_calculate_fields_size_from_id_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_calculate_fields_size_from_id_0 */

static void pbm_record_read_0( xdr_s_type *srv )
{
  boolean output_pointer_not_null;
  uint32 length_uint32;
  uint16 rec_id;
  uint16 *category_ptr = NULL;
  int *num_fields_ptr = NULL;
  uint8 *data_buf = NULL;
  uint32 data_buf_size;
  pbm_return_type pbm_record_read_result;

  if ( ! XDR_RECV_UINT16( srv, &rec_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /* The server must know whether to allocate memory for the output parameter
   * category_ptr or not. A boolean is received to indicate that.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {
    category_ptr = oncrpcxdr_mem_alloc( srv, sizeof(*category_ptr) );
    if ( category_ptr == NULL ) {
      XDR_MALLOC_ERROR( srv, sizeof(*category_ptr) );
    }
  }

  /* The server must know whether to allocate memory for the output parameter
   * num_fields_ptr or not. A boolean is received to indicate that.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {
    num_fields_ptr = oncrpcxdr_mem_alloc( srv, sizeof(*num_fields_ptr) );
    if ( num_fields_ptr == NULL ) {
      XDR_MALLOC_ERROR( srv, sizeof(*num_fields_ptr) );
    }
  }

  /* The server must know whether to allocate memory for the output parameter
   * data_buf or not. A boolean is received to indicate that. The maximum number
   * of objects that could be pointed to by this pointer is also received.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {

    if ( ! XDR_RECV_UINT32( srv, &length_uint32 ) ) {
      // send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }

    data_buf = oncrpcxdr_mem_alloc( srv, length_uint32 * sizeof(*data_buf) );
    if ( data_buf == NULL ) {
      XDR_MALLOC_ERROR( srv, length_uint32 * sizeof(*data_buf) );
    }
  }

  if ( ! XDR_RECV_UINT32( srv, &data_buf_size ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_record_read_result = pbm_record_read(rec_id, category_ptr, num_fields_ptr, data_buf, data_buf_size);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_record_read_result );

  /*lint -save -e123*/
  XDR_SEND_POINTER_NO_ERRCHK( srv, &category_ptr, XDR_SEND_UINT16 );
  /*lint -restore */

  /*lint -save -e123*/
  XDR_SEND_POINTER_NO_ERRCHK( srv, &num_fields_ptr, XDR_SEND_INT );
  /*lint -restore */

  if ( data_buf != NULL ) {
    length_uint32 = data_buf_size;
    length_uint32 = ( length_uint32 > data_buf_size ? data_buf_size : length_uint32 );

    (void) XDR_SEND_UINT32( srv, &length_uint32 );

    (void) XDR_SEND_BYTES(srv, data_buf, length_uint32);
  } else {
    length_uint32 = 0;

    (void) XDR_SEND_UINT32( srv, &length_uint32 );
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_record_read_0 */

static void pbm_record_write_0( xdr_s_type *srv )
{
  boolean xdr_pointer_result;
  uint32 cb_id1;
  void *memset_temp;
  int length_int;
  pbm_device_type pb_id = PBM_DEFAULT;
  uint16 *rec_id_ptr = NULL;
  uint16 cat;
  int num_fields;
  uint8 *data_buf = NULL;
  int data_buf_size;
  PBM_WRITE_CB_FUNC cb1;
  void *user_data;
  pbm_return_type pbm_record_write_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e123*/
  XDR_RECV_POINTER( srv, &rec_id_ptr, XDR_RECV_UINT16, xdr_pointer_result );
  /*lint -restore */
  if ( ! xdr_pointer_result ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT16( srv, &cat ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &num_fields ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &length_int ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( length_int > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( srv, length_int * sizeof( *data_buf ));
    if ( memset_temp == NULL ) {
      XDR_MALLOC_ERROR( srv, length_int * sizeof( *data_buf ));
    }
    memset(memset_temp, 0, length_int * sizeof( *data_buf ));
    data_buf = memset_temp;

    if ( ! XDR_RECV_BYTES(srv, data_buf, length_int) ) {
      // 1 send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }
  }

  if ( ! XDR_RECV_INT( srv, &data_buf_size ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_WRITE_CB_FUNC) rpc_svc_callback_register( (void *) PBM_WRITE_CB_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_RECV_HANDLE( srv, &user_data ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_record_write_result = pbm_record_write(pb_id, rec_id_ptr, cat, num_fields, data_buf, data_buf_size, cb1, user_data);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_record_write_result );

  /*lint -save -e123*/
  XDR_SEND_POINTER_NO_ERRCHK( srv, &rec_id_ptr, XDR_SEND_UINT16 );
  /*lint -restore */

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_record_write_0 */

static void pbm_reg_event_cb_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  PBM_EVENT_FUNC cb1;
  pbm_return_type pbm_reg_event_cb_result;

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_EVENT_FUNC) rpc_svc_callback_register( (void *) PBM_EVENT_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_reg_event_cb_result = pbm_reg_event_cb(cb1);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_reg_event_cb_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_reg_event_cb_0 */

static void pbm_write_0( xdr_s_type *srv )
{
  boolean xdr_pointer_result;
  uint32 cb_id1;
  pbm_device_type pb_id = PBM_DEFAULT;
  pbm_record_s_type *record = NULL;
  PBM_WRITE_COMPAT_CB_FUNC cb1;
  pbm_return_type pbm_write_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  XDR_RECV_POINTER( srv, &record, xdr_pbmlib_recv_pbm_record_s_type, xdr_pointer_result );
  if ( ! xdr_pointer_result ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_WRITE_COMPAT_CB_FUNC) rpc_svc_callback_register( (void *) PBM_WRITE_COMPAT_CB_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_write_result = pbm_write(pb_id, record, cb1);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_write_result );

  XDR_SEND_POINTER_NO_ERRCHK( srv, &record, xdr_pbmlib_send_pbm_record_s_type );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_write_0 */

static void pbm_write_lock_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  pbm_lock_type_e_type type = PBM_LOCK_NOT_INIT;
  void *user_data;
  PBM_WRITE_CB_FUNC cb1;
  pbm_return_type pbm_write_lock_result;

  if ( ! XDR_RECV_ENUM( srv, &type ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_HANDLE( srv, &user_data ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_WRITE_CB_FUNC) rpc_svc_callback_register( (void *) PBM_WRITE_CB_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_write_lock_result = pbm_write_lock(type, user_data, cb1);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_write_lock_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_write_lock_0 */

static void pbm_write_unlock_0( xdr_s_type *srv )
{
  pbm_return_type pbm_write_unlock_result;

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_write_unlock_result = pbm_write_unlock();

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_write_unlock_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_write_unlock_0 */

static void pbm_get_field_info_count_0( xdr_s_type *srv )
{
  boolean output_pointer_not_null;
  pbm_device_type pb_id = PBM_DEFAULT;
  pbm_cat_e_type cat = PBM_CAT_NONE;
  int *num = NULL;
  pbm_return_type pbm_get_field_info_count_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_ENUM( srv, &cat ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /* The server must know whether to allocate memory for the output parameter
   * num or not. A boolean is received to indicate that.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {
    num = oncrpcxdr_mem_alloc( srv, sizeof(*num) );
    if ( num == NULL ) {
      XDR_MALLOC_ERROR( srv, sizeof(*num) );
    }
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_get_field_info_count_result = pbm_get_field_info_count(pb_id, cat, num);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_get_field_info_count_result );

  /*lint -save -e123*/
  XDR_SEND_POINTER_NO_ERRCHK( srv, &num, XDR_SEND_INT );
  /*lint -restore */

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_get_field_info_count_0 */

static void pbm_get_field_info_0( xdr_s_type *srv )
{
  int i;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  int length_int;
  pbm_device_type pb_id = PBM_DEFAULT;
  pbm_cat_e_type cat = PBM_CAT_NONE;
  pbm_field_info_s_type *pf = NULL;
  int size;
  pbm_return_type pbm_get_field_info_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_ENUM( srv, &cat ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /* The server must know whether to allocate memory for the output parameter
   * pf or not. A boolean is received to indicate that. The maximum number
   * of objects that could be pointed to by this pointer is also received.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {

    if ( ! XDR_RECV_UINT32( srv, &length_uint32 ) ) {
      // send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }

    pf = oncrpcxdr_mem_alloc( srv, length_uint32 * sizeof(*pf) );
    if ( pf == NULL ) {
      XDR_MALLOC_ERROR( srv, length_uint32 * sizeof(*pf) );
    }
  }

  if ( ! XDR_RECV_INT( srv, &size ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_get_field_info_result = pbm_get_field_info(pb_id, cat, pf, size);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_get_field_info_result );

  if ( pf != NULL ) {
    length_int = (size/sizeof(pbm_field_info_s_type));
    length_int = ( length_int > (int)(size/sizeof(pbm_field_info_s_type)) ? (size/sizeof(pbm_field_info_s_type)) : length_int );

    (void) XDR_SEND_INT( srv, &length_int );


    /* Calling array of XDR routines */
    for ( i = 0; i < (length_int); i++ ) {
      /*lint -save -e545*/
      (void) xdr_pbmlib_send_pbm_field_info_s_type( srv, &(pf[i]) );
      /*lint -restore */
    }
  } else {
    length_int = 0;

    (void) XDR_SEND_INT( srv, &length_int );
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_get_field_info_0 */

static void pbm_record_validate_0( xdr_s_type *srv )
{
  void *memset_temp;
  int length_int;
  pbm_device_type pb_id = PBM_DEFAULT;
  uint16 rec_id;
  pbm_cat_e_type cat = PBM_CAT_NONE;
  uint8 *data_buf = NULL;
  int data_buf_size;
  int num_fields;
  pbm_return_type pbm_record_validate_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_UINT16( srv, &rec_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_ENUM( srv, &cat ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &length_int ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( length_int > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( srv, length_int * sizeof( *data_buf ));
    if ( memset_temp == NULL ) {
      XDR_MALLOC_ERROR( srv, length_int * sizeof( *data_buf ));
    }
    memset(memset_temp, 0, length_int * sizeof( *data_buf ));
    data_buf = memset_temp;

    if ( ! XDR_RECV_BYTES(srv, data_buf, length_int) ) {
      // 1 send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }
  }

  if ( ! XDR_RECV_INT( srv, &data_buf_size ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_RECV_INT( srv, &num_fields ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_record_validate_result = pbm_record_validate(pb_id, rec_id, cat, data_buf, data_buf_size, num_fields);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_record_validate_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_record_validate_0 */

static void pbm_clear_phonebook_0( xdr_s_type *srv )
{
  pbm_device_type pb_id = PBM_DEFAULT;
  pbm_return_type pbm_clear_phonebook_result;

  if ( ! XDR_RECV_ENUM( srv, &pb_id ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_clear_phonebook_result = pbm_clear_phonebook(pb_id);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_clear_phonebook_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_clear_phonebook_0 */

static void pbm_emergency_number_0( xdr_s_type *srv )
{
  void *memset_temp;
  byte length_byte;
  byte *num = NULL;
  byte len;
  boolean pbm_emergency_number_result;

  if ( ! XDR_RECV_UINT8( srv, &length_byte ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( length_byte > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( srv, length_byte * sizeof( *num ));
    if ( memset_temp == NULL ) {
      XDR_MALLOC_ERROR( srv, length_byte * sizeof( *num ));
    }
    memset(memset_temp, 0, length_byte * sizeof( *num ));
    num = memset_temp;

    if ( ! XDR_RECV_BYTES(srv, num, length_byte) ) {
      // 1 send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }
  }

  if ( ! XDR_RECV_UINT8( srv, &len ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_emergency_number_result = pbm_emergency_number(num, len);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_UINT8( srv, &pbm_emergency_number_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_emergency_number_0 */

static void pbm_emergency_number_cat_0( xdr_s_type *srv )
{
  void *memset_temp;
  byte length_byte;
  boolean output_pointer_not_null;
  byte *num = NULL;
  byte len;
  uint8 *ecc_category_ptr = NULL;
  boolean pbm_emergency_number_cat_result;

  if ( ! XDR_RECV_UINT8( srv, &length_byte ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( length_byte > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( srv, length_byte * sizeof( *num ));
    if ( memset_temp == NULL ) {
      XDR_MALLOC_ERROR( srv, length_byte * sizeof( *num ));
    }
    memset(memset_temp, 0, length_byte * sizeof( *num ));
    num = memset_temp;

    if ( ! XDR_RECV_BYTES(srv, num, length_byte) ) {
      // 1 send svcerr_decode reply
      (void) XDR_MSG_DONE( srv );
      svcerr_decode( srv );
      return;
    }
  }

  if ( ! XDR_RECV_UINT8( srv, &len ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /* The server must know whether to allocate memory for the output parameter
   * ecc_category_ptr or not. A boolean is received to indicate that.
   */
  if ( ! XDR_RECV_UINT8( srv, &output_pointer_not_null ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( output_pointer_not_null ) {
    ecc_category_ptr = oncrpcxdr_mem_alloc( srv, sizeof(*ecc_category_ptr) );
    if ( ecc_category_ptr == NULL ) {
      XDR_MALLOC_ERROR( srv, sizeof(*ecc_category_ptr) );
    }
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_emergency_number_cat_result = pbm_emergency_number_cat(num, len, ecc_category_ptr);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_UINT8( srv, &pbm_emergency_number_cat_result );

  /*lint -save -e123*/
  XDR_SEND_POINTER_NO_ERRCHK( srv, &ecc_category_ptr, XDR_SEND_UINT8 );
  /*lint -restore */

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_emergency_number_cat_0 */

static void pbm_notify_register_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  PBM_NOTIFY_FUNC cb1;
  void *user_data;
  pbm_return_type pbm_notify_register_result;

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_NOTIFY_FUNC) rpc_svc_callback_register( (void *) PBM_NOTIFY_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_RECV_HANDLE( srv, &user_data ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_notify_register_result = pbm_notify_register(cb1, user_data);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_notify_register_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_notify_register_0 */

static void pbm_notify_unregister_0( xdr_s_type *srv )
{
  uint32 cb_id1;
  PBM_NOTIFY_FUNC cb1;
  void *user_data;
  pbm_return_type pbm_notify_unregister_result;

  if ( ! XDR_RECV_UINT32( srv, &cb_id1 ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cb1 = (PBM_NOTIFY_FUNC) rpc_svc_callback_register( (void *) PBM_NOTIFY_FUNC_clnt_0, srv, cb_id1 );
  /*lint -restore */

  if ( ! XDR_RECV_HANDLE( srv, &user_data ) ) {
    // send svcerr_decode reply
    (void) XDR_MSG_DONE( srv );
    svcerr_decode( srv );
    return;
  }

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_notify_unregister_result = pbm_notify_unregister(cb1, user_data);

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_notify_unregister_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_notify_unregister_0 */

static void pbm_have_uids_changed_0( xdr_s_type *srv )
{
  boolean pbm_have_uids_changed_result;

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_have_uids_changed_result = pbm_have_uids_changed();

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_UINT8( srv, &pbm_have_uids_changed_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_have_uids_changed_0 */

static void pbm_validate_uid_changes_0( xdr_s_type *srv )
{
  pbm_return_type pbm_validate_uid_changes_result;

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  pbm_validate_uid_changes_result = pbm_validate_uid_changes();

  (void) xdr_reply_msg_start( srv, &PbmlibVerf );

  (void) XDR_SEND_ENUM( srv, &pbm_validate_uid_changes_result );

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERROR( srv, NULL );
  }
} /* pbm_validate_uid_changes_0 */

/*===========================================================================
              API Callback Clients
===========================================================================*/

void pbmlibcb_null( void )
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  do {
    clnt = rpc_clnt_lookup2(PBMLIBCBPROG, PBMLIBCBVERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERROR(PBMLIBCBPROG, PBMLIBCBVERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               PBMLIBCBPROG, PBMLIBCBVERS,
                               ONCRPC_PBMLIBCB_NULL_PROC, &PbmlibcbCred, &PbmlibcbVerf );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* pbmlibcb_null */


static void PBM_EVENT_FUNC_clnt_0(boolean ready)
{
  xdr_s_type *clnt = NULL;
  rpc_reply_header reply_header;
  rpc_cb_data_type *rpc_cb_data;

  rpc_cb_data = rpc_svc_cb_data_lookup();
  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  XDR_ERRCHK( clnt, ON );

  do {
    (void) xdr_call_msg_start( clnt,
                               PBMLIBCBPROG, PBMLIBCBVERS,
                               ONCRPC_PBM_EVENT_FUNC_PROC, &PbmlibcbCred, &PbmlibcbVerf );

    (void) XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );

    (void) XDR_SEND_UINT8( clnt, &ready );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void ) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* PBM_EVENT_FUNC_clnt_0 */


static void PBM_WRITE_COMPAT_CB_FUNC_clnt_0(pbm_return_type ret)
{
  xdr_s_type *clnt = NULL;
  rpc_reply_header reply_header;
  rpc_cb_data_type *rpc_cb_data;

  rpc_cb_data = rpc_svc_cb_data_lookup();
  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  XDR_ERRCHK( clnt, ON );

  do {
    (void) xdr_call_msg_start( clnt,
                               PBMLIBCBPROG, PBMLIBCBVERS,
                               ONCRPC_PBM_WRITE_COMPAT_CB_FUNC_PROC, &PbmlibcbCred, &PbmlibcbVerf );

    (void) XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );

    (void) XDR_SEND_ENUM( clnt, &ret );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void ) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* PBM_WRITE_COMPAT_CB_FUNC_clnt_0 */


static void PBM_WRITE_CB_FUNC_clnt_0(pbm_writecb_data_s_type *cb_data)
{
  xdr_s_type *clnt = NULL;
  rpc_reply_header reply_header;
  rpc_cb_data_type *rpc_cb_data;

  rpc_cb_data = rpc_svc_cb_data_lookup();
  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  XDR_ERRCHK( clnt, ON );

  do {
    (void) xdr_call_msg_start( clnt,
                               PBMLIBCBPROG, PBMLIBCBVERS,
                               ONCRPC_PBM_WRITE_CB_FUNC_PROC, &PbmlibcbCred, &PbmlibcbVerf );

    (void) XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );

    XDR_SEND_POINTER_NO_ERRCHK( clnt, &cb_data, xdr_pbmlib_send_pbm_writecb_data_s_type );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void ) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* PBM_WRITE_CB_FUNC_clnt_0 */


static void PBM_NOTIFY_FUNC_clnt_0(void *user_data,  pbm_notify_data_s_type *notify_data)
{
  xdr_s_type *clnt = NULL;
  rpc_reply_header reply_header;
  rpc_cb_data_type *rpc_cb_data;

  rpc_cb_data = rpc_svc_cb_data_lookup();
  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  XDR_ERRCHK( clnt, ON );

  do {
    (void) xdr_call_msg_start( clnt,
                               PBMLIBCBPROG, PBMLIBCBVERS,
                               ONCRPC_PBM_NOTIFY_FUNC_PROC, &PbmlibcbCred, &PbmlibcbVerf );

    (void) XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );

    (void) XDR_SEND_HANDLE( clnt, &user_data );

    XDR_SEND_POINTER_NO_ERRCHK( clnt, &notify_data, xdr_pbmlib_send_pbm_notify_data_s_type );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void ) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* PBM_NOTIFY_FUNC_clnt_0 */


static void PBM_FILE_INFO_CB_FUNC_clnt_0(
  pbm_return_type ret,
  pbm_device_type pb_id,
  int records_used,
  int number_of_records,
  int text_len
)
{
  xdr_s_type *clnt = NULL;
  rpc_reply_header reply_header;
  rpc_cb_data_type *rpc_cb_data;

  rpc_cb_data = rpc_svc_cb_data_lookup();
  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  XDR_ERRCHK( clnt, ON );

  do {
    (void) xdr_call_msg_start( clnt,
                               PBMLIBCBPROG, PBMLIBCBVERS,
                               ONCRPC_PBM_FILE_INFO_CB_FUNC_PROC, &PbmlibcbCred, &PbmlibcbVerf );

    (void) XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );

    (void) XDR_SEND_ENUM( clnt, &ret );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    (void) XDR_SEND_INT( clnt, &records_used );

    (void) XDR_SEND_INT( clnt, &number_of_records );

    (void) XDR_SEND_INT( clnt, &text_len );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void ) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* PBM_FILE_INFO_CB_FUNC_clnt_0 */


static void PBM_EXTENDED_FILE_INFO_CB_FUNC_clnt_0(pbm_return_type ret,  pbm_device_type pb_id,  pbm_extended_fileinfo_s_type *info)
{
  xdr_s_type *clnt = NULL;
  rpc_reply_header reply_header;
  rpc_cb_data_type *rpc_cb_data;

  rpc_cb_data = rpc_svc_cb_data_lookup();
  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  XDR_ERRCHK( clnt, ON );

  do {
    (void) xdr_call_msg_start( clnt,
                               PBMLIBCBPROG, PBMLIBCBVERS,
                               ONCRPC_PBM_EXTENDED_FILE_INFO_CB_FUNC_PROC, &PbmlibcbCred, &PbmlibcbVerf );

    (void) XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );

    (void) XDR_SEND_ENUM( clnt, &ret );

    (void) XDR_SEND_ENUM( clnt, &pb_id );

    XDR_SEND_POINTER_NO_ERRCHK( clnt, &info, xdr_pbmlib_send_pbm_extended_fileinfo_s_type );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void ) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* PBM_EXTENDED_FILE_INFO_CB_FUNC_clnt_0 */


static void PBM_FIND_CB_FUNC_clnt_0(pbm_return_type ret,  pbm_record_s_type *rec)
{
  xdr_s_type *clnt = NULL;
  rpc_reply_header reply_header;
  rpc_cb_data_type *rpc_cb_data;

  rpc_cb_data = rpc_svc_cb_data_lookup();
  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  XDR_ERRCHK( clnt, ON );

  do {
    (void) xdr_call_msg_start( clnt,
                               PBMLIBCBPROG, PBMLIBCBVERS,
                               ONCRPC_PBM_FIND_CB_FUNC_PROC, &PbmlibcbCred, &PbmlibcbVerf );

    (void) XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );

    (void) XDR_SEND_ENUM( clnt, &ret );

    XDR_SEND_POINTER_NO_ERRCHK( clnt, &rec, xdr_pbmlib_send_pbm_record_s_type );
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERROR( reply_header );
  } else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERROR( reply_header );
  }

  (void ) XDR_MSG_DONE( clnt );

  XDR_ERRCHK( clnt, OFF );
} /* PBM_FIND_CB_FUNC_clnt_0 */


#endif /* FEATURE_EXPORT_PBMLIB */
#endif /* FEATURE_ONCRPC */
