/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

      R A D I O   L I N K   P R O T O C O L  N A K  P R O C E S S I N G

GENERAL DESCRIPTION
  This file contains generic nak-list processing functions.  It is not
  specific to any one RLP type.
  
  It is assumed that the user will not directly access any nak information
  contained in the nak structure.  Instead, all nak access can be done
  via the externalized functions or macros provided in this file and the
  dsrlpnak.h file.

EXTERNALIZED FUNCTIONS


INITIALIZATION AND SEQUENCING REQUIREMENTS
  Library calls.  Assumes that the nak list passed in has been initialized
  (q_init), and that the nak free q has been initialized also.
  
DESCRIPTION
  The NAK list contains entries, each of which details the missing frames
  and/or frame segments that are missing.  When inserting, the user should
  do:
  
  insert(a,b),  where a is the first missing frame number (inclusive) and
  b is one greater than the last missing frame number (so it is exclusive).
  
  remove(a,b), is a little different (a is inclusive, b is also inclusive)
  
  The kicker is what is meant by "frame number".  The internal representation
  is a 32-bit number of the format:
  
    0000   aaaa   bbbbcccc   ddddeeeeffff  0000
    
    where
    aaaa           = 4-bit SEQ_HI
    bbbbcccc       = 8 bit SEQ (frame number)
    ddddeeeeffff   = 12 bit byte seq. number (S_SEQ).
    
  For insert's, the user should just pass the beginning frame number,
  and then the received frame's sequence number, as generated by 
  frame determination.   The insert() function will take care of any
  issues involving sequence numbers whose S_SEQ is zero/non-zero.
  
  For remove's, the user should pass the 32-bit sequence numbers as
  reported by frame determination to the remove() function.  The func
  will then figure out the required processing based on the 12-bit
  S_SEQ state (zero/non-zero).
  
  The table below shows the different forms the entries can have:
  
  FIRST_SEQ            LAST_SEQ                    ALLOWED
  
  0x00040000           0x00070000                  Yes
  
  0x00040aa0           0x00040bb0                  Yes
  
  0x00040000           0x00040aa0                  Yes
  
  0x00040aa0           0x00050000                  Yes
   
  0x00040000           0x00050aa0                  NO
  

 Copyright (c) 1999 - 2003 by QUALCOMM Incorporated.  All Rights Reserved.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/*===========================================================================

                      EDIT HISTORY FOR FILE

  $PVCSPath: O:/src/asw/COMMON/vcs/dsrlpnak.c_v   1.8   12 Feb 2003 17:33:34   kdevara  $
  $Header: //source/qcom/qct/modem/data/1x/1xrlp/main/lite/src/dsrlpnak.c#1 $ $DateTime: 2007/11/06 01:21:33 $ $Author: nsivakum $

when       who        what, where, why
--------   ---        -------------------------------------------------------
10/30/03   sy         Fixed a problem with seq_hi for the duplicated frames.
04/21/03   ik/js      Modifications for queue defeaturization. 
03/07/03   js         Added RLP events. 
02/12/03   kvd        Added a new function dsrlpnak_get_freenak_count() used 
                      in debug messages printed  after dsrlp cleanup to detect
                      any nak item leaks.
01/28/03   kvd        Modified 4 dsrlpseq macros DSRLPSEQ_GET_NEXT_SEQ,
                      DSRLPSEQ_INCREMENT_SEQ, DSRLPSEQ_INCREMENT_S_SEQ,
                      DSRLPSEQ_INCREMENT_32BIT_SEQ to include modulus as
                      an argument
01/28/03   kvd        Removed Rama's fix for "removing invalid NAK entry
                      0x4000000-0 (0 byte NAK) if the hole wraps around
                      the seq. modulus for HDR". This should now be taken 
                      care of by the above modifications to dsrlpseq macros
12/05/02   vr         Added a new F3 message for RLP retransmissions from the
                      base station filling intermediate holes.
10/15/02   js         Optimized F3 messages by adding more information,
                      and removing unnecessary printouts. Also added RLP
                      stream identifier to distinguish different RLP
                      streams.  
09/19/02   vr         Increment RLP stats only if it is a non-HDR call.
                      hdrrlp will increment it for HDR.
08/07/02   vr         Fixed modulus wrap around bug and not naking complete
                      hole issue for HDR
05/24/01   hcg        Made changes to support HDR (1xEV).
06/08/00   ak         Added MSM5000_IRAM_FWD #ifndef's for IRAM support.
05/10/00   ak         Fixed msgs when hole is filled to be more useful.
05/02/00   na         Fixed a message.
04/28/00   igt        Updated the tx_naks[] statistic
04/20/00   ak         Fixed ASSERT now that abort happens one RTT after the
                      final NAK.
04/13/00   ak         Fixed bug to now wait one round trip time after final
                      NAK before aborting on NAK.  Also made MSGs more screen
                      friendly.
02/15/00   ak         Added function to age the first entry into its last
                      round.
01/19/00   ak         Removed incorrect ASSERT.
01/07/00   ak         Better handling of an empty free q.  
01/06/00   na         When curr_rnd is incremented it checks against max.
                      reverse rounds now.
08/05/99 na/hcg/ak    Created module.

===========================================================================*/

/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/
#include "customer.h"
#include "comdef.h"

#if (defined( FEATURE_DS_RLP3) || defined (FEATURE_HDR))

#include "dsrlp.h"
#include "dsrlpi.h"
#include "dsrlpseq.h"
#include "dsrlpnak.h"
#include "assert.h"
#include "memory.h"
#include "err.h"
#include "queue.h"
#ifdef FEATURE_HDR
#error code not present
#endif
#include "rlp_event_defs.h"


/*===========================================================================

             PUBLIC DEFINITIONS AND DECLARATIONS FOR MODULE

===========================================================================*/


/*===========================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

===========================================================================*/
#define FEATURE_DS_RLP_INTEGRITY_CHK

/*---------------------------------------------------------------------------
  This pool of nak entries will be maintained in a free queue.  These
  entries are shared across all RLP instances on the mobile.
---------------------------------------------------------------------------*/
LOCAL dsrlpi_nak_list_entry_type   dsrlpnak_pool[DSRLPNAK_MAX_NAK_ENTRIES];

/*---------------------------------------------------------------------------
  Minimum amount of time between nak rounds.  Standard spec's min of 5.
  This is in frame times.
---------------------------------------------------------------------------*/
#define  DSRLPNAK_MIN_TIMER           5
/*---------------------------------------------------------------------------
  Pointer to queue of free nak_list_entry structs.
---------------------------------------------------------------------------*/
LOCAL q_type   dsrlpnak_free_q;  

/*= = = = = = = =  = = = = = = = = = =  = = =  = = = = = = = = = = = = = = =
                        MACRO DEFINITIONS
= = = = = = = = = = = = = = =  = = = = =  = = = = = = = = = = = = = = = = =*/
/*===========================================================================

MACRO          DSRLPNAK_INSERT_ENTRY

DESCRIPTION    Inserts an entry into the nak list.  Done for code cleanliness
               below.
               
               3 params:  x, y, z
                          x = ptr to list in which to insert
                          y = ptr to element to insert
                          z = ptr to element to insert in front of
               
DEPENDENCIES   NONE

RETURN VALUE   NONE

SIDE EFFECTS   NONE
===========================================================================*/
#ifdef FEATURE_Q_NO_SELF_QPTR                                              
#define DSRLPNAK_INSERT_ENTRY( x, y, z)                                    \
          q_insert(x,&(y->link),&(z->link));                               
#else                                                                      
#define DSRLPNAK_INSERT_ENTRY( x, y, z)                                    \
          q_insert(&(y->link),&(z->link));                                 
#endif                                                                     



/*===========================================================================

MACRO          DSRLPNAK_DELETE_ENTRY

DESCRIPTION    Deletes an entry from the nak list, and then puts that
               element into the global nak free queue.
               
               2 params:  x, y
                          x = ptr to list from which to delete
                          y = ptr to element to delete
               
DEPENDENCIES   NONE

RETURN VALUE   NONE

SIDE EFFECTS   NONE
===========================================================================*/
#ifdef FEATURE_Q_NO_SELF_QPTR                                              
#define DSRLPNAK_DELETE_ENTRY(x,y)                                         \
{                                                                          \
          q_delete(x,&(y->link));                                          \
          q_put(&dsrlpnak_free_q,&(y->link));                              \
}
#else                                                                      
#define DSRLPNAK_DELETE_ENTRY(x,y)                                         \
{                                                                          \
          q_delete(&(y->link));                                            \
          q_put(&dsrlpnak_free_q,&(y->link));                              \
}
#endif                                                                     


/*===========================================================================

MACRO          DSRLPNAK_GET_NEXT_ENTRY

DESCRIPTION    Gets the next entry from the nak list, given the current
               entry.  This is here so the code in the function is
               readable.
               
               2 params:   q_ptr     = ptr to queue
                           entry_ptr = ptr to current entry
               
DEPENDENCIES   NONE

RETURN VALUE   NONE

SIDE EFFECTS   NONE
===========================================================================*/
#define DSRLPNAK_GET_NEXT_ENTRY(q_ptr,entry_ptr) \
     ((dsrlpi_nak_list_entry_type *)q_next(q_ptr,&(entry_ptr->link)))


/*= = = = = = = =  = = = = = = = = = =  = = =  = = = = = = = = = = = = = = =
                     INTERNAL FUNCTION DEFINTIONS
= = = = = = = = = = = = = = =  = = = = =  = = = = = = = = = = = = = = = = =*/
/*===========================================================================

FUNCTION       RLPNAKI_DUP_ENTRY

DESCRIPTION    Duplicates an entry, except for the first_seq and last_seq,
               which are passed in separately.
               
               4 elements:
                     dup = ptr to element to copy into.  This element is
                           assigned to an element from the free q.
                     old = ptr to element to copy from
                   first = new first_seq for element w
                    last = new last_seq for element w
                       
                
               
DEPENDENCIES   NONE

RETURN VALUE   pointer to new nak list entry.  Else returns NULL if could
               not duplicate.

SIDE EFFECTS   NONE.
===========================================================================*/
dsrlpi_nak_list_entry_type* dsrlpnaki_dup_entry
(
  dsrlpi_nak_list_entry_type*       old,      /* element to duplicate      */
  uint32                            first,    /* first seq for new element */
  uint32                            last      /* last seq for new element  */
)
{
  dsrlpi_nak_list_entry_type*         dup;    /* ptr to new element        */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  dup = (dsrlpi_nak_list_entry_type *)q_get(&dsrlpnak_free_q);
  if (dup == NULL)
  {
    ERR("No nak items in nak free q",0,0,0);
  }
  else
  {
    dup->first_seq = first;
    dup->last_seq  = last;
    dup->age       = old->age;
    dup->curr_rnd  = old->curr_rnd;
    dup->naks_left = old->naks_left;
  }
  return (dup);
}

/*===========================================================================

FUNCTION       DSRLPNAKI_CALC_LAST_NUM

DESCRIPTION    Calculates the last_num to use when removing an item from
               the NAK list.  Input params are:

                 first_num = Sequence number of the received data frame.
                             May be for segmented or unsegmented.  Has
                             a valid 4-bit SEQ_HI value.
                             
                 mask      = Bitmask indicating if SEQ_HI and S_SEQ are in
                             the 32-bit first_num value.
                             
                 length    = byte length of data in the relevent frame.                                       

DEPENDENCIES   Input ptrs are non-null.
               
               This can only be called by the RX task.  Must not be called
               by any other task, as then mutual exclusion issues will
               arise.  Assumed that TX task has higher priority than the
               RX task.
               
RETURN VALUE   The calculated last_num.  This value is an exclusive value.

SIDE EFFECTS   V(N) may be updated.
===========================================================================*/
uint32 rlpnaki_calc_last_num
(    
  uint32                        first_num,   /*   first missing seq num    */
  uint32                        mask,        /* mask indicating if SEQ_HI  */
                                             /* & S_SEQ spec'd in first_num*/
  word                          length,      /* byte-length of data        */
  uint32                        modulus      /* ver-specific seq modulus   */
)
{
  uint32                        last_num;  
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if (DSRLPI_HAS_S_SEQ_MASK(mask))
  {
    /*-----------------------------------------------------------------------
      This is a segmented frame.  Based on last_seg, last_num is either the
      next 8-bit SEQ, or is first_num + the length.  Adding length 
      automatically makes last_num an exclusive value
    -----------------------------------------------------------------------*/
    if (DSRLPI_HAS_LAST_SEG_MASK(mask) == TRUE)
    {
      last_num = DSRLPSEQ_GET_NEXT_SEQ(first_num,modulus);
    }
    else
    {
      last_num = DSRLPSEQ_ADD_S_SEQ(first_num, length, modulus);
    }
  }
  else
  {
    /*-----------------------------------------------------------------------
      Must be non-segmented, as no S_SEQ in first_num
    -----------------------------------------------------------------------*/
    last_num = DSRLPSEQ_GET_NEXT_SEQ(first_num,modulus);
  }

  return(last_num);
}

#ifndef MSM5000_IRAM_FWD
/*===========================================================================

FUNCTION       RLPNAKI_REMOVE

DESCRIPTION    Removes an entry from the nak list.  The remove may cause
               an entry to be split into two separate entries.  For example,
               if there is an entry from 100 - 150, and the user asks to
               remove 120 - 130, then the original entry will be removed,
               and the new entry 100-120 and 131-150 will be added.
               
               If entry does not exist, then nothing is done.
               
               The arguments to the remove function are the same as for
               the _insert() function.  The first_num is inclusive, while
               the second is exclusive.
               
               The input start_ptr can be NULL, in which case this function
               searches for the items to remove.  If not NULL, then it must
               point to an entry in the list.  This function will start its
               search with that particular entry.
               
               If removing a single frame, then first_num and last_num
               will differ by 1 in there 8-bit SEQ's.
               
               For a segmented frame, the first and last will be unequal,
               and will basically say which bytes have been received in
               the latest RLP frame (inclusive).  However, it is assumed
               that the first and last have the same SEQ_HI and SEQ.
               
               Here is a table of the removal actions.  The first num is
               compared to the first_seq, and the last_num is compared to the
               last_seq:
               
  FIRST_NUM     LAST_NUM         ACTION              Exit immediately?
    Less          Less           Remove first part          YES
    Less          Equal          Remove whole entry         YES
    Less          Greater        Remove whole entry         NO
    
    Equal         Less           Remove first part          YES 
    Equal         Equal          Remove whole entry         YES
    Equal         Greater        Remove whole entry         NO
    
    Greater       Less           Remove middle part         YES
    Greater       Equal          Remove last part           YES
    Greater       Greater        Remove last part           NO
    
Rearrange:

CASE 1  Less          Equal          Remove whole entry         YES
        Equal         Equal          Remove whole entry         YES
    
        Less          Greater        Remove whole entry         NO
        Equal         Greater        Remove whole entry         NO

    
CASE 2  Less          Less           Remove first part          YES
        Equal         Less           Remove first part          YES 
    
CASE 3  Greater       Equal          Remove last part           YES
        Greater       Greater        Remove last part           NO

CASE 4  Greater       Less           Remove middle part         YES 
               
               
DEPENDENCIES   Input rscb_ptr is non-null.  

               If removing a segmented piece of data, then it is assumed
               that first_num and last_num are within the same 8-bit SEQ.
               
               The last_seg is set to TRUE only if removing segmented data
               and the data being removed is the last segment (i.e, the
               last_segment bit was set in the RLP frame).

RETURN VALUE   TRUE if could successfully remove item (or if item did not
               exist in list).  Returns FALSE only if there is some error
               in internal memory allocation.  FALSE indicates a need for
               a reset.  It is not done here because the outer function
               should do that.

SIDE EFFECTS   NONE.
===========================================================================*/
boolean rlpnaki_remove
(
  dsrlpi_sess_ctl_blk_type     *rscb_ptr,      /* curr RLP session ctl blk */
  uint32                        first_num,     /* first missing seq num    */
  uint32                        last_num,      /* last missing seq num     */
  dsrlpi_nak_list_entry_type   *start_ptr      /* entry to start from      */
)
{
  q_type                       *nak_q_ptr;     /*  ptr to rlp's nak list   */
  dsrlpi_nak_list_entry_type   *nak_entry_ptr; /*  nak list entry          */
  dsrlpi_nak_list_entry_type   *temp_ptr;      /*  nak list entry          */
  dsrlpi_state_info_type       *state_ptr;     /*  curr state              */ 
  uint32                        temp_val;      /*  placeholder for swap    */

  boolean                   first_equal;       /* first_num = first_seq?   */
  boolean                   last_equal;        /* last_num  = last_seq?    */
  boolean                   first_num_greater; /* first num > first_seq?   */
  boolean                   last_num_greater;  /* last num > first_seq?    */
  boolean                   has_s_seq = FALSE; /* if removing seg. data    */

  uint32                    modulus;           /* sequence modulus         */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  ASSERT(rscb_ptr != NULL);
  
  /*-------------------------------------------------------------------------
    Set up some local vars.  These are used more for cleanliness of code,
    so that some statements can fit on one line
  -------------------------------------------------------------------------*/
  state_ptr = &(rscb_ptr->state);
  nak_q_ptr = &(state_ptr->nak_q);
  modulus   = rscb_ptr->ver_ptr->seq_modulus;

  /*-------------------------------------------------------------------------
    Go through list.  Examine each entry to see if it should be removed
    or modified.  For maximum robustness, it is assumed that the first_num
    and last_num are such that multiple entries may be removed.
  -------------------------------------------------------------------------*/

  if (start_ptr == NULL)
  {
    temp_ptr = (dsrlpi_nak_list_entry_type *)q_check(nak_q_ptr);
  }
  else
  {
    temp_ptr = start_ptr;
  }

  while (temp_ptr != NULL)
  {

    ASSERT(DSRLPSEQ_GE_SEQ_CHECK(last_num,first_num,modulus));
    
    if (last_num == first_num)
    {
      return(TRUE); /* all done */
    }

    /*-----------------------------------------------------------------------
     Also note if the removed entry contains an S_SEQ.  Special processing
     usually required if so.
    -----------------------------------------------------------------------*/
    if (DSRLPSEQ_HAS_S_SEQ(last_num) || DSRLPSEQ_HAS_S_SEQ(first_num))
    {
      has_s_seq = TRUE;
    }

    /*-----------------------------------------------------------------------
      Easy case is where this entry is not affected by NAK removal.  Can
      check by seeing if either 1) last_num <= first_seq or 
      2) first_num >= last_seq.  Do a continue to get past having to nest
      a lot of code under a huge ELSE statement.  Can use the macro below,
      because the last_seq/last_num is exclusive, while the first_seq/first_
      num is inclusive.  If the last_seq == first_num, then there is no work
      to be done with that particular entry.
    -----------------------------------------------------------------------*/

    if (DSRLPSEQ_GE_SEQ_CHECK(temp_ptr->first_seq,
                              last_num,
                              modulus))
    {
      /*--------------------------------------------------------------------
        All future entries are "ahead" of the first_num/last_num.  There-
        fore, all done, and can exit.
      --------------------------------------------------------------------*/
      return(TRUE);
    }
    else if (DSRLPSEQ_GE_SEQ_CHECK(first_num,
                                   temp_ptr->last_seq,
                                   modulus))
    {
      /*---------------------------------------------------------------------
        nak removal is somewhere ahead.  continue to next entry.
      ---------------------------------------------------------------------*/
      temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);
      continue;
    }

    /*-----------------------------------------------------------------------
      The first_num and last_num can each either be less than/equal/greater
      than the first_seq and last_seq respectively.  The action to be taken
      on the entry depends on these relations.  Figure out how the numbers
      coincide, and then take appropriate action.
    -----------------------------------------------------------------------*/
    first_equal = FALSE;
    last_equal  = FALSE;

    first_num_greater = FALSE;
    last_num_greater  = FALSE;


    if (first_num == temp_ptr->first_seq)
    {
      first_equal = TRUE;
    }
    else if (DSRLPSEQ_GE_SEQ_CHECK(first_num,
                                   temp_ptr->first_seq,
                                   modulus))
    {
      first_num_greater = TRUE;
    }

    if (last_num == temp_ptr->last_seq)
    {
      last_equal = TRUE;
    }
    else if (DSRLPSEQ_GE_SEQ_CHECK(last_num,
                                   temp_ptr->last_seq,
                                   modulus))
    {
      last_num_greater = TRUE;
    }

    if (((first_equal == TRUE) || (first_num_greater == FALSE)) &&
        ((last_equal == TRUE) || (last_num_greater == TRUE)))
    {
      /*---------------------------------------------------------------------
        CASE 1:  According to truth table in description above, first do 
        elements which cause removal of the entire entry.
        
        Since deleting current entry, first get next entry, then delete.
        Update first_num to point to a place after this entry, by setting
        it to last_seq of deleted entry.  Remember that last_seq was an
        exclusive value, and so it makes a good value for first_num.
        
        Continue through the loop.  Loop will automatically determine when
        time to exit.
      ---------------------------------------------------------------------*/
      first_num = temp_ptr->last_seq; /* last_seq is exclusive, so no      */
                                      /* increment is required             */
      nak_entry_ptr = temp_ptr;

      temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);

      DSRLPNAK_DELETE_ENTRY(nak_q_ptr,nak_entry_ptr);
    }
    else if (((last_equal == FALSE) && (last_num_greater == FALSE)) &&
             ((first_equal == TRUE) || (first_num_greater == FALSE)))
    {
      /*---------------------------------------------------------------------
        CASE 2:  According to truth table in description above, do entries
        which have their first part removed.  Update first_seq so that it
        reflects first part of entry being removed.
        
        Since only the front part of the entry is removed, can surmise that
        no other entries will be affected.  Immediately exit after modifying
        this entry.
        
        There could be some massive splitting of entries here, depending on
        if the last_num was representing segmented data.  Some interesting
        segmented data cases
        
        Start with        remove        end up with
        
        4 -> 7           4 -> 4b        4b -> 5, 5 -> 7
        4 -> 4d          4 -> 4b        4b -> 4d
        4a -> 5          4a -> 4b       4b -> 5
        4 -> 5           4 -> 4b        4b -> 5
        4a -> 4f         4 -> 4d        4d -> 4f
       
        Note that earlier, the last_num was re-configured for seg. data 
        which was also the last seg. This should make the processing easier.
      ---------------------------------------------------------------------*/

      if (has_s_seq == FALSE)
      {
        /* no segmented data...no special processing required */
        temp_ptr->first_seq = last_num; 
      }
      else if (DSRLPSEQ_HAS_SAME_SEQ(last_num,temp_ptr->last_seq)) 
      {
        /*------------------------------------------------------------------
          If input defines a segmented piece of data, and the last num
          has the same 8-bit SEQ as the entry's last_seq, then this 
          entry is already defining a segmented piece of data.  Sanity check
          to see that last_seq also has a 12-bit S_SEQ.  No special
          processing required here.
          
        ------------------------------------------------------------------*/
        ASSERT(DSRLPSEQ_HAS_S_SEQ(temp_ptr->last_seq));
  
        temp_ptr->first_seq = last_num; 
      }
      else if (DSRLPSEQ_HAS_SAME_SEQ(DSRLPSEQ_GET_NEXT_SEQ(last_num,modulus),
                                     temp_ptr->last_seq))
      {
        /*------------------------------------------------------------------
          Situation where something line 4 -> 5, removing 4 - 4a.  So left
          with 4a -> 5.
        ------------------------------------------------------------------*/
        temp_ptr->first_seq = last_num; 
      }
      else
      {
        /*------------------------------------------------------------------
          Situation where something like 4 -> 7, removing 4 - 4a.  This 
          will result in the following entries:
          
          4a -> 5, 5 -> 7
          
          Get a new entry, and fill it out.  Insertions happen before a
          link, so the original entry will be updated with the 5 -> 7
          info, and the new entry will get the 4a - > 5 info.
        ------------------------------------------------------------------*/
        nak_entry_ptr = dsrlpnaki_dup_entry(temp_ptr,
                                            last_num,
                                            DSRLPSEQ_GET_NEXT_SEQ(last_num,modulus));
        if (nak_entry_ptr == NULL)
        {
          return(FALSE);
        }

        temp_ptr->first_seq = DSRLPSEQ_GET_NEXT_SEQ(last_num,modulus);

        DSRLPNAK_INSERT_ENTRY(nak_q_ptr,nak_entry_ptr,temp_ptr);
      } 
      return(TRUE);  /* all done with case 2 */
    }
    else if ((first_num_greater == TRUE) &&
             ((last_equal == TRUE) || (last_num_greater == TRUE)))
    {
      /*---------------------------------------------------------------------
        Case 3:  According to truth table in description above, do entries
        which have their last part removed.  This involves modifying the
        back end of this entry.  When done, update first_num to be after
        this entry.  Do that by setting first_num equal to last_seq, which
        is an exclusive value.
        
        Continue through loop.  Loop will automatically decide when to
        exit.
        
        Interesting cases when removing segmented data:
          
        Start with        remove        end up with

        4 -> 7           5  -> 7        4->5        
        
        4 -> 7           5b -> 7        4->5, 5->5b
        
        4 -> 4d          4a -> 4d       4->4a
        4a -> 5          4d -> 5        4a->4d
        4 -> 5           4d -> 5        4->4d
        4a->4d           4c -> 4d       4a->4c
      ---------------------------------------------------------------------*/

      if (has_s_seq == FALSE)
      {
        /* no segmented data...no special processing required */
        temp_val = first_num;
        first_num = temp_ptr->last_seq;

        /*------------------------------------------------------------------
          Update to be equal to the start of the removed section (so it is
          exclusive to the remaining part of the entry).
        -------------------------------------------------------------------*/
        temp_ptr->last_seq = temp_val;
      }
      else if (DSRLPSEQ_HAS_SAME_SEQ(first_num,temp_ptr->first_seq))
      {
        /*------------------------------------------------------------------
          If here, then first_num is in the same 8-bit SEQ space as the
          first_seq.  Therefore, no extra entries will be generated.  Cases:
          
          Start with        remove        end up with
          4a -> 5          4d -> 5         4a -> 4d
          4a -> 4d         4b -> 4d        4a -> 4b
          
          Make sure to update first_num to point to a spot past this entry.
        ------------------------------------------------------------------*/
        temp_val = first_num;
        first_num = temp_ptr->last_seq;
        temp_ptr->last_seq = temp_val; 
      }
      else
      {
        /*------------------------------------------------------------------
          Segmented data, but the first num does not match first_seq, in
          terms of the 8-bit SEQ.  Have something like 4 -> 7, removing
          6a -> 7.  Results in 4->6, 6->6a.  Since insertions are done
          before a link, create a new entry, make it the 4->5 one, and then
          insert it.
        ------------------------------------------------------------------*/
        ASSERT(!DSRLPSEQ_HAS_SAME_SEQ(temp_ptr->first_seq,temp_ptr->last_seq));


        nak_entry_ptr = dsrlpnaki_dup_entry(temp_ptr,
                                            temp_ptr->first_seq,
                                            DSRLPSEQ_STRIP_S_SEQ(first_num));
        if (nak_entry_ptr == NULL)
        {
          return(FALSE);
        }

        temp_ptr->first_seq = DSRLPSEQ_STRIP_S_SEQ(first_num);
        temp_ptr->last_seq  = first_num;

        DSRLPNAK_INSERT_ENTRY(nak_q_ptr,nak_entry_ptr,temp_ptr);
      }
      temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);
    }
    else
    {
      /*---------------------------------------------------------------------
        Case 4:  Remove the middle of an entry.  This one requires the
        most work.  Results in entry being split into at least two. 
        When done, return, since no more entries can be modified.  
        Cases:
        
        Start with        remove        end up with

        4 -> 7           5  -> 6        4->5, 6->7
        4 -> 7           5a -> 5b       4->5, 5->5a, 5b->6, 6->7
        4 -> 7           4a -> 4b       4->4a, 4b->5, 5->7
        
        4 -> 8           5a -> 7        4->5, 5->5a,7->8 
                
        4a -> 5          4c -> 4d       4a->4c, 4d->5
        4  -> 4d         4b -> 4c       4->4b, 4c->4d
        4a -> 4f         4b -> 4c       4a->4b, 4c->4f
      ---------------------------------------------------------------------*/
      ASSERT(first_num_greater == TRUE);
      ASSERT(last_num_greater == FALSE);
      ASSERT(last_equal == FALSE);

      if (has_s_seq == FALSE)
      {
        /*------------------------------------------------------------------
          Easy case.  Removing a set of whole frames.  Make new entry,
          and insert before current entry, then return.
        ------------------------------------------------------------------*/
        nak_entry_ptr = dsrlpnaki_dup_entry(temp_ptr,
                                            temp_ptr->first_seq,
                                            first_num);
        if (nak_entry_ptr == NULL)
        {
          return(FALSE);
        }

        temp_ptr->first_seq = last_num;

        DSRLPNAK_INSERT_ENTRY(nak_q_ptr,nak_entry_ptr,temp_ptr);
      }
      else 
      {
        /*------------------------------------------------------------------
           Segmented data.  Handle different scenarios:
        ------------------------------------------------------------------*/
        if (DSRLPSEQ_HAS_SAME_SEQ(first_num,temp_ptr->first_seq))
        {
          /*----------------------------------------------------------------
            Get the first entry to be inserted:
          
            Start with        remove        INSERT:
            4->7              4a->x         4->4a
            4a->4f            4b->4x        4a->4b
            4->4f             4b->4x        4->4b
          ----------------------------------------------------------------*/
          
          nak_entry_ptr = dsrlpnaki_dup_entry(temp_ptr,
                                              temp_ptr->first_seq,
                                              first_num);
          if (nak_entry_ptr == NULL)
          {
            return(FALSE);
          }

          DSRLPNAK_INSERT_ENTRY(nak_q_ptr,nak_entry_ptr,temp_ptr);
        }
        else
        {
          /*----------------------------------------------------------------
            Two entries to be inserted (differing SEQ's on first_num and
            first_seq)
          
            Start with        remove        INSERT:
            4->8              6a->6b        4->6,6->6a
          ----------------------------------------------------------------*/
          ASSERT(!DSRLPSEQ_HAS_S_SEQ(temp_ptr->first_seq));

          nak_entry_ptr = dsrlpnaki_dup_entry(temp_ptr,
                                              temp_ptr->first_seq,
                                           DSRLPSEQ_STRIP_S_SEQ(first_num));
          if (nak_entry_ptr == NULL)
          {
            return(FALSE);
          }

          DSRLPNAK_INSERT_ENTRY(nak_q_ptr,nak_entry_ptr,temp_ptr);

          if (first_num != DSRLPSEQ_STRIP_S_SEQ(first_num))
          {
            nak_entry_ptr = dsrlpnaki_dup_entry(temp_ptr,
                                             DSRLPSEQ_STRIP_S_SEQ(first_num),
                                                first_num);
            if (nak_entry_ptr == NULL)
            {
              return(FALSE);
            }

            DSRLPNAK_INSERT_ENTRY(nak_q_ptr,nak_entry_ptr,temp_ptr);
          }
        }

        /*------------------------------------------------------------------
          Did the front part, dealing with first_num, but still must do
          the back end.
        ------------------------------------------------------------------*/
        if (DSRLPSEQ_HAS_SAME_SEQ(last_num,temp_ptr->last_seq))
        { 
          /*----------------------------------------------------------------
            last_num and last_seq have same 8-bit SEQ, but are not equal
            (otherwise this would have been CASE 3).  Cases:
          
                                            ALREADY      
            Start with        remove        INSERTED     Reconfig first_seq
            4->4f             4b->4c        4->4b           4c->4f    
          ----------------------------------------------------------------*/
          ASSERT(DSRLPSEQ_HAS_S_SEQ(temp_ptr->last_seq));

          temp_ptr->first_seq = last_num;
          return(TRUE);
        }
        else if (DSRLPSEQ_GET_NEXT_SEQ(last_num,modulus) == temp_ptr->last_seq)
        {
          /*----------------------------------------------------------------
            last_num and last_seq have different 8-bit SEQ, but they differ
            by only 1.  Cases:
                                      ALREADY      
            Start with    remove      INSERTED        Reconfig first_seq
            2->5          4b->4c      2->4,4->4b           4c->5    
            
            Note that last segment issues were resolved by bumping last_num
            up to the next 8-bit SEQ at the beginning of the function.
          ----------------------------------------------------------------*/
          temp_ptr->first_seq = last_num;
        }
        else
        {
          /*----------------------------------------------------------------
            last_num and last_seq have different 8-bit SEQ, and differ
            by more than 1.  Cases:
                                      ALREADY       INSERT    Reconfig
            Start with    remove      INSERTED                first_seq   
            2->8          4b->4c      2->4,4->4b    4c->5     5->8
            
            Note that last segment issues were resolved by bumping last_num
            up to the next 8-bit SEQ at the beginning of the function.
          ----------------------------------------------------------------*/
          nak_entry_ptr = dsrlpnaki_dup_entry(temp_ptr,
                                              last_num,
                                           DSRLPSEQ_GET_NEXT_SEQ(last_num,modulus));
          if (nak_entry_ptr == NULL)
          {
            return(FALSE);
          }

          DSRLPNAK_INSERT_ENTRY(nak_q_ptr,nak_entry_ptr,temp_ptr);

          temp_ptr->first_seq = DSRLPSEQ_GET_NEXT_SEQ(last_num,modulus);
        }
      } /* else remove segmented data */
      return(TRUE);
    } /* CASE 4 */
  } /* while */
  return(TRUE);
}
#endif /* MSM5000_IRAM_FWD */

/*===========================================================================

FUNCTION       DSRLPNAKI_NEXT_NAK_RND

DESCRIPTION    Update the current nak entry to the next round's nak info.
               If this is already the last round, then may result in the
               entry being removed from the list.
               
DEPENDENCIES   both input ptrs are non-NULL.

RETURN VALUE   NONE

SIDE EFFECTS   The nak_entry_ptr can be deleted from the nak list.
===========================================================================*/
void rlpnaki_next_nak_rnd
(
  dsrlpi_sess_ctl_blk_type     *rscb_ptr,      /* curr RLP session ctl blk */
  dsrlpi_nak_list_entry_type   *nak_entry_ptr  /* nak list entry           */
)
{
  dsrlpi_state_info_type       *state_ptr;     /*  curr state              */ 
  event_rlp_payload_type   rlp_event_payload;/* payload for RLP events     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  ASSERT(rscb_ptr != NULL);
  ASSERT(nak_entry_ptr != NULL);

  state_ptr = &(rscb_ptr->state);
  
  if (nak_entry_ptr->curr_rnd < DSRLP_MAX_NAK_ROUNDS) 
  {
#ifdef FEATURE_HDR
#error code not present
#endif
    {
     rscb_ptr->stats.tx_naks[nak_entry_ptr->curr_rnd]++;
    }
  }
  nak_entry_ptr->curr_rnd++;
  if ( nak_entry_ptr->curr_rnd <= state_ptr->nak_rounds_rev)
  {
#if defined (FEATURE_HDR)
#error code not present
#endif
    {
      nak_entry_ptr->age     = state_ptr->rlp_delay + DSRLPNAK_MIN_TIMER;
    }

    if (nak_entry_ptr->curr_rnd == state_ptr->nak_rounds_rev)
    {
      /*---------------------------------------------------------------------
        This round is so that the base station has one round-trip time to
        respond to this final NAK.  No more NAKs should be sent for this
        frame.
      ---------------------------------------------------------------------*/ 
      nak_entry_ptr->naks_left = 0;
    }
    else
    {
      nak_entry_ptr->naks_left = 
                    state_ptr->naks_per_round_rev[ nak_entry_ptr->curr_rnd ];
    }
  }
  else
  {
    /*---------------------------------------------------------------------
       Nak entry has expired, and all nak rounds have been exhaused.
       Remove item from list, put back on free q.  Update error stats.
    ---------------------------------------------------------------------*/
    MSG_HIGH("NAK ABORT on %x to %x RLP:%d",
             nak_entry_ptr->first_seq,
             nak_entry_ptr->last_seq,
             rscb_ptr->sr_id);

    DSRLPNAK_DELETE_ENTRY(&(state_ptr->nak_q),nak_entry_ptr);
    /*---------------------------------------------------------------------
      Report the RLP NAK abort event 
    ---------------------------------------------------------------------*/
    rlp_event_payload.event_rlp_type = event_rlp_nak_abort;
    rlp_event_payload.info = rscb_ptr->sr_id;
    event_report_payload (EVENT_RLP, 
                          sizeof(event_rlp_payload_type),
                          &rlp_event_payload);

    
  }
}

/*= = = = = = = =  = = = = = = = = = =  = = =  = = = = = = = = = = = = = = =
                    PUBLIC FUNCTION DEFINTIONS
= = = = = = = = = = = = = = =  = = = = =  = = = = = = = = = = = = = = = = =*/
/*===========================================================================

FUNCTION       DSRLPNAK_INIT

DESCRIPTION    Called at initialization, this takes all nak entries from
               the array and puts them onto the free queue.
               
DEPENDENCIES   NONE

RETURN VALUE   NONE

SIDE EFFECTS   NONE
===========================================================================*/
void dsrlpnak_init(void)
{
  int i;                               /* loop counter                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  q_init(&dsrlpnak_free_q);

  for (i = 0; i < DSRLPNAK_MAX_NAK_ENTRIES; i++)
  {
    q_put(&dsrlpnak_free_q,
          q_link(&dsrlpnak_pool[i], &dsrlpnak_pool[i].link));
  }
}


/*===========================================================================

FUNCTION       DSRLPNAK_RESET

DESCRIPTION    Called when an RLP instance is reset.  This takes any nak list
               entries from that RLP instance and puts them onto the 
               global free queue.
               
DEPENDENCIES   rscb_ptr != NULL

RETURN VALUE   NONE

SIDE EFFECTS   NONE
===========================================================================*/
void dsrlpnak_reset
(
  dsrlpi_sess_ctl_blk_type *rscb_ptr         /* current RLP session ctl blk*/
)
{
  q_type                      *nak_q_ptr;      /*   ptr to rlp's nak list  */
  dsrlpi_nak_list_entry_type  *nak_entry_ptr;  /*   nak list entry         */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  ASSERT(rscb_ptr != NULL);

  nak_q_ptr = &(rscb_ptr->state.nak_q);

  while ((nak_entry_ptr = 
                    (dsrlpi_nak_list_entry_type *)q_get(nak_q_ptr)) != NULL)
  {
    q_put(&dsrlpnak_free_q,&nak_entry_ptr->link);
  }
}

#ifdef FEATURE_DS_RLP3_OBSOLETE
#error code not present
#endif /* FEATURE_DS_RLP3_OBSOLETE */

/*===========================================================================

FUNCTION       DSRLPNAK_AGE_LIST

DESCRIPTION    Go through the list and age the nak list entries.  If any
               of the timers have expired, then set a flag so that the
               RLP Tx routine knows to send more naks out.
               
DEPENDENCIES   rscb_ptr != NULL

RETURN VALUE   TRUE if V(N) has changed.

SIDE EFFECTS   NONE
===========================================================================*/
boolean dsrlpnak_age_list
(
  dsrlpi_sess_ctl_blk_type *rscb_ptr         /* current RLP session ctl blk*/
)
{
  q_type                       *nak_q_ptr;     /*  ptr to rlp's nak list   */
  dsrlpi_nak_list_entry_type   *nak_entry_ptr; /*  nak list entry          */
  dsrlpi_nak_list_entry_type   *temp_ptr;      /*  nak list entry          */
  dsrlpi_state_info_type       *state_ptr;     /*  curr state              */ 
  uint32                        modulus;       /* sequence modulus         */
  uint32                        old_vn;        /* the old V(N)             */
#ifdef FEATURE_DS_RLP_INTEGRITY_CHK
  uint32                       first,last;     /* dummy place holders      */
#endif /* FEATURE_DS_RLP_INTEGRITY_CHK */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  ASSERT(rscb_ptr != NULL);

  /*------------------------------------------------------------------------
    Set up some local vars.  These are used more for cleanliness of code,
    so that some statements can fit on one line
  ------------------------------------------------------------------------*/
  state_ptr = &(rscb_ptr->state);
  nak_q_ptr = &(state_ptr->nak_q);
  modulus   = rscb_ptr->ver_ptr->seq_modulus;

  temp_ptr = (dsrlpi_nak_list_entry_type *)q_check(nak_q_ptr);

  while (temp_ptr != NULL)
  {
    /*---------------------------------------------------------------------
      Within the loop, it is possible for the current nak entry to be
      deleted. Therefore, make a copy of the ptr to the current entry, and
      then immediately get the next entry.  This way, the current entry can
      be deleted safely.  (Otherwise, once the current entry is deleted, it
      becomes impossible to find the next entry).
    ---------------------------------------------------------------------*/ 
    nak_entry_ptr = temp_ptr;
    temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);

#ifdef FEATURE_DS_RLP_INTEGRITY_CHK
    /*---------------------------------------------------------------------
      Since this routine goes through every entry in the list, this is a
      good place to confirm that all RLP entries are sytactically correct:
      
      4  ->  7   GOOD
      4  ->  4a  GOOD
      4a ->  4b  GOOD
      4a ->  5   GOOD
      
      4a -> 6    INCORRECT!
      4  -> 4    INCORRECT
      4  -> 3    INCORRECT (assuming no modulus rollover)
    ---------------------------------------------------------------------*/ 
    first = nak_entry_ptr->first_seq;
    last  = nak_entry_ptr->last_seq;

    ASSERT(last != first);
    ASSERT(DSRLPSEQ_GE_SEQ_CHECK(last,first,modulus));

    if (DSRLPSEQ_HAS_S_SEQ(first))
    {
      if (DSRLPSEQ_HAS_S_SEQ(last))
      {
        ASSERT(DSRLPSEQ_HAS_SAME_SEQ(first,last));
      }
      else
      {
        ASSERT(DSRLPSEQ_GET_NEXT_SEQ(first,modulus) == last);
      }
    }
    else if (DSRLPSEQ_HAS_S_SEQ(last))
    {
      ASSERT(DSRLPSEQ_HAS_SAME_SEQ(first,last));
    }
#endif /* FEATURE_DS_RLP_INTEGRITY_CHK */

    /*---------------------------------------------------------------------
      Age the current entry.
    ---------------------------------------------------------------------*/ 
    if (nak_entry_ptr->age > 0)
    {
      nak_entry_ptr->age--;
    }

    /*--------------------------------------------------------------------
      If the nak timer has expired, then need to set a flag so that the
      Tx routine sends the Naks.  However, it is possible that in this
      round, zero naks are to be sent; in that case, do not set the flag.
      Instead, update the nak timer to the next round information.  If
      this is the last round, then remove this entry.
    --------------------------------------------------------------------*/ 
    ASSERT(nak_entry_ptr->curr_rnd <= DSRLP_MAX_NAK_ROUNDS);  

    if (nak_entry_ptr->age == 0)
    {
      /*-----------------------------------------------------------------
        Have to intlock here as Tx task fiddles with naks_left value
      ------------------------------------------------------------------*/
      INTLOCK();
      if (nak_entry_ptr->naks_left > 0)
      {
        state_ptr->naks_to_send = TRUE;
      }
      else 
      {
        /*---------------------------------------------------------------
          No naks to send, but update to next round info.  This may 
          result in the nak entry being deleted.
        ---------------------------------------------------------------*/
        rlpnaki_next_nak_rnd(rscb_ptr,nak_entry_ptr);
      }
      INTFREE();
    }
  } /* while */

  /*--------------------------------------------------------------------
    It is possible that the first item in the list was deleted.  Update
    the V(N).  If the NAK list is empty, the V(N) = V(R).
  --------------------------------------------------------------------*/
  temp_ptr = (dsrlpi_nak_list_entry_type *)q_check(nak_q_ptr);
  old_vn   = state_ptr->needed_seq_num;

  if (temp_ptr != NULL)
  {
    state_ptr->needed_seq_num = temp_ptr->first_seq;
  }
  else
  {
    state_ptr->needed_seq_num = state_ptr->expected_seq_num;
  }

  if (old_vn != state_ptr->needed_seq_num)
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}


#ifndef MSM5000_IRAM_FWD
/*===========================================================================

FUNCTION       DSRLPNAK_INSERT

DESCRIPTION    Insert this new entry into the nak list.  Inserted according
               to sequence number.  Nak entry is filled out with first nak
               round information.
               
               If entry already exists, then nothing is done.
               
               Insert(a,b):  a is the first missing frame, inclusive.
               b is the 32-bit sequence number of the frame just received,
               as calculated by frame determination.  This means that the
               second number is exclusive to the set of missing frames.
               
               Possible insertions are:
               
               Insert            Results in these being inserted
               3  -> 5                3 -> 5
               
               3  -> 3f               3 -> 3f
               
               3  -> 4a               3 -> 4, 4 -> 4a
               
               3a -> 4                3a -> 4
               
               3a -> 4g               3a -> 4, 4 -> 4g
               
               3a -> 6b               3a -> 4, 4 -> 6, 6 -> 6b
               
               3  -> 6b               3 -> 6, 6 -> 6b
               
               This maintains the rule that if segmented frames are being
               NAK'd, then an entry contains the NAK info for the bytes
               within one 8-bit SEQ space.
               
DEPENDENCIES   Input rscb_ptr is non-null.

RETURN VALUE   TRUE if the information could be inserted, else FALSE.

SIDE EFFECTS   NONE
===========================================================================*/
boolean dsrlpnak_insert
(
  dsrlpi_sess_ctl_blk_type     *rscb_ptr,      /* curr RLP session ctl blk */
  uint32                        first_num,     /* first missing seq num    */
  uint32                        last_num       /* last missing seq num     */
)
{
  q_type                       *nak_q_ptr;     /*  ptr to rlp's nak list   */
  dsrlpi_nak_list_entry_type   *nak_entry_ptr; /*  nak list entry          */
  dsrlpi_nak_list_entry_type   *temp_ptr;      /*  nak list entry          */
  dsrlpi_state_info_type       *state_ptr;     /*  curr state              */ 
  uint32                        modulus;       /* sequence modulus         */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  ASSERT(rscb_ptr != NULL);
  ASSERT(first_num != last_num);              /* must be different numbers */
  
  /*-------------------------------------------------------------------------
    Set up some local vars.  These are used more for cleanliness of code,
    so that some statements can fit on one line
  -------------------------------------------------------------------------*/
  state_ptr = &(rscb_ptr->state);
  nak_q_ptr = &(state_ptr->nak_q);
  modulus   = rscb_ptr->ver_ptr->seq_modulus;

  /*------------------------------------------------------------------------
    Nak entries either already exist in the list or are inserted at the end
    (always).  See which case applies.  If new, make sure that new entry is
    greater than last entry in list.  Also possible that list is empty, in
    which case the entry is automatically inserted.
  ------------------------------------------------------------------------*/
  temp_ptr = (dsrlpi_nak_list_entry_type *)q_last_get(nak_q_ptr);
  if (temp_ptr != NULL)
  {
    /*---------------------------------------------------------------------
     It is possible for the last seq of the prev entry to equal the first
     seq of this entry. (since the last_seq of prev entry is an exclusive
     value, and the first_seq of this entry is an inclusive value). 
    ---------------------------------------------------------------------*/
    if (DSRLPSEQ_GT_SEQ_CHECK(temp_ptr->last_seq,
                              first_num,
                              modulus))
    {
      /*---------------------------------------------------------------------
        If here, than seq number is less than last one in our list. That is 
        an error.  Differing nak entries should never overlap.  Put back 
        the old entry, and return.  Still return TRUE, as this is not a case
        to cause RLP reset.
      ---------------------------------------------------------------------*/
      q_put(nak_q_ptr,&temp_ptr->link);
      ERR("Trying to insert old NAK info into list",0,0,0);
      return(TRUE);
    }
    else
    {
      q_put(nak_q_ptr,&temp_ptr->link);
    }
  }/* temp_ptr != NULL */
  

  /*------------------------------------------------------------------------
    If here, then either it is an empty list, or the seq of the item to be
    inserted is greater than the last seq in the list.
  ------------------------------------------------------------------------*/
  while (first_num != last_num)
  {
    /*-------------------------------------------------------------------
      Insert a nak entry.  Have to get one from the free queue.  Most
      of the fields are the same, no matter if insertion results in
      multiple entries.
    -------------------------------------------------------------------*/
    nak_entry_ptr = (dsrlpi_nak_list_entry_type *)q_get(&dsrlpnak_free_q);

    if (nak_entry_ptr == NULL)
    {
      ERR("Ran out of nak items in free q",0,0,0);
      return FALSE;
    }

    nak_entry_ptr->age       = 0;
    nak_entry_ptr->curr_rnd  = 0;
    nak_entry_ptr->first_seq = first_num;
    nak_entry_ptr->naks_left = state_ptr->naks_per_round_rev[0];

    /*-------------------------------------------------------------------
      See if entry can be inserted cleanly, or requires being broken
      up.
    -------------------------------------------------------------------*/
    if ((DSRLPSEQ_HAS_S_SEQ(first_num))                &&
        (DSRLPSEQ_GT_SEQ_CHECK(last_num,
                               DSRLPSEQ_GET_NEXT_SEQ(first_num,modulus),
                               modulus)))
    {
      /*-----------------------------------------------------------------
        Inserting something like 3a -> 4g or 3a -> 6b.  First insert
        3a -> 4, and then update first_num to 4
      -----------------------------------------------------------------*/
      nak_entry_ptr->last_seq = DSRLPSEQ_GET_NEXT_SEQ(first_num,modulus);
      first_num = DSRLPSEQ_GET_NEXT_SEQ(first_num,modulus);
    }
    else if ((DSRLPSEQ_HAS_S_SEQ(last_num)) &&
             !(DSRLPSEQ_HAS_SAME_SEQ(first_num,last_num)))
    {
      /*-----------------------------------------------------------------
        Inserting something like 3 -> 4a or 3 -> 6b.  First insert 
        3 -> 4 or 3 -> 6 (respectively), and then update first_num to 
        4 or 6 (respectively).
      -----------------------------------------------------------------*/
      nak_entry_ptr->last_seq = DSRLPSEQ_STRIP_S_SEQ(last_num);
      first_num = DSRLPSEQ_STRIP_S_SEQ(last_num);
    }
    else
    {
      /*-----------------------------------------------------------------
        all other cases:  3 -> 5, 3 -> 3f, 3a -> 4
      -----------------------------------------------------------------*/
      nak_entry_ptr->last_seq = last_num;
      first_num = last_num;
    }
    state_ptr->naks_to_send = TRUE;
    q_put(nak_q_ptr,&nak_entry_ptr->link);
  }/* while */

  return TRUE;

} /* dsrlpnak_insert() */
#endif /* MSM5000_IRAM_FWD */

/*===========================================================================

FUNCTION       DSRLPNAK_NAK_WAS_SENT

DESCRIPTION    Tells the nak list if a particular nak was sent over the air.
               Results in decrementing the naks_left counter.  In the case
               where naks_left counter == 0, nothing is done.  The nak_entry
               is "reset" in the Rx Task, in the dsrlpnak_age_list function.
               This scheme prevents any mutual exclusion issues between the
               RX and TX task. 

               The input paramenter is the id given by DSRLP_NAK_GET_NAKS().

DEPENDENCIES   Input ptrs are non-null.
               
               This can only be called by the TX task.  Must not be called
               by any other task, as then mutual exclusion issues will
               arise.  Assumed that TX task has higher priority than the
               RX task.
               
RETURN VALUE   NONE

SIDE EFFECTS   NONE
===========================================================================*/
void dsrlpnak_nak_was_sent
(
  dsrlpi_sess_ctl_blk_type     *rscb_ptr,      /* curr RLP session ctl blk */
  uint32                        nak_id         /* nak id of the nak that   */
                                               /* was sent                 */
)
{
  dsrlpi_nak_list_entry_type   *nak_entry_ptr; /*  nak list entry          */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  
  ASSERT( rscb_ptr != NULL );

  nak_entry_ptr = (dsrlpi_nak_list_entry_type *)nak_id;

  if (nak_entry_ptr->naks_left > 0)
  {
    nak_entry_ptr->naks_left--;
  }
}


/*===========================================================================

FUNCTION       DSRLPNAK_REMOVE

DESCRIPTION    Removes a nak entry from the nak list.  fr_info_ptr must
               contain a fully-known sequence #.

DEPENDENCIES   Input ptrs are non-null.
               
               This can only be called by the RX task.  Must not be called
               by any other task, as then mutual exclusion issues will
               arise.  Assumed that TX task has higher priority than the
               RX task.
               
               nak_id must be the value returned from dsrlpnak_get_seq_hi
               and must be non-zero.
               
RETURN VALUE   TRUE if the remove was successful.  TRUE is returned even
               when the nak item was not in the list.  FALSE is
               returned when there was an internal memory error with
               allocating nak items.  This indicates the calling fcn
               should reset RLP.

SIDE EFFECTS   V(N) may be updated.
===========================================================================*/
boolean dsrlpnak_remove
(
  dsrlpi_sess_ctl_blk_type     *rscb_ptr,      /* curr RLP session ctl blk */
  dsrlpi_curr_fr_info_type     *fr_info_ptr,   /* ptr to curr frame info   */
  word                          length,        /* byte-length of data      */
  uint32                        nak_id         /* ref pt from get_seq_hi   */
)
{
  uint32                        first_num;
  uint32                        last_num;
  uint32                        mask;
  dsrlpi_nak_list_entry_type   *temp_ptr;      /*  nak list entry          */
  q_type                       *nak_q_ptr;     /*  ptr to rlp's nak list   */
  uint32                        modulus; 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  ASSERT(rscb_ptr != NULL);
  ASSERT(fr_info_ptr != NULL);
  
  /*-------------------------------------------------------------------------
    Set up some local vars.  These are used more for cleanliness of code,
    so that some statements can fit on one line
  -------------------------------------------------------------------------*/
  nak_q_ptr = &(rscb_ptr->state.nak_q);
  modulus   = rscb_ptr->ver_ptr->seq_modulus;

  first_num = fr_info_ptr->seq_num;
  mask      = fr_info_ptr->fr_cat;

  temp_ptr = (dsrlpi_nak_list_entry_type *)nak_id;
  ASSERT(temp_ptr != NULL);

  /*-------------------------------------------------------------------------
    Know exactly which frame to start removing from.  Calculate the 
    last_num and remove.  Then update V(N).
  -------------------------------------------------------------------------*/
  last_num = rlpnaki_calc_last_num(first_num, mask, length, modulus);
  if (rlpnaki_remove(rscb_ptr,first_num,last_num,temp_ptr) == FALSE)
  {
    /*-----------------------------------------------------------------------
      If false returned, then there was an error in removing a nak item, due
      to the nak item removal actually causing more nak items to be inserted.
      With FALSE, this indicates the nak list free q is completely empty,
      and so a RESET is required.
    -----------------------------------------------------------------------*/
    ERR("Internal mem error in nak remove",0,0,0);
    return(FALSE);
  }
  
  /*-------------------------------------------------------------------------
    Update V(N) to reflect first missing SEQ.  Have to account for the
    first missing item to be a segmented frame.
  -------------------------------------------------------------------------*/
  temp_ptr = (dsrlpi_nak_list_entry_type *)q_check(nak_q_ptr);
  if (temp_ptr != NULL)
  {
    if (rscb_ptr->state.needed_seq_num != temp_ptr->first_seq)
    {
      MSG_MED("hole filled:new Vn=0x%x,v(r)=0x%x RLP:%d",
              temp_ptr->first_seq,
              rscb_ptr->state.expected_seq_num,
              rscb_ptr->sr_id);
      rscb_ptr->state.needed_seq_num = temp_ptr->first_seq;
    }
    else
    {
      MSG_MED("hole filled - from: 0x%x to 0x%x",
              first_num, last_num, 0);
    }
  }
  else
  {
    MSG_MED("hole filled - Vr = Vn = %x",
            rscb_ptr->state.expected_seq_num,0,0);
    rscb_ptr->state.needed_seq_num = rscb_ptr->state.expected_seq_num;
  }

  return(TRUE);
}


/*===========================================================================

FUNCTION       DSRLPNAK_GET_NAK

DESCRIPTION    Returns an id for the next nak entry which requires a NAK to
               be sent (i.e, age == 0, and naks_left > 0).
               
               The entry is returned as a uint32's.  The TX task is assumed
               to only use functions/macros found in dsrlpnak.c/.h to
               access nak entry info.  As such, it is not important for the
               calling task to know what type the nak_id is.  
               
               Input requires the user to input "curr_nak_id".  If this
               value is zero, then the very first nak entry (requiring
               nak transmission) is returned.  Else, this id refers to a
               nak list entry; in this case the id of nak entry after the
               referenced entry is returned.
               
               A boolean is also used as input parameter.  If "curr_nak_id"
               is zero, then the boolean is ignored, and the very first
               nak entry requiring transmission is returned.  Otherwise,
               if "curr_nak_id" is non-zero, then the next NAK entry
               after "curr_nak_id" is returned according to the value
               of the boolean:
               
               boolean ("segmented")    Returns
               TRUE                     Next segmented nak entry
               FALSE                    Next unsegmented nak entry

DEPENDENCIES   Input ptrs are non-null.
               
               This can only be called by the TX task.  Must not be called
               by any other task, as then mutual exclusion issues will
               arise.  Assumed that TX task has higher priority than the
               RX task.  
               
RETURN VALUE   An id for the next nak entry which requires a nak xmission.
               If the return value is zero, then there are no more nak
               entries requiring transmission.

SIDE EFFECTS   NONE
===========================================================================*/
uint32 dsrlpnak_get_nak
(
  dsrlpi_sess_ctl_blk_type     *rscb_ptr,      /* curr RLP session ctl blk */
  uint32                        curr_nak_id,   /* current nak id           */
  boolean                       segmented      /* TRUE = next segmented    */
)
{
  q_type                       *nak_q_ptr;     /*  ptr to rlp's nak list   */
  dsrlpi_nak_list_entry_type   *temp_ptr;      /*  nak list entry          */
  dsrlpi_state_info_type       *state_ptr;     /*  curr state              */ 
  uint32                        ret_id = 0;    /*  id of next nak entry    */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  
  ASSERT(rscb_ptr    != NULL);

  /*------------------------------------------------------------------------
    Set up some local vars.  These are used more for cleanliness of code,
    so that some statements can fit on one line
  ------------------------------------------------------------------------*/
  state_ptr = &(rscb_ptr->state);
  nak_q_ptr = &(state_ptr->nak_q);

  /*------------------------------------------------------------------------
    look for the next nak entry requiring transmission.  Reference off of
    the input curr_nak_id.
  ------------------------------------------------------------------------*/
  if (curr_nak_id == 0)
  {
    temp_ptr = (dsrlpi_nak_list_entry_type *)q_check(nak_q_ptr);
  }
  else
  {
    temp_ptr = (dsrlpi_nak_list_entry_type *)curr_nak_id;
    temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);
  }

  /*------------------------------------------------------------------------
    loop until the first nak entry requiring transmission is found.
  ------------------------------------------------------------------------*/
  while (temp_ptr != NULL)
  {
    if ((temp_ptr->age == 0) && (temp_ptr->naks_left > 0))
    {
      if (curr_nak_id == 0)
      {
        /*-----------------------------------------------------------------
          In the case where curr_nak_id is 0, then return the
          very first nak entry requiring transmission.  
        -----------------------------------------------------------------*/
          ret_id = (uint32)temp_ptr;
          break;                                                  /* all done */
      }
      else if (DSRLPSEQ_HAS_S_SEQ(temp_ptr->first_seq) || 
               DSRLPSEQ_HAS_S_SEQ(temp_ptr->last_seq))
      {
        /*-----------------------------------------------------------------
          Entry defines a segmented NAK.  If the user has asked for a
          segmented NAK, return this frame.  Else move one to next NAK
          entry.  
        -----------------------------------------------------------------*/
        if (segmented == TRUE)
        {
          ret_id = (uint32)temp_ptr;
          break;                                                  /* all done */
        }
        else
        {
          temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);
        }
      }
      else
      {
        /*-----------------------------------------------------------------
          Entry defines an unsegmented NAK.  If the user has asked for a
          unsegmented NAK, return this frame.  Else move one to next NAK
          entry
        -----------------------------------------------------------------*/
        if (segmented == FALSE)
        {
          ret_id = (uint32)temp_ptr;
          break;                                                  /* all done */
        }
        else
        {
          temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);
        }
      }
    }
    else
    {
      temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);
    }
  }

  return ret_id;
}

#ifdef FEATURE_HDR
#error code not present
#endif /* FEATURE_HDR */

#ifndef MSM5000_IRAM_FWD
/*===========================================================================

FUNCTION       DSRLPNAK_GET_SEQ_HI

DESCRIPTION    Given an input sequence number (with unknown SEQ_HI), 
               finds the SEQ_HI for that number.
               
               The fr_info_ptr's seq_num is updated with the found seq
               number (if it is found).  The input nak_id is updated with
               a reference point, so that if dsrlpnak_remove is called
               with it, it can be more efficient.

DEPENDENCIES   Input ptrs are non-null.
               
               This can only be called by the RX task.  Must not be called
               by any other task, as then mutual exclusion issues will
               arise.  Assumed that TX task has higher priority than the
               RX task.
               
RETURN VALUE   TRUE if frame is in the nak list.  FALSE otherwise.  If 
               the frame is in the list, then the seq is filled with the
               seq_hi (if unknown upon entry).  The nak_id is filled with
               a reference to the nak entry which contains the seq.

SIDE EFFECTS   V(N) may be updated.
===========================================================================*/
boolean dsrlpnak_get_seq_hi
(
  dsrlpi_sess_ctl_blk_type     *rscb_ptr,      /* curr RLP session ctl blk */
  dsrlpi_curr_fr_info_type     *fr_info_ptr,   /* ptr to curr frame info   */
  word                          length,        /* byte-length of data      */
  uint32                       *nak_id         /* filled with ref pt       */
)
{
  uint32                        first_num;
  uint32                        last_num;
  uint32                        mask;
  dsrlpi_nak_list_entry_type   *temp_ptr = NULL;/*  nak list entry         */
  q_type                       *nak_q_ptr;      /*  ptr to rlp's nak list  */
  uint32                        modulus;        /*  seq modulus            */
  boolean                       ret_val = FALSE;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  ASSERT(rscb_ptr != NULL);
  ASSERT(fr_info_ptr != NULL);
  
  /*-------------------------------------------------------------------------
    Set up some local vars.  These are used more for cleanliness of code,
    so that some statements can fit on one line
  -------------------------------------------------------------------------*/
  nak_q_ptr = &(rscb_ptr->state.nak_q);
  modulus   = rscb_ptr->ver_ptr->seq_modulus;

  first_num = fr_info_ptr->seq_num;

  mask = fr_info_ptr->fr_cat;

  /*-------------------------------------------------------------------------
    If the mask indicates that SEQ_HI is included in first_num, then there
    is nothing special to do.  Calculate last_num, and then see if the
    frame is in the list.
    
    Data can only come in one frame at a time; a data frame cannot cross
    two SEQ boundaries.
  -------------------------------------------------------------------------*/
  if (DSRLPI_HAS_SEQ_HI_MASK(mask))
  {
    last_num = rlpnaki_calc_last_num(first_num, mask, length, modulus);
    temp_ptr = (dsrlpi_nak_list_entry_type *)q_check(nak_q_ptr);

    while (temp_ptr != NULL)
    {
      if ((DSRLPSEQ_GE_SEQ_CHECK(temp_ptr->first_seq,last_num,modulus)) ||
          (DSRLPSEQ_GE_SEQ_CHECK(first_num,temp_ptr->last_seq,modulus)))
      {
        temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);
      }
      else
      {
        ret_val = TRUE;
        break;
      }
    } /* while */
  }
  else
  {
    /*-----------------------------------------------------------------------
      Caller did not know what SEQ_HI was.  Now have to find the first NAK
      list entry which corresponds to the 8-bit SEQ num in first_num.  Based
      on that, update first_num and create last_num, and then check against
      the current nak entry.
    -----------------------------------------------------------------------*/
    temp_ptr = (dsrlpi_nak_list_entry_type *)q_check(nak_q_ptr);
    while (temp_ptr != NULL)
    {
      /*---------------------------------------------------------------------
        For each entry, first try to see if the first_seq's SEQ_HI makes
        things work.  Then see if the modified first_num falls within the
        first_seq/last_seq window.  Note that due to exclusive nature of
        last_seq, last_seq should not equal the modified first_num.
      ---------------------------------------------------------------------*/
      byte seq_hi = DSRLPSEQ_GET_SEQ_HI(temp_ptr->first_seq);
      DSRLPSEQ_PUT_SEQ_HI(first_num,seq_hi);

      last_num = rlpnaki_calc_last_num(first_num, mask, length, modulus);

      if ((DSRLPSEQ_GE_SEQ_CHECK(temp_ptr->first_seq,last_num,modulus)) ||
          (DSRLPSEQ_GE_SEQ_CHECK(first_num,temp_ptr->last_seq,modulus)))
      {
        byte seq_hi = DSRLPSEQ_GET_SEQ_HI(temp_ptr->last_seq);
        DSRLPSEQ_PUT_SEQ_HI(first_num,seq_hi);
        last_num = rlpnaki_calc_last_num(first_num, mask, length, modulus);
        
        if ((DSRLPSEQ_GE_SEQ_CHECK(temp_ptr->first_seq,last_num,modulus)) ||
            (DSRLPSEQ_GE_SEQ_CHECK(first_num,temp_ptr->last_seq,modulus)))
        {
          temp_ptr = DSRLPNAK_GET_NEXT_ENTRY(nak_q_ptr,temp_ptr);
        }
        else
        {
          fr_info_ptr->seq_num = first_num;
          ret_val = TRUE;
          break;
        }
      }
      else
      {
        fr_info_ptr->seq_num = first_num;
        ret_val = TRUE;
        break;
      }
    } /* while */
  }/* if SEQ_HI is in the bitmask */

  if (ret_val == FALSE)
  {
    ASSERT(temp_ptr == NULL);
    /*---------------------------------------------------------------------
	 If the received frame doesn't contain a seq_hi, remove the calculated
	 seq_hi as this could carry wrong information in the case of duplicated
	 frames.
	-----------------------------------------------------------------------*/
	if ((DSRLPI_HAS_SEQ_HI_MASK(mask)) == FALSE)
	{
	   DSRLPSEQ_PUT_SEQ_HI(fr_info_ptr->seq_num,0);
	}
  }

  *nak_id = (uint32)temp_ptr;
  return (ret_val);
} /* dsrlpnak_get_seq_hi() */
#endif /* MSM5000_IRAM_FWD */

/*===========================================================================

FUNCTION       DSRLPNAK_GET_FREENAK_COUNT

DESCRIPTION    returns the no. of items in the nak_free Q. This number is
               useful to print in a debug message at the end of rlp cleanup
               to detect nak item leaks

DEPENDENCIES   None

RETURN VALUE   returns the no. if items in nak_free Q

SIDE EFFECTS   None
===========================================================================*/

uint8 dsrlpnak_get_freenak_count()
{
  return q_cnt( &dsrlpnak_free_q );
}

#endif /* any of the RLPs defined */

