/*=============================================================================
   P R O G R E S S I V E   B O O T   E L F   G E N E R A T I O N   T O O L

   This program takes in an ELF file, a scatter load file and generates an
   ELF file in the progressive boot format and a hash table. The hash table
   will need to be signed for secure boot, and the header has to be generated
   before the final image can be created using pboot_add_hash.


EXTERNALIZED FUNCTIONS

INITIALIZATION AND SEQUENCING REQUIREMENTS

Copyright (c) 2005, 2006 by QUALCOMM, Inc.  All Rights Reserved.
=============================================================================*/

/*=============================================================================

                            EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $Header: //depot/asic/msmshared/tools/pboot/pboot_gen_elf.c#17 $

when       who     what, where, why
--------   ---     ------------------------------------------------------------
09/22/06   rjain   Removed an undefined variable that was being used in a printf
                   Strangely it did not show up as an error during compilation
                   on most of the systems.
08/31/06   rjain   Modified for Simple elf support
11/22/05   ty      Added shared segment support
08/08/05   ih      Created

=============================================================================*/


/*=============================================================================

                            INCLUDE FILES FOR MODULE

=============================================================================*/
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <stdint.h>
#include "pboot_elf_utils.h"
#include "pboot_gen_hash.h"

/*=============================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

=============================================================================*/

static char fbuf[PAGE_SIZE];      /* buffer for file ops */
bool debug_print = 0;            /* global debug option */

/*=============================================================================

                              FUNCTION DEFINITIONS

=============================================================================*/

/*===========================================================================
FUNCTION  PRINT_USAGE

DESCRIPTION
    This function prints out the program usage

DEPENDENCIES

RETURN VALUE

SIDE EFFECTS

===========================================================================*/

void print_usage(char *filename)
{
  printf("This program takes in an AMSS ELF file, a scatter load file\n"
         "and generates an ELF file in the progressive boot format and a hash\n"
         "table. The hash table will need to be signed, and the header has to\n"
         "be generated before the final image can be created using pboot_add_hash.\n"
         "Alternatively, the hash table can be the sole output\n\n"
         "Usage: %s [-d] elf_file scl_file output_elf output_hash\n"
         "       %s [-d] elf_file output_hash\n"
         "      -d           - debug mode\n"
         "      elf_file     - input ELF file generated by the linker\n"
         "      scl_file     - input progressive boot scatter load file\n"
         "      output_elf   - output ELF file\n"
         "      output_hash  - output hash table\n", filename, filename);

}

/*===========================================================================

FUNCTION  GEN_HASH

DESCRIPTION
    1) Hash the segments based on paging option

DEPENDENCIES
    None.

RETURN VALUE

SIDE EFFECTS
    None.

===========================================================================*/
int gen_hash
(
 FILE *infile,   /* input elf file.  */
 FILE *hashfp    /* output hash file */
 )
{
  struct elf_file_info src_file;

  int i, size;
  Elf32_Phdr *o_hdr;
  unsigned int ret;
  char hash[PROG_BOOT_DIGEST_SIZE];
  uint32_t phdr_size;
  uint32_t* print_hash_ptr;
  src_file.fd = fileno(infile);

  /* Read and verify the source ELF header */
  ret = process_elf_header(infile, &src_file);
  if (ret)
  {
    printf("Could not process the ELF header - errno(%d)\n", ret);
    return errno;
  }

  /* Get program header size */
  phdr_size = src_file.elf_hdr.e_phnum * src_file.elf_hdr.e_phentsize;

  /* Seek to program header location before you read */
  ret = fseek(infile, src_file.elf_hdr.e_phoff, SEEK_SET);
  if (ret)
  {
    printf("Cannot fseek. ret(%d) - errno(%d)\n", ret, errno);
    return errno;
  }

  /* Get the program header table */
  if(fread((char *)src_file.phdr_table, phdr_size, 1, infile) != 1)
  {
    printf("Unable to read the program header table from input file !\n");
    return errno;
  }

  /* Generate the hash table */
  for(i=0; i<src_file.elf_hdr.e_phnum ; i++)
  {
    o_hdr = &src_file.phdr_table[i];
    if(MI_PBT_PAGE_MODE_VALUE(o_hdr->p_flags) == MI_PBT_PAGED_SEGMENT)
    {
      uint32_t seg_offset, seg_size, off;
      uint32_t hash_size;

      /* Generate hash for each 4K page, 1 page at a time */
      DEBUG("Generating hash table for PAGED segment [%d]\n", i,0,0);
      /* Read page into memory */
      seg_offset = o_hdr->p_offset;
      seg_size = o_hdr->p_filesz;
      DEBUG("   Read [%x] for [%x] bytes\n", seg_offset, seg_size, 0);

      /* Check to see if vaddr is page aligned, if not, start on the next page
      ** instead -- a padding is added in the scl file and that will never be
      ** referenced
      */
      off = o_hdr->p_vaddr & (PAGE_SIZE-1);
      if(off)
      {
        DEBUG("   vaddr not page aligned. Offset [%x]\n", off, 0,0);
        seg_size -= (PAGE_SIZE-off);
        seg_offset += (PAGE_SIZE-off);
      }

      DEBUG("   Start on [%x] for [%x] bytes\n", seg_offset, seg_size, 0);

      /* seg_size should be page aligned */
      if(seg_size & (PAGE_SIZE-1))
      {
        printf("seg_size = 0%x not aligned!\n", seg_size);
        return ERROR;
      }

      DEBUG("   seg_offset [%x], end [%x]\n", seg_offset, seg_offset+seg_size,0);
      off = seg_offset+seg_size;
      while( seg_offset < off)
      {
        if (seg_offset < PAGE_SIZE)
        {
          hash_size = seg_offset;
        }
        else
        {
          hash_size = PAGE_SIZE;
        }
        if(freadn(fbuf, infile, seg_offset, hash_size))
        {
          printf("Cannot read from file!");
          return errno;
        }

        if((MI_PBT_SEGMENT_TYPE_VALUE(o_hdr->p_flags) != MI_PBT_HASH_SEGMENT) &&
           (MI_PBT_ACCESS_TYPE_VALUE(o_hdr->p_flags) != MI_PBT_NOTUSED_SEGMENT) &&
           (MI_PBT_ACCESS_TYPE_VALUE(o_hdr->p_flags) != MI_PBT_SHARED_SEGMENT))
        {
          /* Call the hashing routine */
          secprogboot_generate_hashes(fbuf, PAGE_SIZE, 1, hash);
        }
        else
        {
          memset(hash, 0, PROG_BOOT_DIGEST_SIZE);
        }
        /* Write hash to file */
        if(fwrite(hash, PROG_BOOT_DIGEST_SIZE, 1, hashfp) != 1)
        {
          printf("Cannot write to hash file!");
          return errno;
        }
        seg_offset+=PAGE_SIZE;
      }
    }
    else if(MI_PBT_PAGE_MODE_VALUE(o_hdr->p_flags) == MI_PBT_NON_PAGED_SEGMENT)
    {
      char *file_buff;
      char *file_buff1;
      uint32_t file_size;

      DEBUG("Generating hash table for NOTPAGED segment [%d]\n", i,0,0);

      /* Generate hash for the whole segment
      ** Load the entire file into memory and hash it? Ugh
      */
      if ((file_buff = (uint8_t *) malloc (o_hdr->p_filesz))
          == NULL)
      {
        printf("generate_hash_table: malloc failed.\n");
        return errno;
      }

      DEBUG("   Start on [%x] for [%x] bytes\n", o_hdr->p_offset, o_hdr->p_filesz, 0);

      if(freadn(file_buff, infile, o_hdr->p_offset, o_hdr->p_filesz))
      {
        printf("Cannot read from file!");
        return errno;
      }

      if((MI_PBT_SEGMENT_TYPE_VALUE(o_hdr->p_flags) != MI_PBT_HASH_SEGMENT) &&
         (MI_PBT_ACCESS_TYPE_VALUE(o_hdr->p_flags) != MI_PBT_NOTUSED_SEGMENT) &&
         (MI_PBT_ACCESS_TYPE_VALUE(o_hdr->p_flags) != MI_PBT_SHARED_SEGMENT))
      {
        /* Call the hashing routine */
        secprogboot_generate_hashes(file_buff, o_hdr->p_filesz, 1, hash);
      }
      else
      {
        memset(hash, 0, PROG_BOOT_DIGEST_SIZE);
      }


      /* Write hash to file */
      if(fwrite(hash, PROG_BOOT_DIGEST_SIZE, 1, hashfp) != 1)
      {
        printf("Cannot write to hash file!");
        return errno;
      }
      free(file_buff);
    }
  }

  return 0;
}


/*===========================================================================

FUNCTION    PBOOT_MELF

DESCRIPTION
    1) Move program header to end of ELF header if needed
    2) Move segments to vaddr in ELF after the first page
    3) Pad the end of segments to reach page boundary in RAM
    4) Write paging option to segments based on SCL file
    5) Update program header in the new ELF

DEPENDENCIES
    None.

RETURN VALUE

SIDE EFFECTS
    None.

===========================================================================*/
int pboot_melf
(
 FILE *infile,    /* input elf file.  */
 FILE *opfile,    /* output elf file. */
 segments_t *segs /* segment information */
)
{
  struct elf_file_info src_file;
  struct elf_file_info dest_file;

  int i, size;
  uint32_t initial_padding = 0;
  uint32_t phdrs_bcount = 0;
  uint32_t phdrs_pad_end_offset;
  uint32_t file_offset;
  Elf32_Phdr *i_hdr, *o_hdr;
  unsigned int ret;

  src_file.fd = fileno(infile);
  dest_file.fd = fileno(opfile);

  /* Verify the ELF header */
  size = read(src_file.fd, (char*) &(src_file.elf_hdr), ELF_HDR_SIZE);
  if (size != ELF_HDR_SIZE)
  {
    printf("Couldn't read elf header\n");
    return errno;
  }

  ret = verify_elf_header(&src_file.elf_hdr);
  if (ret)
  {
    printf("ELF header fails verification\n");
    return ERROR;
  }

  /* Copy the source elf header to the destination */
  dest_file.elf_hdr = src_file.elf_hdr;


  /*----------------------------------------------------------------------
     See if the program headers need to be moved to 4K aligned boundary
    ----------------------------------------------------------------------*/
  DEBUG("Checking location of Program Headers:\n", 0, 0, 0);

  /* Check if the Program header is already 4K aligned. If not, do so now.
  ** For now we assume that the first (4K-ELF_HDR_SIZE)bytes will be sufficient
  ** to store the hash signature and hash certificate chain. If this changes in
  ** the future then the start address for program header must be changed accordingly
  */
  if (src_file.elf_hdr.e_phoff != ELF_BLOCK_ALIGN)
  {
    phdrs_bcount = src_file.elf_hdr.e_phnum * src_file.elf_hdr.e_phentsize;

    initial_padding = offset_align((ELF_BLOCK_ALIGN + phdrs_bcount), ELF_BLOCK_ALIGN) -
                                   (ELF_BLOCK_ALIGN + phdrs_bcount);

    DEBUG("   Moving (%d) PHDRS from offset (0x%x) to (0x%x)\n",
              src_file.elf_hdr.e_phnum,
              src_file.elf_hdr.e_phoff,
              ELF_BLOCK_ALIGN);

    DEBUG("   Using (%d) bytes for PHDRS\n", phdrs_bcount, 0, 0);

    DEBUG("   ---> (%d) bytes available for hash signature and certificate chain \n",
              (ELF_BLOCK_ALIGN - ELF_HDR_SIZE), 0, 0);

    DEBUG("   ---> Will add (%d) padding bytes up to the first segment\n\n",
              initial_padding, 0,0);

    dest_file.elf_hdr.e_phoff = ELF_BLOCK_ALIGN;
  }

  dest_file.elf_hdr.e_flags &= ~0x4;  //SYMARESORTED
  dest_file.elf_hdr.e_flags &= ~0x10; //MAPSYMFIRST

  /* Calcuate the start location of the first segment -- again assuming
  ** that the hash signature and cert_chain will fit within the first 4K
  */
  phdrs_pad_end_offset = ELF_BLOCK_ALIGN + phdrs_bcount + initial_padding;
  file_offset = phdrs_pad_end_offset;

  /*----------------------------------------------------------------------
     Remove the section headers
    ----------------------------------------------------------------------*/
  dest_file.elf_hdr.e_shoff = 0;
  dest_file.elf_hdr.e_shnum = 0;
  dest_file.elf_hdr.e_shstrndx = 0;

  /*----------------------------------------------------------------------
     Write the new ELF header
    ----------------------------------------------------------------------*/
  ret = write(dest_file.fd, (char*) &dest_file.elf_hdr, ELF_HDR_SIZE);
  if ((unsigned int)ret != ELF_HDR_SIZE)
  {
    printf("ret(%d) - errno(%d)\n", ret, errno);
    return errno;
  }

  /* Seek to the start location of program header in destination file */
  ret = lseek(dest_file.fd, ELF_BLOCK_ALIGN, SEEK_SET);
  if ((unsigned int)ret != ELF_BLOCK_ALIGN)
  {
    printf("Couldn't seek input file '%d'- errno(%d).\n", ret, errno);
    return errno;
  }

  /*----------------------------------------------------------------------
     The first segment will be put at this offset
    ----------------------------------------------------------------------*/
  memset(&dest_file.phdr_table[0], 0, sizeof(Elf32_Phdr));
  dest_file.phdr_table[0].p_offset = offset_align(phdrs_pad_end_offset,
                                                  ELF_BLOCK_ALIGN);

  /*----------------------------------------------------------------------
     Go to the start of the program header table in input file
    ----------------------------------------------------------------------*/
  ret = lseek(src_file.fd, src_file.elf_hdr.e_phoff, SEEK_SET);
  if ((unsigned int)ret != src_file.elf_hdr.e_phoff)
  {
    printf("Couldn't seek input file '%d'- errno(%d).\n", ret, errno);
    return errno;
  }

  /*----------------------------------------------------------------------
   ** Write the new program headers in the output file,
   ** updating the file offset of each segment to have them
   ** individually aligned on a ELF_BLOCK_ALIGN boundary.
   ----------------------------------------------------------------------*/
  DEBUG("Writing aligned Program Headers offsets:\n",0,0,0);

  /* Check if the number of segments is the same as in scl file */
  if(segs->num_segments != src_file.elf_hdr.e_phnum)
  {
    printf("SCL file has %d segments, but found %d in ELF file!\n",
        segs->num_segments, src_file.elf_hdr.e_phnum);
    return ERROR;
  }

  /*----------------------------------------------------------------------
   * What to do here?
   * 1) Move all segments to be 4K aligned
   * 2) If vaddr is not on a page boundary, move it up to the next page
   * 3) Pad the segment to the end of the page in SDRAM, not flash
   * 4) Update paging info in the flag of each program header
   * 5) Write the updated header to file
   * 6) Hash segments or pages
   *----------------------------------------------------------------------*/
  for(i=1; i<=src_file.elf_hdr.e_phnum ; i++)
  {
    i_hdr = &src_file.phdr_table[i];
    o_hdr = &dest_file.phdr_table[i];

    /* Get the segment description */
    if((ret=read(src_file.fd, (char*) i_hdr, src_file.elf_hdr.e_phentsize))
        != src_file.elf_hdr.e_phentsize)
    {
      printf("Unable to read program header!\n");
      return errno;
    }

    /* Save the values for the output file */
    *o_hdr = *i_hdr;

    o_hdr->p_offset = file_offset;

    DEBUG("   Segment [%d] aligned from [%#x] to [%#x]", i, i_hdr->p_offset,
        file_offset);

    o_hdr->p_filesz = i_hdr->p_filesz;

    file_offset += i_hdr->p_filesz;

    file_offset = offset_align(file_offset, ELF_BLOCK_ALIGN);

    DEBUG(" -- size padded to [%x] [%x] bytes\n", file_offset,
          file_offset-i_hdr->p_filesz, 0);

    /* Check if the SCL matches ELF (need to do i-1 because i starts at 1) */
    if(segs->segments[i-1].start_addr && segs->segments[i-1].start_addr != i_hdr->p_vaddr)
    {
      printf("SCL does not match ELF! seg [%d] vaddr [%x] != start_addr [%x]\n",
             i, i_hdr->p_vaddr, segs->segments[i-1].start_addr);
    }

    /* Update flags (i-1 as before) */
    DEBUG("segs->segments[i-1].flag [0x%x]\n", segs->segments[i-1].flag, 0, 0);
    o_hdr->p_flags = ((o_hdr->p_flags & ~MI_PBT_FLAGS_MASK) | (segs->segments[i-1].flag));

    /* Write the header to the output file */
    ret = write(dest_file.fd, (char*) o_hdr, src_file.elf_hdr.e_phentsize);
    if (ret != src_file.elf_hdr.e_phentsize)
    {
      printf("\nret(%d) - errno(%d)\n", ret, errno);
      return errno;
    }
  }

  DEBUG("\nCopying Segments from old to new offsets:\n",0,0,0);

  /* Copy the program bits */

  for(i=1; i<=src_file.elf_hdr.e_phnum ; i++)
  {
    int padding;

    i_hdr = &src_file.phdr_table[i];
    o_hdr = &dest_file.phdr_table[i];

    DEBUG("   Segment [%#d] moving from [%#x] to [%#x]",
              i, i_hdr->p_offset, o_hdr->p_offset);
    DEBUG("   - Size [%#x]\n", i_hdr->p_filesz, 0, 0);

    if(fcpy(infile, i_hdr->p_offset, opfile, o_hdr->p_offset, i_hdr->p_filesz))
    {
      printf("Unable to copy segment!\n");
      return errno;
    }
  }

  return 0;
}


/*===========================================================================

FUNCTION    MAIN

DESCRIPTION
    Main program function

    Usage: pboot_gen_elf [-d] elf_file scl_file output_elf output_hash
           pboot_gen_elf [-d] elf_file output_hash

DEPENDENCIES
    None.

RETURN VALUE
    !=0  Error
    0    Success

SIDE EFFECTS
    None.

===========================================================================*/
int main(int argc, char **argv)
{
  /* argv[1] = input elf
  ** argv[2] = input scl file
  ** argv[3] = output elf
  ** argv[4] = output hash table
  */
  segments_t segment_info = {0};          /* table containing segment info */
  char *in_elf_file = NULL, *in_scl_file = NULL, *out_elf_file = NULL, *out_hash_file = NULL;
  FILE *in_elf = NULL, *in_scl = NULL, *out_elf = NULL, *out_hash = NULL;
  int i=0, ret;

  if((argc == 6 || argc == 4) && strcmp(argv[1], "-d") == 0)
  {
    /* Enable Debug Mode */
    debug_print = true;
    /* shift argv by 1 */
    i=1;
  }
  else if(argc != 5 && argc != 3)
  {
    print_usage(argv[0]);
    exit(-1);
  }

  if((debug_print && argc == 6) || (!debug_print && argc == 5))
  {
    /* Generate ELF */
    /* Save arguments */
    in_elf_file = argv[1+i];
    in_scl_file = argv[2+i];
    out_elf_file = argv[3+i];
    out_hash_file = argv[4+i];

    OPENFILE(in_scl_file, in_scl, "rb");
    printf("Parse scatter load file %s\n", in_scl_file);
    if(parse_scl_file(in_scl, &segment_info))
    {
      perror("Error parsing scl file");
      exit(-1);
    }
    fclose(in_scl);

    OPENFILE(in_elf_file, in_elf, "rb");
    OPENFILE(out_elf_file, out_elf, "wb+");

    ret = pboot_melf(in_elf, out_elf, &segment_info);
    if(ret)
    {
      if(ret != ERROR) perror("Error generating ELF image");
      exit(-1);
    }

    fclose(in_elf);     /* keep out_elf for hash generation */
  }

  if((debug_print && argc == 4) || (!debug_print && argc == 3))
  {
    /* Save arguments */
    in_elf_file = argv[1+i];
    out_hash_file = argv[2+i];
    OPENFILE(in_elf_file, out_elf, "rb");
  }

  /* Generate hash table */
  OPENFILE(out_hash_file, out_hash, "wb+");
  ret = gen_hash(out_elf, out_hash);
  if(ret)
  {
    if(ret != ERROR) perror("Error generating Hash table");
    exit(-1);
  }
  printf("Finished hashing. Closing files!\n");

  fclose(out_elf);
  fclose(out_hash);
  exit(0);
}

