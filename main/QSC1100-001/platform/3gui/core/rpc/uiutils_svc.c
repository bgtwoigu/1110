/*=============================================================================
                           U I U T I L S _ S V C . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that dispatches RPC requests targetting the
  uiutils api.

Copyright (c) 2007 by QUALCOMM, Incorporated. All Rights Reserved.
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
#ifdef FEATURE_HTORPC_METACOMMENTS
/* Generated by following versions of Htorpc modules:
Id: //depot/asic/msm7500/tools/build/htorpc/htorpc.pl#11 
Id: //depot/asic/msm7500/tools/build/htorpc/Htorpc/Start/Start.pm#36 
Id: //depot/asic/msm7500/tools/build/htorpc/Htorpc/Htoxdr/Htoxdr.pm#35 
Id: //depot/asic/msm7500/tools/build/htorpc/Htorpc/XDR/00.01/XDR.pm#34 
Id: //depot/asic/msm7500/tools/build/htorpc/Htorpc/Output/00.03/Output.pm#18 
Id: //depot/asic/msm7500/tools/build/htorpc/Htorpc/Parser/Parser.pm#26 
Id: //depot/asic/msm7500/tools/build/htorpc/Htorpc/Metacomments/Metacomments.pm#34 
Id: //depot/asic/msm7500/tools/build/htorpc/Htorpc/SymbolTable/SymbolTable.pm#25  */
#endif
/* $Id: //depot/asic/msmshared/apps/Core/rpc/uiutils_svc.c#4 $
=============================================================================*/

#include "customer.h"
#include "target.h"

#ifdef FEATURE_ONCRPC
#ifdef FEATURE_EXPORT_UIUTILS

/* Include files */
#include "err.h"
#include "msg.h"

#include "uiutils.h"
#include "uiutils_rpc.h"

/* Only one copy needed per API */
//static opaque_auth UiutilsCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth UiutilsVerf = { ONCRPC_AUTH_NONE, 0, 0 };


/*=======================================================================
             Prototypes for the API's RPC Server Functions
=======================================================================*/

static void uiutilsprog_0 ( struct svc_req *rqstp, xdr_s_type *srv );

static void uiutils_null_0( xdr_s_type *svc );

static void ui_return_provisioning_status_0( xdr_s_type *srv );

/******************************************************************************/
/*=======================================================================
             API RPC Server Implementation
=======================================================================*/

void uiutils_app_init( void )
{

  uiutils_app_init_with_proxy( NULL );

} /* uiutils_app_init */

void uiutils_app_init_with_proxy( oncrpc_proxy_task_s_type *proxy )
{

  xdr_s_type *transp;

#if (defined FEATURE_ONCRPC_SM)
  transp = svcsm_create(0, 0);
  if ( transp == NULL ) {
    ERR_FATAL("cannot create sm service.", 0, 0, 0);
  }
  if ( !svc_register_with_proxy(transp, UIUTILSPROG, UIUTILSVERS,
                                uiutilsprog_0, (-3), proxy) ) {
    ERR_FATAL("unable to register (UIUTILSPROG, UIUTILSVERS, sm).",0,0,0);
  }

#endif /* (defined FEATURE_ONCRPC_SM) */

} /* uiutils_app_init_with_proxy */

void uiutils_app_lock( boolean lock )
{
  svc_lock( UIUTILSPROG, UIUTILSVERS, lock );
} /* uiutils_app_lock */

static void uiutilsprog_0 ( struct svc_req *rqstp, xdr_s_type *srv )
{

  XDR_ERRCHK( srv, ON );

  switch ( rqstp->rq_proc ) {
    case ONCRPC_UIUTILS_NULL_PROC:
      uiutils_null_0( srv );
      break;
    case ONCRPC_UI_RETURN_PROVISIONING_STATUS_PROC:
      ui_return_provisioning_status_0( srv );
      break;

    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_noproc( srv );
      break;
  }

  oncrpcxdr_mem_free( srv );

  XDR_ERRCHK( srv, OFF );

} /* uiutilsprog_0 */

/******************************************************************************/

static void uiutils_null_0( xdr_s_type *srv )
{

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg, send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  (void) xdr_reply_msg_start( srv, &UiutilsVerf );
  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    ERR_FATAL( "uiutils_null_0: XDR_MSG_SEND failed", 0, 0, 0 );
  }

} /* uiutils_null */

static void ui_return_provisioning_status_0( xdr_s_type *srv )
{

  ui_provisioning_status_type ui_return_provisioning_status_result;

  if ( ! XDR_MSG_DONE( srv ) ) {
    // Left over data in RPC msg
    svcerr_decode( srv );
    return;
  }

  ui_return_provisioning_status_result = ui_return_provisioning_status();


  (void) xdr_reply_msg_start( srv, &UiutilsVerf );
  (void) XDR_SEND_ENUM( srv, &ui_return_provisioning_status_result );


  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    ERR_FATAL( "ui_return_provisioning_status_0: XDR_MSG_SEND failed", 0, 0, 0 );
  }


} /* ui_return_provisioning_status_0 */

#endif /* FEATURE_EXPORT_UIUTILS */
#endif /* FEATURE_ONCRPC */
