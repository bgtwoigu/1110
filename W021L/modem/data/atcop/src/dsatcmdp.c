/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                        D A T A   S E R V I C E S
                A T   C O M M A N D   P R O C E S S O R

GENERAL DESCRIPTION
  This module provides the table driven AT modem command processor.

EXTERNALIZED FUNCTIONS
  dsat_init
    Initializes ATCOP queues and internal variables, as well as all AT
    parameters to their default values.

  dsat_init_service_mode
    Initializes the AT command processor to new operating mode.  AT
    command processing functions are selected from table based on
    new operating mode.

  dsat_process_cmd_line
    Entry point to all of the AT command parsing routines.  Accepts
    a buffer containing a complete command line, and parses and
    executes the commands.

  dsat_process_async_cmd
    Asynchronous ATCOP command handler.  Processes asynchronous ATCOP
    commands received by data services task dispatcher.

  dsat_process_async_signal
    Asynchronous ATCOP REX signal handler.  Processes asynchronous ATCOP
    signals received by data services task dispatcher.

  dsat_nv_sync  
    Initializes the AT parameter manufacturing default values from NV.

  dsat_change_baud
    Change the current baud rate and write the new value to NV.


EXTERNALIZED FUNCTIONS INTERNAL TO DSAT UNIT    
  dsatcmdp_reg_unrec_cmd_handler
    This function registers a handler that is called when an unrecognized
    AT command is received.

  dsatcmdp_init_config
    Initializes the AT parameters to the manufacturing default values.

  dsatcmdp_queue_token
    Queues token structure into token queue.

  dsatcmdp_flush_token_queue
    Flushes any tokens currently in token queue.

  dsatcmdp_queue_cmd_results
    This function places the results of AT commands in a queue,
    so they can be output (or discarded) at the end of the command
    line.

  dsatcmdp_send_queued_cmd_results
    This functions flushes the results queue to the serial port or PS
    protocol stack based on the registered response routing function.
  
  dsatcmdp_discard_queued_cmd_results
    This functions discards any queued up AT command results.  Required
    for IS-707 unrecognized command processing.

  dsatcmdp_handle_async_cmd_rsp
    This function formats the raw unformatted response generated by an
    asynchronous command handler and queues it up for transmission.

  dsatcmdp_abort_command
    Calls abort command handler located in command table to abort the
    abortable AT command currently being processed.

  dsatcmdp_command_abort_complete
    Clears flag used during abort command processing and places SIO
    preprocessor in AT command mode.
  
  dsatcmdp_disable_cmd_abort_complete
    Disables termination of abort command handling of current command
    being processed when call to function to send result code is made
    by clearing flag.

  dsatcmdp_get_operating_cmd_mode
    This function gets the current AT command processor operating service
    mode.
    
  dsatcmdp_get_current_mode
    This function gets the current AT command etsi mode, GSM or WCDMA or CDMA.

  dsatcmdp_block_indications  
    Returns value to indicate whether or not indications sent to the TE
    should be blocked.

    
INITIALIZATION AND SEQUENCING REQUIREMENTS
  Call the function dsat_init on initial power-up and call
  dsat_init_service_mode each time a new operating service mode
  is entered.

   Copyright (c) 2000 - 2009 by QUALCOMM Incorporated.
   All Rights Reserved.
   Qualcomm Confidential and Proprietary.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

  $Header: //source/qcom/qct/modem/data/common/commonatcop/main/lite/src/dsatcmdp.c#11 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
09/14/09   na      Fixed $QCMIPNAI, $QCMIPMASS, $QCMIPMHSS responses 
                   after ATZ execution.
02/03/09   bs      Fixed compilation errors/warnings.
01/21/09   nc      Added support for SMS Commands.
01/02/09   bs      Added support for 1X AT Phonebook commands.
09/17/08   bs      Fixed MIP related commands.
08/21/08   bs      Fixing compiler warnings.
07/09/08   bs      Added support for CDMA NAARefresh.
07/11/08   sn      Changed FEATURE_DS_SIP_MULTIPLE_PROFILE to 
                   FEATURE_DS_MULTIPLE_PROFILES.
06/24/08   sn      Modified to use updated data session function name.
03/28/08   bs      Fixed Lint High's.
03/20/08   psng    Updated feature macro for multiple sip profile
02/11/08   psng    Added NV Support for multiple sip profiles.
10/30/07   sn      Removed unused variable 'temp_optlen'.
10/29/07   sn      Replaced banned string APIs.
08/16/04   gr      Fixed the problem with the AT+CDV command when there is
                   no delimiter between the command and dial string
12/25/03   rsl     Changes relating to Unrec. cmds not working.
05/21/03   rsl     Changed temp_qos_pri type to byte to match rlp func. proto.
05/21/03   atp     Added include dsrlp.h - the change below inadvertently
                   removed it. 
05/05/03   jd      Removed dependency on dsiface_def.h
05/01/03   sb      While processing command line check to see if we are 
                   processing ATH command. If so then exit processing the
                   command line. It will be called later when call is dropped
                   and DSMGR sends us the result code.
04/28/03   sb      AT command flow control. Removed FEATURE_DSAT_FLOW_CONTROL
                   Changed the queue limit #define to a variable. 
04/17/03   dgy     Merged GSM and WCDMA CS Data mode-specific handlers.
04/04/03   ar      Add flush of ME notifications after cmdline processed.
03/17/03   ar      Correct range offset increment for BROKEN_RANGE logic.
02/26/03   ar      Added intialization of ETSI PDP activation tracking.
02/25/03   ar      Removed reset_cbst_val() function.
02/20/03   wx      Clean the feature define logics in dsatcmdp_init_config
02/14/03   wx      Add ABORTING state to the abortable command to 
                   handle the aborting in async command processing.
02/10/03   wx      Add NO_RESET attrib for cmd to prevent ATZ, AT&F
                   from changing parameter values.
01/13/03   ar      Removed call to dsatetsipkt_init_pdp_context() during init
01/09/03   wx      Add support for export +ES and +ESA values
01/07/03   sb      reduced the priority of MSG(E) to MSG_HIGH when we receive
                   unexpected event (when we are in a wrong mode)
12/12/02   ar      Added call to dsatesticmif_init_cmif()
12/05/02   ak      On a strcpy, needed a typecast (under MOBILE_IP)
12/02/02   ak      Compiler fixes for Mobile IP under 1X.
11/14/02   jd      Fixed AT$QCMIPNAI hdling, set QCMDR/QCMIP/CRM correctly
                   on startup.
11/11/02   sb      Moved ETSI related NV initialization into dsat_nv_sync()
                   function.
11/08/02   sb      Check to see if command handlers return NO_CARRIER (for 
                   abortable commands) before setting the SIO preprocessor mode
                   to Abortable mode.
11/07/02   ar      Added FEATURE_GSM_GPRS to FEATURE_DATA_WCDMA_PS wrappers
10/28/02   sb      Added Voice SM initialization functions
10/09/02   sb      Fixed Simba R5.0 Merge issues
10/07/02   atp     Fixed compilation bugs in REL_A.
09/24/02   atp     Added support for QOS. (1x Release-A feature).
09/05/02   sb      ATCOP changes based on new Multi mode Data services design
07/13/02   atp     In process_at_cmd_line() added code to check if fmt 
                   response function registered and if so calls it instead
                   of default fmt_response().
07/12/02   ak      Changes to support writing new IPR value into nv.
07/01/02   ak      When CDMA mode, in init, needed 'break' in switch.
06/27/02   ar      Accomodate changed interface to packet data initialization
06/27/02   wx      Drop any incoming AT cmd when ATCOP is processing an
                   Async cmd
06/11/02   wx      Fix a problem of dsatcmdp_queue_cmd_results.  It lost a 
                   dsm item when cmd_results_hold_queue count reaches 
                   MAX_QUEUED_DSM_ITEMS.
04/17/02   rc      Removed FEATURE wrap FEATURE_DS_SOCKETS around dns 
                   functions.
02/21/02   sjd     Changed init service mode parameter to CM system mode type.
08/28/01   sjd     Modifications to support new ATCOP VU structure.
08/10/01   sjd     Initial release to MSM5200 archives.

===========================================================================*/


/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/

#include "comdef.h"
#include "customer.h"

#ifdef FEATURE_DATA
#include "AEEstd.h"
#include "target.h"
#include "err.h"
#include "assert.h"
#include "ds3gmgr.h"
#ifdef FEATURE_DATA_MM
#include "ds3gsiolib.h"
#else
#include "ds3gsioif.h"
#endif /* FEATURE_DATA_MM */
#include "dsati.h"
#include "dstaski.h"
#include "dsatctab.h"
#include "dsatvend.h"
#include "dsatcmif.h"
#include "dsatvoice.h"
#include "msg.h"
#include "sio.h"
#include "sys.h"
#include "nv.h"
#include "dsatme.h"

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
#error code not present
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */

#if defined(FEATURE_WCDMA) && defined(FEATURE_DATA_WCDMA_CS)
#error code not present
#endif /* defined(FEATURE_WCDMA) && defined(FEATURE_DATA_WCDMA_CS) */

#if defined(FEATURE_DATA_IS707)
  #ifdef FEATURE_IS2000_REL_A
    #include "ds707.h"
    #include "dsrlp.h"
  #endif /* FEATURE_IS2000_REL_A */
  #include "dsat707vendctab.h"
  #include "dsat707util.h"
  #ifdef FEATURE_DS_MOBILE_IP
    #include "dsat707mipctab.h"
    #include "dsat707mip.h"
    #include "ds707_so_pkt.h"
  #endif
#endif /* FEATURE_DATA_IS707 */


#ifdef FEATURE_DS_MULTIPLE_PROFILES
#include "ds707_data_session_profile.h"
#endif /* FEATURE_DS_MULTIPLE_PROFILES */

#if defined(FEATURE_CDMA_SMS) || defined(FEATURE_ETSI_SMS)
#include "dsatsms.h"
#endif /* defined(FEATURE_CDMA_SMS) || defined(FEATURE_ETSI_SMS) */



/*===========================================================================

                    REGIONAL DEFINITIONS AND DECLARATIONS

===========================================================================*/

/*---------------------------------------------------------------------------
  Current AT command state.
---------------------------------------------------------------------------*/
dsat_mode_enum_type dsatcmdp_at_state;

/*---------------------------------------------------------------------------
  Flag that indicates whether or not an abortable command is in progress.
---------------------------------------------------------------------------*/
dsati_abort_type dsatcmdp_abortable_state = NOT_ABORTABLE;

/*---------------------------------------------------------------------------
  Flag that indicates whether or not calling the function to send a
  result code to the TE ends the abort handling for that command.
---------------------------------------------------------------------------*/
boolean dsatcmdp_end_abort_in_send_rsp = TRUE;

/*---------------------------------------------------------------------------
  Flag that indicates whether or not indications that are sent to TE
  should be blocked.  Indications are blocked from the point at which an
  AT command line starts being entered to the end of processing the
  command line and also while a data call is active.
---------------------------------------------------------------------------*/
boolean dsatcmdp_block_indications_flag = FALSE;

/*---------------------------------------------------------------------------
    Flag that indicates whether or not ME is operating in restricted
    command mode due to authorization requirement.
---------------------------------------------------------------------------*/
boolean dsatcmdp_restricted_commands = FALSE;

/*---------------------------------------------------------------------------
    Flag that indicates a async cmd is under processing,
    Atcop preprocessor does not process any incoming char when it is TRUE.
---------------------------------------------------------------------------*/
boolean dsatcmdp_processing_async_cmd = FALSE;

/*---------------------------------------------------------------------------
    Flag that indicates ATH cmd is under processing,
    continues to process the AT command line if TRUE.
---------------------------------------------------------------------------*/
boolean dsati_processing_ath_cmd = FALSE;

/*---------------------------------------------------------------------------
  ds_nv_baud_cmd_buf: Give command to NV to change the Baud Rate.
  This buffer is used to send commands to NV for changing the Baud rate.  A
  new buffer has been used instead of using the DS command buffer because
  ds_change_baud function can be called from any task. The existing nv
  command type expects only DS to call it and blocks the DS task. Since, we
  donot want it to happen, a new command buffer has been used.
  Note that this new command buffer is used by Non-Data tasks only.
---------------------------------------------------------------------------*/
nv_cmd_type ds_nv_baud_cmd_buf;

#ifdef FEATURE_DATA_MM
/* Pointer to function defining how responses should be formated. */
extern dsat_fmting_func_type fmt_at_cmd_rsp_func_ptr;
#endif /* FEATURE_DATA_MM */



/*===========================================================================

            LOCAL DEFINITIONS AND DECLARATIONS FOR MODULE

  This section contains local definitions for constants, macros, types,
  variables and other items needed by this module.

===========================================================================*/

/*--------------------------------------------------------------------------
  Debug macro for this module.
---------------------------------------------------------------------------*/
#ifdef DEBUG_DSATCOP
#define DEBUG( x )  { x }
#else
#define DEBUG( x )
#endif /* DEBUG_DSATCOP */

/*--------------------------------------------------------------------------
  Array of pointers to unrecognized command handlers for each AT command
  operating mode supported.
---------------------------------------------------------------------------*/
LOCAL dsati_unrec_cmd_handler_ptr_type
        unrec_cmd_handler[NUM_OPER_CMD_MODES] = { NULL };


/*--------------------------------------------------------------------------
  Pointer to support processing of abortable commands.  Points to command
  table entry of the currently executing abortable AT command.
---------------------------------------------------------------------------*/
const dsati_cmd_type *abort_cmd_table_entry_ptr;

/*--------------------------------------------------------------------------
  AT command processing queue for token structures generated by parser.
---------------------------------------------------------------------------*/
typedef struct    
{
  q_link_type        link;                    /* Link for queue */
  tokens_struct_type token;                   /* Token structure */
} token_q_struct_type;

#define TOKEN_BUF_CNT    40

LOCAL token_q_struct_type token_buf[TOKEN_BUF_CNT];

LOCAL q_type token_q;
LOCAL q_type token_free_q;


/*--------------------------------------------------------------------------
  Queue to hold command responses while processing an AT command line.
  The maximum number of DSM items on the queue is controlled by the
  maximum queued DSM items threshold.  This is used to control DSM
  usage for command line responses, as some responses can be large.
  Note: This threshold may need to be modified to support IS-707 mode
  of operation.
---------------------------------------------------------------------------*/
LOCAL q_type cmd_results_hold_queue;

/* Based on mode this variable will be changed.
   If it is ETSI then we can send it to TE as we are ready to send 
   However in IS707 we need to hold 5 items before we flush 
*/
LOCAL int max_queued_dsm_items;

/*--------------------------------------------------------------------------
  Buffer to hold token command line data for items on token queue and
  pointers to manage buffer.
---------------------------------------------------------------------------*/
#define TOKEN_BUF_SIZE  (2*MAX_LINE_SIZE)

LOCAL byte  token_buffer[TOKEN_BUF_SIZE];
LOCAL byte *token_fill_ptr = token_buffer;
LOCAL byte *token_empty_ptr = token_buffer;


/*-------------------------------------------------------------------------
   Operating mode for selection of different AT command sets from
   command table.
-------------------------------------------------------------------------*/
LOCAL dsati_operating_cmd_mode_type operating_mode;
LOCAL dsati_mode_e_type present_mode;

/*-------------------------------------------------------------------------
   Pointer to the AT command line currently being processed.
-------------------------------------------------------------------------*/
LOCAL byte *at_cmd_line_ptr = NULL;


/*-------------------------------------------------------------------------
   Pointer to formatted response DSM item containing results of commands
   processed on the current AT command line.  It is global to this module
   to support asynchronous command processing, where two calls are made
   to the command line processor to process each asynchronous command in
   the command line.  This pointer points to buffers allocated across
   asynchronous events for asynchronous commands in a command line.
-------------------------------------------------------------------------*/
LOCAL dsm_item_type *formatted_rsp_ptr;


/*-------------------------------------------------------------------------
   Flow control type received by +IFC command.  The ordering of this enum
   is largely dictated by the standard.
-------------------------------------------------------------------------*/       
typedef enum
{
  DS_FCTL_OFF,                             /* Flow control disabled.       */
  DS_XONXOFF_STRIP_FCTL,                   /* Use XON/XOFF flow control 
                                              but strip XON/XOFF characters
                                              from stream.                 */
  DS_CTSRFR_FCTL,                          /* Hardware flow control.       */
  DS_XONXOFF_NSTRIP_FCTL,                  /* Use XON/XOFF flow control 
                                              and leave XON/XOFF characters
                                              in stream.                   */
  DS_MAX_FLOW                              /* For bounds checking only.    */

} flow_ctl_type;                

/* Regional Variable */
/* Pointer to the current abort handler */
extern dsat_call_abort_cb_type dsat_curr_abort_handler;

/*-------------------------------------------------------------------------
            Constants:
-------------------------------------------------------------------------*/

/* ATCOP subtask signals registered with DS task */
#define DSAT_SUBTASK_SIGNALS \
          (DS_AT_MT_MSG_SIG | DS_AT_SMS_SIG )


/*-------------------------------------------------------------------------
    Prototypes for local functions:
-------------------------------------------------------------------------*/

LOCAL void process_at_cmd_line
(
  dsat_mode_enum_type at_state,
  dsat_result_enum_type result_code,
  byte *cmd_line_ptr
);

LOCAL void free_token
(
  token_q_struct_type *token_item_ptr
);

LOCAL void set_flow_control( void );



/*===========================================================================

FUNCTION  DSAT_INIT 

DESCRIPTION
  Initializes ATCOP queues and internal variables, as well as all AT
  parameters to their default values.

DEPENDENCIES
  This function must be called once on data services task startup.

RETURN VALUE
  Signal mask defining REX signals the AT command processor is waiting
  for.

SIDE EFFECTS
  Initializes ATCOP internal variables and queues.

===========================================================================*/
rex_sigs_type dsat_init( void )
{
  int i;

  /*-------------------------------------------------------------------------
    Initialize queue used to hold responses for commands in AT command line.
  -------------------------------------------------------------------------*/
  (void) q_init( &cmd_results_hold_queue );

  /*-------------------------------------------------------------------------
    Initialize queues used for token structures.
  -------------------------------------------------------------------------*/
  (void) q_init( &token_q );
  (void) q_init( &token_free_q );

  /*------------------------------------------------------------------------
    Link the token items onto the token free queue.
  -------------------------------------------------------------------------*/
  for( i = 0; i < TOKEN_BUF_CNT; i++ )
  {
    q_put( &token_free_q,
           q_link( &token_buf[i], &token_buf[ i].link ) );
  }

  /*------------------------------------------------------------------------
    Initialize all internal ATCOP variables.
  -------------------------------------------------------------------------*/
  dsatcmdp_at_state                = DSAT_CMD;
  dsatcmdp_abortable_state = NOT_ABORTABLE;
  dsatcmdp_end_abort_in_send_rsp   = TRUE;
  dsatcmdp_block_indications_flag   = FALSE;
  abort_cmd_table_entry_ptr = NULL;
  max_queued_dsm_items = 1;
  
  for ( i = 0; i < NUM_OPER_CMD_MODES; i++ )
  {
    /* Initialize unrecognized command handler for each mode. */
    unrec_cmd_handler[i] = NULL;
  }

#ifdef FEATURE_DATA_MM
  /*------------------------------------------------------------------------
    Initialize all the registered call handlers to NULL
  -------------------------------------------------------------------------*/
  dsat_init_cb_handlers();
#endif /* FEATURE_DATA_MM */

  /*------------------------------------------------------------------------
    Initialize all AT parameters to their default values.
  -------------------------------------------------------------------------*/
  dsatcmdp_init_config( );

  /*------------------------------------------------------------------------
    Initialize ATCoP/Call Manager interface 
  -------------------------------------------------------------------------*/
  dsatcmif_init_cmif( );
  
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
#error code not present
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */

  /*------------------------------------------------------------------------
    Initialize ATCoP/GSDI interface
  -------------------------------------------------------------------------*/
#if defined (FEATURE_UIM_SUPPORT_3GPD) || defined (FEATURE_MMGSDI)
  dsatme_init_me( );
#endif /* defined (FEATURE_UIM_SUPPORT_3GPD) || defined (FEATURE_MMGSDI) */

  /*------------------------------------------------------------------------
    Initialize ATCoP/PBM interface
  -------------------------------------------------------------------------*/
#if defined(FEATURE_ETSI_PBM) || defined(FEATURE_DSAT_CDMA_PBM)
  dsatme_init_pbm();
#endif /* defined(FEATURE_ETSI_PBM) || defined(FEATURE_DSAT_CDMA_PBM) */

  /*------------------------------------------------------------------------
    Initialize voice call interface
  -------------------------------------------------------------------------*/
  dsatvoice_init( );

#if defined(FEATURE_CDMA_SMS) || defined(FEATURE_ETSI_SMS)
  /*------------------------------------------------------------------------
    Initialize SMS (Initialize and register Call Back functions)
  -------------------------------------------------------------------------*/
  dsatsms_init_sms( );
#endif /* defined(FEATURE_CDMA_SMS) || defined(FEATURE_ETSI_SMS) */
  
  /* wait for ATCOP subtask signals */ 
  return DSAT_SUBTASK_SIGNALS;        

} /* dsat_init( ) */


/*===========================================================================

FUNCTION DSAT_INIT_SERVICE_MODE

DESCRIPTION
  Initializes the AT command processor to new operating mode.  AT
  command processing functions are selected from table based on
  new operating mode.

DEPENDENCIES
  Must be called each time operating service mode changes.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsat_init_service_mode
(
  sys_sys_mode_e_type service_mode   /* Service mode - GSM, WCDMA, CDMA ... */
)
{
  /* Remap service mode to internal AT command processor service mode
     so proper commmand processing tables are used. */
  switch ( service_mode )
  {
#ifdef FEATURE_GSM    
#error code not present
#endif /* FEATURE_GSM */

#ifdef FEATURE_WCDMA    
#error code not present
#endif /* FEATURE_WCDMA */

#ifdef FEATURE_CDMA    
  case SYS_SYS_MODE_CDMA:
    operating_mode = CDMA_CMD_MODE;
    present_mode = DSAT_MODE_CDMA;
    max_queued_dsm_items = 5;

    break;
#endif /* FEATURE_CDMA */

  default:
    ERR_FATAL( "Invalid service mode %d", service_mode, 0, 0 );
    break;
  }

} /* dsat_init_service_mode( ) */


/*===========================================================================

FUNCTION DSAT_PROCESS_CMD_LINE

DESCRIPTION
  This function parses the AT command line, which may contain multiple
  commands, and processes the commands. Command line does not include
  leading "AT" and is NULL terminated.  Command processing is dependent on
  AT mode: command, online data, or online commmand.  

  Command response and command line result codes are generated.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Token queue is emptied.
  Verifies no DSM items are allocated by referencing formatted_rsp_ptr 
  and will free item if one is allocated.
  
===========================================================================*/
void dsat_process_cmd_line
(
  dsat_mode_enum_type at_state,         /* Command, online data, or online
                                           command */
  byte *cmd_line_ptr                    /* Pointer to NULL terminated
                                           command line. */
)
{
  /* If we are in the middle of processing an async commond
     We drop this new line of at cmd */
  if(dsatcmdp_processing_async_cmd)
  {
    return;
  }

  /* Initialize pointer to command line currently being processed. */
  at_cmd_line_ptr = cmd_line_ptr;

  /* Verify the formatted response pointer is NULL.  This should always
     be the case when this function is called, as it is only called to
     process a new command line. */
  if ( formatted_rsp_ptr != NULL )
  {
    ERR( "Async cmd handling error - formatted rsp item allocated!", 0,0,0 );

    (void) dsm_free_buffer( formatted_rsp_ptr );
    formatted_rsp_ptr = NULL;
  }
    
  /* Parse command line */
  if ( dsatpar_parse_cmd_line( cmd_line_ptr ) != DSAT_ERROR )
  {
    /* Process parsed AT commands.  Initial command result code must be
       OK in order for command line to be processed. */
    process_at_cmd_line( at_state, DSAT_OK, cmd_line_ptr );

  }

} /* dsat_process_cmd_line( ) */


/*===========================================================================

FUNCTION PROCESS_AT_CMD_LINE

DESCRIPTION
  This function processes all commands in a command line.  It processes
  token structures generated by the parser for each command in the command
  line.  These token structures are located in a queue.  The AT command
  processor is table driven.  Based on the ME operating mode and information
  contained within the token structure, a linear search is performed to
  find the command in one of the command tables.  When a match is found
  a command processing function is called to process the command.  The
  response generated by the command, if any, and command result code are
  sent to the destination which is typically the TE.

  Note, in order for a new command line to be processed, the initial result
  code passed in must be DSAT_OK.  To continue processing a command line
  after a command requiring asynchronous events is processed, the result
  code should be set to the result code of the command just completed.

DEPENDENCIES
  ME operating mode must be initialized.

RETURN VALUE
  None

SIDE EFFECTS
  Modifies the modem configuration data base.
  May establish the transport layer.
  Uses formatted_rsp_ptr to point to DSM items allocated.
  
===========================================================================*/
LOCAL void process_at_cmd_line
(
  dsat_mode_enum_type at_state,         /* Command, online data, or online
                                           command state */
  dsat_result_enum_type result_code,    /* Initial command result code */
  byte *cmd_line_ptr                    /* Pointer to NULL terminated
                                           command line. */
)
{
  token_q_struct_type *token_ptr;         /* Pointer to current token    */
  dsm_item_type       *raw_rsp_ptr;       /* Raw command results         */
  boolean              dm_go_flag;        /* Go to DM mode if true       */

  /*-------------------------------------------------------------------------
    Initialize the regional AT state variable.
  -------------------------------------------------------------------------*/  
  dsatcmdp_at_state = at_state;

  /*-------------------------------------------------------------------------
    Results of commands are accummulated until the end of the line, 
    until a command is executed which results in an ONLINE status, or
    until an error is discovered.  The result is initially set to OK.

    'result_code' contains the results codes specified in EIA 602 (plus
    some internal codes).

    'raw_rsp_ptr' points to a temporary buffer, which is reinitialized
    on each command.  It contains the raw result codes for the current
    command.

    'formatted_rsp_ptr' points to a watermark item containing the results
    of all the commands on the current line.  It is formatted according
    to the settings of the ATE and ATV parameters.  This pointer is
    global to this module to support asynchronous command processing.
  -------------------------------------------------------------------------*/

  /*-------------------------------------------------------------------------
      Get an item to hold the responses of the commands in this line, if
      a buffer is not already allocated for formatted responses.  Note,
      the only time a buffer will not be allocated is if this function is
      called by the asynchronous event handler.
  -------------------------------------------------------------------------*/
  if ( formatted_rsp_ptr == NULL )
  {
    formatted_rsp_ptr = dsm_new_buffer( DSM_DS_LARGE_ITEM_POOL );
    if ( formatted_rsp_ptr == NULL )
    {
      /* Flush the token queue and return token buffers to free queue */
      dsatcmdp_flush_token_queue( );

      ERR_FATAL( "Out of memory!",0,0,0 );
    }
  }

  /*-------------------------------------------------------------------------
      BEGIN MAIN LOOP: Process all command tokens for commands making up
      command line as long as result code is OK.
  -------------------------------------------------------------------------*/
  while ( ((token_ptr = q_get( &token_q )) != NULL)
          && result_code == DSAT_OK )
  {
    unsigned int             j=0, k=0;       /* Count indices */
    int                      no_match;   /* Indicates if cmd found in tables */
    dsati_at_cmd_table_entry_type *array_ptr;  /* Ptr to array of cmd tables */
    const dsati_cmd_type *table_ptr;           /* Pointer to cmd table entry */

#ifdef FEATURE_DATA_IS707
	/*-----------------------------------------------------------------------
	Changes relating to AT+CDV. Special processing required since its an
	extended command but format is AT+CDV dialstring, this is not handled 
	by the generic parsing routines.
	-----------------------------------------------------------------------*/ 
	unsigned int cmd_len = 4;
	const char small_cdv[5] = "+cdv";
	const char cap_cdv[5] = "+CDV";
	char tmp_name[MAX_LINE_SIZE];
    unsigned int shift_len = 0;

	/* check if first 4 chars. in tmp_name is +cdv */
	if (((strncmp((char *)token_ptr->token.name, small_cdv, cmd_len)) == 0) 
	   || ((strncmp((char *)token_ptr->token.name, cap_cdv, cmd_len)) == 0))
	{
          /* check if argument has been found in the token. If argument
             has not been found, do the following special processing   */
          if((token_ptr->token.op & AR ) == 0)
          {
            /* The processing of CDV command has the following combinations
               1. +CDV=<dial string> - already taken care of in the 
                  process_extended_command. No special processing needed
               2. +CDV <dial string> - needs special processing. 
               3. +CDV<dial string> - needs special processing
             
               If the length of the command including delimiter and argument
               exceeds the MAX_LINE_SIZE, just shift only the characters that
               would fit in the MAX_LINE_SIZE. Ignore the rest of the string */

            shift_len = strlen((char *)(token_ptr->token.name+cmd_len+1))+1;
            if((shift_len+cmd_len) > MAX_LINE_SIZE )
              shift_len = MAX_LINE_SIZE - cmd_len -1;
      
            (void)std_strlcpy(tmp_name, 
                        (char *)(token_ptr->token.name+cmd_len), 
                        shift_len+1);
            tmp_name[shift_len] = '\0';

            *(token_ptr->token.name+cmd_len) = '\0';
            (void)std_strlcpy ((char *)(token_ptr->token.name+cmd_len+1), 
                         tmp_name, 
                         shift_len+1);
            token_ptr->token.op |=  EQ | AR;
            token_ptr->token.args_found = 1;
            token_ptr->token.arg[0] = token_ptr->token.name+cmd_len+1;
          }
        }  
            
#endif /* FEATURE_DATA_IS707 */
	
	/*-----------------------------------------------------------------------
      Get a buffer for response to command that is about to be processed.
      If no buffers available, flush token queue and return.
    ------------------------------------------------------------------------*/
    raw_rsp_ptr = dsm_new_buffer( DSM_DS_LARGE_ITEM_POOL );
    if ( raw_rsp_ptr == NULL )
    {
       ERR( "Running out of items",0,0,0 );

       /* Free the formatted response buffer */
       (void) dsm_free_buffer( formatted_rsp_ptr );
       formatted_rsp_ptr = NULL;

       /* Free current token and flush any remaining tokens on queue */
       free_token( token_ptr );
       dsatcmdp_flush_token_queue( );

       /* Clear flag to indicate indications are no longer blocked. */
       dsatcmdp_block_indications_flag = FALSE;

       return;
    }
    raw_rsp_ptr->data_ptr[0] = '\0';

    /*-----------------------------------------------------------------------
      Search command tables for command.
    ------------------------------------------------------------------------*/

    /* Get a pointer to array of command table entries for current
       command category and operating mode from command table. */
    ASSERT( token_ptr->token.cmd_category < NUM_AT_CMD_CATEGORIES &&
            operating_mode < NUM_OPER_CMD_MODES );
    array_ptr = at_cmd_table[token_ptr->token.cmd_category][operating_mode];  

    /* Initialize to no command match found in command tables. */
    no_match = 1;

    /* Check if an array of command tables pointers exist for this
       command category and operating mode. */
    if ( array_ptr != NULL )
    {
      /* An array of command table entries exists for this element of
         the table. Now look for command tables within the array and
         search the command table pointed to by each array entry for
         a match to command identified within the token structure.*/

      /* Search each command table entry pointed to by array entry. */
      for ( j = 0, k = 0; array_ptr[j].table_ptr != NULL && no_match; j++ )
      {
        /* Search each command table entry for command match. */
        for ( k = 0; k < *(array_ptr[j].table_size) && no_match; k++ )
        {
          no_match =
            dsatutil_strcmp_ig_sp_case( token_ptr->token.name,
                                        array_ptr[j].table_ptr[k].name );
        }
      }
    }

    /* Check if the command was found in the tables. */
    if ( !no_match )
    {
      /* Command was found in the tables, so process command if function
         pointer not NULL, otherwise just return OK result code. */

      /* Lint complains about j, k, and array_ptr possibly not being
         initialized.  This cannot occur, since no_match can only be
         set to zero if j, k, and array_ptr are initialized. */
      table_ptr = &(array_ptr[j-1].table_ptr[k-1]);   /*lint !e613 !e644 */
      DEBUG( 
             MSG_LOW( "Processing AT Command:\n", 0, 0, 0 );
             MSG_LOW( "  name = %c%c%c\n", token_ptr->token.name[0],
                      token_ptr->token.name[1], token_ptr->token.name[2]);
             MSG_LOW( "%c%c%c\n", token_ptr->token.name[3],
                      token_ptr->token.name[4], token_ptr->token.name[5]);
             MSG_LOW( "  op = 0x%x\n", token_ptr->token.op, 0, 0 );
           );

      DEBUG( unsigned int i;
             for ( i = 0; i < token_ptr->token.args_found; i++ )
             {
               MSG_LOW( "  arg[%d] = %c%c\n", i, 
                      token_ptr->token.arg[i][0], token_ptr->token.arg[i][1]);
               MSG_LOW( "%c%c%c\n", token_ptr->token.arg[i][2], 
                      token_ptr->token.arg[i][3], token_ptr->token.arg[i][4]);
             }
           );

      DEBUG( unsigned int i;
             for ( i = 0; i < token_ptr->token.args_found; i++ )
             {
               MSG_LOW( "  arg[%d] = %c%c\n", i, 
                      token_ptr->token.arg[i][0], token_ptr->token.arg[i][1]);
               MSG_LOW( "%c%c%c\n", token_ptr->token.arg[i][2], 
                      token_ptr->token.arg[i][3], token_ptr->token.arg[i][4]);
             }
           );
      
      /* Check to see if ME in restricted command mode */
      if (!dsatcmdp_restricted_commands ||
          (dsatcmdp_restricted_commands && (table_ptr->attrib & RESTRICTED)))
      {
           
        /* Check if command is abortable and set flag if it is. Also,
           since this is the start of command processing for a new command,
           set flag to insure command abort processing will be ended
           if send response function is called (default behavior). */
        if ( table_ptr->abort_func != NULL )
        {
          dsatcmdp_abortable_state = ABORTABLE;
        }
        dsatcmdp_end_abort_in_send_rsp = TRUE;
      
        /* Process command if processing function pointer not NULL. */
        if ( table_ptr->proc_func != NULL )
        {
          result_code = table_ptr->proc_func( at_state,
                                              table_ptr,
                                              &(token_ptr->token),
                                              raw_rsp_ptr );
        }

        /* Check if abortable command flag is still set after initial
           command processing has completed. */
        if ( dsatcmdp_abortable_state != NOT_ABORTABLE )
        {
          /* Abort command processing still active. */
          if ( result_code == DSAT_ERROR || 
               result_code == DSAT_CMD_ERR_RSP || 
               result_code == DSAT_OK ||
               result_code == DSAT_NO_CARRIER )
          {
            /* A command processing error occurred, so terminate the abort
               processing for command. */
            dsatcmdp_abortable_state = NOT_ABORTABLE;
          }
          else
          {
            /* Command is abortable and no error occurred so save pointer
               to command table entry and set SIO preprocessor mode to
               abort command mode. */
            abort_cmd_table_entry_ptr = table_ptr;
            dsatprep_set_preprocessor_mode( DSATI_ABORT_CMD_MODE );
          }
        }
      }
      else
      {
        /* Restricted command mode in effect but command not tagged with 
           RESTRICTED attribute */
        MSG_MED("%s not allowed in restricted command mode",
                table_ptr->name,0,0);
        result_code = DSAT_ERROR;
      }
    }
    else if ( unrec_cmd_handler[operating_mode] != NULL )
    {
		/* Unrecognized command and an unrecognized command handler is
		registered for the command mode, so call the handler. */
		result_code = unrec_cmd_handler[operating_mode]( cmd_line_ptr );
	}
    else
    {
      /* Unrecognized command and no unrecognized command handler is
         registered, so return error result code. */
      result_code = DSAT_ERROR;
    }

    /*-----------------------------------------------------------------------
      Finally, if 'result_code' is OK or command specific error response,
      and raw responses exist, format the response for this command.  

    ------------------------------------------------------------------------*/
    if ( raw_rsp_ptr->data_ptr[0] != '\0' &&
         (result_code == DSAT_OK || result_code == DSAT_CMD_ERR_RSP) )
    {
      /* Format the raw data response */
#ifdef FEATURE_DATA_MM
      if (   ( fmt_at_cmd_rsp_func_ptr != NULL )
          && ( at_state == DSAT_ONLINE_DATA    ) )
      {
        /*-------------------------------------------------------------------
          If mode-specific handler has registered a function to format
          responses, it should be invoked when in ONLINE DATA mode. This
          is needed for IS-707 async reflected AT cmds which need to format
          responses with 617 codes.
        -------------------------------------------------------------------*/
        fmt_at_cmd_rsp_func_ptr (
                                  &raw_rsp_ptr,
                                  DSAT_COMPLETE_RSP,
                                  FALSE,
                                  &formatted_rsp_ptr,
                                  result_code
                                );
      }
      else
#endif /* FEATURE_DATA_MM */
      {
        dsat_fmt_response( &raw_rsp_ptr, DSAT_COMPLETE_RSP, FALSE,
                           &formatted_rsp_ptr );
      }

      /* Verify we did not run out of buffers */
      if ( formatted_rsp_ptr == NULL )
      {
        ERR_FATAL( "Running out of buffers",0,0,0 );
      }
    }

    /* Free the response buffer */
    (void) dsm_free_buffer( raw_rsp_ptr );

    /* Place the processed token buffer back on the free queue. */
    free_token( token_ptr );

    /*-----------------------------------------------------------------------
      If this is a command that needs to be handled with asynchronous events
      or delayed result code (from DSMGR) , exit this function with the 
      formatted data item allocated so it can be used by the asynchronous 
      event handler or after we receive the delayed result code. This function
      will later be called by the asynchronous event handler or 
      dsat_finished_ath_cmd() when the command processing has been completed.  
      The remaining commands in the command line (token buffers) will then be 
      processed.
    ------------------------------------------------------------------------*/  
    if ( result_code == DSAT_ASYNC_CMD )
    {
      /* Asynchronous events are required to complete processing of
         this command so exit this function. */ 
      dsatcmdp_processing_async_cmd = TRUE;
      return;
    }
    else if ( result_code == DSAT_ATH_CMD )
    {
      /* DSMGR has to tell us when the call has dropped. 
         Need to come back to command line after that */
      dsati_processing_ath_cmd = TRUE;
      return;
    }

  } /*  end MAIN LOOP: token_ptr = q_get ... */


  /*-------------------------------------------------------------------------
    Make sure the token is freed for the case when the main loop was exited
    with result code not equal to DSAT_OK and token pointer not equal
    to NULL.
  -------------------------------------------------------------------------*/
  free_token( token_ptr );

  /*-------------------------------------------------------------------------
    Insure the token queue is empty and all token buffers have been
    placed on the free queue.
  -------------------------------------------------------------------------*/
  dsatcmdp_flush_token_queue( );

  /*-------------------------------------------------------------------------
    Update SIO to reflect the latest flow control and DCD settings.  If
    these parameters were not updated, these calls are benign.
  -------------------------------------------------------------------------*/
  set_flow_control( );
#ifdef FEATURE_DATA_MM 
  (void) ds3g_siolib_set_cd_state( DS3G_SIOLIB_EVENT_NONE );
#else
  (void) ds3g_sio_set_cd_state( DS3G_SIO_EVENT_NONE );
#endif /* FEATURE_DATA_MM */

  /*-------------------------------------------------------------------------
    Check for change to DM mode: if true set up to change mode after
    result (OK) is returned; else continue.
  -------------------------------------------------------------------------*/
  if ( result_code == DSAT_DO_DM )
  {
    dm_go_flag = TRUE;
    result_code = DSAT_OK;
  }
  else
  {
    dm_go_flag = FALSE;
  }

  /*-------------------------------------------------------------------------
    All commands in command line have been processed.  Format the final
    response and output it.
  -------------------------------------------------------------------------*/

  /* Generate a final result code if the result code does not indicate 
     no response or a command specific error should be sent. */
  if ( result_code != DSAT_NO_RSP && result_code != DSAT_CMD_ERR_RSP )
  {
    dsatrsp_fmt_result_code( result_code, &formatted_rsp_ptr );
    if ( formatted_rsp_ptr == NULL )
    {
      ERR_FATAL( "Running out of buffers",0,0,0 );
    }
  }

  /* Flush the queue to the Rm interface. */
  dsatcmdp_send_queued_cmd_results( );

  /* Check the formatted response data item. If it is not empty, send it
     to the Rm interface. */
  if ( formatted_rsp_ptr->used != 0 )
  {
	dsatrsp_send_response( formatted_rsp_ptr, (boolean) !dm_go_flag );
  }
  else
  {
    (void) dsm_free_buffer( formatted_rsp_ptr );
  }
  
  /* Clear flag to indicate indications are no longer blocked if result
     code does not state no response should be sent.  A result code of
     no response, indicates command processing has not completed. Also,
     flush any pending received SMS indications. */
  if ( result_code != DSAT_NO_RSP )
  {
    dsatcmdp_block_indications_flag = FALSE;

    if (at_state == DSAT_CMD)
    {
#ifdef FEATURE_ETSI_SMS    
#error code not present
#endif /* FEATURE_ETSI_SMS */
      
#ifdef FEATURE_DSAT_KEYPAD_EMULATION
      (void)dsat_flush_me_msg_queue( );
#endif /* FEATURE_DSAT_KEYPAD_EMULATION */
    }
  }
  
  formatted_rsp_ptr = NULL;

} /* process_at_cmd_line( ) */


/*===========================================================================

FUNCTION DSATCMDP_REG_UNREC_CMD_HANDLER

DESCRIPTION
  This function registers a handler that is called when an unrecognized
  AT command is received.  The handler is registered for the AT command
  operating mode specified.  If no handler is registered for a command
  operating mode, an error result code is returned by default when an
  unrecognized command is encountered.

  This functionality is intended to provide support for IS-707 unrecognized
  command handling.

  The handler may be deregistered for the AT command mode specified by
  passing in a NULL pointer.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void dsatcmdp_reg_unrec_cmd_handler
(
  dsati_unrec_cmd_handler_ptr_type func_ptr,    /* Pointer to mode specific
                                                   unrecognized command
                                                   handler */
  dsati_operating_cmd_mode_type oper_mode       /* AT command set operating
                                                   mode */
)
{
  /* Verify command operating mode is valid and then initialize pointer
     to handler. */
  ASSERT( oper_mode < NUM_OPER_CMD_MODES );

  /* Assures lint we won't access array out of bounds. */
  if ( oper_mode < NUM_OPER_CMD_MODES )
  { 
    unrec_cmd_handler[oper_mode] = func_ptr;
  }

} /* dsatcmdp_reg_unrec_cmd_handler( ) */


/*===========================================================================

FUNCTION DSATCMDP_QUEUE_TOKEN

DESCRIPTION
  Queues token structure generated by parser on token queue.  A token
  structure is generated by each command parsed by the AT command parser.

DEPENDENCIES
  Token queues must have been initialized.

RETURN VALUE
  DSAT_OK if token structure was successfully queued.  DSAT_ERROR
  if no buffers are available for token structure and it could not be
  placed on queue.

SIDE EFFECTS
  None

===========================================================================*/
dsat_result_enum_type dsatcmdp_queue_token
(
  tokens_struct_type *token_ptr       /* Pointer to token structure */
)
{
  token_q_struct_type *buf_ptr;       /* Token buffer pointer */
  byte                *src_ptr;       /* Source data pointer */
  unsigned int         i;             /* Counter index */

  /*----------------------------------------------------------------------
    Get a token buffer from the free queue.  Call error routine if no
    buffers are available, otherwise copy input token to buffer and
    place on token queue.
  -----------------------------------------------------------------------*/
  if ( (buf_ptr = (token_q_struct_type *) q_get( &token_free_q ) ) != NULL )
  {
    /* Copy token data to new token item obtained from free queue. */
    buf_ptr->token.working_at_line = token_fill_ptr;
    buf_ptr->token.name = token_fill_ptr +
      (token_ptr->name - token_ptr->working_at_line);
    buf_ptr->token.op = token_ptr->op; 

    for ( i = 0; i < token_ptr->args_found; i++ )
    {
      buf_ptr->token.arg[i] = token_fill_ptr +
        (token_ptr->arg[i] - token_ptr->working_at_line);
    }
    buf_ptr->token.args_found = token_ptr->args_found;

    /* Copy token command line data to buffer. */
    src_ptr = token_ptr->working_at_line;
    while ( src_ptr <= token_ptr->end_of_line )
    {
      ASSERT( token_fill_ptr < &token_buffer[TOKEN_BUF_SIZE] );
      *token_fill_ptr++ = *src_ptr++;
    }

    buf_ptr->token.end_of_line = token_fill_ptr - 1;
    buf_ptr->token.cmd_category = token_ptr->cmd_category;

    /* Queue the token. */
    q_put( &token_q, &buf_ptr->link );

    return( DSAT_OK );
  }
  else 
  {
    /* Command line is too long */
    ERR( "Data task AT token free buffer empty.", 0, 0, 0 );

    return( DSAT_ERROR );
  }

} /* dsatcmdp_queue_token( ) */


/*===========================================================================

FUNCTION FREE_TOKEN

DESCRIPTION
  Frees token item placing it back on token free queue.  If token item
  pointer is NULL, function just returns without performing any operation.

DEPENDENCIES
  Token queues must have been initialized.  Assumes a complete command
  line of tokens are first placed on queue and then all are removed
  before any new token items are added.

RETURN VALUE
  None

SIDE EFFECTS
  Updates pointers to token storage buffer.

===========================================================================*/
LOCAL void free_token
(
  token_q_struct_type *token_item_ptr    /* Pointer to token queue item */
)
{
  /* Check for NULL pointer and just return if NULL. */
  if ( token_item_ptr == NULL )
  {
    return;
  }

  /* Update token buffer pointers. */
  token_empty_ptr = token_item_ptr->token.end_of_line + 1;
  ASSERT( token_empty_ptr >= token_buffer &&
          token_empty_ptr < &token_buffer[TOKEN_BUF_SIZE] );
  if ( token_empty_ptr == token_fill_ptr )
  {
    /* All token items have been removed from queue, so update pointers
       to point to beginning of buffer. */
    token_empty_ptr = token_fill_ptr = token_buffer;
  }

  /* Place token back on token free queue. */
  q_put( &token_free_q, &token_item_ptr->link );

} /* free_token( ) */


/*===========================================================================

FUNCTION DSATCMDP_FLUSH_TOKEN_QUEUE

DESCRIPTION
  Flushes token queue.  Any token structures in queue are removed and
  placed back on the token free queue.

DEPENDENCIES
  Token queues must be initialized.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_flush_token_queue( void )
{
  token_q_struct_type *token_ptr;

  /* Flush the token queue and return token buffers to free queue */
  while ( (token_ptr = (token_q_struct_type *) q_get( &token_q )) != NULL )
  {
    free_token( token_ptr );
  }

} /* dsatcmdp_flush_token_queue( ) */


/*===========================================================================

FUNCTION DSATCMDP_QUEUE_CMD_RESULTS

DESCRIPTION
  This function places the results of AT commands in a queue,
  so they can be output (or discarded) at the end of the command
  line. It will output the contents of the queue if more than a
  defined number of DSM items are on the queue.  This is done
  to control DSM usage, as some responses can be large.

  Note: The queue count threshold may require adjustment for IS-707
  mode of operation, to insure the entire command line response
  can be buffered.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_queue_cmd_results
(
  dsm_item_type *item_ptr       /* Pointer to command results to queue */
)
{
  if ( item_ptr != NULL )
  {
    if ( item_ptr->used > 0 )
    {
      /* This code controls the maximum number of DSM items needed by
         ATCOP. It only allows a certain number of DSM items to be
         queued up for a response and flushes the queue to the TE if
         this count is exceeded. In ETSI mode we don't have to queue 
         them.  We can flush them as and when we are ready to send. */
      if ( q_cnt( &cmd_results_hold_queue ) >= max_queued_dsm_items )
      {
        /* Flush the queue to the TE since the maximum queued DSM item
           count has been reached. */
        dsatcmdp_send_queued_cmd_results( );
      }

      /*  Place the DSM item on the queue. */
      q_put( &cmd_results_hold_queue, &(item_ptr->link) );
    }
    else
    {
      (void) dsm_free_buffer( item_ptr );
    }    
  }
} /* dsatcmdp_queue_cmd_results( ) */


/*===========================================================================

FUNCTION DSATCMDP_SEND_QUEUED_CMD_RESULTS

DESCRIPTION
  This functions flushes the results queue to the serial port or PS
  protocol stack based on the registered response routing function.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_send_queued_cmd_results( void )
{
  dsm_item_type *dq_item_ptr;

  while ( (dq_item_ptr = (dsm_item_type *)q_get(&cmd_results_hold_queue))
          != NULL )
  {
    ASSERT( dq_item_ptr->used > 0 );   

    dsatrsp_send_response( dq_item_ptr, FALSE );
  }
  
} /* dsatcmdp_send_queued_cmd_results( ) */


/*===========================================================================

FUNCTION DSATCMDP_DISCARD_QUEUED_CMD_RESULTS

DESCRIPTION
  This functions discards any queued up AT command results.  Required
  for IS-707 unrecognized command processing.

DEPENDENCIES
  AT command processor must have been initialized prior to calling
  this function.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_discard_queued_cmd_results( void )
{
  dsm_item_type *dq_item_ptr;

  while ( (dq_item_ptr = (dsm_item_type *)q_get(&cmd_results_hold_queue))
          != NULL )
  {
    (void) dsm_free_buffer( dq_item_ptr );
  }

} /* dsatcmdp_discard_queued_cmd_results( ) */


/*===========================================================================

FUNCTION DSATCMDP_HANDLE_ASYNC_CMD_RSP

DESCRIPTION
  Handles the raw unformatted AT command response generated by an
  asynchronous command handler function.  Formats the raw response
  contained in possibly chained DSM items and queues it up for
  transmission or sends it immediately.  The DSM item pointed to by
  the raw response buffer is freed.

  The response is formatted based on the input parameter "type of
  response".  This specifies whether the response contained in the
  DSM item is the start, end, complete, or intermediate response and
  in turn if a header, trailer, header and trailer, or no header and
  trailer should be added to the response, respectively.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Uses DSM item pointed to by formatted_rsp_ptr.

===========================================================================*/
void dsatcmdp_handle_async_cmd_rsp
(
  dsm_item_type *raw_rsp_ptr,   /* Ptr to raw unformatted AT cmd response */
  dsat_rsp_enum_type type_of_rsp   /* Type of response data in DSM item   */
)
{

  ASSERT( raw_rsp_ptr != NULL );

  /* Verify the formatted response pointer is not NULL.  A DSM item
     should always be allocated when this function is called, since an
     asynchronous command is being processed when this function is
     called. */
  if ( formatted_rsp_ptr == NULL )
  {
    ERR( "Async cmd handling error - formatted rsp item not allocated!",0,0,0 );
    
    formatted_rsp_ptr = dsm_new_buffer( DSM_DS_LARGE_ITEM_POOL );
    if ( formatted_rsp_ptr == NULL )
    {
      ERR_FATAL( "Out of memory!", 0, 0, 0 );
    }
  }
  
  /* Format the raw data response */
  dsat_fmt_response( &raw_rsp_ptr, type_of_rsp, FALSE, &formatted_rsp_ptr );

  /* Verify we did not run out of buffers */
  if ( formatted_rsp_ptr == NULL )
  {
    ERR_FATAL( "Running out of buffers!", 0, 0, 0 );
  }

} /* dsatcmdp_handle_async_cmd_rsp( ) */


/*===========================================================================

FUNCTION DSAT_PROCESS_ASYNC_CMD

DESCRIPTION
  Asynchronous ATCOP command handler.  Processes asynchronous ATCOP commands
  received by data services task dispatcher.  Function looks up commands in
  mode specific command table.  Command processing function corresponding to
  current command and operating mode is called from table. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsat_process_async_cmd
(
  ds_cmd_type *cmd_ptr          /* Pointer to command */
)
{
  dsati_async_event_handler_type event_handler_func_ptr = NULL;
  dsat_result_enum_type result_code;
  int i;

  ASSERT( operating_mode < NUM_OPER_CMD_MODES );

  /* Search for event match in asynchronous event table. */
  for ( i = 0; i < DSATI_NUM_ASYNC_EVENTS; i++ )
  {
    if ( async_event_table[i].event == cmd_ptr->hdr.cmd_id )
    {
      /* An event match was found in table. */
      event_handler_func_ptr =
        async_event_table[i].event_handler[operating_mode];
      break;
    }
  }

  /* Call the asynchronous event handler if a valid handler exists. */
  if ( event_handler_func_ptr != NULL )
  {
    result_code = event_handler_func_ptr( dsatcmdp_at_state, cmd_ptr );
  }
  else
  {
    MSG_HIGH( "Unexpected ATCoP asynchronous event %d received!",
         cmd_ptr->hdr.cmd_id, 0, 0 );
    result_code = DSAT_ASYNC_EVENT;
  }

  /* Complete processing of AT command line if this is the last
     asynchronous event associated with the current AT command (processing
     of command is complete) and this is not an asynchronous event that is
     not associated with a command. */
  if ( result_code != DSAT_ASYNC_CMD && result_code != DSAT_ASYNC_EVENT )
  {
    /* No more asynchronous events for this command, so first insure
       processing associated with an abortable asynchronous command is
       no longer active and then continue processing the remaining
       commands in command line.
       If the result code is DSAT_NO_RSP, the abortable state is still on.
       The abortability of the command ends when the subsystem call
       dsat_send_result_code to finally end the comand.
    */
    if (result_code != DSAT_NO_RSP)
    {
      dsatcmdp_command_abort_complete( );
    }
    dsatcmdp_processing_async_cmd = FALSE;
    process_at_cmd_line( dsatcmdp_at_state, result_code, at_cmd_line_ptr );
  }
} /* dsat_process_async_cmd( ) */


/*===========================================================================

FUNCTION DSAT_PROCESS_ASYNC_SIGNAL

DESCRIPTION
  Asynchronous ATCOP REX signal handler.  Processes asynchronous ATCOP
  signals received by data services task dispatcher.  Function looks up
  signals in mode specific signal table.  Signal processing function
  corresponding to current signal and operating mode is called from table. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsat_process_async_signal
(
  rex_sigs_type set_sigs            /* ATCOP signals that are set */
)
{
  dsat_result_enum_type result_code = DSAT_ASYNC_EVENT;
  rex_sigs_type         sigs_remaining = set_sigs;

  if( (set_sigs & DS_AT_MT_MSG_SIG) ||
      (set_sigs & DS_AT_SMS_SIG) )
  {  
    (void)rex_clr_sigs( &ds_tcb, DS_AT_SMS_SIG | DS_AT_MT_MSG_SIG );

#if defined(FEATURE_CDMA_SMS) || defined(FEATURE_ETSI_SMS)
    /* 
       Signal handler will attempt to process all items in both MT message 
       watermark dsat_mt_msg_wm and SMS watermark dsat_sms_wm. It will
       return before all items are processed if an event handler result
       other than DSAT_ASYNC_CMD or DSAT_ASYNC_EVENT is encountered 
    */
    result_code = dsatsms_signal_handler(dsatcmdp_at_state);
#endif /* defined(FEATURE_CDMA_SMS) || defined(FEATURE_ETSI_SMS) */

    sigs_remaining &= ~(DS_AT_SMS_SIG | DS_AT_MT_MSG_SIG);
  }

  /* 
     If any signals remain unprocessed set off another round of processing:
     this needed as multiple signals can be received but not all of them 
     processed if they would overwrite a significant result code, and WM's 
     callback called on enqueue will only get called on the transition from 
     empty to non-empty. 
  */
  if ( sigs_remaining & DSAT_SUBTASK_SIGNALS )
  {
    (void)rex_set_sigs( &ds_tcb, sigs_remaining );
  }
  /* This check is to filter the race condition between abort handler 
     and async cmd processing. The first result will send the response to 
     the terminal and clears the dsatcmdp_processing_cmd and 
     ds3g_siolib_active_port. This completes the AT command processing and 
     the second response is filtered here.
  */
  if ( (!dsatcmdp_processing_async_cmd ) && 
       ( result_code != DSAT_ASYNC_CMD && result_code != DSAT_ASYNC_EVENT ) )
  {
    if( formatted_rsp_ptr != NULL )
    {
      (void) dsm_free_buffer( formatted_rsp_ptr );
      formatted_rsp_ptr = NULL;
    }
    MSG_HIGH( "Unexpected ATCoP asynchronous signal received!", 0, 0, 0 );
    result_code = DSAT_ASYNC_EVENT;
  }
  /* 
     Complete processing of AT command line if this is the last
     asynchronous event associated with the current AT command (processing
     of command is complete) and this is not an asynchronous event that is
     not associated with a command. 
  */
  if ( result_code != DSAT_ASYNC_CMD && result_code != DSAT_ASYNC_EVENT )
  {
    /* 
       No more asynchronous events for this command, so first insure
       processing associated with an abortable asynchronous command is
       no longer active and then continue processing the remaining
       commands in command line.
       If the result code is DSAT_NO_RSP, the abortable state is still on.
       The abortability of the command ends when the subsystem call
       dsat_send_result_code to finally end the comand.
    */
    if ( result_code != DSAT_NO_RSP )
    {
      dsatcmdp_command_abort_complete( );
    }

    dsatcmdp_processing_async_cmd = FALSE;
    process_at_cmd_line( dsatcmdp_at_state, result_code, at_cmd_line_ptr );
  }

} /* dsat_process_async_signal( ) */


/*===========================================================================

FUNCTION DSATCMDP_ABORT_COMMAND

DESCRIPTION
  Calls abort command handler located in command table to abort the
  abortable AT command currently being processed.  This function
  may be called multiple times during the command abort process,
  although only the first call to this function during a particular
  command's abort sequence will invoke the command abort handler.

DEPENDENCIES
  None

RETURN VALUE
  Value indicating whether or not call should be aborted:
      TRUE if call should be aborted, FALSE otherwise.

SIDE EFFECTS
  May set abortable command table entry pointer to NULL.

===========================================================================*/
boolean dsatcmdp_abort_command( void )
{
  boolean abort_call;
  
  /* Call the abort function to abort the command currently in
     progress, if the abort command handler has not already been
     called once to abort the current command. */
  if ( abort_cmd_table_entry_ptr != NULL )
  {
    /* Verify abort handler pointer is valid.  Pointer should never be
       NULL when this function is called to abort a command. */
    ASSERT( abort_cmd_table_entry_ptr->abort_func != NULL );

    /* Call the abort command handler and then set pointer to NULL to
       indicate the handler has been called. */
    abort_call =
      abort_cmd_table_entry_ptr->abort_func( abort_cmd_table_entry_ptr );
    abort_cmd_table_entry_ptr = NULL;
  }
  else
  {
    /* Always return FALSE to indicate call should not be aborted when
       this is not the first call to this function during a command
       abort. */
    abort_call = FALSE;
  }

  return abort_call;

} /* dsatcmdp_abort_command( ) */


/*===========================================================================

FUNCTION DSATCMDP_COMMAND_ABORT_COMPLETE

DESCRIPTION
  Clears flag used during abort command processing and places SIO
  preprocessor in AT command mode.  Must be called when command abort
  processing has been completed, even if the command was not sucessfully
  aborted.  

DEPENDENCIES
  Should only be called when the process of aborting a command has
  completed, and must be called even if command was not aborted
  successfully.

RETURN VALUE
  None

SIDE EFFECTS
  Clears abort command flag and sets SIO preprocessor to AT command
  mode.

===========================================================================*/
void dsatcmdp_command_abort_complete( void )
{
  /* Clear flag and set SIO preprocessor mode to AT command mode if
     command abort processing is in progress. */
  if ( dsatcmdp_abortable_state != NOT_ABORTABLE )
  {
    dsatcmdp_abortable_state = NOT_ABORTABLE;
    dsatprep_set_preprocessor_mode( DSATI_AT_CMD_MODE );
#ifdef FEATURE_DATA_MM
    if ( dsat_curr_abort_handler )
    {
      dsat_curr_abort_handler = NULL;
    }
#endif /* FEATURE_DATA_MM */
  }
  
} /* dsatcmdp_command_abort_complete( ) */
     

/*===========================================================================

FUNCTION DSATCMDP_DISABLE_CMD_ABORT_COMPLETE

DESCRIPTION
  Disables termination of abort command handling of current command
  being processed when call to function to send result code is made.
  By default, calls to function to send result code will end the abort
  handling of an abortable command in progress.

  Should be called by ATCoP command execution function requiring this
  behavior for abortable commands.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Clears end abort in send response flag.

===========================================================================*/
void dsatcmdp_disable_cmd_abort_complete( void )
{
  /* Clear flag so call to send result code does not end the abort
     command handling for the command currently being processed. */
  dsatcmdp_end_abort_in_send_rsp = FALSE;
  
} /* dsatcmdp_disable_cmd_abort_complete( ) */
     

/*===========================================================================

FUNCTION DSAT_NV_SYNC

DESCRIPTION
  This function initializes from NV the AT parameter defaults for those
  stored in NV.  (If the NV item is uninitialized, it first writes the
  current, statically initialized AT parameter default to NV.)

  This should be called in at least the following two situtations:

  1) From dsatcmdp_init_config() (e.g. at boot time, ATZ, AT&F)
  2) Whenever any NV-based parameter is changed

DEPENDENCIES
  All NV-based AT parameter defaults must also have been statically
  initialized to proper values.  The statically-initialized values will be
  written to NV if the NV items are found to be uninitialized.

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsat_nv_sync( void )
{
  /*-------------------------------------------------------------------------
    Initialize hardware specific items 
  -------------------------------------------------------------------------*/
  dsatctab_data_init( );

  /*-------------------------------------------------------------------------
    Initialize the Primary and the Secondary DNS from the NV.
  -------------------------------------------------------------------------*/
  dsatvend_init_dns_from_nv( );

#ifdef FEATURE_DS_SOCKETS_TEST_UDP
#error code not present
#endif /* FEATURE_DS_SOCKETS_TEST_UDP */

#ifdef FEATURE_DATA_IS707
  dsat707_nv_sync();
#endif
} /* dsat_nv_sync( ) */


/*===========================================================================

FUNCTION INIT_PARSE_TABLE

DESCRIPTION
  This function initializes the parameters in a specific parse table
  to their default values.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void init_parse_table
(
  const dsati_cmd_type *parse_table,    /*  Pointer to parse table  */
  unsigned int table_size               /*  Size of parse table       */
)
{
    uint32 i, j;
    uint32 range_offset;
#ifdef FEATURE_IS2000_REL_A
  byte temp_qos_pri = 0;
#endif /* FEATURE_IS2000_REL_A */

  for ( i = 0; i < table_size; ++i )
  {
    /*--------------------------------------------------------------------
      A Table entry flagged CONFIG must have a value allocated
    --------------------------------------------------------------------*/
    if ( (parse_table[i].attrib & CONFIG) && parse_table[i].val_ptr == NULL )
    {
      ERR_FATAL( "PARSE TABLE %s, %d\n", parse_table[i].name, i, 0 );
    }
    else
    {
      if ( (parse_table[i].attrib & (CONFIG | LIST | STRING | MIXED_PARAM | 
                                     NO_RESET)) ==
           CONFIG )
      {
        /*---------------------------------------------------------------------
            If the entry is numeric, use the value in the default entry
          ---------------------------------------------------------------------*/
        range_offset = 0;
        for ( j = 0; j < parse_table[i].compound; ++j )
        {
          *((dsat_num_item_type *)parse_table[i].val_ptr + j)
            = ((dflm_type *)parse_table[i].
               def_lim_ptr)[j + range_offset].default_v;

          /* For BROKEN_RANGE, advance to next range segment */
          if (0 != (parse_table[i].attrib & BROKEN_RANGE))
          {
            while (MAX_BROKEN_RANGE !=
                   ((dflm_type *)parse_table[i].
                    def_lim_ptr)[j + range_offset].default_v)
            {
              range_offset++;
            }
          }
        }
      }
      else if ( (parse_table[i].attrib &
                 (CONFIG | LIST | STRING | MIXED_PARAM | 
                  NO_RESET)) == (CONFIG | LIST) )
      {
          /*---------------------------------------------------------------------
            If the entry is list, use the value in the default entry
          ---------------------------------------------------------------------*/
        for ( j = 0; j < parse_table[i].compound; ++j )
        {
          *((dsat_num_item_type *)parse_table[i].val_ptr + j)
              = ((def_list_type *) parse_table[i].def_lim_ptr)[j].default_v;
        }
      }
      else if ( (parse_table[i].attrib & (CONFIG | STRING | MIXED_PARAM | 
                                          NO_RESET)) ==
                (CONFIG | STRING) )
      {
        /*-------------------------------------------------------------------
        If the entry is a string, set it to the null string
        -------------------------------------------------------------------*/
        *(dsat_string_item_type *)parse_table[i].val_ptr = '\0';
      }

      /* handle MIXED_PARAM parameters */
      else if ( (parse_table[i].attrib & (CONFIG | MIXED_PARAM | LIST
                                          | NO_RESET)) ==
                (CONFIG | MIXED_PARAM | LIST) )
      {
        /* if the entry is mixed parms, init them one by one */
        int index;
        dsat_mixed_param_val_type * val_list = 
          (dsat_mixed_param_val_type *) parse_table[i].val_ptr;
        
        mixed_def_s_type ** mixed_def_list = 
          (mixed_def_s_type **) parse_table[i].def_lim_ptr;

        for (index = 0; index < parse_table[i].compound; index++)
        {
          /* The argument is an index into string list, use the default
             in the default entry */
          if( (mixed_def_list[index]->attrib & (CONFIG | STRING | LIST)) == 
              (CONFIG | LIST) )
          {
            val_list[index].num_item = 
              mixed_def_list[index]->def->def_list.default_v;
          }

            /* The argument is an integer with range */
          else if( (mixed_def_list[index]->attrib &
                    (CONFIG | STRING | LIST)) == (CONFIG) )
          {
            val_list[index].num_item =
              mixed_def_list[index]->def->dflm.default_v;
          }

          /* the argument is a string, init it as NULL */
          if( (mixed_def_list[index]->attrib & (CONFIG | STRING | LIST)) == 
              (CONFIG | STRING) )
          {
            val_list[index].string_item[0] = '\0';
          }
        }
      }
      
#ifdef FEATURE_CDMA
      /*---------------------------------------------------------------------
        Special processing 
      ---------------------------------------------------------------------*/
      switch(parse_table[i].special)
        {
#ifdef FEATURE_DS_MOBILE_IP 
          
          case SPECIAL_QCMIP:
            /* JD - add qcmip stuff */
            break;

          case SPECIAL_QCMIPMASS:
            ds_nv_item.ds_mip_ss_user_prof.index =
                         (byte) dsat707_qcmipp_val;
            (void)dsatutil_get_nv_item(NV_DS_MIP_SS_USER_PROF_I,&ds_nv_item);

            if( ds_nv_item.ds_mip_ss_user_prof.mn_aaa_shared_secret_length!= 0 )
            {
              memset(&dsat707_qcmipmass_val[0],0x0,
                ds_nv_item.ds_mip_ss_user_prof.mn_aaa_shared_secret_length);
              
              memcpy((byte*) dsat707_qcmipmass_val,
                     (byte*) ds_nv_item.ds_mip_ss_user_prof.mn_aaa_shared_secret,
                     ds_nv_item.ds_mip_ss_user_prof.mn_aaa_shared_secret_length);
            }
            break;
          
          case SPECIAL_QCMIPMHSS:
            ds_nv_item.ds_mip_ss_user_prof.index =
                         (byte) dsat707_qcmipp_val;
            (void)dsatutil_get_nv_item(NV_DS_MIP_SS_USER_PROF_I,&ds_nv_item);

            if(ds_nv_item.ds_mip_ss_user_prof.mn_ha_shared_secret_length!= 0 )
            {
              memset(&dsat707_qcmipmhss_val[0],0x0,
                ds_nv_item.ds_mip_ss_user_prof.mn_ha_shared_secret_length);
              
              memcpy((byte*) dsat707_qcmipmhss_val,
                     (byte*) ds_nv_item.ds_mip_ss_user_prof.mn_ha_shared_secret,
                     ds_nv_item.ds_mip_ss_user_prof.mn_ha_shared_secret_length);
            }
  
            break;

          case SPECIAL_QCMIPNAI:
            ds_nv_item.ds_mip_gen_user_prof.index = dsat707_qcmipp_val;
            (void)dsatutil_get_nv_item(NV_DS_MIP_GEN_USER_PROF_I,&ds_nv_item);

            if(ds_nv_item.ds_mip_gen_user_prof.nai_length != 0 )
            {
              memset(&dsat707_qcmipnai_val[0],0x0,ds_nv_item.ds_mip_gen_user_prof.nai_length);
              (void)std_strlcpy((char *)dsat707_qcmipnai_val,
                          (char *)ds_nv_item.ds_mip_gen_user_prof.nai, 
                          ds_nv_item.ds_mip_gen_user_prof.nai_length);
            }
            break;

          case SPECIAL_QCMIPHA:
            ds_nv_item.ds_mip_gen_user_prof.index = dsat707_qcmipp_val;
            (void)dsatutil_get_nv_item(NV_DS_MIP_GEN_USER_PROF_I,&ds_nv_item);
          
            dsat707_ha_val = ds_nv_item.ds_mip_gen_user_prof.home_addr;
            break;

          case SPECIAL_QCMIPPHA:
            ds_nv_item.ds_mip_gen_user_prof.index = dsat707_qcmipp_val;
            (void)dsatutil_get_nv_item(NV_DS_MIP_GEN_USER_PROF_I,&ds_nv_item);
          
            dsat707_pri_ha_val = 
                ds_nv_item.ds_mip_gen_user_prof.primary_ha_addr;
            break;

          case SPECIAL_QCMIPSHA:
            ds_nv_item.ds_mip_gen_user_prof.index = dsat707_qcmipp_val;
            (void)dsatutil_get_nv_item(NV_DS_MIP_GEN_USER_PROF_I,&ds_nv_item);
          
            dsat707_sec_ha_val =
                ds_nv_item.ds_mip_gen_user_prof.secondary_ha_addr;
          
            break;
#endif /* FEATURE_DS_MOBILE_IP */

#ifdef FEATURE_IS2000_REL_A
        case SPECIAL_QCQOSPRI:
          if ((dsrlp_get_desired_qos_non_assur_pri(&temp_qos_pri)) == TRUE)
          {
             dsat707_qcqospri_val = temp_qos_pri;
          }
          else
          {
             dsat707_qcqospri_val = DSRLP_QOS_NON_ASSUR_DEFAULT_PRI_ADJ;
          }
          break;
#endif /* FEATURE_IS2000_REL_A */
        default:              /* Pleasing Lint */
          break;
        }
#endif /* FEATURE_CDMA */
    }
  }
} /*  init_parse_table( ) */


/*===========================================================================

FUNCTION DSATCMDP_INIT_CONFIG

DESCRIPTION
  This function initializes the complete set of AT command parameters
  to their default values.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void dsatcmdp_init_config
(
  void
)
{
  unsigned int             i, r, c;          /* Count indices */
  dsati_at_cmd_table_entry_type *array_ptr;  /* Pointer to array of cmd 
                                                table entries */
  /*-----------------------------------------------------------------------
    Set defaults from NV 
  ------------------------------------------------------------------------*/
  dsat_nv_sync( );        

  /*-----------------------------------------------------------------------
    Initialize all AT command table parameters to their default values.
  ------------------------------------------------------------------------*/
  for ( c = 0; c < NUM_OPER_CMD_MODES; c++ )
  {
    for ( r = 0; r < NUM_AT_CMD_CATEGORIES; r++ )
    {
      /* Get a pointer to array of command table entries for operating 
         mode from command table. */
      array_ptr = at_cmd_table[r][c];  

      if ( array_ptr != NULL )
      {
        /* An array of command table entries exists for this element of
           the table, now look for command tables within the array. */

        for ( i = 0; array_ptr[i].table_ptr != NULL; i++ )
        {
          /* Initialize all parameters in each parse table found in the
             array. */
          init_parse_table( array_ptr[i].table_ptr, 
                            *(array_ptr[i].table_size) );
        }
      }
    }
  }


#ifdef FEATURE_DS_MOBILE_IP
  /*-------------------------------------------------------------------------
    Force special QCMIP, CRM and MDR processing here to make sure values
    are ok at startup.  This should be moved elsewhere later.
  -------------------------------------------------------------------------*/
  dsat707_qcmip_set_mdr_val();
  dsat707_qcmip_set_crm_val();
  ds707_so_pkt_recal();
#endif /* FEATURE_DS_MOBILE_IP */

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
#error code not present
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */

#if defined(FEATURE_DSAT_V80) && defined(FEATURE_WCDMA)
#error code not present
#endif /* defined(FEATURE_DSAT_V80) && defined(FEATURE_WCDMA) */

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
#error code not present
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */

#if defined(FEATURE_ETSI_PBM) || defined(FEATURE_DSAT_CDMA_PBM)
  dsatme_reset_pb();
#endif /* defined(FEATURE_ETSI_PBM) || defined(FEATURE_DSAT_CDMA_PBM) */


#ifdef FEATURE_DS_MULTIPLE_PROFILES	   
  ds707_data_session_read_profile_info();
#endif /* FEATURE_DS_MULTIPLE_PROFILES */

} /*  dsatcmdp_init_config( ) */

/*===========================================================================

FUNCTION CONVERT_FLOW_CONTROL

DESCRIPTION
  This function will convert flow control values dictated by AT command
  standard to SIO flow control values.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL sio_flow_ctl_type convert_flow_control
( 
  flow_ctl_type    flow_ctl,              /* Flow control method          */
  boolean          fail_safe              /* Fail safe                    */
)
{
  sio_flow_ctl_type return_val = SIO_CTSRFR_FCTL;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  switch ( flow_ctl )
  {
  case DS_FCTL_OFF:
    return_val = SIO_FCTL_OFF;
    break;       

  case DS_XONXOFF_STRIP_FCTL:
    if ( fail_safe )
    {
      return_val = SIO_XONXOFF_STRIP_FCTL_FS; 
    }
    else
    {
      return_val = SIO_XONXOFF_STRIP_FCTL_NFS;
    }
    break;               

  case DS_CTSRFR_FCTL:
    return_val = SIO_CTSRFR_FCTL; 
    break;                      

  case DS_XONXOFF_NSTRIP_FCTL:
    if ( fail_safe )
    {
      return_val = SIO_XONXOFF_NSTRIP_FCTL_FS; 
    }
    else
    {
      return_val = SIO_XONXOFF_NSTRIP_FCTL_NFS;
    }
    break;             

  case DS_MAX_FLOW:
    /* Invalid flow control so fall through. */

  default:
    ERR_FATAL( "Invalid Flow control value",0,0,0);
    break;
  }

  return return_val;

} /* convert_flow_control */


/*===========================================================================

FUNCTION SET_FLOW_CONTROL

DESCRIPTION
  Sets the flow control in the serial interface.

  If dsat_fclass_val is 2, which means +FCLASS = 2.0, the both
  directions are set from dsat_flo_val (AT+FLO).

  Otherwise, the flow control for each direction is set individually
  from dsat_ifc_val[] (AT+IFC).

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
LOCAL void set_flow_control( void )
{
  sio_flow_ctl_type tx_flow_ctl;
  sio_flow_ctl_type rx_flow_ctl;

  if ( dsat_fclass_val == 2 )
  {
    tx_flow_ctl = convert_flow_control( (flow_ctl_type) dsat_flo_val, TRUE );
    rx_flow_ctl = convert_flow_control( (flow_ctl_type) dsat_flo_val, TRUE );
  }   
  else
  {
    tx_flow_ctl = convert_flow_control( (flow_ctl_type) dsat_ifc_val[0],
                                        TRUE );
    rx_flow_ctl = convert_flow_control( (flow_ctl_type) dsat_ifc_val[1],
                                        TRUE );
  }

#ifdef FEATURE_DATA_MM
  (void) ds3g_siolib_set_flow_ctl_method( tx_flow_ctl, rx_flow_ctl );
#else
  (void) ds3g_sio_set_flow_ctl_method( tx_flow_ctl, rx_flow_ctl );
#endif /* FEATURE_DATA_MM */
} /* set_flow_control( ) */


/*===========================================================================

FUNCTION DSAT_CHANGE_BAUD

DESCRIPTION
  This function is called by other modules to write the value to the current 
  baud rate variable, dsat_ipr_val. Whenever the baud rate is changed
  it should also be entered into the NV.

  The second parameter in this function is a boolean type. It informs 
  the function if the Baud rate should be changed NOW or later (later
  implies, after sending acknowledgement). This is needed because, when 
  UI changes the baud rate, the baud rate should take effect immediately. 
  But when an AT command changes the baud rate, the baud rate should be 
  changed after an "OK" is sent to the TE2. 

DEPENDENCIES
  This code does not check for auto baud enabled or not. So, it is the 
  responsibility of the calling function to ascertain that if 
  FEATURE_AUTOBAUD is not enabled then value 0 should not be passed.

  This code is called from sdevmap.c, which means it can execute in
  non-DS task context.

RETURN VALUE
  None

SIDE EFFECTS
  Modifies the current values of IPR and QCTER and the corresponding
  value ds_default_baud in the NV.    

===========================================================================*/
void dsat_change_baud
(
    sio_bitrate_type new_baud_rate,     /* Requested baud rate   */
    boolean change_baud_now             /* Immediate or post ack */
)
{
  /*--------------------------------------------------------------------------
  Check if the Baud rate is with in the maximum permissible value. If yes 
  update the variable and write to NV. Else return without modifying.

  If Autobaud not allowed, UI gives an "ERROR" to the user. 
  --------------------------------------------------------------------------*/
  if (new_baud_rate >= SIO_BITRATE_BEST ) 
  {
    MSG_HIGH ("Unknown Baud rate requested", 0,0,0);
    return;
  }

  /*-------------------------------------------------------------------------
  Copy the new_baud_rate into the ipr and qcter variables.
  -------------------------------------------------------------------------*/
  dsat_ipr_val = (unsigned int)new_baud_rate;
  dsat_qcter_val  = (unsigned int)new_baud_rate;

  /*-----------------------------------------------------------------------
  Check if the baud rate should be changed NOW or later and change the
  baud rate accordingly, by informing the SIO. 
  -----------------------------------------------------------------------*/
#ifdef FEATURE_DATA_MM
  (void) ds3g_siolib_change_baud_rate((sio_bitrate_type) dsat_ipr_val,
                                    change_baud_now );
#else
  (void) ds3g_sio_change_baud_rate((sio_bitrate_type) dsat_ipr_val, 
                                    change_baud_now );
#endif /* FEATURE_DATA_MM */

  /*-------------------------------------------------------------------------
  Write the new value of the baud_rate to the NV. 
  -------------------------------------------------------------------------*/
#ifdef FEATURE_DATA_MM
  ds_nv_item.ds_default_baudrate = (nv_sio_baudrate_type)dsat_ipr_val;
#else
  ds_nv_item.ds_default_baudrate = (nv_sio_baud_type)dsat_ipr_val;
#endif

  /*-------------------------------------------------------------------------
    Write the new value of the baud_rate to the NV.
  -------------------------------------------------------------------------*/
  ds_nv_item.ds_default_baudrate = (nv_sio_baudrate_type)dsat_ipr_val;
  /*-------------------------------------------------------------------------
    Prepare command buffer to write the item to NV.
        tcb_ptr:    We donot have to inform current task when the write is
                    complete. Note that after the information is written NV,
                    NV task need not inform us. This is done because, baud
                    rate is not very critical and so we donot want to confirm
                    if it is writtena also, we donot want to block current
                    task.
        sigs:       Make it NULL. We donot want any signal to be set because
                    we donot want to block on this action.
        done_q_ptr: Command does not have to go to any queue when done.
        item:       The item to be written is NV_DS_DEFAULT_BAUDRATE_I.
        cmd:        Inform NV to write the item.
        data_ptr:   Give the address of the data to be written as ds_nv_item.
                    Note that this uses the DS space and has a potential to
                    clash between the DS data and UI data. But this is okay
                    because Baud rate given by either UI or AT command will
                    be stored here @ NV_DS_DEFAULT_BAUDRATE_I location.
                    In a racing condition, we leave it for latest entry to
                    be used, which will be done.

        Give the command to the NV task to write the data in the NV.
  -------------------------------------------------------------------------*/
  ds_nv_baud_cmd_buf.tcb_ptr = NULL;
  ds_nv_baud_cmd_buf.sigs = NULL;
  ds_nv_baud_cmd_buf.done_q_ptr = NULL;

  ds_nv_baud_cmd_buf.item = NV_DS_DEFAULT_BAUDRATE_I;
  ds_nv_baud_cmd_buf.cmd = NV_WRITE_F;

  ds_nv_baud_cmd_buf.data_ptr =  &ds_nv_item;

  /*-------------------------------------------------------------------------
   Issue the command to NV. Note that we donot wait for the response.
  -------------------------------------------------------------------------*/
  nv_cmd( &ds_nv_baud_cmd_buf );
} /* dsat_change_baud() */


/*===========================================================================

FUNCTION DSATCMDP_GET_OPERATING_CMD_MODE

DESCRIPTION
  Gets the current AT command processor operating service mode used for
  selection of different AT command sets from command table.

DEPENDENCIES
  None

RETURN VALUE
  Current operating service mode.

SIDE EFFECTS
  None

===========================================================================*/
dsati_operating_cmd_mode_type dsatcmdp_get_operating_cmd_mode( void )
  {
  return operating_mode;
} /* dsatcmdp_get_operating_cmd_mode( ) */


/*===========================================================================

FUNCTION DSATCMDP_GET_CURRENT_MODE

DESCRIPTION
  Gets the current AT command mode, GSM or WCDMA or CDMA.

DEPENDENCIES
  None

RETURN VALUE
  Current service mode.

SIDE EFFECTS
  None

===========================================================================*/
dsati_mode_e_type dsatcmdp_get_current_mode( void )
{
  return present_mode;
} /* dsatcmdp_get_current_mode */



/*===========================================================================

FUNCTION DSATCMDP_BLOCK_INDICATIONS

DESCRIPTION
  Returns value to indicate whether or not indications sent to the TE
  should be blocked.  No indications should be sent to TE from the
  time entering an AT command line begins to the time command line
  processing completes.  Command line processing is considered completed
  after the final result code or response is sent to the TE.  Also,
  indications should not be sent to the TE while in a data call.

DEPENDENCIES
  None

RETURN VALUE
  TRUE if sending of indications to TE should be blocked or FALSE
  otherwise.

SIDE EFFECTS
  None

===========================================================================*/
boolean dsatcmdp_block_indications( void )
{
  return dsatcmdp_block_indications_flag;

}  /* dsatcmdp_block_indications( ) */



/*===========================================================================

FUNCTION DSAT_SIO_IS_BUSY

DESCRIPTION
  This function is used by SIOLib to tell ATCoP that SIO is busy now and 
  Mode Specific Handlers are in charge of SIO.

  This is called when Mode Specific Handlers register their SIO Handlers.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  ATCOP stops sending the AT command results to the TE. It will resume
  its normal operatioon only when dsat_sio_is_free() is called.

===========================================================================*/
void dsat_sio_is_busy ( void )
{
  /* Set regional flag to indicate indications should not be 
     sent to TE at this time. */
  dsatcmdp_block_indications_flag = TRUE;

  return;
}

/*===========================================================================

FUNCTION DSAT_SIO_IS_FREE

DESCRIPTION
  This function is used by SIOLib to tell ATCoP that SIO is free now. ATCoP
  Can now resume its normal operation.

  This is called when Mode Specific Handlers de-register their SIO Handlers.
  i.e. when the serial port is no longer in a call.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  In ETSI mode, the queued SMS indications are flushed.

===========================================================================*/
void dsat_sio_is_free ( void )
{
  /* Clear regional flag to indicate indications can now be sent to TE. */
  dsatcmdp_block_indications_flag = FALSE;

#ifdef FEATURE_ETSI_SMS
#error code not present
#endif /* FEATURE_ETSI_SMS */

  return;
}

/*===========================================================================

FUNCTION DSAT_FINISHED_ATH_CMD

DESCRIPTION
  Resets the state variable. Continues processing the AT command line.
  Called by dsat_send_result_code(). Used when we are processing ATH cmd.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  Does not resutn to CS data handler tillwe finifh processing the AT command
  line.

===========================================================================*/
void dsat_finished_ath_cmd 
(
 dsat_result_enum_type result_code         /* Command result code */
)
{
  /* Clear regional flag to indicate  */
  dsati_processing_ath_cmd = FALSE;

  process_at_cmd_line( dsatcmdp_at_state, result_code, at_cmd_line_ptr );

  return;
}

#endif /* FEATURE_DATA */
