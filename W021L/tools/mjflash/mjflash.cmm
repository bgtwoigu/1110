;============================================================================
;  Name:
;    MJFLASH.CMM
;
;  Description:
;    FLASH Programming Script file for Lauterbach JTAG/ICD TRACE32.
;
;  Execution:
;    Inside the debugger, type at the command line: "do jflash".
;    The script will prompt you for the desired file.
;      or
;    Inside the debugger, type at the command line: "do jflash SBTA".
;    The script will load ..\..\build\ms\SBTA.elf automatically
;      or
;    Inside the debugger, type at the command line: "do jflash DEBUG".
;    The script will go into debug mode
;    The script will prompt you for the desired file.
;      or
;    Inside the debugger, type at the command line: "do jflash DEBUG SBTA".
;    The script will go into debug mode
;    The script will load ..\..\build\ms\SBTA.elf automatically
;
;    NOTE:  DEBUG must be all uppercase and must be before any build ID
;
;    NOTE 2:  DEBUG mode will create a file called "tem.out" in the
;             current directory as the output of the terminal emulation
;             window
;
;
;  Copyright (c) 2006-2008 Qualcomm Incorporated. 
;  All Rights Reserved.
;  Qualcomm Confidential and Proprietary
;----------------------------------------------------------------------------
;============================================================================
;
;                        EDIT HISTORY FOR MODULE
;
; $Header: //depot/asic/msmshared/tools/jflash/JFLASH.03.00/mjflash.cmm#6 $ $DateTime: 2008/08/28 10:49:14 $ $Author: c_surven $
;
; when       who     what, where, why
; -------    ---     --------------------------------------------------------
; 08/15/08   sv      Update to support partition and non partition mode 
; 03/12/08   sv      Clean up status message output 
; 01/03/08   op      Add support for single-image NOR targets
; 02/28/07   op      Support  Nor Sibley
; 02/28/07   rt      Add support for multi-image NOR targets
; 12/06/06   rt      Create initial version from JFLASH 2.1
;============================================================================;



;============================================================================
; Declare variables used
;============================================================================
local &BinName
local &ImageName
local &BuildID
local &Imagedir
local &PbnImage
local &arg1 &arg2 &arg3 &arg4
local &MenuMode
local &DoDebug 
local &ProcessBinName
local &Verbose
local &OSPwd
local &SymbolArg
local &ClearWin
local &Choice
local &WarnChoice
local &DoVerify
;local &UseTerm
local &CurrentCmd
local &ImageDir
local &CheckStatusExit
local &CheckStatusFailed 


local &DateStart
local &DateEnd
local &TimeStart
local &TimeEnd 


local &BinDir
local &BootVectorBin
local &UsrPartiBin
local &SysPartiBin
local &CfgDataQcSblBin
local &OemSblBin
local &AmssBin
local &EfsBin
local &AllBin

local &TermBlipBreak
local &PartiSent
local &SysPartiBinExists
local &BinDialog
local &BinDialogDir

local &StartDir
local &PartiMode
local &Filename 

&StartDir=OS.pwd()
cd ..\..\tools\mjflash


;============================================================================
; Set up some defaults for some variables
;============================================================================
  &MenuMode="STD"            ; Present normal JFLASH menu
  &DoDebug="no"              ; Do not do debugging      
  &ProcessBinName="yes"      ; Processs the binary file name
  &Verbose="yes"             ; Present status messages as we process
  &ClearWin="yes"            ; Remove all windows before starting
  &SymbolArg="/NOSYMBOL"     ; Don't load any symbols.
  &DoVerify="yes"            ; Do not do verify step
  ;&UseTerm="yes"              ; Put up terminal window
  &ImageDir="."              ; Directory to find images in
  &CheckStatusFailed="no"
  &TermBlipBreak="no"        ; set to yes to use buffered IO
  &PartiSent="no"            ; have not yet sent partition table
  &BinDialog="yes"           ; Do not use hard coded binaries, use dialog and path
  &SysPartiBinExists="no"    ; Set default
  &PartiMode="yes"           ; Set to partition mode by default

;Variables for binaries to program
  &BinDir="../../build/ms/bin"
  &BootVectorBin="boot_vector.mbn"
  &UsrPartiBin="usr_partition.mbn"
  &SysPartiBin="sys_partition.mbn"
  &CfgDataQcSblBin="cfg_data_qcsbl.mbn"
  &OemSblBin="oemsblhd_oemsbl.mbn"
  &AmssBin="elf_info_amss.mbn"
  &EfsBin="efs.mbn"
  &AllBin="all.mbn"


;============================================================================
; Get the arguments passed in.
;============================================================================
ENTRY &arg1 &arg2 &arg3 


;============================================================================
; For normal use set up the screen with only area window for reports 
; For debug purposes, don't clear
; In both cases, make sure we have an area window
;============================================================================
  if "&ClearWin"=="yes"  
  (  
    WinCLEAR
    WinPage.Reset
  )

  ;WINPOS 0. 0. 50% 100%
  ;area

  if "&ClearWin"=="yes"  
  (  
    area.RESET 
  )



;============================================================================
; Process the command line arguments and create image names or wildcards
;============================================================================
  gosub ProcessCmdLine

  &JtagSet="no"

;-------------------------------------------------------------------------------
; Variables to control windows and terminal emulation
;   If Debugging is on, set these up correctly, otherwise use as is
;   For debugging, do not clear windows, put up terminal window
;-------------------------------------------------------------------------------
  local &ClearWin
  &ClearWin="yes"
  local &TermUp
  &TermUp="no"

  if "&DoDebug"=="yes"
  (
    &ClearWin="no"
    &TermUp="yes"
  )


;============================================================================
; Set up the screen with only area window for reports
; Variable set to "no" will not clear screen - for debug purposes
;============================================================================
  if "&ClearWin"=="yes"
  (
    WinCLEAR
    WinPage.Reset
  )

  WINPOS 0. 0. 50% 100%
  area



;============================================================================
; Set up a terminal window for JFLASH to print to - for debug purposes
;============================================================================
  if "&TermUp"=="yes"
  (

    ;============================================================================
    ; Put up terminal window
    ;============================================================================
      term.size 60 1000
      term.scroll on
      WinPOS 45 8
      term.view

      term.write term.out

      on error gosub
      (
        term.close
        print "terminal output closed"
        enddo
        return
      )
   )


;============================================================================
; Get variable data to use instead of hardcoded addresses
;============================================================================
  do jflash_param   ; Auto-generated during build process

;============================================================================
; Init important MSM/ASB registers
;  use existing external script
;============================================================================
  do jf_msm_init &JtagSet
  ENTRY &PartiMode

;============================================================================
; Adjust the Bin file Names and their path
;============================================================================
  gosub AdjustBinNames

;-------------------------------------------------------------------------------
; Set some variables used later on to peek and poke parameter block
;   This script file is sourced by both jnand.cmm and jnandtest.cmm
;-------------------------------------------------------------------------------
  do jf_addr_init.cmm

;======================================================
; Create the ROM mapping to be used with all commands
;======================================================
  &RomBegin=&JflashRomBegin
  &RomEnd=&JflashRomEnd
  gosub CreateRom

;======================================================
; Load our flash programming routine and prepare flash
;======================================================
  d.load.elf "jflash.elf" /VERIFY

  ; need this breakpoint as per Lauterbach Spec so that we
  ; can hand back control to the Debugger
  break.delete /ALL
  break.set swbp


;============================================================================
; Possibly put up terminal window
;============================================================================
  if "&UseTerm"=="YES"  
  (  
    term.close
    winclear MYTERM
    term.size 60 1000
    term.scroll on
    WinPOS 50% 0% 50% 100% ,, MYTERM

    if "&TermBlipBreak"=="yes" 
    (
      print "Using buffered terminal IO"
      term.protocol bs
      term output_port input_port
      print "Setting TermBlip breakpoint"
      b.s term_blip /s /onchip
    )
    else
    (
      term.view
      term.write term.out
    )
     
    on error gosub
    (
      term.close
      print "terminal output closed"
      end     ; Terminate here if there is an error
      return
    )
  )


;============================================================================
; Invoke the correct menu
;============================================================================
  if "&PartiMode"=="no"
  (
    gosub LoadNoPartiImage
  )
  else
  (
    if "&MenuMode"=="NOMENU"
    (
      gosub DoNoMenu
    )
    else
    (
      if "&MenuMode"=="STD"
      (
        gosub NormalMenu
      )
      else
      (
        print "Invalid menu mode &MenuMode selected"
        end
      )
    )
  )

;======================================================
; Perform the exit sequence and clean up
;======================================================

  ; Close terminal and flush contents if it was in use
  if "&UseTerm"=="yes"  
  (  
    term.close
  )
  ; ok we're finished, turn off programming mode
  flash.program off

;======================================================
; Perform the exit sequence and clean up
;======================================================
  sys.d
  sys.o.BigEndian off
  sys.o.SHOWERROR on

  sys.o.DisMode Auto

  sys.u

  b.delete /all

  map.reset

  if "&TermUp"=="yes"
  (
    term.close
  )

  print "MJFLASH exited..."

enddo




;;======================================================;; 
;;    _____                 _   _                       ;;
;;   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___       ;;
;;   | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|      ;;
;;   |  _|| |_| | | | | (__| |_| | (_) | | | \__ \      ;;
;;   |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/      ;;
;;                                                      ;;
;;======================================================;; 

;=========================================================
; --- Function to program ALL Image
;=========================================================
LoadNoPartiImage:
  goSub StartTime "Programming ALL Image"

  ;--------------------------------------------------------
  ; Initialize the MJFLASH program - must succeed
  ;  will probe flash and set up first block for writing
  ; We have to set this command up by hand as it is one
  ;  that we added to the flash.* protocol and JTAG does
  ;  not know about it.
  ;--------------------------------------------------------

  &AllBin="&BinDir/&BuildID/&AllBin"
  &FileSize=os.file.size(&AllBin)
  print "Programming image file: &AllBin"

  ;--------------------------------------------------------
  ; actual flash programming happens here
  ;--------------------------------------------------------
  &Command="Flash Init All"
  data.set &ParmCmd %LONG &InitAllCmd
  data.set &ParmSize %LONG &FileSize
  &CurrentCmd=&InitAllCmd
  r.s pc &StartAddr
  go
  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error

  &PbnImage="&AllBin"
  &ImageName="ALL"

  gosub CreateRom

  ;--------------------------------------------------------
  ; put into program mode 
  ;--------------------------------------------------------
  flash.program all
   
  ;--------------------------------------------------------
  ; actual flash programming happens here
  ;--------------------------------------------------------
  &Command="Flash Program"
  &CurrentCmd=&ProgramCmd

  data.load.binary &PbnImage /NOSYMBOL

  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error

  flash.program off
  
  goSub EndTime "Programming ALL Image"

  ; Load symbols from the elf
  d.load.elf ../../build/ms/&BuildID.elf /nocode /noclear /include
  r.s pc 0x0

return     ;LoadNoPartiImage



;============================================================================
; Process the arguments and set modes accordingly
;============================================================================
ProcessCmdLine:

  ; Any mode can take DEBUG, must be first, process it first
  if "&arg1"=="DEBUG"
  (
    print "MJFLASH called with arg1 = &arg1 arg2 = &arg2  arg3 = &arg3"
    
    ; Strip out DEBUG and shift arguments
    &DoDebug="yes"
    &arg1="&arg2"
    &arg2="&arg3"
    &arg3="&arg4"
  )

  if "&arg1"=="NOMENU"
  (
    ; NOMENU mode needs a BUILDID argument
    &MenuMode="&arg1"
    &BuildID="&arg2"

    if "&BuildID"==""
    (
      print "Fatal Error:  Parameter NOMENU requires a valid Build ID"
      gosub CleanUp   
      gosub CleanUpExit
      end
    )
    &Verbose="no"
  )
  else
  (
    &BuildID="&arg1"
    &MenuMode="NOMENU"
  )
  
  if "&DoDebug"=="yes"
  (
    print "MenuMode is &MenuMode"
    print "Debug is &DoDebug"
    print "SecureBoot is &SecureBoot"
    print "Verbose is &Verbose"
    print "BuildID is &BuildID"
  )

return  ; ProcessCmdLine




;============================================================================
; If not in factory mode, process the elf name, helping the user all we
; can so that they have as little work to do as possible.
;
; Processing is slightly different if invoked with NOMENU, STD or FACTORY
;============================================================================
AdjustBinNames:

  ; If we have no BuildID name, have user choose an elf file
  if "&PartiMode"=="yes"
  (
  
    if "&BuildID"==""
    (
      &BootVectorBin="&BinDir/*.mbn"
      &UsrPartiBin="&BinDir/*.mbn"
      &SysPartiBin="&BinDir/*.mbn"
      &CfgDataQcSblBin="&BinDir/*.mbn"
      &OemSblBin="&BinDir/*.mbn"
      &AmssBin="&BinDir/*.mbn"
      &EfsBin="&BinDir/*.mbn"
    )
    else
    (
      &BootVectorBin="&BinDir/&BuildID/&BootVectorBin"
      &UsrPartiBin="&BinDir/&BuildID/&UsrPartiBin"
      &SysPartiBin="&BinDir/&BuildID/&SysPartiBin"
      &CfgDataQcSblBin="&BinDir/&BuildID/&CfgDataQcSblBin"
      &OemSblBin="&BinDir/&BuildID/&OemSblBin"
      &AmssBin="&BinDir/&BuildID/&AmssBin"
      &EfsBin="&BinDir/&BuildID/&EfsBin"
    )

    if "&DoDebug"=="yes"
    (
      print "BootVectorBin   is &BootVectorBin"
      print "UsrPartiBin     is &UsrPartiBin"
      print "SysPartiBin     is &SysPartiBin"
      print "CfgDataQcSblBin is &CfgDataQcSblBin"
      print "OemSblBin       is &OemSblBin"
      print "AmssBin         is &AmssBin"
      print "EfsBin          is &EfsBin"
    )
  )
return   ;AdjustBinNames




;=====================================================
; --- Function to create the FLASH map
;=====================================================
CreateRom:
  ;======================================================
  ; Map flash readonly - must encompass the addresse
  ;     of the image being loaded
  ;======================================================
    map.readonly &RomBegin--&RomEnd
  

  ;--------------------------------------------------------
  ; reset our flash command
  ;--------------------------------------------------------
    flash.res
   
  ;--------------------------------------------------------
  ; Let flash command know where our routine and buffer is located
  ; code at &JnandCodeAddr, data at &JnandParamAddr, buffer size = 16K
  ; Earlier versions of JTAG s/w would allow larger buffer of 64k
  ; but now we seem to be limited to 16k
  ;--------------------------------------------------------
    flash.target &JflashCodeAddr &JflashParamAddr 4000 
   
  ;--------------------------------------------------------
  ; Define our flash range and tell flash command we're using
  ; our own flash programming routine via keyword "target"
  ; right now, we are defining 3 MBytes for code which in
  ; the NAND environment is meaningless, as this has to do
  ; with memory mapping in the flash, but we have to use it
  ; to use the other FLASH.* functions
  ;--------------------------------------------------------
    flash.create &RomBegin--&RomEnd target word

return    ;CreateRom



;=====================================================
; --- Function to clean up the FLASH map after each
;     iteration of the loop
;=====================================================
CleanUp:
   ;--------------------------------------------------------
   ; ok we're finished, turn off programming mode
   ;--------------------------------------------------------
   flash.program off
   FLASH.Reset
   MAP.Reset
return


;=====================================================
; --- Function to clean up just before exit
;=====================================================
CleanUpExit:
    ;--------------------------------------------------------
    ; ok we're finished completely, clean up for exit
    ;--------------------------------------------------------
    b.delete /all
   
    if "&UseTerm"=="yes"  
    (  
      term.close
    )
return


;============================================================================
; Present user with normal main menu for MJFLASH.  Manual selection is done.
;============================================================================
NormalMenu:

if "&ClearWin"=="yes"  
(  
  area.RESET 
)

MainMenu: 
  print
  print   
  print "----------------------------------------------------"
  print "|   __  __     _ _____ _        _    ____  _   _   |"
  print "|  |  \/  |   | |  ___| |      / \  / ___|| | | |  |"
  print "|  | |\/| |_  | | |_  | |     / _ \ \___ \| |_| |  |"
  print "|  | |  | | |_| |  _| | |___ / ___ \ ___) |  _  |  |"
  print "|  |_|  |_|\___/|_|   |_____/_/   \_\____/|_| |_|  |"
  print "|                                                  |"
  print "|                                                  |"
  print "|                 Multi-Image Boot                 |"
  print "|               NOR Flash Programmer               |"
  print "|                                                  |"
  print "|                                                  |"
  print "|       Copyright (c) 2006 by QUALCOMM, Inc.       |"
  print "|                                                  |"
  print "----------------------------------------------------"
  print
  print
  print "  0: Exit"
  print "  1: Send Partition Table"
  print "  2: Program Boot Vector Table"
  print "  3: Program QCSBL Image and Config Data"
  print "  4: Program OEMSBL Image"
  print "  5: Program AMSS Image"
  print "  6: Do it all"
  print
  print "Option 7 and above are not part of 'Do it all' option"
  print
  print "  7: Program EFS image"
  print "  8: Program FOTA UI Bitmaps"
  print "  9: Program FOTA Update Package"
  print
  print " Please make a choice: "
    
  &t32_cmm_stopped=1
  enter &Choice
  &t32_cmm_stopped=0
  print
  print
  if "&ClearWin"=="yes"  
  (  
    area.RESET 
  )
   
  if "&Choice"=="0"  
  (  
    print "...exiting MJFLASH Flash Programmer"
    gosub CleanUp
    gosub CleanUpExit
    return
  )
   
  if "&Choice"=="1" 
  (  
    print "Sending Partition Table"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    goto MainMenu
  )

  if "&Choice"=="2"  
  ( 
    print "Programming Boot Vector Table"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramBootVecTbl
    goto MainMenu
  )
    
  if "&Choice"=="3" 
  (  
    print "Programming QCSBL Config Data and Image into NOR Flash"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramQCSBL
    goto MainMenu
  )

  if "&Choice"=="4" 
  (  
    print "Programming OEMSBL into NOR Flash"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramOEMSBL
    goto MainMenu
  )

  if "&Choice"=="5" 
  (  
    print "Programming AMSS images"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramAMSS
    goto MainMenu
  )

  if "&Choice"=="6" 
  (  
    print "Programming ALL images"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramBootVecTbl
    gosub ProgramQCSBL
    gosub ProgramOEMSBL
    gosub ProgramAMSS
    goto MainMenu
  )

  if "&Choice"=="7" 
  (  
    print "Programming EFS image"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramEFS
    goto MainMenu
  )

  if "&Choice"=="8" 
  (  
    print "Programming FOTA Screen bitmaps"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramFOTAScrnBmps
    goto MainMenu
  )
 

  if "&Choice"=="9" 
  (  
    print "Programming FOTA Update Package"
    print
    print
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramFOTAUpdtPkg
    goto MainMenu
  )
  goto MainMenu
 
return  ; NormalMenu



;============================================================================
; Do not present user with menu.  Program both BootLoader and Code Images
;============================================================================

DoNoMenu:
    ;;gosub SendSecurityMode
    gosub SendPartiTbl
    gosub ProgramBootVecTbl
    gosub ProgramQCSBL
    gosub ProgramOEMSBL
    gosub ProgramAMSS
    gosub CleanUp
    gosub CleanUpExit
return  ; DoNoMenu





;=========================================================
; --- Function to send System and User Partition tables
;=========================================================
SendPartiTbl:

  local &FilePath 

  ; Send partition table once only per invocation of this file
  if "&PartiSent"=="yes"
  (
    return
  )

  if "&Verbose"=="yes"
  (
    print "Sending User Partition table"
  )

  ; Load the partition table into the parameter block
  ; in the data area
  if "&Verbose"=="yes"
  (
    print "Using User Partition Table Binary: &UsrPartiBin"
  )

  &Command="Send User Partition Table"
  data.set &ParmCmd %LONG &UsrPartiTblCmd
  data.set &ParmReserved %LONG &PartiNoOverride
  data.set &ParmWidth %LONG &HardwarePresent 
  &CurrentCmd=&UsrPartiTblCmd
  
  data.load.binary &UsrPartiBin &ParmData /NOSYMBOL
  r.s pc &StartAddr
  go

  ; check status but do not exit if it fails because we will
  ; give the user a chance to override the partition table
  &CheckStatusExit="no"
  gosub check_status
  
  if "&CheckStatusFailed"=="yes"
  (
    ; Make sure that failure was because of parititon table mismatch
    if &Result==0x23   ; 0x23 -> ERR_PARTI_NOMATCH
    (
      print "      "
      print "      "
      print " Partition table sent does not match partition table in flash"
      print "      "
      print "      "
      print "      __        __               _             "
      print "      \ \      / /_ _ _ __ _ __ (_)_ __   __ _ "
      print "       \ \ /\ / / _` | '__| '_ \| | '_ \ / _` |"
      print "        \ V  V / (_| | |  | | | | | | | | (_| |"
      print "         \_/\_/ \__,_|_|  |_| |_|_|_| |_|\__, |"
      print "                                         |___/ "
      print " "
      print
      print
      print
      print " You may force the new table to be accepted"
      print " If you do, it will erase the entire NOR flash"
      print " "
      print " "
      print
      print " Please enter 'YES' to continue, any other value will abort:: "
      
      &t32_cmm_stopped=1
      enter &WarnChoice
      &t32_cmm_stopped=0
      print
      print
       
      if "&WarnChoice"=="YES" 
      (  
        print "Sending new user partition table and erasing entire flash"
      )
      else
      (
        &PartiSent="no"
        print "Bailing out, correct answer not given" 
        return
      )
      
      ; Load the partition table into the parameter block
      ; in the data area
      if "&Verbose"=="yes"
      (
        print "Choose User Partition Table Binary"
      )

      &Command="Send User Partition Table"
      data.set &ParmCmd %LONG &UsrPartiTblCmd
      data.set &ParmReserved %LONG &PartiOverride
      data.set &ParmWidth %LONG &HardwarePresent 
      &CurrentCmd=&UsrPartiTblCmd
    
      data.load.binary &UsrPartiBin &ParmData /NOSYMBOL
      r.s pc &StartAddr
      go
  
      ; check status and exit if it fails
      &CheckStatusExit="yes"
      gosub check_status
      
    )
  )

  if "&Verbose"=="yes"
  (
    print
    print
    print "Sending System Partition table"
  )

  ; Load the partition table into the parameter block
  ; in the data area
  if "&Verbose"=="yes"
  (
    print "Choose System Partition Table Binary"
  )

  &Command="Send System Partition Table"
  data.set &ParmCmd %LONG &SysPartiTblCmd
  data.set &ParmReserved %LONG &PartiNoOverride
  &CurrentCmd=&SysPartiTblCmd

  data.load.binary &SysPartiBin &ParmData /NOSYMBOL
  r.s pc &StartAddr
  go

  ; check status but do not exit if it fails because we will
  ; give the user a chance to override the partition table
  &CheckStatusExit="no"
  gosub check_status

  if "&CheckStatusFailed"=="yes"
  (
    ; Flash a warning to the user that a more optimal layout is possible
    ; Prompt the user to see if they want to use the more optimal one.

    print "Build time system partition table does not match"  
    print "the run time version"  
  )

  &PartiSent="yes"

return    ;SendPartiTbl





;=====================================================
; --- Function to check command status return
;       and exit if 0x100
;=====================================================
check_status:
   wait !run()
  
   &Result=data.long(A:&ParmStatus)
   if &Result==0x100
   (
     print " " 
     print "---- &Command failed"
     &Result=data.long(A:&ParmReserved)
     ;;do jflash_ext_error &Result
     print " "
     
     if "&CheckStatusExit"=="no"
     (
       ; If conversion of user partition table failed,
       ; bail out. Conversion failure is not the same
       ; as the partition mismatch. In case of partition
       ; mismatch, conversion would have succeed.
       if &Result==0x36
       (
         &CheckStatusExit="yes"
       )
     )
     
     if "&CheckStatusExit"=="yes"
     (
       print "EXITING due to failed command:: &Command"
  
       if "&UseTerm"=="yes"  
       (  
         print "Closing teminal window on error"
         term.close
       )
       
       end 
     )
     else
     (
      &CheckStatusFailed="yes"
     )
   )
   else
   (
     if (&Result==&CurrentCmd)
     (
       print " " 
       print "----  DID NOT COMPLETE &Command"
       print " "
       print "EXITING due to failed command:: &Command"
       
       if "&UseTerm"=="yes"  
       (
         print "Closing teminal window on error"
         term.close
       )
       
       end
     )
     else
     (
       if "&Verbose"=="yes"
       (
         print "+++++ &Command Succeeded"  
       )
     )
   )
return     ;CheckStatus




;=====================================================
; --- Function to print start time
;=====================================================
StartTime:
  LOCAL &msg
  ENTRY &msg
  
  if "&Verbose"=="yes"
  (
    &DateStart=CLOCK.DATE()
    &TimeStart=CLOCK.TIME()
    PRINT " "
    PRINT "Start &msg at &DateStart at &TimeStart"
  )

return     ;StartTime




;=====================================================
; --- Function to print end time
;=====================================================
EndTime:
  LOCAL &msg
  ENTRY &msg
  if "&Verbose"=="yes"
  (
    &DateEnd=CLOCK.DATE()
    &TimeEnd=CLOCK.TIME()
    PRINT " "
    PRINT "End &msg at &DateEnd at &TimeEnd"
    print " "                                             
  )
return     ;EndTime




;=====================================================
; --- Function to Program flash part but not verify
;=====================================================
DoProgramming:

LOCAL &ImageSize
   ;--------------------------------------------------------
   ; put into program mode 
   ;--------------------------------------------------------
   flash.program all
   
   ;--------------------------------------------------------
   ; actual flash programming happens here
   ;--------------------------------------------------------
   &Command="Flash Program"
   &CurrentCmd=&ProgramCmd

 
   if "&Verbose"=="yes"
  (
     print "Choose &ImageName Binary"
  )  
   data.load.binary &PbnImage &RomBegin /NOSYMBOL
   
   &CheckStatusExit="yes"
   gosub check_status  ;; will not return if error
   
   ;--------------------------------------------------------
   ; OK we're finished, turn off programming mode.
   ; If we do not turn it off, any data writes within
   ; the address range of the defined ROM will be taken
   ; as flash programming commands and this will cause
   ; failures if the code size overlaps the parameter
   ; block address.
   ;--------------------------------------------------------
   flash.program off
  
   ;--------------------------------------------------------
   ; restore breakpoint which flash.program deleted
   ;--------------------------------------------------------
   
   
   ;--------------------------------------------------------
   ; Finalize the JNAND program - must succeed
   ;  writes out the last code block and any boot info blocks
   ; We have to set this command up by hand as it is one
   ;  that we added to the flash.* protocol and JTAG does
   ;  not know about it.
   ;--------------------------------------------------------
   ;
   if "&Verbose"=="yes"
   (   
     print "Finalizing flash programming"
   )
   &Command="Flash Finalize"
   data.set &ParmCmd %LONG &FinishCmd
   &CurrentCmd=&FinishCmd
   
   r.s pc &StartAddr
   go

   &CheckStatusExit="yes"
   gosub check_status  ;; will not return if error
  

return    ;DoProgramming




;=========================================================
; --- Function to program BOOT VECTOR TABLE Image
;=========================================================
ProgramBootVecTbl:

  goSub StartTime "Programming BOOT VECTOR TABLE Image"
  
  ;--------------------------------------------------------
  ; Initialize the MJFLASH program - must succeed
  ;  will probe flash and set up first block for writing
  ; We have to set this command up by hand as it is one
  ;  that we added to the flash.* protocol and JTAG does
  ;  not know about it.
  ;--------------------------------------------------------
  ;
  if "&Verbose"=="yes"
  (
    print "Probing flash and setting up"
  )
  &Command="Flash Initialize for BOOT VECTOR TABLE Image Programming"
  data.set &ParmCmd %LONG &InitBootVecTblCmd
  &CurrentCmd=&InitBootVecTblCmd
  
  r.s pc &StartAddr
  go
  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error 
  
  &PbnImage="&BootVectorBin"


  &ImageName="BOOT_VEC_TBL"
  gosub DoProgramming  
 
  goSub EndTime "Programming BOOT VECTOR TABLE Image"

return     ;ProgramBootVecTbl




;=========================================================
; --- Function to program CONFIG DATA QCSBL Image
;=========================================================
ProgramQCSBL:

  goSub StartTime "Programming CFG DATA QCSBL Image"
  
  ;--------------------------------------------------------
  ; Initialize the MJFLASH program - must succeed
  ;  will probe flash and set up first block for writing
  ; We have to set this command up by hand as it is one
  ;  that we added to the flash.* protocol and JTAG does
  ;  not know about it.
  ;--------------------------------------------------------
  ;
  if "&Verbose"=="yes"
  (
    print "Probing flash and setting up"
  )
  &Command="Flash Initialize for CONFIG DATA QCSBL Image Programming"
  data.set &ParmCmd %LONG &InitQcSblCmd
  &CurrentCmd=&InitQcSblCmd
  
  r.s pc &StartAddr
  go
  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error 
  
  &PbnImage="&CfgDataQcSblBin"


  &ImageName="CONFIG DATA QCSBL"
  gosub DoProgramming  
 
  goSub EndTime "Programming CFG DATA QCSBL Image"

return     ;ProgramQCSBL





;=========================================================
; --- Function to program OEMSBL Image
;=========================================================
ProgramOEMSBL:

  goSub StartTime "Programming OEMSBL Image"
  
  ;--------------------------------------------------------
  ; Initialize the MJFLASH program - must succeed
  ;  will probe flash and set up first block for writing
  ; We have to set this command up by hand as it is one
  ;  that we added to the flash.* protocol and JTAG does
  ;  not know about it.
  ;--------------------------------------------------------
  ;
  if "&Verbose"=="yes"
  (
    print "Probing flash and setting up"
  )
  &Command="Flash Initialize for OEMQCSBL Image Programming"
  data.set &ParmCmd %LONG &InitOemSblCmd
  &CurrentCmd=&InitOemSblCmd
  
  r.s pc &StartAddr
  go
  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error 
  
  &PbnImage="&OemSblBin"


  &ImageName="OEMSBL"
  gosub DoProgramming  
 
  goSub EndTime "Programming OEMSBL Image"

return     ;ProgramQCSBL





;=========================================================
; --- Function to program AMSS Image
;=========================================================
ProgramAMSS:

  goSub StartTime "Programming AMSS Image"
  
  ;--------------------------------------------------------
  ; Initialize the MJFLASH program - must succeed
  ;  will probe flash and set up first block for writing
  ; We have to set this command up by hand as it is one
  ;  that we added to the flash.* protocol and JTAG does
  ;  not know about it.
  ;--------------------------------------------------------
  ;
  if "&Verbose"=="yes"
  (
    print "Probing flash and setting up"
  )
  &Command="Flash Initialize for AMSS Image Programming"
  data.set &ParmCmd %LONG &InitAmssCmd 
  &CurrentCmd=&InitAmssCmd
  
  r.s pc &StartAddr
  go
  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error 
  
  &PbnImage="&AmssBin"


  &ImageName="AMSS"
  gosub DoProgramming  
 
  goSub EndTime "Programming AMSS Image"

return     ;ProgramAMSS



;=========================================================
; --- Function to program EFS Image
;=========================================================
ProgramEFS:

LOCAL &ImagePath

  goSub StartTime "Programming EFS Image"
  
  ;--------------------------------------------------------
  ; Initialize the MJFLASH program - must succeed
  ;  will probe flash and set up first block for writing
  ; We have to set this command up by hand as it is one
  ;  that we added to the flash.* protocol and JTAG does
  ;  not know about it.
  ;--------------------------------------------------------
  ;
  if "&Verbose"=="yes"
  (
    print "Probing flash and setting up"
  )
  &Command="Flash Initialize for EFS Image Programming"
  data.set &ParmCmd %LONG &InitEfsCmd 
  &CurrentCmd=&InitEfsCmd
  
  r.s pc &StartAddr
  go
  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error 
  
  &PbnImage="&EfsBin"

  IF !os.file(&PbnImage)
  (
    &ImagePath=OS.FILE.PATH(&PbnImage)
    dialog.file "&ImagePath\*.*"
    entry &PbnImage

    IF "&PbnImage"==""
    (
      print
      print "Image not available"
      print "No image programmed. Please try again!"
      return 
    )
  )

  &ImageName="EFS"
  gosub DoProgramming  
 
  goSub EndTime "Programming EFS Image"

return     ;ProgramEFS




;=========================================================
; --- Function to program FOTA Screen Bitmaps
;=========================================================
ProgramFOTAScrnBmps:

LOCAL &ImagePath

  goSub StartTime "Programming FOTA Screen Bitmaps"
  
  ;--------------------------------------------------------
  ; Initialize the MJFLASH program - must succeed
  ;  will probe flash and set up first block for writing
  ; We have to set this command up by hand as it is one
  ;  that we added to the flash.* protocol and JTAG does
  ;  not know about it.
  ;--------------------------------------------------------
  ;
  if "&Verbose"=="yes"
  (
    print "Probing flash and setting up"
  )
  &Command="Flash Initialize for FOTA Screen Bitmaps Programming"
  data.set &ParmCmd %LONG &InitFotaUIBmpCmd 
  &CurrentCmd=&InitFotaUIBmpCmd
  
  r.s pc &StartAddr
  go
  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error 
  
  &PbnImage="&BinDir\*.*"

  IF !os.file(&PbnImage)
  (
    &ImagePath=OS.FILE.PATH(&PbnImage)
    dialog.file "&ImagePath\*.*"
    entry &PbnImage

    IF "&PbnImage"==""
    (
      print
      print "Image not available"
      print "No image programmed. Please try again!"
      return 
    )
  )

  &ImageName="EFS"
  gosub DoProgramming  
 
  goSub EndTime "Programming FOTA Screen Bitmaps"

return     ;ProgramFotaScrnBmps






;=========================================================
; --- Function to program FOTA Update Package
;=========================================================
ProgramFOTAUpdtPkg:

LOCAL &ImagePath

  goSub StartTime "Programming FOTA Update Package"
  
  ;--------------------------------------------------------
  ; Initialize the MJFLASH program - must succeed
  ;  will probe flash and set up first block for writing
  ; We have to set this command up by hand as it is one
  ;  that we added to the flash.* protocol and JTAG does
  ;  not know about it.
  ;--------------------------------------------------------
  ;
  if "&Verbose"=="yes"
  (
    print "Probing flash and setting up"
  )
  &Command="Flash Initialize for FOTA Update Package Programming"
  data.set &ParmCmd %LONG &InitFotaPkgCmd 
  &CurrentCmd=&InitFotaPkgCmd
  
  r.s pc &StartAddr
  go
  &CheckStatusExit="yes"
  gosub check_status  ;; will not return if error 
  
  &PbnImage="&BinDir\*.*"

  IF !os.file(&PbnImage)
  (
    &ImagePath=OS.FILE.PATH(&PbnImage)
    dialog.file "&ImagePath\*.*"
    entry &PbnImage

    IF "&PbnImage"==""
    (
      print
      print "Image not available"
      print "No image programmed. Please try again!"
      return 
    )
  )

  &ImageName="EFS"
  gosub DoProgramming  
 
  goSub EndTime "Programming FOTA Update Package"

return     ;ProgramFOTAUpdtPkg
