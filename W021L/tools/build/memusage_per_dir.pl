#!/usr/bin/perl
# ------------------------------------------------------------------------
# AMSS Memory Usage Tool
# Copyright (c) 2004 QUALCOMM Inc. All Rights Reserved.
# $Header: //depot/asic/qsc1100/tools/build/memusage_per_dir.pl#5 $
#
# - Parses map file and group files and writes memory usage in the
#   named groups out to HTML
# - Groups are of the form:
#   <group name>:: a.o b.o c.o
# - Group names may repeat
# - There must be a space between the :: and the first .o file named
# ------------------------------------------------------------------------
use BuildTools;
use strict;
use Cwd;

my $MapFile = "Unnamed_Map_File";
my $target_dir = "Unnamed_TARGETDIR";
my $Build = "";
my $DescFile  = "";
my $fVerbose = 0;
my $opt_image = "";
my $fHasDescriptions = 0;
my @modem_dirs = ();
my $topLevelDirs;
my @topLevelDirsArr;
my %preCompliedLibsPaths;
my %debugLibs;
my $debug = 0;
my $veneerObj = 'anon$$obj.o';
my $length_2_print = 400;
my $logFile;

if (-e '..\..\GetVUs.log') {
   $logFile = '..\..\GetVUs.log';
}elsif (-e '..\..\syncvulog.txt') {
   $logFile = '..\..\syncvulog.txt';
}else {
   print "Couldnt find GetVUs.log or syncvulog.txt\n";
}

my $path2TopLevel = '..\..';
my $printRamSize = 0;
my $maxRamSize = 0;
my $maxRomSizeAmssPartition= 0;
my $elfFile= "";
my $odir = 0;


# ------------------------------------------------------------------------
# Memory Usage
#   $MemUsage{ object }
#                                    {code}    - number of code bytes
#                                    {ro}      - number of read only bytes
#                                    {rw}      - number of read/write bytes
#                                    {zi}      - number of zero init bytes
#                                    {group}   - normalized group name
#                                    {library} - part of this library
#                                    {visited} -
# ------------------------------------------------------------------------
my %MemUsage = ();

# ------------------------------------------------------------------------
# Memory Group
#   $MemGroup{ group name }{ object name } = object name
#                          {ram}           -  total ram size
#                          {rom}           -  total rom size  
#
# Group Info
#   $GroupInfo{ group name }{ description }
# ------------------------------------------------------------------------
my %MemGroup  = ();
my %GroupInfo = ();


# ------------------------------------------------------------------------
# SUBROUTINE: Usage 
#
# ------------------------------------------------------------------------
sub Usage 
{
   (my $sec, my $min, my $hour, my $mday, my $mon, my $year, my $wday, my $yday, my $isdst) = localtime(time);
   $year += 1900;

   print <<usage;

$0 - Copyright (c) $year QUALCOMM Inc.
   % perl memusage.pl 
                      
                      REQUIRED
                      
                      -mf <MAPFILE> Map file that should be taken as input.
                      -targetdir <TARGETDIR>   - Specify the name of the target dir.
		      
                      
                      OPTIONAL
                      -veneer <anon\$\$obj.o>             - The veneer code generated by the Linker
                      -odir                               - Redirecting mem_qwiki.txt to respective directory
                      -desc <XML file>                    - Specify if you want the description in the output  Specify the XML file that has descriptions.
                      -b <build id>                       - This will be printed in the top of your HTML REPORT
                      -image <GIF FILE>                   - Image that will be inserted into heading of HTML files
                      -v                                  - Verbose output for debugging, Outputs the Object files in each directory and their sizes
                      -printlevel <Depth of Display>      - The Depth to which your directory structure should be displayed in the HTML output
		      -logfile  <GetVus.log>              - Path to GetVus.log file
		      -toplevelpath <PATH>                - Path to topLevel Directories.
		      -warn <MAXRAMSIZE> <MAXROMSIZE>     - Outputs a warning message if the size of Ram Required is Greater than MAXRAMSIZE 
		                                            or the size of ROM required by the AMSS partition is greater than MAXROMSIZE
		      -elf <Path to Elf File>             - Path to the elf file.
		      

   Example:
      % perl $0 -mf SMBRRA.map -targetdir SXBRRA
      % perl $0 -mf SMBRRA.map -targetdir SXBRRA -odir c:\Qwikioutputdir\
      % perl $0 -mf SMBRRA.map -targetdir SXBRRA -warn 67108864 25165824
      % perl $0 -mf SMBRRA.map -targetdir SXBRRA -warn 67108864 25165824 -elf SMRRRRRRR.elf
      % perl $0 -mf SMBRRA.map -targetdir SXBRRA -veneer anonobj.o -desc MSM6800_Descriptions.xml -printlength 5
      % perl $0 -mf SMBRRA.map -targetdir SXBRRA -veneer anonobj.o -desc MSM6800_Descriptions.xml -printlength 5 -image prodshot_msm6100.gif -b M6100CSBTZ5050 -v
      % perl $0 -b q1100ASBNAAL3209 -mf SBNAAL.map -targetdir SXNAAL -image ../doc/prodshot_msq1100.gif -elf bin/SBNAAL/inputimages/amss.mbn > ../doc/q1100ASBNAAL3209.mem.html
   

usage
   return;
} # END Usage


# ------------------------------------------------------------------------
# SUBROUTINE: ProcessCommandLine
#
# ------------------------------------------------------------------------
sub ProcessCommandLine
{
   for( my $i=0; $i<$#ARGV+1; $i++)
   {
      my $arg = $ARGV[$i];
      
      # Name of the map file
      #
      if ( $arg eq "-mf" )
      {
         $i++;
         $MapFile = $ARGV[$i];
      }

      # Required to see if the map file is correct
      elsif( $arg eq "-targetdir" )
      {
         $i++;
         $target_dir = $ARGV[$i];
                  
      }

      elsif( $arg eq "-odir")
      {
         $i++;
         $odir = $ARGV[$i];
      }
      
      # Verbose output
      #
      elsif( $arg eq "-v" )
      {
         $fVerbose = 1;
      }
      
      # Output Description
      #
      elsif( $arg eq "-desc" )
      {
	 $i++;
         $DescFile = $ARGV[$i];	 
         $fHasDescriptions = 1;
      }
      
      # Build ID to name the output file
      #
      elsif( $arg eq "-b" )
      {
         $i++;
         $Build = $ARGV[$i];
      }
      
      # Optional Image Used in HTML Output
      #
      elsif( $arg eq "-image" )
      {
         $i++;
         $opt_image = $ARGV[$i];
      }
      
      # Optional Veneer code     
      elsif( $arg eq "-veneer" )
      {
         $i++;
         $veneerObj = $ARGV[$i];
                  
      }
      
      # The Level of Directory Tree to Print out 
      elsif( $arg eq "-printlevel")
      {
         $i++;
         $length_2_print = $ARGV[$i]; 
      }
      
      # Path to GetVus.log
      elsif( $arg eq "-logfile")
      {
         $i++;
         $logFile = $ARGV[$i]; 
      }
      
      # Path to the toplevel
      elsif( $arg eq "-toplevelpath")
      {
         $i++;
         $path2TopLevel = $ARGV[$i]; 
      }
      # Print Ram Size
      elsif( $arg eq "-warn")
      {
         $printRamSize = 1;
         $i++;
         $maxRamSize = $ARGV[$i];
         $i++;
         $maxRomSizeAmssPartition = $ARGV[$i];
      }
      # Print Ram Size
      elsif( $arg eq "-elf")
      {
         $i++;
         $elfFile = $ARGV[$i]; 
      }
            
   }
      
   if(( $MapFile  eq "Unnamed_Map_File"  ) || ( $target_dir eq "Unnamed_TARGETDIR" ))
   {
      Usage();
      exit;
   }

   return;
} # END ProcessCommandLine

# ------------------------------------------------------------------------
# SUBROUTINE:PrintRamSizeRequired
#
# ------------------------------------------------------------------------
sub PrintRamSizeRequired
{

    my $armroot = $ENV{'ARMROOT'};
    my $path = $ENV{'PATH'};
    $ENV{'PATH'} = "$path\;\$armroot";
    my $op_txt = "op_memusage.txt";
    my $size_infile = 0;
    my $size_inmemory = 0;
    my $size_inram = 0;
    my $size_inrom = 0;
    my $size_dynamic_heap = 0;
    my $hex1=0;
    my $hex2=0;
    my $hex3=0;
    my $hex4=0;
    my $hex5=0;
    
    my @build_id = split(/\./,$MapFile);
    my $build = $build_id[0];
    
    $elfFile = "bin\/$build\/amss\.mbn" if ($elfFile eq "") ;
    
    my $rdelf_cmd = "readelf -l $elfFile > $op_txt";
    system("$rdelf_cmd");

    open(OP_READELF,"$op_txt") || die "Cannot open file $op_txt  \n";

     foreach(<OP_READELF>){

       #LOAD  0x001000 0x033f1000 0x033f1000 0x0c648 0x0d000     0x7c90ee18
       if(/LOAD\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){

        $hex1 = hex($1);
        $hex2 = hex($2);
        $hex3 = hex($3);
        $hex4 = hex($4);
        $hex5 = hex($5);

        $size_infile = $size_infile + $hex4    ;
        $size_inmemory = $size_inmemory + $hex5  ;

        if(($hex3 + $hex5) > $size_inram)
        {
          $size_inram = $hex3 + $hex5;
        }
        
        if(($hex1 + $hex4) > $size_inrom)
        {
           $size_inrom = $hex1 + $hex4;
        }
       
      }

     }


     
     # Calculate the size avaliable for the Dynamic heap here
     # What ever is left over in the RAM is avaliable for DYNAMIC HEAP
     if($maxRamSize > $size_inram){
        $size_dynamic_heap = ($maxRamSize - $size_inram );   
     }
     else{
        $size_dynamic_heap = 0;
     }
     
 print <<mem_title;
      <H3 ALIGN="CENTER">Memory Requirements Summary</H3>
mem_title
 	
  print <<mem_header;
      <table width="50%" border="0" cellspacing="1" cellpadding="10">
mem_header

   print <<mem_entry;
	       <tr bgcolor='#00FF99'> 
		 <td align="left"><p>Total RAM Used </p></td>
		 <td align="right">$size_inram bytes</td>
	       </tr>
mem_entry

    print <<mem_entry;
    	       <tr bgcolor='#00FF99'> 
    		 <td align="left"><p>Total ROM Used</p></td>
    		 <td align="right">$size_inrom bytes</td>
    	       </tr>
mem_entry

# Print the Ideal RAM/ROM Usage Only If verbose is specified.
if ($fVerbose == 1) 
{

    print <<mem_entry;
    	       <tr bgcolor='#00FF99'> 
    		 <td align="left"><p>Total RAM Required(Ideally)</p></td>
    		 <td align="right">$size_inmemory bytes</td>
    	       </tr>
mem_entry

        print <<mem_entry;
    	       <tr bgcolor='#00FF99'> 
    		 <td align="left"><p>Total ROM Required(Ideally)</p></td>
    		 <td align="right">$size_infile bytes</td>
    	       </tr>
mem_entry

}

    print <<mem_entry;
    	       <tr bgcolor='#00FF99'> 
    		 <td align="left"><p>Dynamic Heap Size</p></td>
    		 <td align="right">$size_dynamic_heap bytes</td>
    	       </tr>
mem_entry

 print <<mem_footer;
     </table>
     <p align="left"><strong></strong></p>
   </div>
mem_footer


# Output the warings here
if($size_inram > $maxRamSize){
  
  print STDERR "\n\n\n ******************  WARNING  WARNING   WARNING  WARNING ****************** \n";
  print STDERR "The Size Required By the Image($size_inram) in RAM Exceeds the Max Ram Size ($maxRamSize) Avaliable \n";
  print STDERR "\n\n\n ******************  *********************************** ****************** \n";
}

if($size_infile > $maxRomSizeAmssPartition){

  print STDERR "\n\n\n ******************  WARNING  WARNING   WARNING  WARNING ****************** \n";
  print STDERR "The Size Required By the Amss Image($size_infile) in ROM Exceeds the Max ROM Size ($maxRomSizeAmssPartition) \n";
  print STDERR "Increase the size of Amss Partition in partition.c \n\n";
  print STDERR "\n\n\n ******************  *********************************** ****************** \n";
  
}


} # END PrintRamSizeRequired

# ------------------------------------------------------------------------
# SUBROUTINE: GetTopLevelDirs
# Get the top level directories and store it in the string $topLevelDirs
# ------------------------------------------------------------------------
sub GetTopLevelDirs
{
  my $scriptDir = cwd;
  $topLevelDirs = '(';
  
  chdir $path2TopLevel;
  open STATUS, "ls -d */. |" or die "can't fork: $!";
  
  while (<STATUS>) {
      # remove '\n' and '/.' from output
      chomp;
      s/\/\.//g;
      push(@topLevelDirsArr,$_);
      $topLevelDirs = $topLevelDirs."$_"."|";
  } 
  close STATUS or die "Not able to find top Level Dirs: $! $?";
  
  chdir($scriptDir);
  
  chop $topLevelDirs;
  $topLevelDirs = $topLevelDirs.')';

  # Debug information
  if ($debug == 1)
  {
    print "\n The top level Direcotories are \n";	  
    for(my $i = 0; $i <= $#topLevelDirsArr; $i++)
    {
      print "$topLevelDirsArr[$i]\n";
    }
  } 
}

# ------------------------------------------------------------------------
# SUBROUTINE: ParseGetVusLog
# parses the GetVu's log to get the path to precompiled libs in the build
# ------------------------------------------------------------------------
sub ParseGetVusLog
{
#//depot/asic/msmshared/wlan/oem/phg/libs/wlan_phg_hhal.lib#4 - added as E:\CRMBuilds1\rlynch\M6800ASMBRRA2001_22APR2005_100822am\M6800ASMBRRA2001\wlan\oem\phg\libs\wlan_phg_hhal.lib

#http://www.cs.tut.fi/~jkorpela/perl/course.html#greedy
#Regular expressions are greedy, seeking the longest possible match not the shortest match.
#In Perl 5, it would also be possible to use +? instead of + to request the shortest match to be made
my $libPattern_depot = '\/\/depot\S+\/(\w+\.lib).+?('.$topLevelDirs.'\S+)';
my $libPattern_source = '\/\/source\S+\/(\w+\.lib).+?('.$topLevelDirs.'\S+)';
my $fileLoc = "";
my $lib = "";
my $prePath = '..\..'."\\";

#my $scriptDir = cwd;
#chdir('..\..');
open( LOGFILE, $logFile ) or die "Couldn't open LogFile $logFile\n";
while( <LOGFILE> )
{
  if(/$libPattern_depot/){
         
	 $lib = $1;
 	 $fileLoc = $2;
	 $fileLoc = substr($2,0,-(length($lib) + 1));
	 $fileLoc = "$prePath$fileLoc";
	 $fileLoc =~ s/\//\\/g;
	 $preCompliedLibsPaths{$lib} = $fileLoc;
  } 
  elsif(/$libPattern_source/){
       	 $lib = $1;
 	 $fileLoc = $2;
	 $fileLoc = substr($2,0,-(length($lib) + 1));
	 $fileLoc = "$prePath$fileLoc";
	 $fileLoc =~ s/\//\\/g;
	 $preCompliedLibsPaths{$lib} = $fileLoc;
  }
}
close(LOGFILE);
#chdir($scriptDir);


#Debug for PreCompiled Libraries
if ($debug == 1)
{
  print "\n\n The Precompiled Library Information after parsing GetVus Log is \n";
  foreach my $key (sort keys %preCompliedLibsPaths)
  {
    print "$key   $preCompliedLibsPaths{$key} \n";	   
  }
exit;
}

}


# ------------------------------------------------------------------------
# SUBROUTINE: InitMemUsage
# Parses the entire map file and stores the information in hashes %MemUsage %MemGroup
# ------------------------------------------------------------------------
sub InitMemUsage{

   # Initialize the MemUsage Array with the veneer code
   $MemUsage{$veneerObj}{group} = "VENEER_CODE";
   $MemGroup{"VENEER_CODE"}{$veneerObj} = $veneerObj;

}


# ------------------------------------------------------------------------
# SUBROUTINE: ParseMapFile
# Parses the entire map file and stores the information in hashes %MemUsage %MemGroup
# ------------------------------------------------------------------------
sub ParseMapFile
{
  my $ok_to_look_for_objects     = 0;
  my $ok_to_look_for_filePaths   = 0;
  my $ok_to_look_for_libraries   = 0;
  
  # EXAMPLE:132     0       4       0       8136   ran.o 
  # EXAMPLE:13932   0       0       0        556   sinterp4_ads.obj
  my $MemEntryPattern            = '(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\S+\.(obj|o|lib))';
  
  # EXAMPLE: ..\..\services\rex\rextime.c             0x00000000   Number         0  rextime.o ABSOLUTE
  my $FilePathPattern            = '(\S+)\s+0x00000000\s+Number\s+0\s+(\S+)\s+ABSOLUTE';
  
  # EXAMPLE: vdecoder_mp4.o(qtv_dec_mp4.lib)
  my $ObjLibraryPattern          = '(\S+\.(o|obj|lib))\((\S+\.(lib|l|a))\)';
  
  my $FilePath = "";
  my @FilePathParts;
  my $file = "";
  my $Library = "";
  
  my $mapFileLineNo = 0;
  
  
   # Gather the list of objects that contributed to memory usage in this
   # build.
   
   open( MAPFILE, "<$MapFile\n" ) or die "Couldn't open $MapFile\n";
   while( <MAPFILE> )
   {
   
     $mapFileLineNo++;
         
         #---------------------------------------------------------------------------------------------------
         # Map file should contain the absolute path to the file. If the path is listed as Target dir or libs 
         # report an error and exit. ex SXBRRA/rexarm.i
         #---------------------------------------------------------------------------------------------------
	 #SXBRRA/rexarm.i                          0x00000000   Number         0  rexarm.o ABSOLUTE
	 #SXBRRA\corestartapp.mif.c                0x00000000   Number         0  corestartapp.mif.o ABSOLUTE
	 #if(((/$target_dir.+\s+((\w|\.)+\.o)\s+ABSOLUTE/) || (/libs.+\s+((\w|\.)+\.o)\s+ABSOLUTE/)) && ($ok_to_look_for_filePaths == 1)){
	 
	 if(((/\s+$target_dir\S+\s+0x00000000\s+Number\s+0\s+((\w|\.)+\.o)\s+ABSOLUTE/) || (/\s+libs\S+\s+0x00000000\s+Number\s+0\s+((\w|\.)+\.o)\s+ABSOLUTE/)) && ($ok_to_look_for_filePaths == 1)){
          
	    #Place all the objects whose path is unknown in the UNKNOWN group.
            $MemUsage{$1}{group} = "UNKNOWN";
	    $MemGroup{UNKNOWN}{$1} = $1;
	    next;
            
          # Activate this code when brew fixes the BREWCR.
          #print "\nFATAL ERROR::  line $mapFileLineNo\n\n";
          #print "$_:\n";
          #print "\nMap file should contain the absolute path to the file $1 \n";
          #exit;
         
         }
         
         #---------------------------------------------------------------------------------------------------
         # Look for the string named "Image Component sizes".
         # We should stop searching for libraries start searching for objects srch for $ObjLibraryPattern starts here)
         #---------------------------------------------------------------------------------------------------
         elsif(/Image\scomponent\ssizes/) 
         {
            $ok_to_look_for_objects   = 1;
            $ok_to_look_for_libraries = 0;
            next;
         }
         
         #---------------------------------------------------------------------------------------------------
         # Look for the string named "Local Symbols".
         # We should start looking for File and its path (srch for $FilePathPattern starts here)
         #---------------------------------------------------------------------------------------------------
         elsif(/Local\sSymbols/)
         {
            $ok_to_look_for_filePaths = 1;
            next;
         }  
         
         
         #---------------------------------------------------------------------------------------------------
         # Look for the string named "Memory Map of the image".
         # We should start looking for objects and the libraries they belong to here (srch for $ObjLibraryPattern starts here)
         #---------------------------------------------------------------------------------------------------
	 elsif(/Memory\sMap\sof\sthe\simage/)
	 {
	     $ok_to_look_for_filePaths = 0;
	     $ok_to_look_for_libraries = 1;
	     next;
	                   
         }

         #---------------------------------------------------------------------------------------------------
         # Code    RO Data    RW Data    ZI Data      Debug   Library Member Name
         # If we encounter the above string, we stop looking for objects
         #---------------------------------------------------------------------------------------------------
         elsif( /Code\s+RO Data\s+RW Data\s+ZI Data\s+Debug\s+Library\s+Name/ )  
         {
            $ok_to_look_for_objects = 0;
            next;
         }
           #elsif( /Code(.*)\s+RO Data\s+RW Data\s+ZI Data\s+Debug\s+Library\s+Member/ )  
         elsif( /Code \(inc\. data\)\s+RO Data\s+RW Data\s+ZI Data\s+Debug\s+Library\s+Member/ )  
         {
            $ok_to_look_for_objects = 0;
            next;
         }
	 
         
         
         #---------------------------------------------------------------------------------------------------
         # If line matches $FilePathPattern,Extract the path part of total path and if the path starts with 
         # any of the top level directories add the file to %MemGroup  and update the group for file in MemUsage
         #---------------------------------------------------------------------------------------------------
         elsif((/$FilePathPattern/) && ($ok_to_look_for_filePaths  == 1))
         {  
                        
            $file = $2; 
	    $FilePath = lc($1);
	    $FilePath =~ /(\S+)(\\|\/)((\w|\.)+\.(cpp|c|i))/;
	    $FilePath = $1;
	    $FilePath =~ s/\//\\/g;
            @FilePathParts = split(/\\/,$FilePath);

	   	               
            # Only the files that are compiled as a part of build have $topLevelDirs in their path
            # Files part of precompiled libs do not have $topLevelDirs in their path
	    if(( $FilePathParts[2] =~ /$topLevelDirs/ ) && (scalar(@FilePathParts) > 2))
	    {
                $MemUsage{$file}{group} = $FilePath;
	        $MemGroup{$FilePath}{$file} = $file;
            }  
                 
         }
         
         #---------------------------------------------------------------------------------------------------
         # If line matches $ObjLibraryPattern, See the group for file in %MemUsage. The only time we wont be able to 
         # get a group for a file is, if it is part of a precompiled library. There should exist an entry for precompiled library in 
         # %MemGroup, add the file to the precompiled library group.
         #---------------------------------------------------------------------------------------------------
         elsif((/$ObjLibraryPattern/) && ($ok_to_look_for_libraries == 1))
	 {
	    $file = $1;
	    $Library = $3;

	    # Since we have the path to the precompiled library, once we know that the file is a part of 
	    # a precompiled library we place the file in the same group as the precompiled library    
	    if(!defined $MemUsage{$file})
	    {
      
      
	       # If the file satisfies this condition then its a part of ARM Library or Mango Library
               if(!defined $preCompliedLibsPaths{$Library})
	       {
                  if($Library =~ m/Mng-\w+\.lib/i) {
                     $FilePath = "MANGOLIBRARY";
                  }else{
                     $FilePath = "ARMLIBRARY";
                  }
	              
	       }else{	     
	          $FilePath = $preCompliedLibsPaths{$Library};
               }
	       
      
	       $MemUsage{$file}{group} = $FilePath;
               $MemGroup{$FilePath}{$file} = $file;               
	       $debugLibs{$Library}{group} = $FilePath;
             
	       
	    }
	    elsif($MemUsage{$file}{library} eq "" )
	    {
	    	$MemUsage{$file}{library} = $Library;
	    }  
	           
         }
         
         #---------------------------------------------------------------------------------------------------
         # If line matches $MemEntryPattern, Update object's ro, rw, code and zi sizes in %MemUsage
         #---------------------------------------------------------------------------------------------------
         elsif((/$MemEntryPattern/) && ($ok_to_look_for_objects  == 1))
	 {
	             
	     if( $6 ne "" )
	     {
	       # If it matches the memory pattern it has to definately be in the memusage array
	       # else its an error, this is just a cross check
	       if(defined $MemUsage{$6})
	       {
		$MemUsage{$6}{code} = $1;
  		$MemUsage{$6}{ro}   = $2;
		$MemUsage{$6}{rw}   = $3;
		$MemUsage{$6}{zi}   = $4;
	       } 
               else{
	         print "ERROR:: $6 found in the Memory Pattern but not in MemUsage \n";	       
		 exit;
	       }	 
	     }  
	             
         }
         
            
   
   }
   close( MAPFILE );

   return;
} # END ParseMapFile


# ------------------------------------------------------------------------
# SUBROUTINE: Calculates the size of each group and stores in %MemGroup
#
# ------------------------------------------------------------------------
sub CalculateGroupSizes
{

my $code = 0;
my $data = 0;
my $this_obj_rom_size = 0;
my $this_obj_ram_size = 0;
my $object = 0;
my $group = "";
  
  #Calculate the size of each group
  #
  foreach $group (sort keys %MemGroup)
  {
        $code = 0;
        $data = 0;
                
        foreach $object (sort keys %{ $MemGroup{$group} } )
        {

	   # print STDERR "object=$object\n";
           if( !exists $MemUsage{ $object } )
           {
              print "FATAL ERROR: $object not in MemUsage\n";
              exit;
           }
  
           if( $MemUsage{ $object }{ visited } == 2 )
           {
                 print "FATAL ERROR: Already accounted for $object\n";
                 exit;
              
           }
     
           $MemUsage{ $object }{ visited } = 2;
     
           $code += ($MemUsage{$object}{code} + $MemUsage{$object}{ro} + $MemUsage{$object}{rw});
           $data += ($MemUsage{$object}{rw}   + $MemUsage{$object}{zi});
     
                      
        }
        
        # Store the code and data here 
        $MemGroup{$group}{rom} = $code;
        $MemGroup{$group}{ram} = $data;
     
    }
    
    
return;

}

# ------------------------------------------------------------------------
# SUBROUTINE: ReadDescriptionInfo
#
# ------------------------------------------------------------------------
sub ReadDescriptionInfo
{

  if( $fHasDescriptions == 1 )
  {     
        %GroupInfo = AMSSBuildTools::ParseXMLgroupFile($DescFile);
  }
  
return;

}

# ------------------------------------------------------------------------
# SUBROUTINE: WriteMemoryTable
#
# ------------------------------------------------------------------------
sub WriteMemoryTable
{
   my $DescHeading = "";
   my $this_description = "";
   my $DescField = "";
   my $tot_rom = 0;
   my $tot_ram = 0;
   my $tot_rw  = 0;
   my $this_obj_rom_size = 0;
   my $this_obj_ram_size = 0;
   my $object = "";
   my $object2 = "";
   my @GroupPath = ();
   my $srch_string = '..\..';
   my %SRCHSTRINGS;
   my $this_group_rom = 0;
   my $this_group_ram = 0;
   my $srch_group = "";
   my $str_len = 0;
   my $print_str_len = 0;
   my $sub_str = "";
   my $srch_string2 = "";
   my $group = "";
   my %MemGroup2 = %MemGroup;
   my $this_group_printed = 0;
   my $brew_mem_rom = 0;
   my $brew_mem_ram = 0;
   my $apps_mem_rom = 0;
   my $apps_mem_ram = 0;
   my $ui_mem_rom = 0;
   my $ui_mem_ram = 0;
   my $mod_mem_rom = 0;
   my $mod_mem_ram = 0;
   my $WIKIDATA = "";
   my $WIKITAB = "";
   my $WIKIDETAILS = "";
 
  
   # Satya added for Qwiki output
   my $qwikifile = "mem_qwiki.txt";

   if($odir)
   {
      open( WIKIFILE, ">$odir\\$qwikifile\n" ) or die "Couldn't open $qwikifile\n";
   }
   else 
   {
      open( WIKIFILE, ">$qwikifile\n" ) or die "Couldn't open $qwikifile\n";
   }

   
  
   
    
   if( $fHasDescriptions == 1 )
   {
      $DescHeading = "<td><div align=\"center\"><strong>Description<\/strong><\/div><\/td>";
   }
   
   print <<mem_title;
         <H3 ALIGN="CENTER">AMSS Memory Requirements</H3>
mem_title

   print <<mem_header;
     <div align="center">
     <table width="50%" border="0" cellspacing="1" cellpadding="10">
       <tr bgcolor="996699"> 
         <td><div align="center"><strong>Group</strong></div></td>
         <td><div align="center"><strong>RAM</strong></div></td>
         <td><div align="center"><strong>ROM</strong></div></td>
         $DescHeading
       </tr>
mem_header
   
   $WIKIDATA .= "<table>";
   $WIKIDATA .= "<tr><td><strong>AMSS Memory Requirements</strong></td></tr>";
   $WIKIDATA .= "<tr><td><strong>Group</strong></td>";
   $WIKIDATA .= "<td><strong>RAM</strong></td>";
   $WIKIDATA .= "<td><strong>ROM</strong></td></tr>";
   
   foreach $group (sort keys %MemGroup)
   {
      
      $this_obj_rom_size = 0;
      $this_obj_ram_size = 0;
      $this_group_printed = 0;
      
      # Get the description info here
      if( exists $GroupInfo{ lc( $group ) } )
      {
            $this_description = $GroupInfo{ lc( $group ) };
      }
      else
      {
            $this_description = "";
      }

      if( $fHasDescriptions == 1 )
      {
          $DescField = "<td align='left'>$this_description<\/td>";
      }
      else
      { 
	 $DescField = "";
      }	 
      
      
      #Get the branched logic here
      @GroupPath = split(/\\/,$group);
      $srch_string = '..\..'."\\";
      
      for(my $i = 2; $i <= $#GroupPath; $i++){
         
         $srch_string = $srch_string.$GroupPath[$i]."\\";
         
        
	 $this_group_rom = 0;
         $this_group_ram = 0;
         $str_len = length $srch_string;
         
         if($SRCHSTRINGS{$srch_string}{value} eq ""){
	      
	      $SRCHSTRINGS{$srch_string}{value} = 1;
	              
	      #Search for the entities with $srch_string in %MemGroup
	      foreach $srch_group (sort keys %MemGroup2)
	      {
	        $sub_str = substr($srch_group,0,$str_len);
	        
		if($sub_str eq $srch_string){
		
		  $this_group_rom = $this_group_rom + $MemGroup2{$srch_group}{rom};
		  $this_group_ram = $this_group_ram + $MemGroup2{$srch_group}{ram};
		  	
		}  

	      }
	      
	   if(($this_group_rom != 0) || ($this_group_ram != 0)){  
	   
	   $srch_string2 = $srch_string;
	   chop $srch_string2;
	   $this_group_rom = $this_group_rom + $MemGroup2{$srch_string2}{rom};
	   $this_group_ram = $this_group_ram + $MemGroup2{$srch_string2}{ram};
	   
	   #Store size of the group, later used in MODEM SIZE CALCULATION
	   $SRCHSTRINGS{$srch_string}{rom} =  $this_group_rom;
	   $SRCHSTRINGS{$srch_string}{ram} =  $this_group_ram;
	   
	   #print the group entry into HTML here
	   $print_str_len = split(/\\/,$srch_string);
           # substracting the ..\.. from the length  
	   $print_str_len = ($print_str_len - 2);

	   #print "$srch_string $print_str_len\n";
	   
	   if($print_str_len <= $length_2_print)
	   {
	    print <<mem_group;
	       <tr bgcolor='#00FF99'> 
		 <td align="left"><p>$srch_string</p></td>
		 <td align="right">$this_group_ram</td>
		 <td align="right">$this_group_rom</td>
                 <td align="right"></td>
	       </tr>
mem_group
            $WIKIDATA .= "<tr>";
            $WIKIDATA .= "<td>$srch_string</td>";
            $WIKIDATA .= "<td>$this_group_ram</td>";
            $WIKIDATA .= "<td>$this_group_rom</td>";
            if ($srch_string =~ /platform\\brew\\$/ || $srch_string =~ /asic\\apps\\staticextensions\\$/ ) 
            {
               $brew_mem_rom += $this_group_rom;
               $brew_mem_ram += $this_group_ram;
               #print "BREW $srch_string \t RAM: $this_group_ram \t ROM: $this_group_rom\n";
            }
            if ($srch_string =~ /platform\\3gui\\$/ || $srch_string =~ /qtv\\apps\\$/ || $srch_string =~ /camera\\apps\\$/ || $srch_string =~ /wms\\wmsapp\\$/ || $srch_string =~ /bthost\\brew\\statapp\\$/ ) 
            {
               $ui_mem_rom += $this_group_rom;
               $ui_mem_ram += $this_group_ram;
               #print "UI $srch_string \t RAM: $this_group_ram \t ROM: $this_group_rom\n";
            }
           }
          }
        }     
     }
           
     
   
      # Print the group and the ROM and RAM sizes here
      $print_str_len = split(/\\/,$group);
      $print_str_len = ($print_str_len - 2);
      if($print_str_len <= $length_2_print)
      {
       $this_group_printed = 1;	      
      print <<mem_entry;
           <tr bgcolor='#CCFFFF'> 
             <td align="left">$group</td>
             <td align="right">$MemGroup{$group}{ram}</td>
             <td align="right">$MemGroup{$group}{rom}</td>
           $DescField
           </tr>
mem_entry
      $WIKIDATA .= "<tr>";
      $WIKIDATA .= "<td>$group</td>";
      $WIKIDATA .= "<td>$MemGroup{$group}{ram}</td>";
      $WIKIDATA .= "<td>$MemGroup{$group}{rom}</td>";
      }
      

      # Print the Objects if the verbose flag is turned on
      foreach $object (sort keys %{ $MemGroup{$group} } )
      {
       if(($object eq "ram") || ($object eq "rom")){
                 next;
       }
       $tot_rw += $MemUsage{$object}{rw};

	  # Print each object if the verbose flag is turned on.
	  if(( $fVerbose == 1 ) && ( $this_group_printed == 1))
	  {
	      $this_obj_rom_size     = $MemUsage{$object}{code} + $MemUsage{$object}{ro} + $MemUsage{$object}{rw};
	      $this_obj_ram_size     = $MemUsage{$object}{rw}   + $MemUsage{$object}{zi};

	      print <<mem_object;
	       <tr> 
		 <td><blockquote><p>$object</p></blockquote></td>
		 <td align="right">$this_obj_ram_size</td>
		 <td align="right">$this_obj_rom_size</td>
	       </tr>
mem_object
          }
               
      
      }
      
      $tot_ram += $MemGroup{$group}{ram};
      $tot_rom += $MemGroup{$group}{rom};
   }
   

   
   
   print <<mem_total;
       <tr bordercolor="#666666"> 
         <td><strong>TOTAL</strong></td>
         <td><strong>$tot_ram</strong></td>
         <td><strong>$tot_rom</strong></td>
       </tr>
mem_total
   
   $WIKIDATA .= "<tr><br>";
   $WIKIDATA .= "<td><strong>Total</strong></td><br>";
   $WIKIDATA .= "<td><strong>$tot_ram</strong></td><br>";
   $WIKIDATA .= "<td><strong>$tot_rom</strong></td><br>";
   
   
   print <<mem_footer;
     </table>
     <p align="left"><strong></strong></p>
   </div>
mem_footer
   
   my $tot_phys_rom = $tot_rom;
   my $tot_ro_data = $tot_rom - $tot_rw;
   print <<physical_memory_table;
   <div align="center">
     <table bgcolor="#CCFFFF" width="40%" border="1" cellspacing="0" cellpadding="0">
       <tr>
         <td><strong>Total RO  Size(Code + RO Data)</strong></td>
         <td bgcolor="#CCFFFF">$tot_ro_data</td>
       </tr>
       <tr>
         <td><strong>Total RW  Size(RW Data + ZI Data)</strong></td>
         <td bgcolor="#CCFFFF">$tot_ram</td>
       </tr>
       <tr >
         <td><strong>Total ROM Size(Code + RO Data + RW Data)</strong></td>
         <td bgcolor="#CCFFFF">$tot_phys_rom</td>
       </tr>
     </table><br>
   </div>
physical_memory_table

WriteAUMemoryTable();

 $WIKITAB .= "</table>";
   $WIKITAB .= "<table>";
   $WIKITAB .= "<tr><td><strong>Top-Level Categories</strong></td>";
   $WIKITAB .= "<td><strong>RAM</strong></td>";
   $WIKITAB .= "<td><strong>ROM</strong></td></tr>";
  # print WIKIFILE "<tr><tr><tr>";
   $WIKITAB .= "<tr><td><strong>BREW, BUIW + Static Extension</strong></td>";
   $WIKITAB .= "<td>$brew_mem_ram</td>";
   $WIKITAB .= "<td>$brew_mem_rom</td></tr>";
   $WIKITAB .= "<tr><td><strong>UI + Reference BREW Apps</strong></td>";
   $WIKITAB .= "<td>$ui_mem_ram</td>";
   $WIKITAB .= "<td>$ui_mem_rom</td></tr>";
   $WIKITAB .= "<tr><td><strong>Others</strong></td>";
   $mod_mem_ram = $tot_ram - $ui_mem_ram - $brew_mem_ram;
   $mod_mem_rom = $tot_rom - $ui_mem_rom - $brew_mem_rom;
   $WIKITAB .= "<td>$mod_mem_ram</td>";
   $WIKITAB .= "<td>$mod_mem_rom</td></tr>";
   $WIKITAB .= "</tr>";
   $WIKITAB .= "</table><br>";

   $WIKIDETAILS = $WIKITAB . $WIKIDATA;
   print WIKIFILE $WIKIDETAILS;

   return;
   
} # END WriteMemoryTable


# ------------------------------------------------------------------------
# SUBROUTINE: WriteAUMemoryTable
#
# ------------------------------------------------------------------------
sub WriteAUMemoryTable
{

my $tempramasic=0;
my $tempromasic=0;
my $tempramcore=0;
my $tempromcore=0;
my $temprammodem=0;
my $temprommodem=0;
my $temprammm=0;
my $temprommm=0;
my $tempramplatform=0;
my $tempromplatform=0;
my $tempramwconnect=0;
my $tempromwconnect=0;
my $total_rom=0;
my $total_ram=0;
my $group = "";

foreach $group (sort keys %MemGroup)
   {
     if($group =~ m/\.\\asic\\/i)
      {
         $tempramasic += $MemGroup{$group}{ram};
         $tempromasic += $MemGroup{$group}{rom};
  
      }
      if($group =~ m/\.\\core\\/i)
      {
         $tempramcore += $MemGroup{$group}{ram};
         $tempromcore += $MemGroup{$group}{rom};
  
      }
      if($group =~ m/\.\\modem\\/i)
      {
         $temprammodem += $MemGroup{$group}{ram};
         $temprommodem += $MemGroup{$group}{rom};
  
      }
      if($group =~ m/\.\\multimedia\\/i)
      {
         $temprammm += $MemGroup{$group}{ram};
         $temprommm += $MemGroup{$group}{rom};
  
      }
      if($group =~ m/\.\\platform\\/i)
      {
         $tempramplatform += $MemGroup{$group}{ram};
         $tempromplatform += $MemGroup{$group}{rom};
  
      }
      if($group =~ m/\.\\wconnect\\/i)
      {
         $tempramwconnect += $MemGroup{$group}{ram};
         $tempromwconnect += $MemGroup{$group}{rom};
  
      }

}

$total_ram=$tempramasic+$tempramcore+$temprammodem+$temprammm+$tempramplatform+$tempramwconnect;
$total_rom=$tempromasic+$tempromcore+$temprommodem+$temprommm+$tempromplatform+$tempromwconnect;

print <<physical_table;
   <div align="center">
     <table bgcolor="#CCFFFF" width="40%" border="1" cellspacing="0" cellpadding="0">
     <tr bgcolor="996699"> 
         <td><strong>Group</strong></td>
         <td><strong>RAM</strong></td>
         <td><strong>ROM</strong></td>
       </tr>
       <tr>
         <td><strong>Asic</strong></td>
         <td bgcolor="#CCFFFF">$tempramasic</td>
         <td bgcolor="#CCFFFF">$tempromasic</td>
       </tr>
       <tr>
         <td><strong>Core</strong></td>
         <td bgcolor="#CCFFFF">$tempramcore</td>
         <td bgcolor="#CCFFFF">$tempromcore</td>
       </tr>
        <tr>
         <td><strong>Modem</strong></td>
         <td bgcolor="#CCFFFF">$temprammodem</td>
         <td bgcolor="#CCFFFF">$temprommodem</td>
       </tr>
       <tr>
         <td><strong>Multimedia</strong></td>
         <td bgcolor="#CCFFFF">$temprammm</td>
         <td bgcolor="#CCFFFF">$temprommm</td>
       </tr>
       <tr>
         <td><strong>Platform</strong></td>
         <td bgcolor="#CCFFFF">$tempramplatform</td>
         <td bgcolor="#CCFFFF">$tempromplatform</td>
       </tr>
       <tr>
         <td><strong>Wconnect</strong></td>
         <td bgcolor="#CCFFFF">$tempramwconnect</td>
         <td bgcolor="#CCFFFF">$tempromwconnect</td>
       </tr>
       <tr>
         <td><strong>Total</strong></td>
         <td bgcolor="#CCFFFF">$total_ram</td>
         <td bgcolor="#CCFFFF">$total_rom</td>
       </tr>
     </table>
   </div>
physical_table

 return;
}

# ------------------------------------------------------------------------
# SUBROUTINE: HTML_Header
#
# ------------------------------------------------------------------------
sub HTML_Header
{

 AMSSBuildTools::HTML_FileHeader("STDOUT","Memory Usage",$Build,$opt_image);
 
} # END HTML_Header

# ------------------------------------------------------------------------
# SUBROUTINE: HTML_Footer
#
# ------------------------------------------------------------------------
sub HTML_Footer
{
   print "</body>\n";
   print "</html>\n";
   return;
} # END HTML_Footer

# ------------------------------------------------------------------------
# SUBROUTINE: Debug
#
# ------------------------------------------------------------------------
sub debug
{
my $tot = 0;
my $tot_code = 0;
my $tot_ro = 0;
my $tot_rw = 0;
my $tot_zi = 0;

while ((my $key,my $value) = each(%MemUsage))
#while ((my $key,my $value) = each(%debugLibs))
{
	   
	# print "$key $debugLibs{$key}{rom} $debugLibs{$key}{ram} \n";
	   #if($value->{'visited'} eq 3){
	   $tot_code += $value->{code};
	   $tot_ro += $value->{ro};
	   $tot_rw += $value->{rw};
	   $tot_zi += $value->{zi};
	   #}
	   #print "$key is            $value->{'visited'} \n";
	   #if($value->{'visited'} ne 2){
		  # print "$key $value->{'visited'} \n";
	   #}
	
}

#print "total code is $tot_code \n total ro is $tot_ro \n total rw is $tot_rw \n total ZI is $tot_zi \n";

#exit;

my $tot_rom = 0;
my $tot_ram = 0;

foreach my $group (sort keys %MemGroup)
{
   
  $tot_rom += $MemGroup{$group}{rom};
  $tot_ram += $MemGroup{$group}{ram};

}

print "total ram = $tot_ram ; total rom = $tot_rom \n";

exit;


}

# ------------------------------------------------------------------------
# MAIN SCRIPT
#
# ------------------------------------------------------------------------
ProcessCommandLine();
GetTopLevelDirs();
ParseGetVusLog();
InitMemUsage();
ParseMapFile();
CalculateGroupSizes();
#debug();
ReadDescriptionInfo();
HTML_Header();

if($printRamSize == 1){
    PrintRamSizeRequired();
}

WriteMemoryTable();
HTML_Footer();
