


ARM Macro Assembler    Page 1 


    1 00000000         ;*====*====*====*====*====*====*====*====*====*====*====
                       *====*====*====*====*
    2 00000000         ;
    3 00000000         ;     B O O T  U T I L  A S S E M B L Y
    4 00000000         ;
    5 00000000         ; GENERAL DESCRIPTION
    6 00000000         ;
    7 00000000         ; EXTERNALIZED SYMBOLS
    8 00000000         ;   _memset
    9 00000000         ;   _memset_w
   10 00000000         ;   __rt_memclr
   11 00000000         ;   __rt_memclr_w
   12 00000000         ;   __aeabi_memset
   13 00000000         ;   __aeabi_memclr
   14 00000000         ;   __aeabi_memclr4
   15 00000000         ;   __aeabi_memclr8
   16 00000000         ;   qmemset
   17 00000000         ;   
   18 00000000         ; INITIALIZATION AND SEQUENCING REQUIREMENTS
   19 00000000         ;
   20 00000000         ; Copyright (c) 2007 by QUALCOMM, Incorporated.All Right
                       s Reserved.
   21 00000000         ;*====*====*====*====*====*====*====*====*====*====*====
                       *====*====*====*====*
   22 00000000         ;*====*====*====*====*====*====*====*====*====*====*====
                       *====*====*====*====*
   23 00000000         ;
   24 00000000         ;                           EDIT HISTORY FOR FILE
   25 00000000         ;
   26 00000000         ; This section contains comments describing changes made
                        to the module.
   27 00000000         ; Notice that changes are listed in reverse chronologica
                       l order.
   28 00000000         ;
   29 00000000         ; $Header: 
   30 00000000         ;
   31 00000000         ; when       who     what, where, why
   32 00000000         ; --------   ---     -----------------------------------
                       ---------------------
   33 00000000         ; 12/03/07   MJS     Ported from Raptor2 QSD8x50 PBL.
   34 00000000         ;*====*====*====*====*====*====*====*====*====*====*====
                       *====*====*====*====*
   35 00000000         ;=======================================================
                       =====================
   36 00000000         ;
   37 00000000         ;                            MODULE INCLUDES
   38 00000000         ;
   39 00000000         ;=======================================================
                       =====================
   40 00000000         ;=======================================================
                       =====================
   41 00000000         ;
   42 00000000         ;                             MODULE DEFINES
   43 00000000         ;
   44 00000000         ;=======================================================
                       =====================
   45 00000000         ;=======================================================
                       =====================
   46 00000000         ;



ARM Macro Assembler    Page 2 


   47 00000000         ;                             MODULE IMPORTS
   48 00000000         ;
   49 00000000         ;=======================================================
                       =====================
   50 00000000         ;=======================================================
                       =====================
   51 00000000         ;
   52 00000000         ;                             MODULE EXPORTS
   53 00000000         ;
   54 00000000         ;=======================================================
                       =====================
   55 00000000         ; Export the symbols defined in this module
   56 00000000                 EXPORT  _memset
   57 00000000                 EXPORT  _memset_w
   58 00000000                 EXPORT  __rt_memclr
   59 00000000                 EXPORT  __rt_memclr_w
   60 00000000                 EXPORT  __aeabi_memset
   61 00000000                 EXPORT  __aeabi_memclr
   62 00000000                 EXPORT  __aeabi_memclr4
   63 00000000                 EXPORT  __aeabi_memclr8
   64 00000000                 EXPORT  qmemset
   65 00000000         ;=======================================================
                       =====================
   66 00000000         ;
   67 00000000         ;                             MODULE DATA AREA
   68 00000000         ;
   69 00000000         ;=======================================================
                       =====================
   70 00000000                 PRESERVE8
   71 00000000                 AREA    BOOT_UTIL_ASM, CODE, READONLY
   72 00000000                 CODE32
   73 00000000         ;=======================================================
                       ===============
   74 00000000         ;
   75 00000000         ; void __aeabi_memset(void *dst, uint32 size, uint8 c)
   76 00000000         ; void __aeabi_memclr(uint32 *dst, uint32 size)
   77 00000000         ; void __aeabi_memclr4(uint32 *dst, uint32 size)
   78 00000000         ; void __aeabi_memclr8(uint64 *dst, uint32 size)
   79 00000000         ; void __rt_memclr(uint32 *dst, uint32 size)
   80 00000000         ; void __rt_memclr_w(uint32 *dst, uint32 size)
   81 00000000         ;
   82 00000000         ; Fast replacement for C library memset(), optimized usi
                       ng the stm
   83 00000000         ; instruction to generate INCR8 AXI transactions, and re
                       placing all
   84 00000000         ; 8-bit memory accesses with 32-bit accesses.
   85 00000000         ; 
   86 00000000         ; Parameters:
   87 00000000         ;   r0 contains the destination address
   88 00000000         ;   r1 is the size in bytes to be set or cleared
   89 00000000         ;   r2 is the byte pattern to fill the destination memor
                       y
   90 00000000         ;
   91 00000000         ;=======================================================
                       ===============
   92 00000000         ;
   93 00000000         ; void qmemset(uint32 *dst, uint32 val, uint32 len)
   94 00000000         ; 
   95 00000000         ; Parameters:



ARM Macro Assembler    Page 3 


   96 00000000         ;   r0 contains the destination address
   97 00000000         ;   r1 is the byte pattern to fill the destination memor
                       y
   98 00000000         ;   r2 is the size in bytes to be set
   99 00000000         ;
  100 00000000         ;=======================================================
                       ===============
  101 00000000         qmemset
  102 00000000         ; Re-arrange the parameters AND
  103 00000000         ; Fill the 32-bit value with the byte pattern that we wa
                       nt to set
  104 00000000 E20130FF        and     r3, r1, #0xFF
  105 00000004 E1A01002        mov     r1, r2
  106 00000008 E1832403        orr     r2, r3, r3, lsl #0x08
  107 0000000C E1822802        orr     r2, r2, r2, lsl #0x10
  108 00000010 EAFFFFFE        b       _memset_entry
  109 00000014         __aeabi_memset
  110 00000014         ; Fill the 32-bit value with the byte pattern that we wa
                       nt to set
  111 00000014 E20230FF        and     r3, r2, #0xFF
  112 00000018 E1832403        orr     r2, r3, r3, lsl #0x08
  113 0000001C E1822802        orr     r2, r2, r2, lsl #0x10
  114 00000020 EAFFFFFE        b       _memset_entry
  115 00000024         __rt_memclr
  116 00000024         __rt_memclr_w
  117 00000024         __aeabi_memclr
  118 00000024         __aeabi_memclr4
  119 00000024         __aeabi_memclr8
  120 00000024         ; If the compiler tells us we are doing a memclr then in
                       itialize the
  121 00000024         ; byte pattern to 0
  122 00000024 E3A02000        mov     r2, #0
  123 00000028         _memset
  124 00000028         _memset_w
  125 00000028         _memset_entry
  126 00000028         ; First test if the destination is unaligned and do an i
                       nitial unaligned
  127 00000028         ; access if so
  128 00000028 E2103003        ands    r3, r0, #3
  129 0000002C 1AFFFFFE        bne     _memset_first_unaligned_bytes
  130 00000030         ; Else test if the total remaining bytes to set is less 
                       than a word,
  131 00000030         ; and if so just set the last bytes
  132 00000030 E3510004        cmp     r1, #4
  133 00000034 3AFFFFFE        bcc     _memset_last_uneven_bytes
  134 00000038         _memset_main
  135 00000038         ; Store the work registers on the stack, store 8 registe
                       rs so we can
  136 00000038         ; do this with a single burst transfer
  137 00000038 E92D0FF0        stmdb   r13!,{r4-r11}
  138 0000003C         ; Initialize all the work registers to the byte pattern
  139 0000003C E1A03002        mov     r3, r2
  140 00000040 E1A04002        mov     r4, r2
  141 00000044 E1A05002        mov     r5, r2
  142 00000048 E1A06002        mov     r6, r2
  143 0000004C E1A07002        mov     r7, r2
  144 00000050 E1A08002        mov     r8, r2
  145 00000054 E1A09002        mov     r9, r2
  146 00000058         ; We will transfer 8 words at a time, so subtract 32 fro



ARM Macro Assembler    Page 4 


                       m the total
  147 00000058         ; and set the flags
  148 00000058 E2511020        subs    r1, r1, #0x20
  149 0000005C         _memset_loop
  150 0000005C         ; If the total is still non-negative then write 8 words 
                       to memory
  151 0000005C 28A003FC        stmcsia r0!, {r2-r9}
  152 00000060         ; Subtract 32 from the total again, do this twice in the
                        main loop 
  153 00000060         ; to avoid delays due to pipeline flushing in the tight 
                       loop
  154 00000060 22511020        subcss  r1, r1, #0x20
  155 00000064 28A003FC        stmcsia r0!, {r2-r9}
  156 00000068 22511020        subcss  r1, r1, #0x20
  157 0000006C         ; If the total is still non-negative then transfer more 
                       
  158 0000006C 2AFFFFFE        bcs     _memset_loop
  159 00000070         ; Now shift out the total 28 places, even though the tot
                       al went negative
  160 00000070         ; the lower 5 bits represent the number of bytes still t
                       o transfer, and
  161 00000070         ; by shifting by 28 bit 4 goes into the carry bit and bi
                       t 3 becomes the 
  162 00000070         ; sign bit
  163 00000070 E1B01E01        movs    r1, r1, lsl #0x1C
  164 00000074 28A0003C        stmcsia r0!, {r2-r5}
  165 00000078 48A0000C        stmmiia r0!, {r2-r3}
  166 0000007C         ; Now shift the total out 2 more bits, bit 2 of the tota
                       l is now the carry
  167 0000007C         ; bit and bit 1 is now the sign bit
  168 0000007C E1B01101        movs    r1, r1, lsl #2
  169 00000080 28A00004        stmcsia r0!, {r2}
  170 00000084         ; We can restore the work registers now
  171 00000084 E8BD0FF0        ldmia   r13!,{r4-r11}
  172 00000088         ; If bits 1 and 0 are zero then we are done
  173 00000088 012FFF1E        bxeq    lr
  174 0000008C         ; Otherwise shift the total back to the right
  175 0000008C E1A01F21        mov     r1, r1, lsr #0x1E
  176 00000090         _memset_last_uneven_bytes
  177 00000090         ; Take the number of bytes left to copy in r1, multiply 
                       by 8, and then
  178 00000090         ; shift our mask by that amount
  179 00000090 E1A01181        mov     r1, r1, LSL #3 ; Multiply by 8 bits per 
                                                   byte
  180 00000094 E3E0C000        ldr     r12, =0xFFFFFFFF
  181 00000098 E1A0C11C        mov     r12, r12, LSL r1
  182 0000009C         ; Load the first partial word from memory, mask out the 
                       part that will be
  183 0000009C         ; set, mask out the part of the memset value that we wil
                       l use set the
  184 0000009C         ; memory, OR the values together and then store back to 
                       memory
  185 0000009C E5903000        ldr     r3, [r0]
  186 000000A0 E003300C        and     r3, r3, r12
  187 000000A4 E1C2C00C        bic     r12, r2, r12
  188 000000A8 E183300C        orr     r3, r3, r12
  189 000000AC E5803000        str     r3, [r0]
  190 000000B0 E12FFF1E        bx      lr
  191 000000B4         _memset_first_unaligned_bytes



ARM Macro Assembler    Page 5 


  192 000000B4         ; r3 has the unaligned offset into the first word, subtr
                       act from
  193 000000B4         ; r0 to get an aligned pointer, subtract (4 minus this v
                       alue) from 
  194 000000B4         ; the total size to transfer; set the flags in case the 
                       total size 
  195 000000B4         ; just went went negative
  196 000000B4 E0400003        sub     r0, r0, r3
  197 000000B8 E0811003        add     r1, r1, r3
  198 000000BC E2511004        subs    r1, r1, #4
  199 000000C0         ; load the full 32-bit mask for memclr of partial word
  200 000000C0 E3E0C000        ldr     r12, =0xFFFFFFFF
  201 000000C4         ; r3 has unaligned offset, multiply this by 8 and then s
                       hift the mask
  202 000000C4         ; by this amount
  203 000000C4 E1A03183        mov     r3, r3, LSL #3 ; Multiply by 8 bits per 
                                                   byte
  204 000000C8 E1A0C31C        mov     r12, r12, LSL r3
  205 000000CC         ; If the total size went negative, the negative of r1 no
                       w has the number
  206 000000CC         ; of extra bytes that would be copied if we copied all t
                       he bytes to the end
  207 000000CC         ; of the first word, so negate r1, multiply by 8 and the
                       n shift out the
  208 000000CC         ; mask by this amount and then shift it back, so that th
                       e upper bits of
  209 000000CC         ; the mask are now zeros
  210 000000CC 42613000        rsbmi   r3, r1, #0  ; r3 = -r1
  211 000000D0 41A03183        movmi   r3, r3, LSL #3 ; Multiply by 8 bits per 
                                                   byte
  212 000000D4 41A0C31C        movmi   r12, r12, LSL r3
  213 000000D8 41A0C33C        movmi   r12, r12, LSR r3
  214 000000DC         ; Load the first partial word from memory, mask out the 
                       part that will be
  215 000000DC         ; set, mask out the part of the memset value that we wil
                       l use set the
  216 000000DC         ; memory, OR the values together and then store back to 
                       memory
  217 000000DC E5903000        ldr     r3, [r0]
  218 000000E0 E1C3300C        bic     r3, r3, r12
  219 000000E4 E002C00C        and     r12, r2, r12
  220 000000E8 E183300C        orr     r3, r3, r12
  221 000000EC E4803004        str     r3, [r0], #4
  222 000000F0         ; If the total size is still greater than 0 then do alig
                       ned memsets
  223 000000F0 CAFFFFFE        bgt     _memset_main
  224 000000F4 E12FFF1E        bx      lr
  225 000000F8                 END
Command Line: [C:\ARM\ADSv1_2\bin\armasm.exe -list ../../../dblobj_SBNAALZ/boot
_util_asm.lst -g -apcs /interwork -cpu ARM926EJ-S]
