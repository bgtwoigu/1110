/*=================================================================
USE CASE SCENARIOS DOCUMENTATION
==================================================================
=IPOSDET - An Introduction to the Use Case Scenarios=

The BREW IPOSDET interface allows BREW applications to access the location-based services that are available on the device.

In order to use the sector-based position determination methods such as IPOSDET_GetSectorInfo(), SectorInfo privileges are required. Similarly, for GPS based position determination methods such as 

* IPOSDET_SetGPSConfig(), 
* IPOSDET_GetGPSConfig(), and 
* IPOSDET_GetGPSInfo(),
*
Position Determination Privileges are required.

====Note====
Some BREW devices may not have the IPOSDET API implemented. A handset supporting E911 services does not necessarily allow BREW applications to access position information via IPOSDET. 

The Use Cases in this section document how to use the BREW IPOSDET interface to create applications which make use of location-based services.

=======================================================
= IPOSDET - Placing a single request for GPS position information=

This model is useful for applications requesting position information to
* make an emergency service request, 
* display a map with the current position indicated by a mark, 
* display a list of services available near by, or 
* similar task
*
The information returned is GPS based position information. 

[[Image:AEEPosDet/IPOSDET_single_request1.gif]]


The sequence of BREW API calls is illustrated in the diagram titled “Placing a single request for GPS position information”.  Each step is described in detail following the diagram.

==Step 1.  Configure the position determination engine==

Establishing the type of position fix is accomplished by calling IPOSDET_SetGPSConfig(), passing the AEEGPSConfig structure as a parameter. To simplify the configuration process, applications should only modify the configuration fields of interest. The existing configuration can be obtained using IPOSDET_GetGPSConfig. A position fix can be obtained without configuring the position determination engine if the default configuration is acceptable.

The example shown here sets only one possible configuration item.  Please refer to AEEGPSConfig and IPOSDET_SetGPSConfig() documentation to determine what configuration is correct for a particular application.
{{{
{
   AEEGPSConfig config;
   int nError;

   MEMSET(&config, 0, sizeof(AEEGPSConfig));

   nError =  IPOSDET_GetGPSConfig( pts->pPos, &config );
   
   if (nError != SUCCESS){
      // request rejected
   }
   else {
      config.mode = AEEGPS_MODE_ONE_SHOT;
      nError =  IPOSDET_SetGPSConfig( pts->pPos, &config );
      …
   }
   …
}
}}}

==Step 2.  Place the request for GPS position information using IPOSDET_GetGPSInfo()==

Take care to ensure that the callback and information structures passed to this method remain in scope until the callback returns. 
{{{
{
  …
  if( SUCCESS != IPOSDET_GetGPSInfo( pts->pPos, 
      AEEGPS_GETINFO_LOCATION|AEEGPS_GETINFO_ALTITUDE,
      AEEGPS_ACCURACY_LEVEL1, 
      &pts->theInfo, &pts->cbInfo ) ) {

      // request rejected
      
   }
   …
}
}}}
==Step 3.  Privacy Dialog events and handling during the request==

IPOSDET_GetGPSInfo() enforces the privacy policies recommended by the network operator. Privacy implementation on the device may prompt the user using a dialog. Applications invoking this function must be prepared to surrender the screen to allow any dialog prompts to the user to be displayed. The application must suspend any paint to the screen upon receipt of the event EVT_DIALOG_START and must redraw upon receipt of the event EVT_DIALOG_END. 

An application can use the function ISHELL_GetDeviceInfoEx() with the device item AEE_DEVICEITEM_POSDET_PRIVACY_ALERT to determine if the user is to be prompted before a position determination request.  

==Step 4.  Callback function is called on completion of position determination==
The position response is placed in the memory pointing to the structure AEEGPSInfo.  The status field of the AEEGPSInfo structure indicates if the position determination was successful.  
{{{
{
   if( pts->theInfo.status == AEEGPS_ERR_NO_ERR ) {
      // position determination was successful
      // position response is in AEEGPSInfo struct,
      // pts->theInfo in this example
   }
   …
}
}}}
==Step 5.  Convert AEEGPSInfo response to AEEPositionInfoEx format==

AEEGPSInfo provides position information in the IS-801 location response format.  In this format, latitude, longitude, velocity and altitude are provided as fixed point values.  Applications may wish to convert these values to floating point degrees before using them. IPOSDET_ExtractPositionInfo() is a conversion utility which converts latitude, longitude, velocity and altitude from fixed point to floating point degrees.  Uncertainty is converted from enumerated Gaussian distribution, as specified by IS-801, to meters.
{{{
{  
   AEEPositionInfoEx  *po;
   po = (AEEPositionInfoEx*) MALLOC(sizeof(AEEPositionInfoEx));
   if(!po){
      // malloc failed, handle the error condition
      return;
   }

   po->dwSize = sizeof(AEEPositionInfoEx);
   if( SUCCESS != IPOSDET_ExtractPositionInfo(pts->pPos,
                     pts->theInfo, po ) {
      // conversion failed
   }
   …
   FREEIF(po);
}
}}}
=======================================================
= IPOSDET - Placing multiple requests for GPS position information=

This model is useful for applications requesting position information to 
* track a current position on a map, 
* give turn-by-turn instructions with recalculation when the user goes off course, or 
* similar tasks  

The information returned in this example is GPS based position information.  

If you want to implement a position tracking application which requests positions periodically, you must wait for the callback to return and then initiate a new IPOSDET_GetGPSInfo() call.

[[Image:AEEPosDet/IPOSDET_multiple requests2.gif]]


The sequence of BREW API calls is illustrated in the diagram titled “Placing multiple requests for GPS position information”.  Each step is described in detail following the diagram.

==Step 1.  Configure the position determination engine==

The basics of configuring the position determination engine are described in the “Placing a single request for GPS position information” use case.  Please refer to that use case for more details.  

Applications which are making multiple position determination requests may specify AEEGPSConfig.mode as AEEGPS_MODE_TRACK_OPTIMAL. The Track part of the name may be misleading as this mode does not implement any persistent tracking session with the PDE.  To perform tracking, the application has to call the IPOSDET_GetGPSInfo() function at regular intervals.  

This mode allows the application to request a position fix without worrying about which underlying method is used by the position determination engine. AEEGPSConfig.optim is used to tell the position determination engine what optimization is desired. Applications may 
* optimize for speed, 
* optimize for accuracy, or 
* minimize the data transfer with the server

Additionally, in this mode, the position determination engine can use information about upcoming requests from the application to optimize its performance. The nFixes and nInterval fields in the AEEGPSConfig structure are used to tell the position determination engine how many requests the application expects to make, and at what interval.  Refer to the AEEGPSConfig documentation for more details about these parameters.
{{{
{
   AEEGPSConfig config;
   int nError;

   MEMSET(&config, 0, sizeof(AEEGPSConfig));

   nError =  IPOSDET_GetGPSConfig( pts->pPos, &config );
   
   if (nError != SUCCESS){
      // request rejected
   }
   else {
      config.mode = AEEGPS_MODE_TRACK_OPTIMAL;
      config.optim = AEEGPS_OPT_SPEED;
      config.nFixes = 180;    //estimated number of fixes
      config.nInterval = 10;  //estimated interval in seconds  
      nError =  IPOSDET_SetGPSConfig( pts->pPos, &config );
      …
   }
   …
}
}}}

==Step 2.  Place the request for GPS position information using IPOSDET_GetGPSInfo()==  

Take care to ensure that the callback and information structures passed to this method remain in scope until the callback returns. 
{{{
{
  …
  if( SUCCESS != IPOSDET_GetGPSInfo( pts->pPos, 
      AEEGPS_GETINFO_LOCATION|AEEGPS_GETINFO_ALTITUDE,
      AEEGPS_ACCURACY_LEVEL1, 
      &pts->theInfo, &pts->cbInfo ) ) {

      // request rejected
      
   }
   …
}
}}}

====Note====
IPOSDET_GetGPSInfo() enforces the privacy policies recommended by the network operator.  Handling of privacy dialog events is described in Step 3. of the “Placing a single request for GPS position information” use case.

==Step 3.  Callback function is called on completion of position determination==
See Step 4. 

==Step 4.  Initiate the next position determination request== 

(Step 3. and Step 4. are shown together in the following code sample.)
The position response is placed in the memory pointing to the structure AEEGPSInfo.  The status field of the AEEGPSInfo structure indicates if the position determination was successful. 
 
Applications may convert the data in the AEEGPSInfo structure to the AEEPositionInfoEx format.  The use of IPOSDET_ExtractPositionInfo() to accomplish this is described in Step 5. of the “Placing a single request for GPS position information” use case.

A tracking application can initiate a new position request once the IPOSDET_GetGPSInfo callback has been called.  A timer can be used to initiate the new request after the appropriate interval.

{{{
{
   if( pts->theInfo.status == AEEGPS_ERR_NO_ERR ) {
      // position determination was successful
      // position response is in AEEGPSInfo struct,
      // pts->theInfo in this example

      …

      // set a time to place the next request
      ISHELL_SetTimerEx( pts->pShell, pts->nTrackInterval * 1000, 
                         &pts->cbIntervalTimer);
   }
   else {
      // position determination request was not successful
   }
}
}}}
The new position determination request is placed from the timer callback function.
{{{
{
   …
   if( SUCCESS != IPOSDET_GetGPSInfo( pts->pPos, 
      AEEGPS_GETINFO_LOCATION|AEEGPS_GETINFO_ALTITUDE,
      AEEGPS_ACCURACY_LEVEL1, 
      &pts->theInfo, &pts->cbInfo ) ) {

      // new request rejected
  }
   …
}
}}}

==See Also:==
“Developing Location Based Applications with BREW” is an article available on the BREW Developer Resources web page.  Look for this article as part of the Knowledge Base.

[http://brew.qualcomm.com/brew/en/developer/resources/dev_resources.html http://brew.qualcomm.com/brew/en/developer/resources/dev_resources.html]

An IPOSDET sample application is available at: 
[https://brewx.qualcomm.com/brew/sdk/download.jsp?page=dx/samplecode https://brewx.qualcomm.com/brew/sdk/download.jsp?page=dx/samplecode]

You can download and modify this application to become familiar with the capabilities of IPOSDET.

=======================================================================*/

