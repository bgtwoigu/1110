/*=====================================================================
      USE CASE SCENARIOS DOCUMENTATION

=======================================================================
=INetMgr - Preview=
The NetMgr Use Case Scenarios demonstrate the usage of advanced networking features.

These features allow the user to perform network diagnostics and configuration.

=======================================================================
=INetMgr - Monitoring Network Events=
This section will demonstrate an application that monitors network events using INETMGR_OnEvent().

The application, which holds an INetMgr object, registers for network events 
notifications using INETMGR_OnEvent(). It then opens a socket and communicates over it.
During these activities, it will be notified on every event occuring on the network underlying its INetMgr object.

==Data Initialization==
The following macro will be used to release objects
{{{
 #define RELEASEIF(p) { if (p) { IBASE_Release((IBase*)(p)); p = 0; } }
}}}
The application should include and initialize the follwoing data members:
{{{
 typedef struct _CApp {
   
   IShell*   pIShell;
   INetMgr*  m_pNetMgr;
 
   // socket related data
   ISockPort*  m_pSock;
   AEESockAddrStorage m_SockAddr;
   AEECallback        m_SockCB;
   char               m_pchWriteBuff[ BUFF_SIZE ];   
   char               m_pchReadBuff[ BUFF_SIZE ]; 
 
 } CApp;
}}}

==Events Notification Registration==
'''CApp_OnEvent()''' registers for receiving network events, 
so that every event will invoke CApp_onEventBC().
*
It then calls '''CApp_StartSockConn()''', to perform network - bound activities.
{{{
 void CApp_OnEvent(CApp* pme)
 {
   int ret;
   
   // register for network events
   ret = INETMGR_OnEvent(pme->m_pNetMgr,  // NetMgr pointer 
                         CApp_OnEventCB,  // user - specified callback
                         pme,             // user - specified data
                         TRUE             // register
                        );
 
   if (SUCCESS != ret)
   {
      // handle the error
      ...
   }
 
   // perform network - bound activities
   CApp_StartSockConn(pme);
 }
}}}
'''CApp_OnEventCB()''' will be called when the network changes state.
In addition to the user data, it will supply the current event type, and additional event data.
The user may plug in its code to handle each event.
{{{
 void CApp_OnEventCB(void* pv,         // user data
                     NetMgrEvent evt,  // the event that triggered the callback
                     uint32 dwData     // data passed by the caller
                    )
 {
   CApp* pme = (CApp*)pv;
 
   switch (evt) { 
      case NE_PPP:
      {
         NetState ns = (NetState)dwData;
         switch (ns) {
            case NET_PPP_OPENING:
               // network is openning
               ...
               break;
 
            case NET_PPP_OPEN:
               // network is open
               ...
               break;
 
            case NET_PPP_CLOSING:
               // network closing
                ...
               break;
 
            case NET_PPP_CLOSED:
               // network is closed
               ...
               break;
 
            case NET_PPP_SLEEPING:
               // network is going to sleep
               ...
               break;
 
            case NET_PPP_ASLEEP:
               // network is asleep
               ...
               break;
 
            case NET_PPP_WAKING:
               // network is waking
                ...
               break;
            default:
               break;
         }
         break;
      }
 
      case NE_IP:
         // device gets a new IP address.
         // before the network is up, the IP address of the device is undefined.
         // once the network is brought up, a concrete IP is assigned to the device.
         // when the network goes down, the IP is undefined again, and this event will
         // occur again.
         ...
         break;
 
      default:
         break;
   }
 }
}}}
Followed are socket activities which may cause changes in network state. The application
will be notified about these events.
{{{
 // ===========================================================================
 // Open a socket
 // ===========================================================================
 void CApp_StartSockConn(CApp* pme)
 {
   int ret; 
 
   // create the ISockPort object.
   ret = ISHELL_CreateInstance(pme->pIShell, AEECLSID_SOCKPORT, (void**)&(pme->m_pSock));
   if (SUCCESS != ret) { 
      // handle the error
     return;
   }
   // open the SockPort.
   ret = ISOCKPORT_OpenEx(pme->m_pSock,        // ISockPort pointer
                         AEE_AF_INET,          // wFamily = IPv4 
                         AEE_SOCKPORT_STREAM,  // nType   = TCP
                         0                     // let the system select its default 
                                               // protocol for the given wFamily and nType
                        );
  if (SUCCESS != ret) {     
     // handle the error
     return;
  }
  // connect to the server
  CApp_TryConnect(pme);
 }
 
 
 // ===========================================================================
 // connect to the server
 // ===========================================================================
 void CApp_TryConnect(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
 
   // connect to the distant server
   ret = ISOCKPORT_Connect(pme->m_pSock,     // ISockPort object
                           &pme->m_SockAddr  // pointer to dest socket address struct
                          );
   if (AEEPORT_WAIT == ret) {
      ISOCKPORT_WriteableEx(pme->m_pSock, &pme->m_SockCB, CApp_TryConnect, pme);
      return;
 
   }
   if (SUCCESS != ret) {
      // do error handling
      return;
   }
   // socket is connected
 }
 
 .
 .
 .
 . // do various networking activities
 .
 .
 
 // ===========================================================================
 // release the socket
 // ===========================================================================
 void CApp_Release(void* po)
 {
   // release the socket
   RELEASEIF(pme->m_pSock);
 }
}}}
During the execution of the socket activities, the application will be notified of the
changes in the state of the network.

=======================================================================
=INetMgr - Setting Linger and Dormancy Timeouts=
* Setting linger and dormancy timeouts allow economizing traffic channel resources while the network is idle.
* The user's ability to control over the dormancy timeout is not supported on all handsets.
* In general, dormancy may be initiated by the handset or by the network. This use case discusses handset-initiated dormancy, and not network-initiated dormancy. The user can't configure the network-initated dormancy's timeouts. Thus, even if handset-initiated dormancy is set by the BREW app to optimize its activity, network-initiated dormancy may still take place in accordance with Network dormancy settings.
* While linger timeout expiration will close both traffic channel and PPP connection, dormancy timeout expiration will close only the traffic channel, leaving the PPP connection open.
* Linger timeout is triggered when a Socket or Network operation (e.g. ISOCKPORT_Read) takes place, not when last socket is released. Dormancy timeout expiration solely depends on Network activity. Dormancy takes place when no network activity occurred for the duration of the dormancy timeout.
* Typically, both linger and dormancy timeouts have a default value of 30 seconds. however, these defaults may vary in some handsets, and should be verified for the specific handset of interest. One can change these values, to balance between physical resource consumption (traffic channel) and application performance (bringing the network up again is a time consuming process, which might prolong the application excecution).
*
==Example 1==
CApp_LingerDormancyEx1() demonstrates the need for changing the default linger timeout value. It periodically creates a socket, performs some activities on it and then releases it. If the linger timeout expires before socket creation occurs, both PPP and traffic channel will be brought down. 
If the dormancy timeout expires before socket creation occurs, only the traffic channel will be brought down.
In both cases, in the next iteration, the application will first need to wait until the traffic channel (and possibly PPP) are up again.
Note that in this example, linger and dormancy timeouts are set to 30 seconds.
{{{
 void CApp_LingerDormancyEx1(CApp* pme)
 {
   int ret;
 
   //--------------------------------------------------//
   // ~~ START OF PERIODICALLY REPEATING CODE BLOCK ~~ //
   //--------------------------------------------------//
   
      // create the ISockPort object.
      ret = ISHELL_CreateInstance(pme->pIShell, AEECLSID_SOCKPORT, (void**)&(pme->m_pSock));
      if (SUCCESS != ret) { 
      // handle the error
         return;
      }
      // open the SockPort.
      ret = ISOCKPORT_OpenEx(pme->m_pSock,         // ISockPort pointer
                              AEE_AF_INET,         // wFamily = IPv4 
                              AEE_SOCKPORT_STREAM, // nType   = TCP
                              0                    // let the system select its default 
                                                   // protocol for the given wFamily and nType
                              );
      
      // perform socket activities: connect(), read(), write()...
      
      //          LAST SOCKET ACTIVITY
      //   Linger and Dormancy timers are being reset
      //                ---
      //                 |
      //                 |
      //                 |
      //          30 seconds elapse
      //  The linger and dormancy timeouts have elapsed.
      //  Linger doesn't take effect since there is still an open socket.
      //  Hence, the PPP connection does not go down.
      //
      //  Dormancy does take effect, since no network activity occurred 
      //  within 30 seconds. Thus the traffic channel is released.
      //                ---
      //                 |
      //      Additional 5 seconds elapse    
      //                 |
      //           SOCKET CLOSURE
      RELEASEIF(pme->m_pSock);
 
      // since linger timeout < 35 seconds, PPP goes down now.
      // If the traffic channel is still up (dormancy was not activated
      // from some reason) it is brought down now. 
 
   //------------------------------------------------//
   // ~~ END OF PERIODICALLY REPEATING CODE BLOCK ~~ //
   //------------------------------------------ -----//
 }
}}}
In such a scenario, it is better to set the linger and dormancy timeout values to be bigger than the time
between last socket activity of iteration n and first socket activity of iteration n+1. This can
be done by adding the following code before the for() loop: 
{{{
 INETMGR_SetLinger(pme->m_pNetMgr, 50);
 
 ret = INETMGR_SetDormancyTimeout(pme->m_pNetMgr, 50);
 if (SUCCESS != ret) {
   // handle error
   ...
 }
}}}
In this example the timeouts are set to 50 seconds. The user should use value large enough to prevent network from going down.

==Example 2==
CApp_LingerDormancyEx2() is very similar to the previous example. 
The only difference is that sokcet creation and release are not performed within the repetative code block.
Again, linger and dormancy timeouts are set to 30 seconds.

In this scenario, the linger timeout will never cause the network to go down, 
since the socket is not released within the repetative code block.
Nevertheless, if the network idle time is greater than the dormancy timeout, 
the latter will expire, causing the traffic channel to be released.

{{{
 void CApp_LingerDormancyEx2(CApp* pme)
 {
   int ret, i;
 
   // create the ISockPort object.
   ret = ISHELL_CreateInstance(pme->pIShell, AEECLSID_SOCKPORT, (void**)&(pme->m_pSock));
   if (SUCCESS != ret) { 
      // handle the error
      return;
   }
   // open the SockPort.
   ret = ISOCKPORT_OpenEx(pme->m_pSock,        // ISockPort pointer
                          AEE_AF_INET,         // wFamily = IPv4 
                          AEE_SOCKPORT_STREAM, // nType   = TCP
                          0                    // let the system select its default 
                                               // protocol for the given wFamily and nType
                         );
    
   //--------------------------------------------------//
   // ~~ START OF PERIODICALLY REPEATING CODE BLOCK ~~ //
   //--------------------------------------------------//
      
      // perform socket activities: connect(), read(), write()...
 
      //          LAST SOCKET ACTIVITY
      //   Linger and Dormancy timers are reset
      //                ---
      //                 |
      //                 |
      //                 |
      //          30 seconds elapse
      //  The linger and dormancy timeouts have elapsed.
      //  Linger doesn't take effect since there is still an open socket.
      //  Hence, the PPP connection does not go down.
      //
      //  Dormancy does take effect, since no network activity occurred 
      //  within 30 seconds. Thus the traffic channel is released.
      //                 |
      //                ---
  
   //------------------------------------------------//
   // ~~ END OF PERIODICALLY REPEATING CODE BLOCK ~~ //
   //------------------------------------------ -----//
   
   // release the socket    
   RELEASEIF(pme->m_pSock);
 }
}}}
To prevent this, one can set the dormancy timeout to a larger value value to be bigger than the time
between last socket activity of iteration n and first socket activity of iteration n+1:
{{{
 ret = INETMGR_SetDormancyTimeout(pme->m_pNetMgr, 50);
 if (SUCCESS != ret) {
   // handle error
   ...
 }
}}}
Again, here the timeouts are set to 50 seconds. The user should use value large enough to prevent network from going down.
=======================================================================*/
