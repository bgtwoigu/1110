sys.CPU ARM926EJ 
sys.JTAGCLOCK RTCK 
sys.u


local &efuse &start &blow_value &fuse_len &fuse_chain
local &val &i &fuse_bit &EF_CONFIG_MSB_value &EF_CONFIG_LSB_value &CHIP_ID_val &FEATURE_ID_val
local &sub_chain &sub_bit_position &sub_shift_value &sub_reg_read &sub_reg_write //subroutine var

WINPAGE.RESET
winclear



;PATH
;&shared_cmmpath="\\jetsam\vi_qsc1100\shared_code\ASIC\Release_Rev20\cmm"
;PATH + &shared_cmmpath

entry &efuse &blow_value 

do "Trace32_Init"

do symbols
radix.hex
area
area.SELECT
area.clear

;============================================
; note: to port this, one need to change: 
;  1. the y.create.l section
;  2. the sub func "find_fuse_start_position"
;  3. the sub func "find_fuse_len"
;  4. also the REPEAT_LOOP print out
;============================================

// config chain                      start position
y.create.l  SPARE_FUSE_BIT_31         63;
y.create.l  TIC_DISABLE               62;
y.create.l  PBL_JTAG_DISABLE          61;
y.create.l  CLK_INCREASE_DISABLE      60;
y.create.l  CONFG_RESERVED            59;
y.create.l  DISABLE_MODEM             58;
y.create.l  V_SCALE                   54;
y.create.l  FOUNDRY_REVISION          51;
y.create.l  SPI_SLAVE_DISABLE         50;
y.create.l  ARM9_RAM_ACC_CTRL         46;
y.create.l  SPARE_FUSE_BIT_13         45;
y.create.l  SOFTWARE_CRASH_DEBUG      44;
y.create.l  ARM9_JTAG_EN_N            43;
y.create.l  SECURE_BOOT               42;
y.create.l  BOOT_FROM_ROM             41;
y.create.l  DISABLE_153_KBPS          40;
y.create.l  DISABLE_MULTIMEDIA        39;
y.create.l  ROOT_KEY_SELECT           36;
y.create.l  OEM_HW_ID                  4;
y.create.l  SW_FUSE_PGM_DSBL           3;
y.create.l  HW_KEY_PGM_DISABL          2;
y.create.l  CHIP_ID_DSBL               1;
y.create.l  CONFIG_PGM_DSBL            0;

    
//EFUSE_CHIP_ID_CHAIN
y.create.l  FEATURE_ID                600;
y.create.l  CHIP_ID                   560;

y.create.done 





if ("&blow_value"=="")
(
&EF_CONFIG_MSB_value=data.LONG(RD:EF_CONFIG_MSB)
&EF_CONFIG_LSB_value=data.LONG(RD:EF_CONFIG_LSB)
&FEATURE_ID_value=data.LONG(RD:CHIP_FEATURE_ID)
&CHIP_ID_value=data.LONG(RD:HW_REVISION_NUMBER)
&CHIP_ID_value=&CHIP_ID_value&0x0000F000
&CHIP_ID_value=&CHIP_ID_value>>12.

print " config_Chain LSB, MSB: &EF_CONFIG_MSB_value &EF_CONFIG_LSB_value"
print " Chip_ID: &CHIP_ID_value Feature_ID: &FEATURE_ID_value"
print " "
print " press any key to continue"
enter

REPEAT_LOOP:

	area.clear	
	print " please enter efuse name and it's value"
	print ""
	print " config_Chain fuses:"        
	print "  SPARE_FUSE_BIT_31....1 bit   TIC_DISABLE..........1 bit"
	print "  PBL_JTAG_DISABLE.....1 bit   CLK_INCREASE_DISABLE.1 bit"
	print "  CONFG_RESERVED.......1 bit   DISABLE_MODEM........1 bit"
	print "  V_SCALE..............4 bits  FOUNDRY_REVISION.....3 bits"
	print "  SPI_SLAVE_DISABLE....1 bit   ARM9_RAM_ACC_CTRL....4 bits"
	print "  SPARE_FUSE_BIT_13....1 bit   SOFTWARE_CRASH_DEBUG.1 bit"
	print "  ARM9_JTAG_EN_N.......1 bit   SECURE_BOOT..........1 bit"
	print "  BOOT_FROM_ROM........1 bit   DISABLE_153_KBPS.....1 bit"
	print "  DISABLE_MULTIMEDIA...1 bit   ROOT_KEY_SELECT......3 bits"
	print "  OEM_HW_ID...........32 bits  SW_FUSE_PGM_DSBL.....1 bit"
	print "  HW_KEY_PGM_DISABL....1 bit   CHIP_ID_DSBL.........1 bit"
	print "  CONFIG_PGM_DSBL......1 bit"
	print ""
	print " chip_id_Chain fuses:"
	print "  FEATURE_ID...........4 bits  CHIP_ID..............4 bits"
	print " "
	print "note:"
	print " for  low tier chip(QSC1100_800MHz),   blow CHIP_ID to 0xF"
	//print "                                     DISABLE_MULTIMEDIA to 1"
	//print "                                     and DISABLE_153_KBPS to 1"
	print " for  mid tier chip(QSC1100_TRI_BAND), blow CHIP_ID to 0xE"
	print " for high tier chip(QSC1110),          blow CHIP_ID to 0x8"
	print " "
	print "enter fuse name: "
	enter &efuse
	print "enter fuse val: "
	enter &blow_value
	print ""
        print "do blow_fuse &efuse &blow_value"
         
	do blow_fuse &efuse &blow_value	

	print ""
	print "&efuse blow process done, press anykey to continue"
	enter
	goto REPEAT_LOOP
)

// this will take care of start position
gosub find_fuse_start_position // take &efuse and return &start

// this will take care of fuse length
gosub find_fuse_len // take &efuse and return &fuse_len

// this will take care of fuse chain
&fuse_chain=4
if (&efuse==FEATURE_ID)
(
  &fuse_chain=8
)
if (&efuse==CHIP_ID)
(
  &fuse_chain=8
)


print "BLOW &efuse to &blow_value"
print " fuse parameter:"
print "     fuse logical start bit &start" 
print "     fuse logical len &fuse_len" 
print "     fuse belong to chain &fuse_chain"

gosub SSBI_INIT

// set vreg_RUIM to 2.9V
do set_ldo RUIM 2.9;	 // set efuse programming voltage to 2.9V

&i=0
while (&i<&fuse_len)
(	
	&val=(&blow_value>>&i)&1
	if (&val==1)
	(
		&fuse_bit=2*(&start+&i)
		gosub blow_efuse_physical_bit &fuse_chain &fuse_bit
		&fuse_bit=&fuse_bit+1
		gosub blow_efuse_physical_bit &fuse_chain &fuse_bit
	)
	&i=&i+1
)



// after done, set vreg_RUIM back to 2.85
do set_ldo RUIM 2.85;
enddo

;*******************************************
;SSBI_INIT:
;*******************************************
SSBI_INIT:
	D.S SW_RESET_REG     %L 0x0
	D.S ARM_CLK_EN_REG   %L 0xFFFFFFFF
	D.S MODEM_CLK_HALT   %L 0xC
	D.S MODEM_CLK_HALT_2 %L 0x0
        D.S MISC_CFG_REG %L 0x003AA955
	D.S MODEM_CLK_MISC_CTL %L 0xC4000
	D.S HWIO_SSBI_WRAPPER_SSBI_RESET_ADDR %L 1	
	D.S HWIO_SSBI_WRAPPER_SSBI_PRIORITIES_ADDR %L 0x4688	
	D.S HWIO_SSBI_WRAPPER_SSBI_CTL_ADDR %L (1<<15.)|(1<<4)|(1<<2)|(1<<0)	
    RETURN

;	uint32 wakup_final_cnt	= 0x00; // [bits 20:17]
;	uint32 ssbi_data_pden 	= 0x00; // [bit 16]
;	uint32 activate_reserve = 0x01; // [bit 15]
;	uint32 disable_term_sym = 0x00; // [bit 14]
;	uint32 slave_id 	= 0x00; // [bit 13:8]
;	uint32 ftm_mode 	= 0x00; // [bit 7]
;	uint32 sel_rd_data 	= 0x00; // [bits 6:5]
;	uint32 enable_ssbi_int 	= 0x01; // [bit 4]
;	uint32 ssbi_data_del 	= 0x01; // [bits 3:2]
;	uint32 idle_syms 	= 0x01; // [bits 1:0]



;*******************************************
;find_fuse_start_position:
;*******************************************
find_fuse_start_position:
	if (&efuse==SPARE_FUSE_BIT_31) 
	(
		&start=63.
	)
	if (&efuse==TIC_DISABLE) 
	(
		&start=62.
	)
	if (&efuse==PBL_JTAG_DISABLE) 
	( 
		&start=61.
	)
	if (&efuse==CLK_INCREASE_DISABLE) 
	( 
		&start=60.
	)
	if (&efuse==CONFG_RESERVED) 
	( 
		&start=59.
	)
	if (&efuse==DISABLE_MODEM) 
	( 
		&start=58.
	)
	if (&efuse==V_SCALE) 
	( 
		&start=54.
	)
	if (&efuse==FOUNDRY_REVISION) 
	( 
		&start=51.
	)
	if (&efuse==SPI_SLAVE_DISABLE) 
	( 
		&start=50.
	)
	if	 (&efuse==ARM9_RAM_ACC_CTRL) 
	( 
		&start=46.
	)
	if (&efuse==SPARE_FUSE_BIT_13) 
	( 
		&start=45.
	)
	if (&efuse==SOFTWARE_CRASH_DEBUG) 
	( 
		&start=44.
	)
	if (&efuse==ARM9_JTAG_EN_N) 
	( 
		&start=43.
	)
	if (&efuse==SECURE_BOOT) 
	( 
		&start=42.
	)
	if (&efuse==BOOT_FROM_ROM) 
	( 
		&start=41.
	)
	if (&efuse==DISABLE_153_KBPS) 
	( 
		&start=40.
	)
	if (&efuse==DISABLE_MULTIMEDIA) 
	( 
		&start=39.
	)
	if (&efuse==ROOT_KEY_SELECT) 
	( 
		&start=36.
	)
	if (&efuse==OEM_HW_ID) 
	( 
		&start=4.
	)
	if (&efuse==SW_FUSE_PGM_DSBL) 
	( 
		&start=3.
	)
	if (&efuse==HW_KEY_PGM_DISABL) 
	( 
		&start=2.
	)
	if (&efuse==CHIP_ID_DSBL) 
	( 
		&start=1.
	)
	if (&efuse==CONFIG_PGM_DSBL) 
	( 
		&start=0.
	)
		    
	//EFUSE_CHIP_ID_CHAIN
	if (&efuse==FEATURE_ID) 
	( 
		&start=60.
	)
	if (&efuse==CHIP_ID) 
	( 
		&start=56.
	)

RETURN



;*******************************************
;find_fuse_len in physical bit len
;*******************************************
find_fuse_len:
	&fuse_len=1
	if (&efuse==V_SCALE)
	(
	  &fuse_len=4
	)
	if (&efuse==FOUNDRY_REVISION)
	(
	  &fuse_len=3
	)
	if (&efuse==ARM9_RAM_ACC_CTRL)
	(
	  &fuse_len=4
	)
	if (&efuse==ROOT_KEY_SELECT)
	(
	  &fuse_len=3
	)
	if (&efuse==OEM_HW_ID)
	(
	  &fuse_len=32
	)
	if (&efuse==FEATURE_ID)
	(
	  &fuse_len=4
	)
	if (&efuse==CHIP_ID)
	(
	  &fuse_len=4
	)
	
	// this will take care of fuse chain
	&fuse_chain=4
	if (&efuse==FEATURE_ID)
	(
	  &fuse_chain=8
	)
	if (&efuse==CHIP_ID)
	(
	  &fuse_chain=8
	)
RETURN


;*******************************************
;blow_efuse_physical_bit
;*******************************************
blow_efuse_physical_bit:
	entry &sub_chain &sub_bit_position 
	print " BLOW chain &sub_chain physical bit &sub_bit_position "
 	&sub_shift_value=128.-&sub_bit_position

        // step 1 HWIO_OUT(EF_CHAIN_SEL, chain);
	data.set EF_CHAIN_SEL %long &sub_chain

	// step 2 HWIO_OUTFV(EF_PWR_CTL, SW_VDD_4_BLOW_EN, TURN_OFF_THE_VDD_4_BLOW);
	&sub_reg_read=data.LONG(RD:EF_PWR_CTL)
	&sub_reg_write=&sub_reg_read|0x1
	data.set EF_PWR_CTL %long &sub_reg_write

	// step 3 HWIO_OUT(EF_BLOW_VALUE, 0);
	data.set EF_BLOW_VALUE %long 0x0
	
	// step 4 HWIO_OUT(EF_SHIFT_VALUE, 0x100); HWIO_OUT(EF_BLOW_TIMER, 0xFF);
	data.set EF_SHIFT_VALUE %long 0x100
	data.set EF_BLOW_TIMER %long 0xFF

	// step 5 HWIO_OUT(EF_STATUS, 1);   // start e-fuse blowing process
	data.set EF_STATUS %long 0x1

	// step 6 
	//while(HWIO_INF(EF_STATUS, STATUS_DONE) != 1); // check for status_done	
	//HWIO_OUTF(EF_STATUS, STATUS_START, 0);
	&sub_reg_read=0	  
        while (&sub_reg_read==0)
	(
		&sub_reg_read=data.LONG(RD:EF_STATUS)
		&sub_reg_read=&sub_reg_read&0x2 
	)
        data.set EF_STATUS %long 0x0
        
	// step 7 HWIO_OUT(EF_BLOW_TIMER, blow_time);
        data.set EF_BLOW_TIMER %long 0xC0

	// setp 8 HWIO_OUT(EF_BLOW_VALUE, 1);
	data.set EF_BLOW_VALUE %long 0x1	

	// step 9 HWIO_OUT(EF_SHIFT_VALUE, shift_value); // shifting start from MSB
	data.set EF_SHIFT_VALUE %long &sub_shift_value 

	// step 10 HWIO_OUTFV(EF_PWR_CTL, SW_VDD_4_BLOW_EN, TURN_ON_THE_VDD_4_BLOW);
	&sub_reg_read=data.LONG(RD:EF_PWR_CTL)
	&sub_reg_write=&sub_reg_read&(~0x1)
	data.set EF_PWR_CTL %long &sub_reg_write	

	// step 11 HWIO_OUT(EF_STATUS, 1);     // start e-fuse blowing process
	data.set EF_STATUS %long 0x1

	// step 12 
	//while(HWIO_INF(EF_STATUS, STATUS_DONE) != 1); // check for status_done
	//HWIO_OUTF(EF_STATUS, STATUS_START, 0);
	&sub_reg_read=0	  
        while (&sub_reg_read==0)
	(
		&sub_reg_read=data.LONG(RD:EF_STATUS)
		&sub_reg_read=&sub_reg_read&0x2 
	)
        data.set EF_STATUS %long 0x0	

	// step 13 HWIO_OUTFV(EF_PWR_CTL, SW_VDD_4_BLOW_EN, TURN_OFF_THE_VDD_4_BLOW);
	&sub_reg_read=data.LONG(RD:EF_PWR_CTL)
	&sub_reg_write=&sub_reg_read|0x1
	data.set EF_PWR_CTL %long &sub_reg_write

	// step 14 HWIO_OUT(EF_CHAIN_SEL, EFUSE_NULL_CHAIN);		
	data.set EF_CHAIN_SEL %long 0x0

RETURN












