=======================================
USE CASE SCENARIOS DOCUMENTATIONS
========================================
=ITelephone - Originating a call=

The BREW client provides access to the telephony capabilities of a BREW enabled device in the form of the ITAPI and ITelephone family of interfaces. The ITAPI interface provides access to the basic telephony capabilities. The ITelephone family of interfaces consists of ITelephone, IPhoneNotifier, ICall, ICallMgr, IPhoneCtl, ISuppsTrans and IMultiPartyCall interfaces and provides access to a vast array of telephony capabilities rich enough for the realization of sophisticated telephony applications such as the “Dialer” application of a device. The following use case scenarios explain how these interfaces can be used.

The ITAPI interface supports voice call origination in the form of the ITAPI_MakeVoiceCall() method. The following snippet demonstrates a typical use of ITAPI_MakeVoiceCall().

The following code snippet shows how to request a voice call origination by dialing “8585551234”. Then resume the application if it gets suspended because of some other application, such as the “Dialer” application, becoming top visible, and to display the call status.

{{{

nError = ITAPI_MakeVoiceCall(pITAPI, “8585551234”, 0);

if (nError != SUCCESS)

{

   // voice call origination request rejected

   …

}

else

{

   // voice call origination request accepted

   …

}

}}}

The voice call origination using ITAPI_MakeVoiceCall() can result in a privacy dialog being displayed. The application must be prepared to handle dismissal of this dialog by repainting the application UI on an EVT_DIALOG_END event.

A SUCCESS return value from ITAPI_MakeVoiceCall() signifies the acceptance of the voice call origination request. The application needing to know about call progress can do so by monitoring the call status using ITAPI_OnCallStatus().

The ITelephone family of interfaces provides ICallMgr interface to support call origination. Call origination using ICallMgr consists of the following:

* Specifying the call origination parameters 
* Initializing a call listener
* Invocing a call origination method of ICallMgr interface
* Monitoring the call state using a call listener.
*


==Specifying the call origination parameters==

The call origination parameters are defined as AEET_ORIGOPT_XXX. The default call origination parameters are originated using the ICallMgr interface can be specified using ICALLMGR_AddOrigOpt() method as shown in the following code snippet:

{{{

{

   int nError;

   AEETOriginateOpt coo[2];

   

   MEMSET(coo, 0, sizeof(coo));

   coo[1].nId = MSGOPT_END;

   // suppress caller information restriction

   coo[0].nId = AEET_ORIGOPT_CLIR_INFO;

   coo[0].pVal = (void *) AEET_CLIR_SUPPRESSION;

  

   nError = ICALLMGR_AddOrigOpt (pMe->pICallMgr, coo);

   if (SUCCESS != nError)

   {

      // failed to specify ICallMgr call origination parameters

      …

   }

   else

   {

      // specified ICallMgr call origination parameters

      …

   }

} 

}}}

==Initializing a call listener==

A call listener must be a member of an applet structure and can be initialized as shown below:

{{{

// pMe is pointer to applet structure

LISTENER_Init(&pMe->callListener, Applet_OriginateListener, pMe);
}}}

==Invocing a call origination method of ICallMgr interface==

The call origination methods of the ICallMgr interface are as follows:
* ICALLMGR_Originate()
* ICALLMGR_OriginateVoice()
* ICALLMGR_OriginateEx()
*
The following code snippet demonstrates a typical use of the ICALLMGR_Originate() method to originate a voice call.
{{{
nError = ICALLMGR_Originate(pMe->pICallMgr, AEET_CALL_TYPE_VOICE, szNumber, NULL, &pMe->pOutgoingCall, &pMe->callListener);

if (SUCCESS != nError)

{

   // call origination request rejected

   …

}

else

{

   // call origination request accepted

   …

}
}}}

The following code snippet demonstrates a typical use of the ICALLMGR_OriginateVoice() method to originate a voice call.

{{{
nError = ICALLMGR_OriginateVoice(pMe->pICallMgr, szNumber, &pMe->pOutgoingCall, &pMe->callListener);

if (SUCCESS != nError)

{

   // call origination request rejected

   …

}

else

{

   // call origination request accepted

  …

}
}}}
The following code snippet demonstrates a typical use of the ICALLMGR_OriginateEx() method to originate a voice call.
{{{
{

   AEETOriginateOpt coo[3]; 

   coo[0].nId = AEET_ORIGOPT_CALLED_NUMBER;

   coo[0].pVal = szNumber;

   // Invoke caller information restriction

   coo[1].nId = AEET_ORIGOPT_CLIR_INFO;

   coo[1].pVal = (void*) AEET_CLIR_INVOCATION;

   coo[2].nId = AEET_ORIGOPT_END;

   coo[2].pVal = NULL;

   nError = ICALLMGR_OriginateEx(pMe->pICallMgr, AEET_CALL_TYPE_VOICE, &pMe->pOutgoingCall, &pMe->callListener, coo);

   if (SUCCESS != nError)

   {

      // call origination request rejected

      …

   }

   else

   {

      // call origination request accepted

      …

   }

}               

}}}

The following snippet demonstrates typical use of ICALLMGR_OriginateEx to originate a circuit switched data call.

{{{

{

   AEETOriginateOpt coo[3]; 

   coo[0].nId = AEET_ORIGOPT_CALLED_NUMBER;

   coo[0].pVal = szNumber;

   coo[1].nId = AEET_ORIGOPT_CLIR_INFO;

   coo[1].pVal = (void*) AEET_CLIR_INVOCATION;

   coo[2].nId = AEET_ORIGOPT_END;

   coo[2].pVal = NULL;

   nError = ICALLMGR_OriginateEx(pMe->pICallMgr, AEET_CALL_TYPE_CS_DATA, &pMe->pOutgoingCall, &pMe->callListener, coo);

   if (SUCCESS != nError)

   {

      // call origination request rejected

      …

   }

   else

   {

      // call origination request accepted

      …

   }

}

}}}

==Monitoring the call state using a call listener==

The following code snippet provides a typical implementation of a call listener.

{{{

void Applet_OriginateListener (CApplet* pMe, ModelEvent* pEvent)

{

   AEETCallEvent* pCallEvent = (AEETCallEvent*) pEvent;

   switch (pCallEvent->evCode)

   {

      case AEET_EVENT_CALL_XXX:

         …

         break;

      default:

         …

         break;

   }

}

}}}

========================================
=ITelephone - Accessing an incoming call=

Accessing an incoming call using the ITelephone family of interfaces consists of getting notified of an incoming call and obtaining access to the ICall object corresponding to the incoming call. An application can get notified of an incoming call and obtain access to the ICall object there after in the following two ways:

* Register with AEECLSID_PHONENOTIFIER using AEET_NMASK_NEW_CALLDESC mask via the application MIF file

* Register a model listener with the ITelephone interface
**Obtaining access to ICall object when model listener is invoked


==Register with AEECLSID_PHONENOTIFIER using AEET_NMASK_NEW_CALLDESC mask via the application MIF file== 
On an incoming call, the application receives the EVT_NOTIFY event. The dwParam for this event is of the type AEENotify where the pData member of this event is of the type AEETNotifyInfo. The following code snippet shows a typical handling of this event:

{{{

{

   AEENotify * pNotify = (AEENotify *) dwParam;

   if (pNotify->dwMask & AEET_NMASK_NEW_CALLDESC)

   {

      AEETNotifyInfo * pTNotifyInfo = pNotify->pData;

      if (pTNotifyInfo && (AEET_EVENT_CALL_INCOM ==pTNotifyInfo->event))

      {

         AEETCallEventData * pTCallEventData = (AEETCallEventData *)&(pTNotifyInfo->event_data);

         ICALLMGR_GetCall(pMe->pICallMgr, pTCallEventData->cd, &pMe->pIncomingCall);

      }

   }

}

}}}

==Register a model listener with the ITelephone interface==
On an incoming call, a model listener is invoked with the details of the incoming call. The following code snippet demonstrates registering a model listener with the ITelephone interface:

{{{

{

   Int nError;

   IModel* pModel = NULL;

   if (SUCCESS == ITELEPHONE_QueryInterface(pMe->pTelephone, AEEIID_MODEL, (void**) &pModel))

   {

      nError = IMODEL_AddListenerEx(pModel, &pMe->phoneListener, Applet_TelephoneListener, pMe);

      IMODEL_Release(pModel);

   

      if (SUCCESS != nError)

      {

         // failed to add listener

         …

      }

      else

      {

         // listener added

         …

      }

   }

}

}}}
==Obtaining access to ICall object when model listener is invoked==

The following code snippet demonstrates obtaining access to ICall object when model listener is invoked:

{{{

void Applet_TelephoneListener (CApplet* pMe, ModelEvent* pEvent)

{

   AEETCallEvent * pCallEvent = (AEETCallEvent*) pEvent;

   if (pCallEvent && (AEET_EVENT_CALL_INCOM == pCallEvent->evCode))

   {

      AEETCallEventData * pTCallEventData = (AEETCallEventData *)&(pCallEvent->call);

      ICALLMGR_GetCall(pMe->pICallMgr, pTCallEventData->cd, &pMe->pIncomingCall);

   }

}

}}} 

========================================
=ITelephone - Answering an incoming call=

Answering an incoming call using the ITelephone family of interfaces consists of getting access to ICall object corresponding to the incoming call and using the ICall object to answer the call.

Refer to the '''ITelephone - Accessing an incoming call''' use case for obtaining an ICall object corresponding to the incoming call. The following code snippet demonstrates how an application can answer the call using an ICall object corresponding to the call.

{{{

if (pMe->pIncomingCall)

{ 

   nError = ICALL_Answer(pMe->pIncomingCall);

   if (SUCCESS != nError)

   {

      // failed to answer call

      …

   }

   else

   {

      // call answered

      …

   }

}

}}}

========================================
=ITelephone - Rejecting an incoming call=

Rejecting an incoming call using the ITelephone family of interfaces consists of getting access to the ICall object corresponding to the incoming call and using the ICall object to end the call.

Refer to the '''ITelephone - Accessing an incoming call''' use case for obtaining ICall object corresponding to the incoming call. The following code snippet demonstrates how an application can end the call using the ICall object corresponding to the call.

{{{

if (pMe->pIncomingCall)

{ 

   nError = ICALL_End(pMe->pIncomingCall);

   if (SUCCESS != nError)

   {

      // failed to end call

      …

   }

   else

   {

      // call ended

      …

   }

}

}}}

========================================
=ITelephone - Redirecting an incoming call to another device=

Redirecting an incoming call using the ITelephone family of interfaces consists of getting access to ICall object corresponding to the incoming call and using the ICall object to redirect the call.

Refer to the '''ITelephone - Accessing an incoming call''' use case for obtaining ICall object corresponding to the incoming call. The following code snippet demonstrates how an application can redirect the call using ICall object corresponding to the call.

{{{

if (pMe->pIncomingCall)

{ 

   nError = ICALL_Redirect(pMe->pIncomingCall, szNumber);

   if (SUCCESS != nError)

   {

      // failed to redirect call

      …

   }

   else

   {

      // call redirected

      …

   }

}

}}}

========================================
=ITelephone - Putting an outgoing call on hold=

Putting an outgoing call on hold using the the ITelephone family of interfaces consists of getting access to the ICall object corresponding to the outgoing call and using the ICall object to put the call on hold.

Refer to the '''ITelephone - Originating a call''' use case for obtaining the ICall object corresponding to the outgoing call. The following code snippet demonstrates how an application can put the outgoing call on hold using thke ICall object corresponding to the call.

{{{

if (pMe->pOutgoingCall)

{ 

   nError = ICALL_Hold(pMe->pOutgoingCall);

   if (SUCCESS != nError)

   {

      // failed to put call on hold

      …

   }

   else

   {

      // call put on hold

      …

   }

}

}}}

========================================
=ITelephone - Activating a call put on hold=

Activating a call put on hold, using the ITelephone family of interfaces, consists of getting access to the ICall object corresponding to the call put on hold and using the the ICall object to activate the call.

Refer to the '''ITelephone - Putting an outgoing call on hold''' use case for obtaining the ICall object corresponding to the outgoing call put on hold. The following code snippet demonstrates how an application can activate the outgoing call that was put on hold using the ICall object corresponding to the call.

{{{

if (pMe->pOutgoingCall)

{ 

   nError = ICALL_Answer(pMe->pOutgoingCall);

   if (SUCCESS != nError)

   {

      // failed to activate call

      …

   }

   else

   {

      // call activated

      …

   }

}

}}}

========================================
=ITelephone - Transferring an outgoing call to an incoming call=

Transferring an outgoing call to an incoming call, using the ITelephone family of interfaces, consists of originating a call, putting the originated call on hold, receiving and answering an incoming call and transferring outgoing call to incoming call.

Refer to the '''ITelephone - Putting an outgoing call on hold''' use case for originating a call and putting that call on hold. Likewise, Refer to the '''ITelephone - Answering an incoming call''' use case for receiving and answering an incoming call. The following code snippet demonstrates how an application can transfer the an outgoing call to the an incoming call.

{{{

if (pMe->pOutgoingCall && pMe->pIncomingCall)

{ 

   nError = ICALL_Transfer(pMe->pOutgoingCall, pMe->pIncomingCall);

   if (SUCCESS != nError)

   {

      // failed to transfer Call

      …

   }

   else

   {

      // call transferred

      …

   }

}

}}}

========================================
=ITelephone - Accessing call information=

The information corresponding to a call can be obtained in the following two ways:
* By call descriptor(cd) 
* By ICall object (pICall)

==Using the call descriptor ==
An application can obtain the information corresponding to the call identified by the call descriptor(cd) using ITELEPHONE_GetCallInfo() as shown in the code snippet below.

{{{

{

   int nError;

   AEETCallInfo sTCallInfo;

   MEMSET(&sTCallInfo, 0, sizeof(sTCallInfo));

   nError = ITELEPHONE_GetCallInfo(pITelephone, cd, &sTCallInfo, sizeof(sTCallInfo));

   if (SUCCESS != nError)

   {

      // failed to get call information

      …

   }

   else

   {

      // got call information

      …

   }

}

}}}
==Using the ICall object pICall==
An application can obtain the information corresponding to the call identified by the ICall object “pICall” using ICALL_GetInfo() as shown in the code snippet below.

{{{

{

   int nError;

   AEETCallInfo sTCallInfo;

   MEMSET(&sTCallInfo, 0, sizeof(sTCallInfo));

   nError = ICALL_GetInfo(pICall, &sTCallInfo, sizeof(sTCallInfo));

   if (SUCCESS != nError)

   {

      // failed to get call information

      …

   }

   else

   {

      // got call information

      …

   }

}

}}}

========================================
=ITelephone - Finding out if system supports both of 1x and DO=

The following code snippet demonstrates how an application can determine if system supports both 1x and DO standards.

{{{

{

   int nError;

   AEETSSInfo sTSSInfo;

   MEMSET(&sTSSInfo, 0, sizeof(sTSSInfo));

   nError = ITELEPHONE_GetServingSystemInfo(pITelephone, &sTSSInfo, sizeof(sTSSInfo));

   

   if ((SUCCESS == nError) && (TRUE == sTSSInfo.hdr_hybrid))

   {

      // system supports both of 1x and DO

      …  

   }

   else

   {

      …

   }

}

}}}

========================================
=ITelephone - Sending key presses after the call is connected=

The following code snippet demonstrates a typical use of ICALL_BurstDTMF to send key presses on an outgoing call.

{{{

nError = ICALL_BurstDTMF(pMe->pOutgoingCall, AEET_DTMF_ON_350, AEET_DTMF_OFF_200, “8585551234”);

if (nError != SUCCESS)

{

   // DTMF burst request is rejected

   …

}

else

{

   // DTMF burst request is being processed

   …

}


}}}

========================================
=ITelephone - Finding out if there is a data call present on the device=

The following code snippet demonstrates how an application can get call descriptors corresponding to active calls on the device and then determine if there is an active data call.

{{{
{

   int nError

   uint32 dwCalls[32];

   nError = ITELEPHONE_GetCalls(pITelephone, (AEETCalls*)dwCalls, sizeof(dwCalls));

   if (nError != SUCCESS)

   {

      // ITELEPHONE_GetCalls() failed

      …

   }

   else

   {

      // Call descriptors of active calls obtained

      int nCalls = 0; 

      AEETCallInfo sTCallInfo;

      MEMSET(&sTCallInfo, 0, sizeof(sTCallInfo));

      AEETCalls * pCalls = (AEETCalls *)dwCalls;

      for (nCall = 0; nCall < pCalls->dwCount; nCall++)

      {

         if ((SUCCESS == ITELEPHONE_GetCallInfo(pITelephone, cd, &sTCallInfo, sizeof(sTCallInfo))) && 

             ((AEET_CALL_TYPE_CS_DATA == sTCallInfo.call_type) || (AEET_CALL_TYPE_PS_DATA == sTCallInfo.call_type)))

         {

            // call is data call

            …

         }

      }

   }

}



========================================
=ITelephone - Checking if a device does not have service=

The following code snippet demonstrates how an application can determine if a device does not have service:
{{{
{

   int nError;

   AEETSSInfo sTSSInfo;

   MEMSET(&sTSSInfo, 0, sizeof(sTSSInfo));

   nError = ITELEPHONE_GetServingSystemInfo(pITelephone, &sTSSInfo, sizeof(sTSSInfo));

   

   if ((SUCCESS == nError) && (AEET_SRV_STATUS_NO_SRV == sTSSInfo.srv_status))

   {

      // device doesn’t have service

      …  

   }

   else

   {

      // device service status is unknown

      …

   }

}
}}}

========================================
=ITelephone - Finding SID or NID for the selected network=

SID/NID information is provided as serving system information. The following code snippet 
demonstrates how an application can determine SID/NID for the selected network.

{{{

{

   int nError;

   AEETSSInfo sTSSInfo;

   MEMSET(&sTSSInfo, 0, sizeof(sTSSInfo));

   nError = ITELEPHONE_GetServingSystemInfo(pITelephone, &sTSSInfo, sizeof(sTSSInfo));

   

   if (SUCCESS == nError)

   {

      // sTSSInfo.sys_id.id.is95.sid and sTSSInfo.sys_id.id.is95.nid respectively
      // represents SID and NID of the selected network
      …  

   }

   else

   {

      …

   }

}

}}}

========================================
=ITelephone - Listening for changes to serving system information=

Serving system information provides details on serving system. SID/NID information
is the part of the serving system information. The following code snippet demonstrates 
how an application can listen to any changes to the serving system information.

==Register a model listener with the ITelephone interface==
On changes to serving system information, a model listener is invoked with the details of the changes. The following code snippet demonstrates registering a model listener with the ITelephone interface:

{{{

{

   Int nError;

   IModel* pModel = NULL;

   if (SUCCESS == ITELEPHONE_QueryInterface(pMe->pTelephone, AEEIID_MODEL, (void**) &pModel))

   {

      nError = IMODEL_AddListenerEx(pModel, &pMe->phoneListener, Applet_TelephoneListener, pMe);

      IMODEL_Release(pModel);

   

      if (SUCCESS != nError)

      {

         // failed to add listener

         …

      }

      else

      {

         // listener added

         …

      }

   }

}

}}}

==Finding serving system information changes when model listener is invoked==

The following code snippet demonstrates obtaining information on serving system information changes when model listener is invoked:

{{{

void Applet_TelephoneListener (CApplet* pMe, ModelEvent* pEvent)

{

   AEETSSEvent * pSSEvent = (AEETSSEvent*) pEvent;

   if (pSSEvent && (AEET_EVENT_SS_SRV_CHANGED == pSSEvent->evCode))

   {

      AEETSSEventData * pTSSEventData = (AEETSSEventData *)&(pSSEvent->ss);

      // pTSSEventData->changed_fields represents the changed fields of serving
      // system structure and pTSSEventData->ss_info represents the serving system
      // information.
      
   }

}

}}} 