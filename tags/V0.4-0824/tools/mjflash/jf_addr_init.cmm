;============================================================================
;  Name:
;    JF_ADDR_INIT.CMM
;
;  Variable initialization script used by erasechip.cmm
;
;
;  Copyright (c) 2006-2008 Qualcomm Incorporated. 
;  All Rights Reserved.
;  Qualcomm Confidential and Proprietary
;----------------------------------------------------------------------------
;============================================================================
;
;                        EDIT HISTORY FOR MODULE
;
; $Header: //depot/asic/msmshared/tools/jflash/JFLASH.03.00/jf_addr_init.cmm#4 $ $DateTime: 2008/02/22 18:12:18 $ $Author: opham $
;
; when       who     what, where, why
; -------    ---     --------------------------------------------------------
; 01/03/08   op      Add support for single-image NOR targets
; 02/28/07   rt      Add support for multi-image NOR targets
; 12/06/06   rt      Create initial version from JFLASH 2.1
;
;============================================================================;


;-------------------------------------------------------------------------------
; This structure is used to communcate between TRACE32 Debugger and
; our FLASH plug-in.
;-------------------------------------------------------------------------------
;
; struct type_jtag_flash_param {
;    uint32 flashaddr;   // offset 0x00
;    uint32 flashwidth;  // offset 0x04
;    uint32 width;       // offset 0x08
;    uint32 offset;      // offset 0x0C
;    uint32 addr;        // offset 0x10 in: address of the flash to write/erase
;    uint32 size;        // offset 0x14 in: size of data to write/erase
;    uint32 reserved;    // offset 0x18
;    uint32 status;      // offset 0x1C in: 1=program, 2=erase, 5=erase, out: 0=o.k., 0x100=fail
;    byte   data[0x20000]; /offset 0x20	// give 128K worth of buffer
;                            // this is where TRACE32 will store data that
;                            // we'll be writing to the FLASH
; };



;-------------------------------------------------------------------------------
; These variables implement the structure above in PRACTICE variables
;
;  &JnandCodeAddr and &JnandParamAddr come from a generated file and are
;  the only varibles which contain any MSM specific information
;-------------------------------------------------------------------------------
;
GLOBAL &StartAddr &ParmBlk
GLOBAL &ParmFlashaddr &ParmFlashwidth &ParmWidth
GLOBAL &ParmOffset &ParmAddr &ParmSize
GLOBAL &ParmReserved &ParmStatus &ParmCmd &ParmData &ParmID
GLOBAL &ReportBytesGap &ReportBlocksGap &ReportImageSize
GLOBAL &EraseCmd &ProgramCmd &InitCmd &InitBootCmd &FinishCmd
GLOBAL &TestCmd &ReportCmd &VerifyCmd &EraseChipCmd
GLOBAL &ReportInt &Result &CmdName &RetrieveID &ValidateBoot
GLOBAL &PartiNoOverride &PartiOverride 


GLOBAL &UsrPartiTblCmd &SysPartiTblCmd &InitBootVecTblCmd
GLOBAL &InitQcSblCmd &InitOemSblCmd &InitAmssCmd &InitAllCmd
GLOBAL &InitEfsCmd &InitFotaUIBmpCmd &InitFotaPkgCmd
GLOBAL &HardwarePresent

&StartAddr=        &JflashCodeAddr
&ParmBlk=          &JflashParamAddr

;print "parm block at " &ParmBlk

; addresses of contents of parameter block
;
&ParmFlashaddr=    &ParmBlk+0x00
&ParmFlashwidth=   &ParmBlk+0x04
&ParmWidth=        &ParmBlk+0x08
&ParmOffset=       &ParmBlk+0x0C
&ParmAddr=         &ParmBlk+0x10
&ParmSize=         &ParmBlk+0x14
&ParmReserved=     &ParmBlk+0x18
&ParmID=           &ParmBlk+0x18
&ParmStatus=       &ParmBlk+0x1C
&ParmCmd=          &ParmBlk+0x1C
&ParmData=         &ParmBlk+0x20

&ReportBytesGap=   &ParmBlk+0x00
&ReportBlocksGap=  &ParmBlk+0x04
&ReportImageSize=  &ParmBlk+0x08


; command values for parameter block
;
&ProgramCmd=       0x01 ;; Lauterbach cmd to program flash
&EraseCmd=         0x02 ;; Lauterbach cmd to erase flash
&InitCmd=          0x09 ;; our cmd to probe and bad block check to happen
&FinishCmd=        0x0A ;; our cmd to cause RAM copy of block map to be written
&TestCmd=          0x0B ;; our cmd to cause self test
&ReportCmd=        0x0C ;; our cmd to cause a report of bad blocks
&VerifyCmd=        0x0D ;; our cmd to cause verify of spans
&InitBootCmd=      0x0E ;; our cmd to init into boot block program mode
&EraseChipCmd=     0x20 ;; our cmd to erase entire NAND flash
&RetrieveID=       0x21 ;; our cmd to retrieve raw NAND ID
&ValidateBoot=     0x22 ;; our cmd to validate boot block

; Commands for Multi-Image Boot
&UsrPartiTblCmd=   0x40 ;; our cmd to send User partition table
&InitPblCmd=       0x41 ;; our cmd to init for PBL programming
&InitQcSblHdCmd=   0x42 ;; our cmd to init for QCSBL Header programming
&InitQcSblCmd=     0x43 ;; our cmd to init for QCSBL Programming
&InitOemSblCmd=    0x44 ;; our cmd to init for OEMSBL Programming
&InitAmssCmd=      0x45 ;; our cmd to init for AMSS Programming
&PrintMibibCmd=    0x46 ;; our cmd to print MIBIB contents
&PrintLayoutCmd=   0x47 ;; our cmd to print flash layout
&SecModeCmd=       0x48 ;; our cmd to send security mode

&InitEfsCmd=       0x4C ;; our cmd to init for EFS image
&SysPartiTblCmd=   0x4D ;; our cmd to send System partition table
&InitBootVecTblCmd=0x4E ;; our cmd to send BOOT Vector table
&InitFotaUIBmpCmd= 0x4F ;; our cmd to send FOTA UI Bitmaps
&InitFotaPkgCmd=   0x50 ;; our cmd to send FOTA Delta Package
&InitAllCmd=       0x51 ;; our cmd to init for ALL image

&PartiNoOverride=0x0
&PartiOverride=0x1

&HardwarePresent=0x1


; misc
;
&ReportInt=    0x0
&Result=       0x0
&CmdName=      "No command yet"

enddo




