/*=====================================================================
      USE CASE SCENARIOS DOCUMENTATION

=======================================================================
=ISockPort - Preview=
This section discusses general issues concerning the use of ISockPort interface.
==Asynchronous Calls==
As opposed to other soket APIs (e.g. Berkeley Sockets API), work with Brew ISockPort is always asynchronous.
For example, an accept() operation in Brew will return immediately, even if there is no pending connect()
request at the moment. For any operation that may block, the user should check the return status. If it is AEEPORT_WAIT, it means that
the system could not make a progress with the operation. In that case, the user should register a callback 
that will be called when the desired activity can actually make a progress.

For example, consider the following function. The user calls ISOCKPORT_Connect(), 
which returns immediately. Then the user examines the return value: If it is AEEPORT_WAIT, it 
means that the operation can not progress at the moment. In this case, the user calls ISOCKPORT_WriteableEx()
to register a callback that will be called when the operation may make a progress.

{{{
 void CApp_TryConnect(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
 
   // connect to the distant server
   ret = ISOCKPORT_Connect(pme->m_pISockPort,  // ISockPort object
                           &pme->m_saSockAddr  // pointer to dest socket address struct
                          );
 
   if (AEEPORT_WAIT == ret) {
      // register CApp_TryConnect() as a callback to be called when the write operation may progress.
      ISOCKPORT_WriteableEx(pme->m_pISockPort,  // ISockPort object pending on the operation 
                            &pme->m_cbCallback, // AEECallback* to be associated with the concrete callback
                            CApp_TryConnect,    // the callback function
                            pme                 // user data to be passed to the callback
                           );
      return;
   }
 
   // hadle other ret values
   ...
 }
}}}
Socket operations can be divided into two groups: ''read'' operations and ''write'' operations. 

On a ''read'' operation, the user should call ISOCKPORT_ReadableEx().
On a ''write'' operation, the user should call ISOCKPORT_WriteableEx().

Note that that when the callback code is reached, there is no guarantee that 
the desired operation will now make a progress. That's why the user has to repeatedly check if its
operation completed or it can't progress at the moment.

=======================================================================
=ISockPort - Writing a UDP client application=
This section will demonstrate a simple UDP client application that sends and receives data over an ISockPort object.
*
The steps demonstrated are as follows:
# Data initialization.
# Creating and opening an ISockPort object.
# Sending data to a server.
# Receiving data from a server.
# Closing a SockPort.
#
Note that the application assumes the existence of a UDP server.


==Data Initialization==
One should define the following:
{{{
 // define port number and IP address of the server
 #define SERVER_PORT   0x1212
 #define SERVER_ADDR   "129.46.229.214"
 
 // define message length
 #define BUFFER_SIZE   100
 #
}}}

Among others, the applet should have the follwoing members:
{{{
 IShell*             m_pIShell,                       // IShell pointer 
 ISockPort*          m_pISockPort;                    // ISockPort pointer
 AEECallback         m_cbSendToCallback;              // AEECallback pointer for send operations
 AEECallback         m_cbRecvFromCallback;            // AEECallback pointer for receive operations
 AEESockAddrStorage  m_saSockAddr;                    // socket address structure
 char                m_caSendBuffer[BUFFER_SIZE];     // buffer to send
 char                m_caReceiveBuffer[BUFFER_SIZE];  // buffer to receive
 uint32              m_uBytesReceived;                // number of received bytes
 uint32              m_uBytesSent;                    // number of sent bytes
}}}


Initialization of the server address structure should be also carried out:
{{{
 // initialize the addresses
 pme->m_saSockAddr.wFamily     = AEE_AF_INET;           // IPv4 socket
 pme->m_saSockAddr.inet.port   = HTONS(SERVER_PORT);    // set port number
 
 // set server IP address
 INET_PTON(pMe->saSockAddr.wFamily,  
           ECHO_SERVER_ADDR,  
           &(pMe->saSockAddr.inet.addr)); 
}}}

Initialize some of the members:
{{{
 pme->m_uBytesReceived = 0;
 pme->m_uBytesSent     = 0;
 
 // initialize the Send buffer  
 for (i = 0; i < BUFFER_SIZE; ++i) {
     pme->m_caSendBuffer[i] = (char)(i % 10);
   }
}}}
Note that both the counters (m_uBytesReceived, m_uBytesSent) and the buffers (m_caSendBuffer and m_caReceiveBuffer) carry the state of a single transaction. It is the application's responsibility to prevent running over them during an ongoing transaction (or maintain a more sophisticated data structure).
==Creating a UDP SockPort==
For having a functional ISockport object, the following stages must be performed:

# Calling IShell_CreateInstance(), to create an ISockPort object.
# Calling ISockPort_OpenEx(), to open the SockPort.
#

{{{
 void CApp_StartUDPClient(void* po)
 {
   CApp* pme = (CApp*)po;
 
   // create the ISockPort object.
   ret = ISHELL_CreateInstance(pme->m_pIShell, AEECLSID_SOCKPORT, (void**)&(pme->m_pISockPort));
   if (SUCCESS != ret) { 
      // handle the error
      ...
      return;
   }
 
   // open the SockPort.
   ret = ISOCKPORT_OpenEx(pme->m_pISockPort,    // ISockPort pointer
                          AEE_AF_INET,          // wFamily     = IPv4
                          AEE_SOCKPORT_DGRAM,   // socket type = UDP
                          0                     // Protocol type:
                                                // Use 0 (recommended) to let the system select its default 
                                                // protocol for the given address family and socket type
                          );
   if (SUCCESS != ret) { 
      // handle the error
      ...
      return;
   }
 }
}}}
At this stage the client is ready for sending data. Note that the client is still not ready for receiving data, since it is not bounded.


==Sending data over the SockPort==
The example function - '''CApp_TrySendTo()''' - shown below, attempts to send data to the server, using ISOCKPORT_SendTo().

It then handles all the possible values ISOCKPORT_SendTo() may return:
* AEEPORT_WAIT - the system can't send data at this time. Often, it is because the system needs to establish a data connection between the phone and the cellular network on which the UDP data can be transmitted. In this case - call ISOCKPORT_WriteableEx() and register CApp_TrySendTo() as a callback, to be called again when the SendTo operation can make a progress.
* AEEPORT_ERROR - an error occurred. Check the error code.
* pme->m_uBytesSent <  BUFFER_SIZE - not all the data was sent yet. Register to receive a notification when more data can be sent.
* pme->m_uBytesSent == BUFFER_SIZE - all bytes were successfully sent.
*

{{{
 void CApp_TrySendTo(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
 
   // send the data to the server.
   ret = ISOCKPORT_SendTo(pme->m_pISockPort,                         // ISockPort object
                          (pme->m_caSendBuffer + pme->m_uBytesSent), // buffer to send
                          (BUFFER_SIZE - pme->m_uBytesSent),         // buffer length
                          0,                                         // no special flags
                          &pme->m_saSockAddr                         // pointer to dest socket address struct
                         );
                           
   // data can't be sent now.
   if (AEEPORT_WAIT == ret) {
      // register CApp_TrySendTo() as a callback to be called when the SendTo operation may progress.
      ISOCKPORT_WriteableEx(pme->m_pISockPort, &pme->m_cbSendToCallback, CApp_TrySendTo, pme);
      return;
   }   
   // an error occurred. get the error code.
   if (AEEPORT_ERROR == ret) {
      ret = ISOCKPORT_GetLastError(pme->m_pISockPort);
      ...
      return;
   }
    
   // some data was sent - update the bytes counter  
   pme->m_uBytesSent += ret;
   
   // not all the data bytes were sent yet.
   if (pme->m_uBytesSent < BUFFER_SIZE) {
      // register CApp_TrySendTo() as a callback to be called when the SendTo operation may progress.
      ISOCKPORT_WriteableEx(pme->m_pISockPort, &pme->m_cbSendToCallback, CApp_TrySendTo, pme);
      return;
   }
 
   // (BUFFER_SIZE == pme->m_uBytesSent ) - all bytes were successfully sent.
   // reset the bytes counter for next transaction
   pme->m_uBytesSent = 0;
   ...
 }
}}}

==Receiving data over the SockPort==
The example function - '''CApp_TryRecvFrom()''' - shown below, attempts to receive data from the server, using ISOCKPORT_RecvFrom().

It then handles all the possible values ISOCKPORT_RecvFrom() may return:
* AEEPORT_WAIT - no data to be received at this time. Often, it is because the system needs to establish a data connection between the phone and the cellular network on which the UDP data can be received. In this case - call ISOCKPORT_ReadableEx() and register CApp_TryRecvFrom() as a callback, to be called again when the RecvFrom operation can make a progress.
* AEEPORT_ERROR - an error occurred. Check the error code.
* pme->m_uBytesReceived <  BUFFER_SIZE - not all the data was received yet. Register to receive a notification when more data can be received.
* pme->m_uBytesReceived == BUFFER_SIZE - all bytes were successfully received.
*

{{{
 void CApp_TryRecvFrom(void* po)
 {
   int ret;
   int nSockAddrSize;
   AEESockAddrStorage sa;
   CApp* pme = (CApp*)po;
  
   // receive data from the server.
   ret = ISOCKPORT_RecvFrom(pme->m_pISockPort,                              // ISockPort object
                            (pme->m_caReceiveBuffer + pme->m_uBytesReceived), // buffer for received message
                            (BUFFER_SIZE - pme->m_uBytesReceived) ,           // buffer length
                            0,                                              // flags, not used
                            &sa,                                            // pointer to the address struct to be filled
                            &nSockAddrSize                                  // a pointer to the size of sa 
                           );
 
   // no data is available for reading.
   if (AEEPORT_WAIT == ret) {
      // register CApp_TryRecvFrom() as a callback to be called when the RecvFrom operation may progress.
      ISOCKPORT_ReadableEx(pme->m_pISockPort, &pme->m_cbRecvFromCallback, CApp_TryRecvFrom, pme);
      return;
   }
      
   // an error occurred. get the error code.
   if (AEEPORT_ERROR == ret) {
      ret = ISOCKPORT_GetLastError(pme->m_pISockPort);
      ...
      return;
   }
 
   // some data was received - update the bytes counter  
   pme->m_uBytesReceived += ret;
 
   // not all the data bytes were received yet.
   if (pme->m_uBytesReceived < BUFFER_SIZE) {
      // register CApp_TryRecvFrom() as a callback to be called when the RecvFrom operation may progress.
      ISOCKPORT_ReadableEx(pme->m_pISockPort, &pme->m_cbRecvFromCallback, CApp_TryRecvFrom, pme);
      return;
   }
 
   // (BUFFER_SIZE == ret) - all bytes were successfully received.
   // reset the bytes counter for next transaction
   pme->m_uBytesReceived = 0;
   ...
 }
}}}

==Closing an ISockPort==
Whenever done with a SockPort (either when an error occurred or when exiting the application), 
it is important to close and release ISockPort object.

RELEASEIF macro calls ISOCKPORT_Release(), which will implicitly close the socket in the background if it is open.
{{{
 #define RELEASEIF(pi) { if (pi) { IBASE_Release((IBase*)(pi)); (pi)=0; }}
}}}

A function like '''CApp_SockPortEnd()''' can be applied.
{{{
 void CApp_SockPortEnd(CApp* pme)
 {
     CALLBACK_Cancel(&pme->m_cbRecvFromCallback);
     CALLBACK_Cancel(&pme->m_cbSendToCallback);
     RELEASEIF(pme->m_pISockPort);
 }
}}}

=======================================================================
=ISockPort - Writing a UDP server application=
This section demonstrates a simple UDP echo server application, using an ISockPort object.

The steps demonstrated are as follows:
# Data initialization.
# Creating and opening an ISockPort object.
# Binding a Sockport.
# Receiving data from a client.
# Sending data to a client.
# Closing a SockPort.
#

==Data Initialization==
One should define the following:
{{{
 // define port number of the server
 #define SERVER_PORT   7
 
 // define message length
 #define BUFFER_SIZE   100
}}}

Among others, the applet should have the follwoing members:
{{{
 IShell*             m_pIShell,                       // IShell pointer 
 ISockPort*          m_pISockPort;                    // ISockPort pointer
 AEECallback         m_cbRecvFromCallback;            // AEECallback pointer for receive operations
 AEECallback         m_cbSendToCallback;              // AEECallback pointer for send operations
 AEESockAddrStorage  m_saSockAddr;                    // server socket address structure
 AEESockAddrStorage  m_saClientAddr;                  // socket address of the current client
 char                m_caBuffer[BUFFER_SIZE];         // data buffer
 uint32              m_uBytesReceived;                // number of bytes received in this transaction
 uint32              m_uBytesSent;                    // number of bytes sent
}}}

Initialization of the address structure should be also carried out:
{{{
 // initialize the addresses. 
 pme->m_saSockAddr.wFamily   = AEE_AF_INET;           // IPv4 socket
 pme->m_saSockAddr.inet.port = HTONS(SERVER_PORT);    // set port number
 pme->saSockAddr.inet.addr   = HTONL(AEE_INADDR_ANY); // set IP address to any available address.
}}}

Initialize some of the members: 
{{{
 pme->m_uNumOfBytesRead = 0;
 pme->m_uBytesSent      = 0;
}}}

==Creating a UDP SockPort==
For having a functional ISockport object, the following stages must be performed:

# Calling IShell_CreateInstance(), to create an ISockPort object.
# Calling ISockPort_OpenEx(), to open the SockPort.
#
{{{
 void CApp_StartUDPClient(void* po)
 {
   CApp* pme = (CApp*)po;
 
   // create the ISockPort object.
   ret = ISHELL_CreateInstance(pme->m_pIShell, AEECLSID_SOCKPORT, (void**)&(pme->m_pISockPort));
   if (SUCCESS != ret) { 
      // handle the error
      ...
      return;
   }
 
   // open the SockPort.
   ret = ISOCKPORT_OpenEx(pme->m_pISockPort,    // ISockPort pointer
                          AEE_AF_INET,          // wFamily     = IPv4
                          AEE_SOCKPORT_DGRAM,   // socket type = UDP
                          0                     // Protocol type:
                                                // Use 0 (recommended) to let the system select its default 
                                                // protocol for the given address family and socket type
                          );
   if (SUCCESS != ret) { 
      // handle the error
      ...
      return;
   }
 }
}}}

==Binding a SockPort==
The server SockPort has to be bound. The example function - '''CApp_TryBind()''' - shown below, attempts to bind the SockPort, using ISOCKPORT_Bind()

It then handles all the possible values ISOCKPORT_Bind() may return:
* AEEPORT_WAIT - the operation cannot be completed at present. Often, it is because the system needs to establish a data connection between the phone and the cellular network on which the UDP data can be transmitted. In this case - call ISOCKPORT_WriteableEx() and register CApp_TryBind() as a callback, to be called again when the bind operation can make a progress.
* ret !=  SUCCESS - an error occurred. ret holds the error code.
* ret == SUCCESS - operation succeeded.
*

Note that ISOCKPORT_Bind() returns the error code, and there is no need to explicitly get it using ISOCKPORT_GetLastError().

{{{
 void CApp_TryBind(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
    
   // use AEE_INADDR_ANY for binding     
   ret = ISOCKPORT_Bind( pme->m_pISockPort, &( pme->m_saSockAddr ) );
   if(AEEPORT_WAIT == ret)
   {
      ISOCKPORT_WriteableEx(pme->m_pISockPort, &pme->m_cbSendToCallback, CApp_TryBind, pme);
      return;
   } 
   else if(SUCCESS != ret)
   {
      // handle the error
      ...
      return;
   }
  
   // (SUCCESS == ret) - the SockPort is bound, receive data on it.
   CApp_TryRecvFrom(pme);
 }
}}}
Note that in m_saSockAddr, inet.addr was set to AEE_INADDR_ANY. Currently, this is the only supported option for bind operation.

At this stage the server is ready for receiving data.


==Receiving data over the SockPort==
The example function - '''CApp_TryRecvFrom()''' - shown below, attempts to receive data from a client, using ISOCKPORT_RecvFrom().

It then handles all the possible values ISOCKPORT_RecvFrom() may return:
* AEEPORT_WAIT - the system can't receive data at this time. Often, it is because the system needs to establish a data connection between the phone and the cellular network on which the UDP data can be received. In this case - call ISOCKPORT_ReadableEx() and register CApp_TryRecvFrom() as a callback, to be called again when the RecvFrom operation can make a progress.
* AEEPORT_ERROR - an error occurred. Check the error code.
* ret >  0 - data bytes were received. Update m_uBytesReceived with actual number of bytes recieved, and echo them back to the client. Note that we copy the client's address struct to the application's struct. This will allow the server to reply the client.
*

{{{
 void CApp_TryRecvFrom(void* po)
 {
   int ret;
   int nSockAddrSize;
   AEESockAddrStorage sa;
   CApp* pme = (CApp*)po;
  
   // receive data from the server.
   ret = ISOCKPORT_RecvFrom(pme->m_pISockPort,     // ISockPort object
                            pme->m_caBuffer,       // buffer for received message
                            BUFFER_SIZE,           // buffer length
                            0,                     // flags, not used
                            &sa,                   // pointer to the address struct to be filled
                            &nSockAddrSize         // a pointer to the size of sa 
                           );
 
   // no data is available for receiving.
   if (AEEPORT_WAIT == ret) {
      // register CApp_TryRecvFrom() as a callback to be called when the RecvFrom operation may progress.
      ISOCKPORT_ReadableEx(pme->m_pISockPort, &pme->m_cbRecvFromCallback, CApp_TryRecvFrom, pme);
      return;
   }
      
   // an error occurred. get the error code.
   if (AEEPORT_ERROR == ret) {
      ret = ISOCKPORT_GetLastError(pme->m_pISockPort);
      ...
      return;
   }
   
   // some bytes were received. update the counters.
   pme->m_uBytesReceived = ret;
   pme->m_uBytesSent = 0;
 
   // save the client's address, to allow the server to reply it.
   pme->m_saClientAddr = sa;
    
   // echo the data back to the client.
   CApp_TrySendTo(pme);
 }
}}}

==Sending data over the SockPort==
The example function - '''CApp_TrySendTo()''' - shown below, attempts to send data to the client, using ISOCKPORT_SendTo().

It then handles all the possible values ISOCKPORT_SendTo() may return:
* AEEPORT_WAIT - the system can't send data at this time. Often, it is because the system needs to establish a data connection between the phone and the cellular network on which the UDP data can be sent. In this case - call ISOCKPORT_WriteableEx() and register CApp_TrySendTo() as a callback, to be called again when a SendTo operation can make a progress.
* AEEPORT_ERROR - an error occured. Check the error code.
* ret >  0 - some data was sent. If not all the data was sent - register on a callback to be notified when SendTo may progress. If all data was sent - try to receive data.
*

{{{
 void CApp_TrySendTo(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
 
   // send the data to the server.
   ret = ISOCKPORT_SendTo(pme->m_pISockPort,                             // ISockPort object
                          (pme->m_caBuffer + pme->m_uBytesSent),         // buffer to send
                          (pme->m_uBytesReceived - pme->m_uBytesSent),   // buffer length
                          0,                                             // no special flags
                          &pme->m_saClientAddr                           // pointer to dest socket address struct
                         );
                          
   // data can't be sent now.
   if (AEEPORT_WAIT == ret) {
      // register CApp_TrySendTo() as a callback to be called when the SendTo operation may progress.
      ISOCKPORT_WriteableEx(pme->m_pISockPort, &pme->m_cbSendToCallback, CApp_TrySendTo, pme);
      return;
   }
 
   // an error occurred. get the error code.
   if (AEEPORT_ERROR == ret) {
      ret = ISOCKPORT_GetLastError(pme->m_pISockPort);
      ...
      return;
   }
      
   // data bytes were sent.
   pme->m_uBytesSent += ret;
   
   // not all the data was sent
   if (pme->m_uBytesSent < pme->m_uBytesReceived) {
      // register CApp_TrySendTo() as a callback to be called when SendTo operation may progress.
      ISOCKPORT_WriteableEx(pme->m_pISockPort, &pme->m_cbSendToCallback, CApp_TrySendTo, pme);
      return;
    }
   
   // (pme->m_uBytesSent == pme->m_uBytesReceived) - all data was sent. 
   // reset counter
   pme->m_uBytesReceived = 0;
 
   // go back to receiving data.
   CApp_TryRecvFrom(pme);
 }
}}}
==Closing an ISockPort==
Whenever done with a SockPort (either when an error occurred or when exiting the application), 
it is important to close and release ISockPort object.

RELEASEIF macro calls ISOCKPORT_Release(), which will implicitly close the socket in the background if it is open.
{{{
 #define RELEASEIF(pi) { if (pi) { IBASE_Release((IBase*)(pi)); (pi)=0; }}
}}}

A function like '''CApp_SockPortEnd()''' can be applied.
{{{
 void CApp_SockPortEnd(CApp* pme)
 {
     CALLBACK_Cancel(&pme->m_cbSendToCallback);
     CALLBACK_Cancel(&pme->m_cbRecvFromCallback);
     RELEASEIF(pme->m_pISockPort);
 }
}}}

=======================================================================
=ISockPort - Writing a TCP client application=
This section will demonstrate a simple TCP client application that
reads and writes data over an ISockPort object.

The steps demonstrated are as follows:
# Data initialization.
# Creating and opening an ISockPort object.
# Connecting to the server.
# Writing data to a server.
# Reading data from a server.
# Closing a SockPort.
#
Note that the application assumes the existence of a TCP server.


==Data Initialization==
One should define the following:
{{{
 // define port number and IP address of the server
 #define SERVER_PORT   0x1212
 #define SERVER_ADDR   "129.46.229.214"
 
 // define message length
 #define BUFFER_SIZE 100
}}}


Among others, the applet should have the follwoing members:
{{{
 IShell*             m_pIShell,                    // IShell pointer 
 ISockPort*          m_pISockPort;                 // ISockPort pointer
 AEECallback         m_cbReadCallback;             // AEECallback pointer for read operations
 AEECallback         m_cbWriteCallback;            // AEECallback pointer for write operations
 AEESockAddrStorage  m_saSockAddr;                 // socket address structure
 char                m_caWriteBuffer[BUFFER_SIZE]; // buffer to write
 char                m_caReadBuffer[BUFFER_SIZE];  // buffer to read
 int                 m_nBytesWritten;              // number of bytes written
 int                 m_nBytesRead;                 // number of bytes read
}}}

Initialization of the server address structure should be also carried out:
{{{
 // initialize the addresses
 pme->m_saSockAddr.wFamily     = AEE_AF_INET;           // IPv4 socket
 pme->m_saSockAddr.inet.port   = HTONS(SERVER_PORT);    // set port number
 
 // set server IP address
 INET_PTON(pMe->saSockAddr.wFamily,  
           ECHO_SERVER_ADDR,  
           &(pMe->saSockAddr.inet.addr)); 
}}}

Set the following members to zero
{{{
 pme->m_nBytesWritten = 0;
 pme->m_nBytesRead    = 0;
 
 // initialize the write buffer  
 for (i = 0; i < BUFFER_SIZE; ++i) {
    pme->m_caWriteBuffer[i] = (char)(i % 10);
  }
}}}
Note that both the counters (m_nBytesRead, m_nBytesWritten) and the buffers (m_caWriteBuffer and m_caReadBuffer) 
carry the state of a single transaction. It is the application's responsibility to prevent running over them 
during an ongoing transaction (or maintain a more sophisticated data structure). 
==Creating a TCP SockPort==
For having a functional ISockport object, the following stages must be performed:

# Calling IShell_CreateInstance(), to create an ISockPort object.
# Calling ISockPort_OpenEx(), to open the SockPort.
#

{{{
 void CApp_StartTCPClient(void* po)
 {
   CApp* pme = (CApp*)po;
 
   // create the ISockPort object.
   ret = ISHELL_CreateInstance(pme->m_pIShell, AEECLSID_SOCKPORT, (void**)&(pme->m_pISockPort));
   if (SUCCESS != ret) { 
      // handle the error
      ...
      return;
   }
 
   // open the SockPort.
   ret = ISOCKPORT_OpenEx(pme->m_pISockPort,    // ISockPort pointer
                          AEE_AF_INET,          // wFamily     = IPv4
                          AEE_SOCKPORT_STREAM,  // socket type = TCP
                          0                     // Protocol type:
                                                // Use 0 (recommended) to let the system select its default 
                                                // protocol for the given address family and socket type
                          );
   if (SUCCESS != ret) { 
      // handle the error
      ...
      return;
   }
 }
}}}

==Connecting to the server==
The next stage is to establish a TCP connection to the remote server.

The example function '''CApp_TryConnect()''' demonstrates this process: It calls ISOCKPORT_Connect(), and checks the returned value:

* If (ret == AEEPORT_WAIT), call ISOCKPORT_WriteableEx() and register CApp_TryConnect() as a callback to be invoked when the connect operation on this SockPort can make a progress.

* If (ret == SUCCESS), the ISockPort object is ready for writing and reading data.
*

{{{
 static void CApp_TryConnect(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
 
   // connect to the distant server
   ret = ISOCKPORT_Connect(pme->m_pISockPort,  // ISockPort object
                           &pme->m_saSockAddr  // pointer to dest socket address struct
                          );
 
   if (AEEPORT_WAIT == ret) {
      // register CApp_TryConnect() as a callback to be called when the connect operation may progress.
      ISOCKPORT_WriteableEx(pme->m_pISockPort, &pme->m_cbWriteCallback, CApp_TryConnect, pme);
      return;
   }
   
   if (SUCCESS != ret) {
      // do error handling
      ...
      return;
   }
   
   // (SUCCESS == ret), the SockPort is connected
   ...
 }
}}}


==Writing data to the server==
The example function - '''CApp_TryWrite()''' - shown below, attempts to write data to the server, using ISOCKPORT_Write().

It then handles all the possible values ISOCKPORT_Write() may return:
* AEEPORT_WAIT - the system can't write data at this time. Often, this is because the system needs to establish a data connection between the phone and the cellular network on which the TCP data can be transmitted. Call ISOCKPORT_WriteableEx() and register CApp_TryWrite() as a callback, to be called again when the write operation can make a progress.
* AEEPORT_ERROR - an error occurred. Check the error code.
* AEEPORT_CLOSED - connection was closed by the server.
* ret <  BUFFER_SIZE - not all the data was written yet. Register CApp_TryWrite() as a callback to be called when writing can proceed.
* ret == BUFFER_SIZE - all bytes were successfully written.
*

{{{
 void CApp_TryWrite(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
 
   // write the data to the server.
   ret = ISOCKPORT_Write(pme->m_pISockPort,                           // ISockPort object
                         pme->m_caWriteBuffer + pme->m_nBytesWritten, // buffer to write
                         BUFFER_SIZE - pme->m_nBytesWritten);         // buffer length
                          
   // the system can't write data at the moment.
   if (AEEPORT_WAIT == ret) {
      // call CApp_TryWrite() again when the write operation may progress.
      ISOCKPORT_WriteableEx(pme->m_pISockPort, &pme->m_cbWriteCallback, CApp_TryWrite, pme);
      return;
   }
 
   // an error occurred. get the error code.
   if (AEEPORT_ERROR == ret) {
      ret = ISOCKPORT_GetLastError(pme->m_pISockPort);
      ...
      return;
   }
      
   // connection closed by the other side
   if (AEEPORT_CLOSED == ret) {
      // handle connection closure
      ...
      return;
   }
 
   // some bytes were written.
   pme->m_nBytesWritten += ret;
 
   // not all the bytes were written yet. call CApp_TryWrite() again when the write operation may progress.
   if (pme->m_nBytesWritten < BUFFER_SIZE) {
      ISOCKPORT_WriteableEx(pme->m_pISockPort, &pme->m_cbWriteCallback, CApp_TryWrite, pme);
      return;
   }
 
   // (BUFFER_SIZE == ret) - all the bytes were successfully written
   // reset the bytes counter for next write operation
   pme->m_nBytesWritten = 0;
   ...
 }
}}}


==Reading data from the server==
The example function - '''CApp_TryRead()''' - shown below, attempts to read data from the server, using ISOCKPORT_Read().

It then handles all the possible values ISOCKPORT_Read() may return:
* AEEPORT_WAIT - the system can't read data at this time. Often, this is because the system needs to establish a data connection between the phone and the cellular network on which the TCP data can be received. In this case - call ISOCKPORT_ReadableEx() and register CApp_TryRecvFrom() as a callback, to be called again when the read operation can make a progress.
* AEEPORT_ERROR - an error occurred. Check the error code.
* AEEPORT_CLOSED - no more data to be read, connection was closed by the server.
* ret <  BUFFER_SIZE - not all the data was received yet.
* ret == BUFFER_SIZE - all bytes were successfully received.
*

{{{
 void CApp_TryRead(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
  
   // read the data from the server.
   ret = ISOCKPORT_Read(pme->m_pISockPort,                        // ISockPort object
                        pme->m_caReadBuffer + pme->m_nBytesRead,  // buffer for read data
                        BUFFER_SIZE - pme->m_nBytesRead           // buffer length
                       );
 
   // no data is available for reading at the moment.
   if (AEEPORT_WAIT == ret) {
      // call CApp_TryRead() again when the read operation may progress.
      ISOCKPORT_ReadableEx(pme->m_pISockPort, &pme->m_cbReadCallback, CApp_TryRead, pme);
      return;
   }
      
   // an error occurred. get the error code.
   if (AEEPORT_ERROR == ret) {
      ret = ISOCKPORT_GetLastError(pme->m_pISockPort);
      ...
      return;
   }
 
   // connection closed by the other side
   if (AEEPORT_CLOSED == ret) {
      // handle connection closure
      ...
      return;
   }
 
   // some bytes were read.
   pme->m_nBytesRead += ret;
 
   // not all the bytes were read yet. call CApp_TryRead() again when the read operation may progress.
   if (pme->m_nBytesRead < BUFFER_SIZE) {
      ISOCKPORT_ReadableEx(pme->m_pISockPort, &pme->m_cbReadCallback, CApp_TryRead, pme);
      return;
   }
 
   // (BUFFER_SIZE == ret) - all bytes were successfully read.
   // reset the bytes counter for next read operation
   pme->m_nBytesRead = 0;
   ...
 }
}}}

==Closing a SockPort==
Whenever done with a SockPort (either when an error occurred or when exiting the application), 
it is important to close and release ISockPort object.

RELEASEIF macro calls ISOCKPORT_Release(), which will implicitly close the socket in the background if it is open.

{{{
 #define RELEASEIF(pi) { if (pi) { IBASE_Release((IBase*)(pi)); (pi)=0; }}
}}}

A function like '''CApp_SockPortEnd()''' can be applied.
{{{
 void CApp_SockPortEnd(CApp* pme)
 {
     CALLBACK_Cancel(&pme->m_cbReadCallback);
     CALLBACK_Cancel(&pme->m_cbWriteCallback);
     RELEASEIF(pme->m_pISockPort);
 }
}}}

=======================================================================
=ISockPort - Writing a TCP server application=
This section will demonstrate a TCP server application that exchanges data with clients over an ISockPort object.

The application implements a rudimentary echo server.

The steps demonstrated are as follows:
# Data initialization.
# Creating and opening an ISockPort object.
# Binding a Sockport.
# Listening on a Sockport.
# Accepting new connections.
# Reading data from a client.
# Writing data to a client.
# Closing connections.
#

==Data Initialization==
The server application should define the following: 
{{{
 // define port number of the server
 #define SERVER_PORT   7
 
 // define the pending connections backlog size
 #define BACKLOG_SIZE 3
 
 // define message length
 #define BUFFER_SIZE 100
}}}


The application will use the following structures to organize data needed for socket communication

{{{
 // struct representing a single client-server connection
 struct TCPConnection
 {
   CApp*       pme;             // pointer to the application
   ISockPort*  pSock;           // the socket used for this connection
   AEECallback ReadSockCB;      // AEECallback for the connection's read operations
   AEECallback WriteSockCB;     // AEECallback for the connection's write operations
   char szBuf[BUFFER_SIZE];     // data buffer
   uint32 nTotalBytesToWrite;   // num of bytes received from the client.
                                // which is also num of bytes the
                                // server should echo
   uint32 nBytesWritten;        // number of bytes already written to client
   
   TCPConnection* pNext;        // pointer to the next element in the list.
 };
 
 // struct representing the server socket
 struct TCPServerSockPort
 {
   ISockPort* pListenSocket;     // the SockPort itself
   AEECallback ListenSocketCB;   // callback for the socket 
   AEESockAddrStorage Sockaddr;  // socket address struct
 };
}}}
Among others, the applet should have the follwoing members:
{{{
 IShell*            m_pIShell,            // IShell pointer 
 TCPServerSockPort  m_TCPServerSockPort;  // pointer to a TCPServerSockPort object
 TCPConnection*     m_pHead;              // head of singly-linked list of connections 
}}}



Initialization of the address structure should be also carried out:
{{{
 // initialize the addresses. 
 pme->m_TCPServerSockPort.Sockaddr.wFamily   = AEE_AF_INET;           // IPv4 socket
 pme->m_TCPServerSockPort.Sockaddr.inet.port = HTONS(SERVER_PORT);    // set port number
 pme->m_TCPServerSockPort.Sockaddr.inet.addr = HTONL(AEE_INADDR_ANY); // set IP address to any available address.
}}}

==Creating the Server's Listening SockPort==
For having a functional ISockport object, the following stages must be performed:

# Calling IShell_CreateInstance(), to create an ISockPort object.
# Calling ISockPort_OpenEx(), to open the SockPort.
#
{{{
 void CApp_StartTCPServer(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
   TCPServerSockPort* pSock = &(pme->m_TCPServerSockPort);
 
   // create the ISockPort object.
   ret = ISHELL_CreateInstance(pSock->pIShell, AEECLSID_SOCKPORT, (void**)&(pSock->pListenSocket));
   if (SUCCESS != ret) { 
      // handle the error
      ...
      return;
   }
 
   // open the SockPort.
   ret = ISOCKPORT_OpenEx(pSock->pListenSocket, // ISockPort pointer
                          AEE_AF_INET,          // wFamily     = IPv4 
                          AEE_SOCKPORT_STREAM,  // socket type = TCP
                          0                     // Protocol type:
                                                // Use 0 (recommended) to let the system select its default 
                                                // protocol for the given address family and socket type
                         );
   if (SUCCESS != ret) {     
      // handle the error
      ...
      return;
   }
 }
}}}

==Binding the Server's Listening SockPort==
The server SockPort has to be bound. The example function '''CApp_TryBind()''' attempts to bind the SockPort, using ISOCKPORT_Bind().

It then handles all the possible values ISOCKPORT_Bind() may return:
* AEEPORT_WAIT - the operation cannot be completed at present.  Often, this is because the system needs to establish a data connection between the phone and the cellular network on which the TCP data can be transmitted. In this case - call ISOCKPORT_WriteableEx() and register CApp_TryBind() as a callback, to be called again when the bind operation can make a progress.
* ret !=  SUCCESS - an error occurred. ret holds the error code.
* ret == SUCCESS - operation succeeded.
*

Note that ISOCKPORT_Bind() returns the error code, and there is no need to explicitly get it using ISOCKPORT_GetLastError().

{{{
 void CApp_TryBind(void* po)
 {
   int ret;       
   CApp* pme = (CApp*)po;
   TCPServerSockPort* pSock = &(pme->m_TCPServerSockPort);
    
   // use AEE_INADDR_ANY for binding
   ret = ISOCKPORT_Bind(pSock->pListenSocket, &(pSock->Sockaddr));
   if (AEEPORT_WAIT == ret) {
      ISOCKPORT_WriteableEx(pSock->pListenSocket, &pSock->ListenSocketCB, CApp_TryBind, pme);
      return;
   }
   else if (SUCCESS != ret) {
      // ret holds the error code
      // release resources
      CApp_ServerEnd(pSock);
      ...
      return;
   }
  
   // the SockPort is bound, try to listen.
   CApp_TryListen(pme);
   ...
 }
 
}}}
Note that in TCPServerSockPort.Sockaddr, inet.addr was set to AEE_INADDR_ANY. Currently, this is the only supported option for bind operation.

Once the SockPort is bound, it may listen to incoming connections.


==Listenning on the Server Sockport==
Once bound to an address, the SockPort may listen for incoming connections requests.
'''CApp_TryListen()''' calls ISOCKPORT_Listen(), and then handles all the possible values ISOCKPORT_Listen() may return:
* AEEPORT_WAIT - the operation cannot be completed at present.  Often, this is because the system needs to establish a data connection between the phone and the cellular network on which the TCP data can be transmitted. In this case - call ISOCKPORT_WriteableEx() and register CApp_TryListen() as a callback, to be called again when the listen operation can make a progress.
* ret !=  SUCCESS - an error occurred. ret holds the error code.
* ret == SUCCESS - operation succeeded.
*

When the SockPort is listening, it may attempt to accept incoming connections.

{{{
 void CApp_TryListen(void* po)
 {
   int ret;
   CApp* pme = (CApp*)po;
   TCPServerSockPort* pSock = &(pme->m_TCPServerSockPort);
   
   ret = ISOCKPORT_Listen(pSock->pListenSocket, BACKLOG_SIZE);
   if (AEEPORT_WAIT == ret) {
      ISOCKPORT_WriteableEx(pSock->pListenSocket, &pSock->ListenSocketCB, CApp_TryListen, pme);
      return;
   }
 
   if (SUCCESS != ret)
   {
      // ret holds the error code
      // release resources
      CApp_ServerEnd(pSock);
      ...
      return;
   }
 
   // try accepting new connections
   CApp_TryAccept(pme);
 }
}}}

==Accepting new connections==
The server socket is now ready to accept clients' "connect" requests.

The example function '''CApp_TryAccept()''' uses ISOCKPORT_Accept() for accepting incomming "connect" requests.
If AEEPORT_WAIT is returned, it registers itself as a callback to be called when the accept operation may progress.

After a connection was established, the server application may exchange data with the client through
the new SockPort created during ISOCKPORT_Accept(). Before doing so, CApp_TryAccept() does two things:
# It calls ISOCKPORT_ReadableEx() again, thus registering itself for accepting subsequent "connect" requests. Since Brew applications must not block, the user should use the callback mechanism to wait for incoming "connect" requests.
# It allocates and initializes the data structures representing the new connection.
#

In this example, the application will attempt to read data from the client, and write it back to the client (echo).

{{{
 void CApp_TryAccept(void* po)
 {
   int ret;
   ISockPort* pTmpSocket;
   TCPConnection* pConnection;
   CApp* pme = (CApp*)po;
   TCPServerSockPort* pServerSock = &(pme->m_TCPServerSockPort);
  
   // accept a request. pTmpSocket will point to the newly created socket
   ret = ISOCKPORT_Accept(pServerSock->pListenSocket, &pTmpSocket);
   if (AEEPORT_WAIT == ret) {
  
      // the request is blocked. Register CApp_TryAccept() as a callback
      // to be called again when accept operation may progress.
      ISOCKPORT_ReadableEx(pServerSock->pListenSocket, &pServerSock->ListenSocketCB, CApp_TryAccept, pme);
      return;                
   }
  
   if (SUCCESS != ret) {
  
      // operation failed, release resources
      CApp_ServerEnd(pServerSock);
  
      // ret holds the error code, handle it
      ...
      return;
   }
  
   // ISOCKPORT_Accept() succeeded. 
   // Register CApp_TryAccept() as a callback, for accepting further incoming "connect" requests.
   ISOCKPORT_ReadableEx(pServerSock->pListenSocket, &pServerSock->ListenSocketCB, CApp_TryAccept, pme);
 
   // allocate struct for holding the new connection's data 
   pConnection = MALLOCREC(TCPConnection);
   if (!pConnection) {
      // allocation failed - reject the connection 
      ISOCKPORT_Release(pTmpSocket);
      return;
   } 
 
   // init the connection's struct
   pConnection->pme                 = pme;
   pConnection->pSock               = pTmpSocket;
   pConnection->nBytesWritten       = 0;
   pConnection->nTotalBytesToWrite  = 0;
  
   // insert the new connection at head of the server's connections list
   pConnection->pNext = pme->m_pHead;
   pme->m_pHead = pConnection;
 
   // wait for an incoming data on this connection.
   CApp_TryRead(pConnection);
 }
}}}

==Reading data over the SockPort==
The example function - '''CApp_TryRead()''' - shown below, attempts to read data from a client, using ISOCKPORT_Read().

It then handles all the possible values ISOCKPORT_Read() may return:
* nRead == AEEPORT_WAIT - the system can't read data at this time.  Often, this is because the system needs to establish a data connection between the phone and the cellular network on which the TCP data can be received. In this case - call ISOCKPORT_ReadableEx() and register ISOCKPORT_Read() as a callback, to be called again when the read operation can make a progress.
* nRead == AEEPORT_ERROR - an error occurred. Check the error code.
* nRead == AEEPORT_CLOSED - no more data to be read, connection was closed by the client.
* nRead >  0 - data bytes were read. Write them back to the client.
*

{{{
 void CApp_TryRead(TCPConnection* pConnection)
 {
   int32 nRead;
 
   // read the data
   nRead = ISOCKPORT_Read(pConnection->pSock,
                          pConnection->szBuf,
                          sizeof(pConnection->szBuf));
    
   if (AEEPORT_WAIT == nRead) {
      ISOCKPORT_ReadableEx(pConnection->pSock, &pConnection->ReadSockCB, CApp_TryRead, pConnection);
      return;
   }
   
   // an error occurred
   if (AEEPORT_ERROR == nRead) {
      // get the error code and close the connection
      nRead = ISOCKPORT_GetLastError(pConnection->pSock);
      CApp_ConnClose(pConnection);
      ...
      return;
   }
  
   // connection was closed by the distant socket
   if (AEEPORT_CLOSED == nRead) {
      // close the connection
      CApp_ConnClose(pConnection);
      ...
      return;
   }
 
   // increment num of bytes read from the connection
   pConnection->nTotalBytesToWrite = nRead;
   pConnection->nBytesWritten = 0;
 
   // echo the data back to the client
   CApp_TryWrite(pConnection);
 }
}}}


==Writing data over the SockPort==
The example function - '''CApp_TryWrite()''' - shown below, attempts to write data to a client, using ISOCKPORT_Write().

It then handles all the possible values ISOCKPORT_Write() may return:
* nWrite == AEEPORT_WAIT - the system can't write data at this time.  Often, this is because the system needs to establish a data connection between the phone and the cellular network on which the TCP data can be transmitted. In this case - call ISOCKPORT_WriteableEx() and register CApp_TryWrite() as a callback, to be called again when the write operation can make a progress.
* nWrite == AEEPORT_ERROR - an error occurred. Check the error code.
* nWrite == AEEPORT_CLOSED - connection was closed by the client.
* nWrite >  0 - Data bytes were written. If not all the data was written - wait until a further write may progress. If all the bytes were written - try to read data from the client.
*

{{{
 void CApp_TryWrite(TCPConnection* pConnection)
 {
   int32 nWrite;
   
   // write the data
   nWrite = ISOCKPORT_Write(pConnection->pSock, 
                            (pConnection->szBuf + pConnection->nBytesWritten), 
                            (pConnection->nTotalBytesToWrite - pConnection->nBytesWritten)
                           );
 
   if (AEEPORT_WAIT == nWrite) {
      ISOCKPORT_WriteableEx(pConnection->pSock, &pConnection->WriteSockCB, CApp_TryWrite, pConnection);
      return;
   }
 
   // an error occurred
   if (AEEPORT_ERROR == nWrite) {        
      // get the error code and close the connection
      nWrite = ISOCKPORT_GetLastError(pConnection->pSock);
      CApp_ConnClose(pConnection);
      ...
      return;
   }
 
   // connection was closed by the distant socket
   if (AEEPORT_CLOSED == nWrite) {        
      // close the connection
      CApp_ConnClose(pConnection);
      ...
      return;
   }
  
   // update num of bytes written.
   pConnection->nBytesWritten += nWrite;
   
   // in case of partial write register a callback to be called when further write can progress.
   if (pConnection->nBytesWritten < pConnection->nTotalBytesToWrite) {
      ISOCKPORT_WriteableEx(pConnection->pSock, &pConnection->WriteSockCB, CApp_TryWrite, pConnection);
      return;
   }
 
   // all bytes were written.
   // wait for an incoming packet
   ISOCKPORT_ReadableEx(pConnection->pSock, &pConnection->ReadSockCB, CApp_TryRead, pConnection);
 }
}}}


==Closing connections==
The following functions demonstrate how to gracefully close connections and free resources.

RELEASEIF macro will be used to release the object. It will call ISOCKPORT_Release(), which
will implicitly close the socket in the background if it is open.
{{{
 #define RELEASEIF(pi) { if (pi) { IBASE_Release((IBase*)(pi)); (pi)=0; }}
}}}

'''CApp_ServerEnd()''' releases the server socket.
{{{
 void CApp_ServerEnd(TCPServerSockPort* pServerSock)
 {
   CALLBACK_Cancel(&pServerSock->ListenSocketCB);
   RELEASEIF(pServerSock->pListenSocket);
   RELEASEIF(pServerSock->pIShell);
 }
}}}

'''CApp_ConnClose()''' detaches one connection from the application's connection list, and releases it.
{{{
 void CApp_ConnClose(TCPConnection* pConnection)
 {
   TCPConnection* pCurr = NULL;
   TCPConnection* pPrev = NULL;
    
   // release the connection's data
   CALLBACK_Cancel(&pConnection->ReadSockCB);
   CALLBACK_Cancel(&pConnection->WriteSockCB);
   ISOCKPORT_Release(pConnection->pSock);
  
   // remove this connection from the server's list
    for (pCurr = pConnection->pme->m_pHead; pCurr != NULL; pCurr = pCurr->pNext)
   {
      if (pCurr == pConnection) {
         if (NULL == pPrev) {
            // the connection is in the head of the list
            pConnection->pme->m_pHead = pCurr->pNext;
         }
         else {
            pPrev->pNext = pCurr->pNext;
         }
         break;
      }
      pPrev = pCurr;
   }
 
   FREE(pConnection);
 }
}}}
=======================================================================*/

