/*==============================================================================

High Speed USB Host HID Test Application

GENERAL DESCRIPTION
Implementation of the High Speed USB Host HID Test Application.
This application does not have its own task.
In its initialization function, it registers (in the caller's context) 
with the usbhost api for HID notifications. It uses the usbhost api to open
HID devices that are connected to the host, and register a callback to be called
when events are generated by the device..

Copyright (c) 2007 by QUALCOMM, Incorporated.  All Rights Reserved.
==============================================================================*/

/*==============================================================================

EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order.

$Header:

when      who     what, where, why
--------  ---     --------------------------------------------------------------

==============================================================================*/

/*==============================================================================

INCLUDE FILES FOR MODULE

==============================================================================*/

#include "comdef.h"
#include "customer.h"

#include "hsu_common.h"
#include "hsu_host_al_hid_test_app.h"
#include "usbhost_api.h"
#include "hsu_host_api_i.h"

#include "AEE.h"
#include "AEE_OEMEvent.h"
#include "OEMFeatures.h"

/* Interval for getting sampled data */
#define SAMPLED_DATA_TIMER_INTERVAL 400

static const char* hsu_host_al_hid_test_app_client_desc = "HSU HID TEST APP";

static usbhost_client_id_type hsu_host_al_hid_test_app_client_id[USBHOST_MAX_PDEV_TYPE];
static usbhost_dev_handle_type hsu_host_al_hid_test_app_dev_handle[USBHOST_MAX_PDEV_TYPE];

static usbhost_client_id_type hsu_host_al_hid_test_app_dev_inst_to_client_id[USBHOST_MAX_DEVICES];

/* Timer for fetching sampled data */
static rex_timer_type hsu_host_al_hid_test_app_sampled_timer;

#ifdef  FEATURE_BREW
/*===========================================================================

FUNCTION hsu_host_al_hid_test_app_send_event_to_brew

DESCRIPTION
This function is used to send a hid event usage to Brew.

DEPENDENCIES
None.

RETURN VALUE
None.

SIDE EFFECTS
None.

===========================================================================*/
static void hsu_host_al_hid_test_app_send_event_to_brew
(
  const usbhost_hid_event_type* event
)
{
  if (event == NULL)
  {
    return;
  }

  switch (event->usage)
  {
  case USBHOST_HID_USAGE_NONE:
    /* Just ignore these */
    break;

  case USBHOST_HID_USAGE_BUTTON:
  case USBHOST_HID_USAGE_DIAL:
  case USBHOST_HID_USAGE_HATSWITCH:
  case USBHOST_HID_USAGE_BYTECOUNTER:
  case USBHOST_HID_USAGE_MOTIONWAKEUP:
  case USBHOST_HID_USAGE_START:
  case USBHOST_HID_USAGE_SELECT:
  case USBHOST_HID_USAGE_SYSCONTRL:
  case USBHOST_HID_USAGE_SYSPOWERDOWN:
  case USBHOST_HID_USAGE_SYSSLEEP:
  case USBHOST_HID_USAGE_SYSWAKE:
  case USBHOST_HID_USAGE_SYSCONMENU:
  case USBHOST_HID_USAGE_SYSMAINMENU:
  case USBHOST_HID_USAGE_SYSAPPMENU:
  case USBHOST_HID_USAGE_SYSMENUHELP:
  case USBHOST_HID_USAGE_SYSMENUEXIT:
  case USBHOST_HID_USAGE_SYSMENURIGHT:
  case USBHOST_HID_USAGE_SYSMENULEFT:
  case USBHOST_HID_USAGE_SYSMENUUP:
  case USBHOST_HID_USAGE_SYSMENUDOWN:
  case USBHOST_HID_USAGE_DPADUP:
  case USBHOST_HID_USAGE_DPADDOWN:
  case USBHOST_HID_USAGE_DPADRIGHT:
  case USBHOST_HID_USAGE_DPADLEFT:
  case USBHOST_HID_USAGE_WHEEL:
#ifdef EVT_HID_DATA
    /* Some builds may not support EVT_HID_DATA so we have to check for it
    ** and not attempt to compile in this code is it is not available.
    */
    (void) AEE_Event(EVT_HID_DATA, 
      (uint16) event->data_val,
      (uint32) event->usage);
#endif
    break;

  case USBHOST_HID_USAGE_KEY_UP:
    (void) AEE_Event(EVT_KEY_PRESS, 0xe031, 0);
    (void) AEE_Event(EVT_KEY, 0xe031, 0);
    (void) AEE_Event(EVT_KEY_RELEASE, 0xe031, 0);
    break;

  case USBHOST_HID_USAGE_KEY_DOWN:
    (void) AEE_Event(EVT_KEY_PRESS, 0xe032, 0);
    (void) AEE_Event(EVT_KEY, 0xe032, 0);
    (void) AEE_Event(EVT_KEY_RELEASE, 0xe032, 0);
    break;

  case USBHOST_HID_USAGE_KEY_LEFT:
    (void) AEE_Event(EVT_KEY_PRESS, 0xe033, 0);
    (void) AEE_Event(EVT_KEY, 0xe033, 0);
    (void) AEE_Event(EVT_KEY_RELEASE, 0xe033, 0);
    break;

  case USBHOST_HID_USAGE_KEY_RIGHT:
    (void) AEE_Event(EVT_KEY_PRESS, 0xe034, 0);
    (void) AEE_Event(EVT_KEY, 0xe034, 0);
    (void) AEE_Event(EVT_KEY_RELEASE, 0xe034, 0);
    break;

  case USBHOST_HID_USAGE_KEY_ENTER:
  case USBHOST_HID_USAGE_KEY_PAD_ENTER:
    (void) AEE_Event(EVT_KEY_PRESS, 0xe035, 0);
    (void) AEE_Event(EVT_KEY, 0xe035, 0);
    (void) AEE_Event(EVT_KEY_RELEASE, 0xe035, 0);
    break;

  case USBHOST_HID_USAGE_KEY_BACKSPACE:
    (void) AEE_Event(EVT_KEY_PRESS, 0xe030, 0);
    (void) AEE_Event(EVT_KEY, 0xe030, 0);
    (void) AEE_Event(EVT_KEY_RELEASE, 0xe030, 0);
    break;

    /* Sampled data usages are not sent to BREW at this time */
  case USBHOST_HID_USAGE_X:
  case USBHOST_HID_USAGE_Y:
  case USBHOST_HID_USAGE_Z:
  case USBHOST_HID_USAGE_RX:
  case USBHOST_HID_USAGE_RY:
  case USBHOST_HID_USAGE_RZ:
  case USBHOST_HID_USAGE_VX:
  case USBHOST_HID_USAGE_VY:
  case USBHOST_HID_USAGE_VZ:
  case USBHOST_HID_USAGE_VBRX:
  case USBHOST_HID_USAGE_VBRY:
  case USBHOST_HID_USAGE_VBRZ:
  case USBHOST_HID_USAGE_VNO:
  case USBHOST_HID_USAGE_SLIDER:
    break;

  case USBHOST_HID_USAGE_KEY_A:
  case USBHOST_HID_USAGE_KEY_B:
  case USBHOST_HID_USAGE_KEY_C:
  case USBHOST_HID_USAGE_KEY_D:
  case USBHOST_HID_USAGE_KEY_E:
  case USBHOST_HID_USAGE_KEY_F:
  case USBHOST_HID_USAGE_KEY_G:
  case USBHOST_HID_USAGE_KEY_H:
  case USBHOST_HID_USAGE_KEY_I:
  case USBHOST_HID_USAGE_KEY_J:
  case USBHOST_HID_USAGE_KEY_K:
  case USBHOST_HID_USAGE_KEY_L:
  case USBHOST_HID_USAGE_KEY_M:
  case USBHOST_HID_USAGE_KEY_N:
  case USBHOST_HID_USAGE_KEY_O:
  case USBHOST_HID_USAGE_KEY_P:
  case USBHOST_HID_USAGE_KEY_Q:
  case USBHOST_HID_USAGE_KEY_R:
  case USBHOST_HID_USAGE_KEY_S:
  case USBHOST_HID_USAGE_KEY_T:
  case USBHOST_HID_USAGE_KEY_U:
  case USBHOST_HID_USAGE_KEY_V:
  case USBHOST_HID_USAGE_KEY_W:
  case USBHOST_HID_USAGE_KEY_X:
  case USBHOST_HID_USAGE_KEY_Y:
  case USBHOST_HID_USAGE_KEY_Z:
  case USBHOST_HID_USAGE_KEY_1:
  case USBHOST_HID_USAGE_KEY_2:
  case USBHOST_HID_USAGE_KEY_3:
  case USBHOST_HID_USAGE_KEY_4:
  case USBHOST_HID_USAGE_KEY_5:
  case USBHOST_HID_USAGE_KEY_6:
  case USBHOST_HID_USAGE_KEY_7:
  case USBHOST_HID_USAGE_KEY_8:
  case USBHOST_HID_USAGE_KEY_9:
  case USBHOST_HID_USAGE_KEY_0:
  case USBHOST_HID_USAGE_KEY_ESCAPE:
  case USBHOST_HID_USAGE_KEY_TAB:
  case USBHOST_HID_USAGE_KEY_SPACE:
  case USBHOST_HID_USAGE_KEY_MINUS:
  case USBHOST_HID_USAGE_KEY_EQUAL:
  case USBHOST_HID_USAGE_KEY_LEFT_BRACKET:
  case USBHOST_HID_USAGE_KEY_RIGHT_BRACKET:
  case USBHOST_HID_USAGE_KEY_BACKSLASH:
  case USBHOST_HID_USAGE_KEY_SEMICOLON:
  case USBHOST_HID_USAGE_KEY_QUOTE:
  case USBHOST_HID_USAGE_KEY_GRAVE:
  case USBHOST_HID_USAGE_KEY_COMMA:
  case USBHOST_HID_USAGE_KEY_PERIOD:
  case USBHOST_HID_USAGE_KEY_FORWARD_SLASH:
  case USBHOST_HID_USAGE_KEY_CAPS_LOCK:
  case USBHOST_HID_USAGE_KEY_F1:
  case USBHOST_HID_USAGE_KEY_F2:
  case USBHOST_HID_USAGE_KEY_F3:
  case USBHOST_HID_USAGE_KEY_F4:
  case USBHOST_HID_USAGE_KEY_F5:
  case USBHOST_HID_USAGE_KEY_F6:
  case USBHOST_HID_USAGE_KEY_F7:
  case USBHOST_HID_USAGE_KEY_F8:
  case USBHOST_HID_USAGE_KEY_F9:
  case USBHOST_HID_USAGE_KEY_F10:
  case USBHOST_HID_USAGE_KEY_F11:
  case USBHOST_HID_USAGE_KEY_F12:
  case USBHOST_HID_USAGE_KEY_PRINT_SCREEN:
  case USBHOST_HID_USAGE_KEY_SCROLL_LOCK:
  case USBHOST_HID_USAGE_KEY_PAUSE:
  case USBHOST_HID_USAGE_KEY_INSERT:
  case USBHOST_HID_USAGE_KEY_HOME:
  case USBHOST_HID_USAGE_KEY_PAGE_UP:
  case USBHOST_HID_USAGE_KEY_DELETE:
  case USBHOST_HID_USAGE_KEY_END:
  case USBHOST_HID_USAGE_KEY_PAGE_DOWN:
  case USBHOST_HID_USAGE_KEY_NUM_LOCK:
  case USBHOST_HID_USAGE_KEY_PAD_DIVIDE:
  case USBHOST_HID_USAGE_KEY_PAD_MULTIPLY:
  case USBHOST_HID_USAGE_KEY_PAD_SUBTRACT:
  case USBHOST_HID_USAGE_KEY_PAD_ADD:
  case USBHOST_HID_USAGE_KEY_PAD_1:
  case USBHOST_HID_USAGE_KEY_PAD_2:
  case USBHOST_HID_USAGE_KEY_PAD_3:
  case USBHOST_HID_USAGE_KEY_PAD_4:
  case USBHOST_HID_USAGE_KEY_PAD_5:
  case USBHOST_HID_USAGE_KEY_PAD_6:
  case USBHOST_HID_USAGE_KEY_PAD_7:
  case USBHOST_HID_USAGE_KEY_PAD_8:
  case USBHOST_HID_USAGE_KEY_PAD_9:
  case USBHOST_HID_USAGE_KEY_PAD_0:
  case USBHOST_HID_USAGE_KEY_PAD_DECIMAL:
  case USBHOST_HID_USAGE_KEY_PAD_EQUAL:
  case USBHOST_HID_USAGE_KEY_LEFT_CONTROL:
  case USBHOST_HID_USAGE_KEY_LEFT_SHIFT:
  case USBHOST_HID_USAGE_KEY_LEFT_ALT:
  case USBHOST_HID_USAGE_KEY_LEFT_GUI:
  case USBHOST_HID_USAGE_KEY_RIGHT_CONTROL:
  case USBHOST_HID_USAGE_KEY_RIGHT_SHIFT:
  case USBHOST_HID_USAGE_KEY_RIGHT_ALT:
  case USBHOST_HID_USAGE_KEY_RIGHT_GUI:
  case USBHOST_HID_USAGE_KEY_NON_US_BACKSLASH:
  case USBHOST_HID_USAGE_KEY_APPL:
  case USBHOST_HID_USAGE_KEY_POWER:

#ifdef EVT_CHAR
    (void) AEE_Event(EVT_CHAR, 
      (uint16) event->data_val,
      (uint32) event->usage);
#endif
    break;

  default:
    HSU_MSG_HIGH("hsu_host_al_hid_test_app_send_event_to_brew(): Received unsupported HID Usage event, usage=%d", 
      event->usage,0,0);
  } /* switch */
} /* hsu_host_al_hid_test_app_send_event_to_brew */
#endif  /* FEATURE_BREW */

/*===========================================================================

FUNCTION hsu_host_al_hid_test_app_client_notify_cb

DESCRIPTION
A callback, called by the HID adaptation layer in order to notify the
application of events relating to connected HID devices.

DEPENDENCIES
None.

RETURN VALUE
None.

SIDE EFFECTS
None.

===========================================================================*/
static void hsu_host_al_hid_test_app_client_notify_cb
(
 usbhost_dev_handle_type dev_hndl,
 usbhost_pdev_type       pdev_type,
 usbhost_hid_event_type* event
)
{
  HSU_USE_PARAM(dev_hndl);
  HSU_PARAM_COULD_BE_CONST(event);

  if (pdev_type == USBHOST_PDEV_TYPE_HID_KEYBOARD)
  {
    HSU_MSG_HIGH("hsu_host_al_hid_test_app_client_notify_cb(): Keyboard key pressed, usage=%d, ascii value=%d.",
                 event->usage, event->data_val, 0);

    #ifdef FEATURE_BREW
    hsu_host_al_hid_test_app_send_event_to_brew(event);
    #endif
  }
  else
  {
    HSU_MSG_HIGH("hsu_host_al_hid_test_app_client_notify_cb(): Got event, usage=%d, value=%d, mkbrk=%d.",
                 event->usage, event->data_val, event->data_mkbrk);
  }
}

/*===========================================================================

FUNCTION hsu_host_al_hid_test_app_close_req_cb

DESCRIPTION
This function is called when another client tries to open a device
that is currently owned by the High Speed USB Host HID test application.

DEPENDENCIES
None.

RETURN VALUE
None.

SIDE EFFECTS
None.

===========================================================================*/
static void hsu_host_al_hid_test_app_close_req_cb
(
  usbhost_dev_handle_type dev_handle,
  char* asking_client_desc,
  usbhost_client_id_type asking_client_id,
  void* param
)
{
  HSU_USE_PARAM(dev_handle);
  HSU_USE_PARAM(asking_client_desc);
  HSU_USE_PARAM(asking_client_id);
  HSU_USE_PARAM(param);
}

/*===========================================================================

FUNCTION hsu_host_al_hid_test_app_open_notify_cb

DESCRIPTION
A callback that notifies the High Speed USB Host HID Test Application
of the result of a request to open a connected device.

DEPENDENCIES
None.

RETURN VALUE
Relevant only if the open_status parameter is USBHOST_OPEN_NOT_AVAILABLE.
Returning USBHOST_OPEN_RET_RESCHEDULE means that we still want to be queued 
for opening the device and returning USBHOST_OPEN_RET_UNSCHEDULE
means that we no longer want to open the device.
We always return USBHOST_OPEN_RET_RESCHEDULE.

SIDE EFFECTS
None.

===========================================================================*/
static usbhost_open_ret_type hsu_host_al_hid_test_app_open_notify_cb
(
  usbhost_dev_instance_type dev_inst,
  usbhost_dev_handle_type dev_handle,
  usbhost_open_status open_status,
  char* holding_client_desc,
  void* param
)
{
  usbhost_ioctl_hid_cfg_type cfg;
  /* uint8 idle_rate; */
  usbhost_status_type status;
  usbhost_client_id_type client_id;
  usbhost_pdev_type pdev_type;
  uint8 i ;

  HSU_USE_PARAM(param);
  HSU_USE_PARAM(holding_client_desc);

  if (open_status == USBHOST_OPEN_AVAILABLE)
  {
    /* Get the client id that matches the given device instance */
    HSU_ASSERT((uint32)dev_inst < USBHOST_MAX_DEVICES);
    client_id = hsu_host_al_hid_test_app_dev_inst_to_client_id[dev_inst];
    
    if (client_id == USBHOST_INVALID_CLIENT_ID)
    {
      HSU_MSG_ERROR("hsu_host_al_hid_test_app_open_notify_cb(): No client id for dev_inst=%d.",
                    dev_inst,0,0);
    }
    else /* client id is valid */
    {
      pdev_type = USBHOST_MAX_PDEV_TYPE;
      /* Get the pdev_type that matches the client id */
      for (i=0; i<(uint8)USBHOST_MAX_PDEV_TYPE; i++)
      {
        if (hsu_host_al_hid_test_app_client_id[i] == client_id)
        {
          pdev_type = (usbhost_pdev_type)i;
        }
      }
      if (pdev_type == USBHOST_MAX_PDEV_TYPE)
      {
        HSU_MSG_ERROR("hsu_host_al_hid_test_app_open_notify_cb(): No pdev_type for client_id=%d.",
                      client_id,0,0);
      }
      else /* pdev_type is ok */
      {
        /* Get device descriptor information */
        usbhost_ioctl_devInfo_type dev_info;
        status = usbhost_ioctl(client_id, 
                               dev_handle, 
                               USBHOST_IOCTL_GET_DEV_INFO,
                               (void*)&dev_info);
        if (status != USBHOST_SUCCESS)
        {
          HSU_MSG_ERROR("hsu_host_al_hid_test_app_open_notify_cb(): Can't get device descriptor info.",
                        0,0,0);
        }
        else
        {
          HSU_MSG_HIGH("Device with VendforID=0x%X, ProductID=0x%X.",
                       dev_info.d_vendorID,
                       dev_info.d_productID, 
                       0);
        }

        if ((pdev_type == USBHOST_PDEV_TYPE_HID_MOUSE) ||
            (pdev_type == USBHOST_PDEV_TYPE_HID_JOYSTICK))
        {
          usbhost_hid_attrib_type attributes;
          HSU_MSG_HIGH("Opened device, pdev_type=%d. Getting attributes:", 
                       pdev_type,0,0);
          status = usbhost_ioctl(client_id, 
                                 dev_handle, 
                                 USBHOST_IOCTL_HID_GET_ATTRIB,
                                 (void*)&attributes);
          if (status != USBHOST_SUCCESS)
          {
            HSU_MSG_ERROR("hsu_host_al_hid_test_app_open_notify_cb(): Can't get attributes.",
                          0,0,0);
          }
          else
          {
            HSU_MSG_HIGH("Device with pdev_type=%d, max_buttons=%d",
                         pdev_type, attributes.max_buttons,0);
            HSU_MSG_HIGH("Device with pdev_type=%d, min_x=%d, max_x=%d",
                         pdev_type, attributes.min_x, attributes.max_x);
            HSU_MSG_HIGH("Device with pdev_type=%d, min_y=%d, max_y=%d",
                         pdev_type, attributes.min_y, attributes.max_y);
          }
        }
        hsu_host_al_hid_test_app_dev_handle[pdev_type] = dev_handle;

        cfg.client_notify_cb = hsu_host_al_hid_test_app_client_notify_cb;
        status = usbhost_ioctl(client_id, 
                               dev_handle, 
                               USBHOST_IOCTL_HID_SET_CONFIGURATION,
                               (void*)&cfg);

        if (status != USBHOST_SUCCESS)
        {
          HSU_MSG_ERROR("hsu_host_al_hid_test_app_open_notify_cb(): Can't set client_notify_cb.",
            0,0,0);
        }

/*      if (pdev_type == USBHOST_PDEV_TYPE_HID_KEYBOARD)
        {
          idle_rate = 100;
          status = usbhost_ioctl(client_id, 
                                 dev_handle, 
                                 USBHOST_IOCTL_HID_SET_IDLE_RATE,
                                 (void*)&idle_rate);
          if (status != USBHOST_SUCCESS)
          {
            HSU_MSG_ERROR("hsu_host_al_hid_test_app_open_notify_cb(): Can't set idle rate.",
              0,0,0);
          }
        }
*/
      }
    }
  }

  return USBHOST_OPEN_RET_RESCHEDULE;
}

/*===========================================================================

FUNCTION hsu_host_al_hid_test_app_dev_notify_cb

DESCRIPTION
A callback that notifies the High Speed USB Host HID Test Application
when a HID device is connected or disconnected.
Upon connection, this function requests to open the device.

DEPENDENCIES
None.

RETURN VALUE
None.

SIDE EFFECTS
None.

===========================================================================*/
static void hsu_host_al_hid_test_app_dev_notify_cb
(
  usbhost_pdev_type pdev_type, 
  usbhost_dev_status_type dev_stat, 
  usbhost_dev_instance_type dev_inst,
  void * param
)
{
  usbhost_status_type status;

  HSU_USE_PARAM(param);

  if (dev_stat ==  USBHOST_DEV_CONNECTED)
  {
    /* Device connected --> open it */
    hsu_host_al_hid_test_app_dev_inst_to_client_id[dev_inst] =
      hsu_host_al_hid_test_app_client_id[pdev_type];

    status = usbhost_req_open(hsu_host_al_hid_test_app_client_id[pdev_type],
                              dev_inst,
                              hsu_host_al_hid_test_app_open_notify_cb,
                              hsu_host_al_hid_test_app_close_req_cb);
    if (status != USBHOST_SUCCESS)
    {
      HSU_MSG_ERROR("hsu_host_al_hid_test_app_dev_notify_cb(): usbhost_req_open() failed.",
                    0,0,0);
    }
  }
  else
  {
    hsu_host_al_hid_test_app_dev_inst_to_client_id[dev_inst] = USBHOST_INVALID_CLIENT_ID;
    hsu_host_al_hid_test_app_dev_handle[pdev_type] = USBHOST_INVALID_DEV_HNDL;
  }
}

/*===========================================================================

FUNCTION hsu_host_al_hid_test_app_pdev_type_has_sampled_data

DESCRIPTION
Helper function. Used to check if a given pdev_type is once whose 
devices potentially generate sampled data.

DEPENDENCIES
None.

RETURN VALUE
None.

SIDE EFFECTS
None.

===========================================================================*/
static boolean hsu_host_al_hid_test_app_pdev_type_has_sampled_data
(
  usbhost_pdev_type pdev_type
)
{
  return (boolean)((pdev_type == USBHOST_PDEV_TYPE_HID_MOUSE) ||
                  (pdev_type == USBHOST_PDEV_TYPE_HID_JOYSTICK));
}

/*===========================================================================

FUNCTION hsu_host_al_hid_test_app_sampled_timer_cb

DESCRIPTION
Timer callback. Fetches sampled data for the currently connected devices
and displays it.

DEPENDENCIES
None.

RETURN VALUE
None.

SIDE EFFECTS
None.

===========================================================================*/
static void hsu_host_al_hid_test_app_sampled_timer_cb(unsigned long arg)
{
  /* Fetch sampled data for connected devices */
  usbhost_status_type status;
  usbhost_dev_handle_type handle;
  usbhost_pdev_type pdev_type;
  usbhost_hid_event_type event;
  usbhost_client_id_type client_id;
  int32 x, y, z, rz;

  HSU_USE_PARAM(arg);

  for (pdev_type=(usbhost_pdev_type)0; pdev_type<USBHOST_MAX_PDEV_TYPE; pdev_type++)
  {
    if (hsu_host_al_hid_test_app_pdev_type_has_sampled_data(pdev_type))
    {
      handle = hsu_host_al_hid_test_app_dev_handle[pdev_type];
      if (handle != USBHOST_INVALID_DEV_HNDL)
      {
        client_id = hsu_host_al_hid_test_app_client_id[pdev_type];

        event.usage = USBHOST_HID_USAGE_X;
        status = usbhost_ioctl(client_id,
                               handle,
                               USBHOST_IOCTL_HID_READ_SAMPLED,
                               &event);
        if (status != USBHOST_SUCCESS)
        {
          HSU_MSG_ERROR("Can't get USAGE_X for pdev_type=%d", pdev_type,0,0);
          continue;
        }
        x = event.data_val;

        event.usage = USBHOST_HID_USAGE_Y;
        status = usbhost_ioctl(client_id,
                               handle,
                               USBHOST_IOCTL_HID_READ_SAMPLED,
                               &event);
        if (status != USBHOST_SUCCESS)
        {
          HSU_MSG_ERROR("Can't get USAGE_Y for pdev_type=%d", pdev_type,0,0);
          continue;
        }
        y = event.data_val;

        event.usage = USBHOST_HID_USAGE_Z;
        status = usbhost_ioctl(client_id,
          handle,
          USBHOST_IOCTL_HID_READ_SAMPLED,
          &event);
        if (status != USBHOST_SUCCESS)
        {
          HSU_MSG_ERROR("Can't get USAGE_Z for pdev_type=%d", pdev_type,0,0);
          continue;
        }
        z = event.data_val;

        event.usage = USBHOST_HID_USAGE_RZ;
        status = usbhost_ioctl(client_id,
          handle,
          USBHOST_IOCTL_HID_READ_SAMPLED,
          &event);
        if (status != USBHOST_SUCCESS)
        {
          HSU_MSG_ERROR("Can't get USAGE_RZ for pdev_type=%d", pdev_type,0,0);
          continue;
        }
        rz = event.data_val;

        HSU_MSG_MED("Sampled data for pdev_type %d: (x,y)=(%d,%d)",
                     pdev_type, x, y);
        HSU_MSG_MED("Sampled data for pdev_type %d: (z,rz)=(%d,%d)",
          pdev_type, z, rz);
      }
    }
  }

  (void)rex_set_timer(&hsu_host_al_hid_test_app_sampled_timer, 
                      SAMPLED_DATA_TIMER_INTERVAL);
}

/*===========================================================================

FUNCTION hsu_host_al_hid_test_app_init

DESCRIPTION
Initialization function. Registers with the usbhost api.

DEPENDENCIES
None.

RETURN VALUE
None.

SIDE EFFECTS
None.

===========================================================================*/
void hsu_host_al_hid_test_app_init(void)
{
#ifndef CANDLEBOX_FEATURE_USBHID
  usbhost_task_table_type client_sigs;
  uint32 i;

  client_sigs.dog_rpt_fn_ptr = NULL;
  client_sigs.dog_rpt_sig = 0;
  client_sigs.sem_wait_sig = 0;
  client_sigs.wait_sig = 0;

  for (i=0; i<(uint32)USBHOST_MAX_PDEV_TYPE; i++)
  {
    hsu_host_al_hid_test_app_client_id[i] = USBHOST_INVALID_CLIENT_ID;
    hsu_host_al_hid_test_app_dev_handle[i] = USBHOST_INVALID_DEV_HNDL;
  }

  for (i=0; i<USBHOST_MAX_DEVICES; i++)
  {
    hsu_host_al_hid_test_app_dev_inst_to_client_id[i] = USBHOST_INVALID_CLIENT_ID;
  }

  hsu_host_al_hid_test_app_client_id[USBHOST_PDEV_TYPE_HID_KEYBOARD] = 
                                usbhost_register(
                                        USBHOST_PDEV_TYPE_HID_KEYBOARD,
                                        hsu_host_al_hid_test_app_client_desc,
                                        client_sigs,
                                        hsu_host_al_hid_test_app_dev_notify_cb,
                                        NULL);
  if (hsu_host_al_hid_test_app_client_id[USBHOST_PDEV_TYPE_HID_KEYBOARD] == 
      USBHOST_INVALID_CLIENT_ID)
  {
    HSU_MSG_ERROR("hsu_host_al_hid_test_app_init(): Can't register for keyboard notifications.",
                  0,0,0);
  }

  hsu_host_al_hid_test_app_client_id[USBHOST_PDEV_TYPE_HID_MOUSE] = 
                                usbhost_register(
                                        USBHOST_PDEV_TYPE_HID_MOUSE,
                                        hsu_host_al_hid_test_app_client_desc,
                                        client_sigs,
                                        hsu_host_al_hid_test_app_dev_notify_cb,
                                        NULL);
  if (hsu_host_al_hid_test_app_client_id[USBHOST_PDEV_TYPE_HID_MOUSE] == 
      USBHOST_INVALID_CLIENT_ID)
  {
    HSU_MSG_ERROR("hsu_host_al_hid_test_app_init(): Can't register for mouse notifications.",
                  0,0,0);
  }

  hsu_host_al_hid_test_app_client_id[USBHOST_PDEV_TYPE_HID_JOYSTICK] = 
                                usbhost_register(
                                        USBHOST_PDEV_TYPE_HID_JOYSTICK,
                                        hsu_host_al_hid_test_app_client_desc,
                                        client_sigs,
                                        hsu_host_al_hid_test_app_dev_notify_cb,
                                        NULL);
  if (hsu_host_al_hid_test_app_client_id[USBHOST_PDEV_TYPE_HID_JOYSTICK] == 
      USBHOST_INVALID_CLIENT_ID)
  {
    HSU_MSG_ERROR("hsu_host_al_hid_test_app_init(): Can't register for joystick notifications.",
                  0,0,0);
  }

  rex_def_timer_ex(&hsu_host_al_hid_test_app_sampled_timer, 
                   hsu_host_al_hid_test_app_sampled_timer_cb, 
                   NULL);
  (void)rex_set_timer(&hsu_host_al_hid_test_app_sampled_timer, 0);
#endif /* !CANDLEBOX_FEATURE_USBHID */
}
