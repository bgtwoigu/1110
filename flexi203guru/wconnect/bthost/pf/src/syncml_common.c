/*===========================================================================

                        EDIT HISTORY FOR MODULE

  This section contains comments describing changes made to the module.
  Notice that changes are listed in reverse chronological order.

$Header: //source/qcom/qct/wconnect/bthost/pf/rel/00.00.26/src/syncml_common.c#1 $ 

$Log: $
*
*    #8        09 Oct  2008           AP
*  Fixed Critical Errs generated by superlint
*
*    #7        18 Oct  2006           PR
*  Merged OI Code v3.0.14rev1revQ
*
*    #6        19 Sept 2006           MH
*  Changed to support OI client connect command
*
*    #4-5      10 Jul 2006            JH
* Removed extra linefeeds introduced in previous checkin.
*
*    #3        23 Jun 2006            JH
* Modified to work with updated OBEX code which supports JSR82.
*
===========================================================================*/
/** @file
 * @internal
 * common routines for SyncML OBEX bindings
 *
 */

/**********************************************************************************
  $Revision: #1 $
  Copyright 2002 - 2004 Open Interface North America, Inc. All rights reserved.
***********************************************************************************/

#define __OI_MODULE__ OI_MODULE_SYNCML


#include "oi_syncml.h"
#include "oi_argcheck.h"
#include "oi_std_utils.h"
#include "oi_debug.h"
#include "oi_assert.h"

/**
 *
 * @param addr                the remote device to which to connect
 * @param channel             the RFCOMM server channel to which to connect
 * @param uuid                the OBEX UUID to which to connect
 * @param connectCfmCB        connect confirmation callback function to be used
 * @param disconnectIndCB     disconnect indication callback function to be used
 * @param authChallengeIndCB  authentication challenge indication callback function to be used
 * @param connectionId        connection indication callback function to be used 
 */
OI_STATUS OI_SyncML_Connect(OI_BD_ADDR *addr,
                            OI_UINT8 channel,
                            OI_CHAR *uuid,
                            OI_OBEXCLI_CONNECT_CFM connectCfmCB,
                            OI_OBEXCLI_DISCONNECT_IND disconnectIndCB,
                            OI_OBEXCLI_AUTH_CHALLENGE_IND authChallengeIndCB,
                            OI_OBEXCLI_CONNECTION_HANDLE *connectionId)
{
    OI_OBEX_HEADER hdrs[1];
    OI_OBEX_HEADER_LIST hdrList;
    OI_OBEX_BYTESEQ target;
    
    target.data = (OI_BYTE *)uuid;
    target.len = OI_StrLen(uuid);

    hdrList.list = hdrs;
    hdrList.count = 0;

    hdrList.list[hdrList.count].id = OI_OBEX_HDR_TARGET;
    hdrList.list[hdrList.count].val.target = target;
    hdrList.count++;

    return OI_OBEXCLI_Connect(addr,
                              channel,
                              &hdrList,
                              connectCfmCB,
                              disconnectIndCB,
                              authChallengeIndCB,
#ifndef OI_CODE
                              NULL, /*Challenge Response Call back */
#endif
                              connectionId,
                              NULL);
}

/**
 * @param connectionId   OBEX connection handle
 * @param putCfm         callback function to confirm the put
 * @param mimeType       the MIME type to send
 * @param data           the data to send
 * @param dataLen        the amount of data available to send
 * @param putLen         [OUT] the amount of data sent
 * @param status         status code
 */
OI_STATUS OI_SyncML_Put(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
                        OI_OBEXCLI_PUT_CFM putCfm,
                        OI_CHAR *mimeType,
                        OI_BYTE *data,
                        OI_UINT16 dataLen,
                        OI_UINT16 *putLen,                        
                        OI_STATUS status)
{
    OI_OBEX_HEADER hdrs[2];
    OI_OBEX_HEADER_LIST hdrList;
    OI_OBEX_BYTESEQ body;
    OI_OBEX_BYTESEQ type;
    OI_STATUS result;
#ifdef OI_CODE
#error code not present
#endif /* OI_CODE */

    ARGCHECK(mimeType);
    ARGCHECK(putLen);

    hdrList.list = hdrs;
    hdrList.count = 0;

    /* type */
    type.data = (OI_BYTE *)mimeType;
    type.len = OI_StrLen(mimeType) + 1;
    hdrList.list[hdrList.count].id = OI_OBEX_HDR_TYPE;
    hdrList.list[hdrList.count].val.type = type;
    hdrList.count++;

    /* body */
    body.data = data;
#ifdef OI_CODE
#error code not present
#endif /* OI_CODE */
    if (data != NULL) {
        hdrList.list[hdrList.count].id = (status == OI_OK) ? OI_OBEX_HDR_END_OF_BODY : OI_OBEX_HDR_BODY;
        hdrList.list[hdrList.count].val.body = body;
        hdrList.count++;
    }

    result = OI_OBEXCLI_Put(connectionId, &hdrList, putCfm, status);
    if (OI_SUCCESS(result)) {
        *putLen = body.len;
    }
    else {
        *putLen = 0;
    }
    return result;
}

/**
 * @param connectionId  connection indication callback function
 * @param getRecvData   callback function with which the data received from the get is passed
 * @param mimeType      the MIME type to send
 */
OI_STATUS OI_SyncML_Get(OI_OBEXCLI_CONNECTION_HANDLE connectionId,
                        OI_OBEXCLI_GET_RECV_DATA getRecvData,
                        OI_CHAR *mimeType)
{
    OI_OBEX_HEADER hdrs[1];
    OI_OBEX_HEADER_LIST hdrList;
    OI_OBEX_BYTESEQ type;
    
    ARGCHECK(mimeType);
    
    hdrList.list = hdrs;
    hdrList.count = 0;

    /* type */
    type.data = (OI_BYTE *)mimeType;
    type.len = OI_StrLen(mimeType) + 1;  
    hdrList.list[hdrList.count].id = OI_OBEX_HDR_TYPE;
    hdrList.list[hdrList.count].val.type = type;
    hdrList.count++;
    
    return OI_OBEXCLI_Get(connectionId, &hdrList, getRecvData, TRUE);
}



OI_STATUS OI_SyncML_PutResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
                                OI_STATUS status)
{
    return OI_OBEXSRV_PutResponse(connectionId, NULL, status);
}

OI_STATUS OI_SyncML_GetResponse(OI_OBEXSRV_CONNECTION_HANDLE connectionId,
                                OI_BYTE *data,
                                OI_UINT16 dataLen,
                                OI_UINT16 *putLen,  
                                OI_STATUS status)
{
    OI_OBEX_HEADER hdrs[1];
    OI_OBEX_HEADER_LIST hdrList;
    OI_OBEX_BYTESEQ body;
    OI_STATUS result;
#ifdef OI_CODE
#error code not present
#endif /* OI_CODE */

    ARGCHECK(putLen);

    hdrList.list = hdrs;
    hdrList.count = 0;

    /* body */
    body.data = data;
#ifdef OI_CODE
#error code not present
#endif /* OI_CODE */
    if (data != NULL) {
        hdrList.list[hdrList.count].id = (status == OI_OK) ? OI_OBEX_HDR_END_OF_BODY : OI_OBEX_HDR_BODY;
        hdrList.list[hdrList.count].val.body = body;
        hdrList.count++;
    }

    result = OI_OBEXSRV_GetResponse(connectionId, &hdrList, status);
    if (OI_SUCCESS(result)) {
        *putLen = body.len;
    }
    else {
        *putLen = 0;
    }
    return result;
}

OI_STATUS OI_SyncML_Disconnect(OI_OBEXCLI_CONNECTION_HANDLE connectionId)
{
#ifdef OI_CODE
#error code not present
#else
    return OI_OBEXCLI_Disconnect(connectionId, NULL);
#endif
}

