#!/usr/local/bin/perl
# ------------------------------------------------------------------------
# Script to Create Scatter Loader file for Progressive Boot
# Copyright (c) 2001-2004 QUALCOMM Inc. All Rights Reserved.
# 
#-------------------------------------------------------------------------
#/*===========================================================================
#
#                           EDIT HISTORY FOR FILE
#  This section contains comments describing changes made to the module.
#  Notice that changes are listed in reverse chronological order.
#
# when       who     what, where, why
# --------   ---     -------------------------------------------------------
# 11/11/04   tk      Modified the script to take RO and RW sections from armlink (eliminated fromelf and armar)
# 11/04/04   tk      Modified the script to be efficient by eliminating all the arrays.
# 10/25/04   tk      Change the script to parse the file generated by make to get all the objs and libs
# 10/04/04   tk      Create Scatter Loader only if it doesn't exist.
# 10/04/04   tk      Added support for Parsing a Template and creating the Scatter Loader
# 09/22/04   tk      created
#===========================================================================*/

use warnings;
use strict;
use Cwd;
use FileHandle;
use Time::Local;
our $now;

$| = 1;

# Global Variables   

our @dirs;
our @exclude_dirs;
our @exclude_libs;
our @exclude_dirs_absolute_paths;
our $brewLibPath = "NONE";



our %OBJECTS;
our %LIBRARIES;
our %BREWLIBRARIES;
our %CLIBRARIES;
our %OTHER_PRECOMPILED_LIBRARIES;
our @EXCLUDELIBS;
our %OBJECTS_SRC;

our %RO_OBJ_EXCLUDE;
our %RW_OBJ_EXCLUDE;
our %RO_LIB_EXCLUDE;
our %RW_LIB_EXCLUDE;


our $modem_code_partition_size = 0;
our $modem_data_partition_size = 0;
our $code_exec_region_num = 1;
our $data_exec_region_num = 2;

our $script_dir = cwd;
our $build_id = "NONE";
our $asic = "NONE";
our $build_dir = "NONE";
our $arm_home = "NONE";
our $arm_lib = "";
our $ref_scl_file = "";
our $scl_des_file = "";
our $found_lib = 0;
our $no_clean = 0;

our $pboot_dirs_lf = "NONE";
our $pboot_excludedirs_lf = "NONE";
our $pboot_excludelibs_lf = "NONE";

our $pboot_sclfile_in = "NONE";
our $pboot_sclfile_out = "NONE";

our $pboot_list = "";
our $pboot_sizes = "";
our $pboot_sizes_temp = "";
our $pboot_errors = "";
our $ref_scl_file_temp = "";
our $scl_final = "";

our $lib_exts = '(lib|b|a|l)';



# Add hash segment variables.

our $num_l4_nonpaged_segments = 100;
our $hash_tbl_size = 0;
our $PROG_BOOT_DIGEST_SIZE = 20;
#our $MAX_EXEC_REGION_SIZE = 0x400000;
our $LIMIT_EXEC_REGION_SIZE = 0x300000 ;

# These definations should be consistent with the definations in
# tools/headergen/pboot_elf_utils.h

#our $RO           =   "RO";
#our $RW           =   "RW";
our $ZI           =   "ZI";
our $PAGEABLE     =   "PAGED";
our $NOTPAGEABLE  =   "NOTPAGED";
#our $RESERVED     =   "RESERVED";
#our $HASHTBL      =   "HASH";
#our $SHARED       =   "SHARED";
our $NOTUSED      =   "NOTUSED";

our $SIZE4K = 0x1000;
our $HASH_TABLE_CAL_ERROR_PAGED = 0x19000;    # (100K  ~  20MB)
our $HASH_TABLE_CAL_ERROR_NOTPAGED = 0x1000;  # (4K   ~   1MB)
our $BUFFER_FIRST_SEGMENT_AND_HASH_SEGMENT = 0x0;  #(0K)


 
  
  
  
#--------------------------------------------------------------------
#  SUBROUTINE: get_dir
#
#  Given a filename returns the directory path to the file 
#-------------------------------------------------------------------- 
      
      
      sub get_dir {
         
       		      
        my ($dir) = shift;
        my ($item) = shift;
        my $filee = "";
        my $path = "";
        
        
        chdir($dir) || die "Cannot chdir to $dir\n";
        local(*DIR);
        opendir(DIR, ".");
        while ($filee = readdir(DIR)) {
        
          if ($filee eq "." || $filee eq ".."){  
  		 next;
  	  }
  	  elsif($filee eq $item){
  		 return $dir;
  	  }
  	  elsif (-d $filee) {  
            
            # recurse the sub directories to find the file
            $path  = &get_dir($dir."/".$filee,$item);
  	    if($path ne "NOTFOUND"){
  	       return "$path";
  	    }
  	    
  	  }
  
  
  
  	}
  	chdir("..");
        closedir(DIR);
  
        return "NOTFOUND";
     } 
     
#-------------------------------------------------------------------------------------------
#  SUBROUTINE: create_exclude_objects_libs
#
#  Parses the template "<ASIC>_pboot.scl" and creates an array of RO and RW objects and libs
#  This is done to make sure these objects are not again included in the Scatter Loader 
#--------------------------------------------------------------------------------------------
       
       sub create_exclude_objects_libs{
       
           my $obj = 0;
       
           # Parse the entire reference file and create the RO and RW arrays for both objects and libraries
           open(REFERENCEFILE,$ref_scl_file) || die "Cannot open $ref_scl_file \n";
           while (<REFERENCEFILE>){
           
            # Dont Process if its a comment
            if(!(/\/\//)){
              if(/(\w+\.o)/){
              
                        $obj = $1;
        
        		if(/\+RO/){
        		    $RO_OBJ_EXCLUDE{"$obj"} = 1;
        		}
        		elsif(/\+RW/){
        		    $RW_OBJ_EXCLUDE{"$obj"} = 1;
        		}
        
        		
               }
               elsif(/\*\s*(\w+\.$lib_exts)\s*\(/)
               {
               
                        $obj = $1;
        
        		if(/\+RO/){
        		    $RO_LIB_EXCLUDE{"$obj"} = 1;
        		}
        		elsif(/\+RW/){
        		    $RW_LIB_EXCLUDE{"$obj"} = 1;
        		}
               }
             }
           }  
          close(REFERENCEFILE);
       
       
      }

#-------------------------------------------------------------------------------------------
#  SUBROUTINE: exclude_libs 
#  
#  These Libs even though fall into PARTITION 1 are excluded from PARTITION 1
#-------------------------------------------------------------------------------------------
    
sub exclude_libs
{
    
     my $key = "";
     my $exclude_lib;
     my @ARRAY_SUB_PATH;
     my $sub_path = "";


     for(my $i =0; $i <= $#EXCLUDELIBS;$i++)
     {
        $exclude_lib = $EXCLUDELIBS[$i]; 
       
       # Search in Libs here
       foreach $key (keys %LIBRARIES)
       {
       	    @ARRAY_SUB_PATH = split(/\//,$key);
       	    $sub_path = pop(@ARRAY_SUB_PATH);
       	      
       	      if($sub_path eq  $exclude_lib) 
       	      {
       	      	 $LIBRARIES{"$key"} = -3;
		        	      
       	      }
             	    
       }
       
       # Search in BREWLIBS here
       foreach $key (keys %BREWLIBRARIES)
       {
       	    @ARRAY_SUB_PATH = split(/\//,$key);
       	    $sub_path = pop(@ARRAY_SUB_PATH);
       	      
       	      if($sub_path eq  $exclude_lib) 
       	      {
       	      	 $BREWLIBRARIES{"$key"} = -3;
       	      
       	      }
             	    
       }

       # Search in PRECOMPILED here
       foreach $key (keys %OTHER_PRECOMPILED_LIBRARIES)
       {
       	    @ARRAY_SUB_PATH = split(/\//,$key);
       	    $sub_path = pop(@ARRAY_SUB_PATH);
       	      
       	      if($sub_path eq  $exclude_lib) 
       	      {
       	      	 $OTHER_PRECOMPILED_LIBRARIES{"$key"} = -3;
       	      
       	      }
             	    
       }
       
     }
       
       
 }
    
#-----------------------------------------------------------------------------------------
# SUBROUTINE: find_objs_libs
# Parse $pboot_list and get all the objects and Libraries here
#-----------------------------------------------------------------------------------------
    
    
sub find_objs_libs{
    
    my @TEMP_LIB_OBJECTS;
    my @ARMLINK_PARAM;
    
    my $obj = "";
    my $arr = "";
    my $lib = "";
    my $lf_file = "";
    my $i_file = "";
    my $s_file = "";
    my $key = "";
    my $value = "";
    my $armlink_cmd = "";
    my $print_to_temp_file = 0;
    #my $lib_obj = "";
    #my $process_lib_obj = 0;
    
    
    local(*DIR1);
    opendir(DIR1, ".") || die "Cannot open \n";
         
          open(INFO,"$pboot_list") || die "Cannot open file $pboot_list\n"; 
          while(<INFO>){


               	  if((/^echo/) || (/^pboot_make/)){
			 next;
		  }



                     
          #C:/Apps/Ads120/bin/tcc -c -cpu ARM926EJ-S -apcs /noswst/interwork -littleend -fa -g -dwarf2  -Wb -Ospace -O2 -DFEATURE_LIBRARY_ONLY -DT_ARM  -DCUST_H=\"CUSTSMAPR.H\"   -DASSERT=ASSERT_FATAL -I../../drivers/adc -I../../drivers/adie -I../../services/adsp -I../../core/buses/sbi/src -I../../services/mvs -I../../core/services/ansic/src -I../../drivers/atmr -I../../services/audfmt -I../../services/avs -I../../test/be_data -I../../drivers/bio -I../../drivers/boot -I../../apps/BREW_3.1/sdk/inc -I../../apps/BREW_3.1/pk/inc/msm -I../../apps/BREW_3.1/pk/inc -I../../apps/BREW_3.1/pk/src -I../../apps/BREW_3.1/pk/src/msm -I../../apps/BREW_3.1/pk/src/msm/bridle -I../../services/bt -I../../services/bt/pf -I../../services/bt/pf/ext -I../../apps/Bluetooth -I../../services/camcorder -I../../apps/qcamcorder -I../../services/camera -I../../apps/qcamera -I../../drivers/camsensor -I../../apps/cat -I../../drivers/chg -I../../core/systemdrivers/clk/src -I../../services/cm -I../../services/cmx -I../../apps/Contact -I../../apps/Core -I../../1x/cp -I../../build/cust -I../../data/data -I../../apps/DataStats -I../../drivers/dec -I../../core/services/diag/src -I../../apps/dialer -I../../services/dload -I../../services/dsm -I../../services/dtv/common -I../../services/egl -I../../drivers/enc -I../../core/storage/efs/src -I../../core/drivers/flash/src -I../../apps/FldDbg -I../../services/fota -I../../core/storage/fs/src -I../../services/ftm -I../../test/ftm_hwtc -I../../services/gles -I../../apps/OpenGLES/inc -I../../services/gps -I../../1x/srch/gps -Ilibs/gpssrch.lib -I../../services/graph -I../../drivers/grp -I../../services/gstk -I../../apps/gunimon -I../../services/hs -I../../drivers/hw -I../../drivers/i2c -I../../services/ipl -I../../services/joyst -I../../services/jpeg -I../../drivers/kpd -I../../drivers/lcd -I../../drivers/mddi -I../../drivers/mdp -I../../drivers/drvLib -I../../services/mdsp -I../../services/mdspsvc -I../../apps/MediaPlayer -I../../drivers/mmc -I../../services/mmoc -I../../services/mmgsdi -I../../apps/Mobimon -I../../build/ms -I../../apps/MobileSuite/Security -I../../apps/MobileSuite/Security/services/adaption -I../../apps/MobileSuite/Security/services/ms/sec/config -I../../apps/MobileSuite/Security/services/ms/sec/cryptlib -I../../apps/MobileSuite/Security/services/ms/sec/include -I../../apps/MobileSuite/Security/services/ms/sec/plugin -I../../apps/MobileSuite/Security/services/ms/sec/source -I../../apps/MobileSuite/Security/services/ms/sec/swwim -I../../apps/MobileSuite/Security/services/ms/sec/swwim/crypto -I../../apps/MobileSuite/SMSListener -I../../apps/MobileSuite/TMT -I../../apps/MobileSuite/TMT/apps/common -I../../apps/MobileSuite/TMT/apps/mms_app -I../../apps/MobileSuite/TMT/apps/mms_app/Resources -I../../apps/MobileSuite/TMT/apps/wap_app -I../../apps/MobileSuite/TMT/apps/wap_app/Resources -I../../apps/MobileSuite/TMT/services/adaption -I../../apps/MobileSuite/TMT/services/ms/mic/adapt -I../../apps/MobileSuite/TMT/services/ms/mic/config -I../../apps/MobileSuite/TMT/services/ms/mic/include -I../../apps/MobileSuite/TMT/services/ms/mic/source -I../../apps/MobileSuite/TMT/services/ms/mms/config -I../../apps/MobileSuite/TMT/services/ms/mms/include -I../../apps/MobileSuite/TMT/services/ms/mms/source -I../../1x/mux -I../../apps/netdiagnostics -I../../core/services/nv -I../../core/services/nv -I../../data/ossl -I../../test/plt -I../../services/pe -I../../drivers/pm -I../../apps/PureVoice -I../../services/qdsp -I../../services/Qtv/app -I../../services/Qtv/common -I../../services/Qtv/dec -I../../services/Qtv/dec/mp4 -I../../services/Qtv/dec/h264 -I../../services/Qtv/dec/jpeg -I../../services/Qtv/stream -I../../apps/StaticExtensions/OEM/Inc -I../../apps/StaticExtensions/OEM/Src -I../../apps/StaticExtensions/Inc -I../../core/services/rex/src -I../../apps/recentcalls -I../../drivers/rf -I../../services/rpc -I../../services/sam -I../../core/buses/sbi/src -I../../services/sd -I../../drivers/sdac -I../../core/storage/sdcc/src 
-I../../data/sec -I../../services/sfat -I../../core/wiredconnectivity/sio/src -I../../services/sleep -I../../1x/srch 
-I../../1x/srch/init -I../../1x/srch/idle -I../../1x/srch/traffic -I../../1x/srch/common -ISXAPR -I../../data/sta -I../../apps/SvcPrg -I../../core/debugtools/task/src -I../../services/tcxomgr -I../../drivers/therm -I../../core/systemdrivers/tlmm/src -I../../core/hwengines/tmc/src -I../../services/tokenbucket -I../../core/systemdrivers/tramp/src -I../../services/transcoder -I../../services/dtv/drivers/ts_camif -I../../services/uasms -I../../apps/Core -I../../apps/ui -I../../services/uim -I../../core/wiredconnectivity/usb/src -I../../core/services/utils/src -I../../drivers/vbatt -I../../services/vdb -I../../services/videofmt -I../../services/vm -I../../services/vr -I../../services/vre -I../../services/vs -I../../services/wms -I../../test/hwtc -I../../apps/wmsapp -I../../apps/gps -I../../apps/Java -I../../apps/Java/custom_config -I../../apps/Java/ams -I../../hdr -I../../services/time -I../../apps/OpenGLES/samples -I../../apps/OpenGLES/oem/inc -I../../drivers/qgl -I../../services/rte -I../../services/xmllib  -I"C:\Apps\Ads120\Include" -DBUILD_ASIC=\"M6550A\" -DBUILD_TARGET=\"SMAPR\" 
          #-DBUILD_VER=\"....\"   -o libs/rfmsm6500/sbi_api.o ../../core/buses/sbi/src/sbi_api.c
          #checks for string's of the form above in $pboot_list
          
          elsif((/tcc.+-o\s+(.+\.o)\s+(.+\.c)/) || (/tcpp.+-o\s+(.+\.o)\s+(.+\.cpp)/) || (/armcc.+-o\s+(.+\.o)\s+(.+\.c)/)){
          
               # Store all the source of objects here. 
               # This will be used Later to see if a Library belongs to Partition 1
               $OBJECTS_SRC{"$1"} = $2;
               
	       if(&check_exists_dirs_array("$2"))
               {
                     $OBJECTS{"$1"} = 1;
		                         
               }
               else{
                     #$OBJECTS{"$1"} = -1;
               }
               
          
          }
          
                 
          
          #C:/Apps/Ads120/bin/armar -r libs/pe.lib libs/ms_based/ap_diag.o 
          #libs/ms_based/cd.o libs/ms_based/cd_atmosph.o libs/ms_based/cd_decode.o 
          #libs/ms_based/cd_getpt.o libs/ms_based/cd_health.o libs/ms_based/cd_msg.o libs/ms_based/cd_rcvr.o libs/ms_based/cd_steer.o libs/ms_based/cd_svcalc.o libs/ms_based/cd_task.o libs/ms_based/me_api.o libs/ms_based/nf.o libs/ms_based/nf_fdic.o libs/ms_based/nf_getpt.o libs/ms_based/nf_magdv.o libs/ms_based/nf_proc.o libs/ms_based/nf_task.o libs/ms_based/os_api.o libs/ms_based/pe_api.o libs/ms_based/pe_fs.o libs/ms_based/pelog.o libs/ms_based/pepdsm.o       
          #checks for string's of the form above in $pboot_list
          
          elsif(/armar.+\s+(.+\.lib)\s+(.+)/){

              $lib = "$1";
              @TEMP_LIB_OBJECTS = split(/\s+/,"$2");
              
              $found_lib = 0;
             
              foreach $obj (@TEMP_LIB_OBJECTS)
              {
               if(exists($OBJECTS_SRC{$obj}))
               {
                 if(&check_exists_dirs_array($OBJECTS_SRC{$obj}))
                 {
                    $found_lib = 1;
                    last;
                 }
               }
              }

              
              if($found_lib == 1)
              {
                 $LIBRARIES{"$lib"} = 1;
                 while(@TEMP_LIB_OBJECTS){
    	               $obj = pop(@TEMP_LIB_OBJECTS);
    	               $OBJECTS{"$obj"} = -2;
    	               #undef $OBJECTS{"$obj"};
    	         }
              }
              else{
                 $LIBRARIES{"$lib"} = -1; 
              }
           }

	          
           #C:/Apps/Ads120/bin/tcc -E -DT_ARM -DCUST_H=\"CUSTSMAPR.H\" -D_ARM_ASM_ -apcs /noswst/interwork   -I../../drivers/adc -I../../drivers/adie -I../../services/adsp -I../../core/buses/sbi/src -I../../services/mvs -I../../core/services/ansic/src -I../../drivers/atmr -I../../services/audfmt -I../../services/avs -I../../test/be_data -I../../drivers/bio -I../../drivers/boot -I../../apps/BREW_3.1/sdk/inc -I../../apps/BREW_3.1/pk/inc/msm -I../../apps/BREW_3.1/pk/inc -I../../apps/BREW_3.1/pk/src -I../../apps/BREW_3.1/pk/src/msm -I../../apps/BREW_3.1/pk/src/msm/bridle -I../../services/bt -I../../services/bt/pf -I../../services/bt/pf/ext -I../../apps/Bluetooth -I../../services/camcorder -I../../apps/qcamcorder -I../../services/camera -I../../apps/qcamera -I../../drivers/camsensor -I../../apps/cat -I../../drivers/chg -I../../core/systemdrivers/clk/src -I../../services/cm -I../../services/cmx -I../../apps/Contact -I../../apps/Core -I../../1x/cp -I../../build/cust -I../../data/data -I../../apps/DataStats -I../../drivers/dec -I../../core/services/diag/src -I../../apps/dialer -I../../services/dload -I../../services/dsm -I../../services/dtv/common -I../../services/egl -I../../drivers/enc -I../../core/storage/efs/src -I../../core/drivers/flash/src -I../../apps/FldDbg -I../../services/fota -I../../services/core/storage/fs/src -I../../services/ftm -I../../test/ftm_hwtc -I../../services/gles -I../../apps/OpenGLES/inc -I../../services/gps -I../../1x/srch/gps -I../../1x/srch/gps -I../../services/graph -I../../drivers/grp -I../../services/gstk -I../../apps/gunimon -I../../services/hs -I../../drivers/hw -I../../drivers/i2c -I../../services/ipl -I../../services/joyst -I../../services/jpeg -I../../drivers/kpd -I../../drivers/lcd -I../../drivers/mddi -I../../drivers/mdp -I../../drivers/drvLib -I../../services/mdsp -I../../services/mdspsvc -I../../apps/MediaPlayer -I../../drivers/mmc -I../../services/mmoc -I../../services/mmgsdi -I../../apps/Mobimon -I../../build/ms -I../../apps/MobileSuite/Security -I../../apps/MobileSuite/Security/services/adaption -I../../apps/MobileSuite/Security/services/ms/sec/config -I../../apps/MobileSuite/Security/services/ms/sec/cryptlib -I../../apps/MobileSuite/Security/services/ms/sec/include -I../../apps/MobileSuite/Security/services/ms/sec/plugin -I../../apps/MobileSuite/Security/services/ms/sec/source -I../../apps/MobileSuite/Security/services/ms/sec/swwim -I../../apps/MobileSuite/Security/services/ms/sec/swwim/crypto -I../../apps/MobileSuite/SMSListener -I../../apps/MobileSuite/TMT -I../../apps/MobileSuite/TMT/apps/common -I../../apps/MobileSuite/TMT/apps/mms_app -I../../apps/MobileSuite/TMT/apps/mms_app/Resources -I../../apps/MobileSuite/TMT/apps/wap_app -I../../apps/MobileSuite/TMT/apps/wap_app/Resources -I../../apps/MobileSuite/TMT/services/adaption -I../../apps/MobileSuite/TMT/services/ms/mic/adapt -I../../apps/MobileSuite/TMT/services/ms/mic/config -I../../apps/MobileSuite/TMT/services/ms/mic/include -I../../apps/MobileSuite/TMT/services/ms/mic/source -I../../apps/MobileSuite/TMT/services/ms/mms/config -I../../apps/MobileSuite/TMT/services/ms/mms/include -I../../apps/MobileSuite/TMT/services/ms/mms/source -I../../1x/mux -I../../apps/netdiagnostics -I../../core/services/nv -I../../core/services/nv -I../../data/ossl -I../../test/plt -I../../services/pe -I../../drivers/pm -I../../apps/PureVoice -I../../services/qdsp -I../../services/Qtv/app -I../../services/Qtv/common -I../../services/Qtv/dec -I../../services/Qtv/dec/mp4 -I../../services/Qtv/dec/h264 -I../../services/Qtv/dec/jpeg -I../../services/Qtv/stream -I../../apps/StaticExtensions/OEM/Inc -I../../apps/StaticExtensions/OEM/Src -I../../apps/StaticExtensions/Inc -I../../core/services/rex/src -I../../apps/recentcalls -I../../drivers/rf -I../../services/rpc -I../../services/sam -I../../core/buses/sbi/src -I../../services/sd -I../../drivers/sdac -I../../core/storage/sdcc/src -I../../data/sec -I../../services/sfat -I../../core/wiredconnectivity/sio/src -I../../services/sleep -I../../1x/srch -I../../1x/srch/init -I../../1x/srch/idle -I../../1x/srch/traffic -I../../1x/srch/common -ISXAPR -I../../data/sta -I../../apps/SvcPrg -I../../core/debugtools/task/srck -I../../services/tcxomgr -I../../drivers/therm -I../../core/systemdrivers/tlmm/src -I../../core/hwengines/tmc/src -I../../services/tokenbucket -I../../core/systemdrivers/tramp/src -I../../services/transcoder -I../../services/dtv/drivers/ts_camif -I../../services/uasms -I../../apps/Core -I../../apps/ui -I../../services/uim -I../../core/wiredconnectivity/usb/src -I../../core/services/utils/src -I../../drivers/vbatt -I../../services/vdb -I../../services/videofmt -I../../services/vm -I../../services/vr -I../../services/vre -I../../services/vs -I../../services/wms -I../../test/hwtc -I../../apps/wmsapp -I../../apps/gps -I../../apps/Java -I../../apps/Java/custom_config -I../../apps/Java/ams -I../../hdr -I../../services/time -I../../apps/OpenGLES/samples -I../../apps/OpenGLES/oem/inc -I../../drivers/qgl -I../../services/rte 
           #-I../../services/xmllib < ../../apps/BREW_3.1/pk/src/msm/bridle/bridle_asmmmu.s | ../../tools/build/ppasm".exe"     - > SXAPR/bridle_asmmmu.i
           #checks for string's of the form above in $pboot_list
           
           elsif(/tcc.+<(.+\.s).+>\s+(.+\.i)/){
           
           	   $i_file = "$2";
           	   $s_file = "$1";
           	              	              
            }
            
            
            #C:/Apps/Ads120/bin/armasm -cpu ARM926EJ-S -apcs /noswst/interwork -g -dwarf2  -I../../services/ftm/lib 
            #-list libs/ftm_dft.lst libs/ftm_dft.i -o libs/rfmsm6500/ftm_dft.o
            #checks for string's of the form above in $pboot_list
            
            elsif(/armasm.+$i_file\s+-o\s+(.+\.o)/)
	    {

               $OBJECTS_SRC{"$1"} = $s_file;
                

               if(&check_exists_dirs_array("$s_file"))
               {
                        $OBJECTS{"$1"} = 1;
                                     
               }
               else{
           	      
           	        #$OBJECTS{"$1"} = -1;
               }
           	
           	      
            } #asm ends here
           
             
           
           
           # Get the BrewLibs that are passed to the linker here
           # Also get all the precompiled libraries here
           # Also get all the libraries passed by <xyz>LIBS.lf here
           
           elsif((/armlink/) && (!/^echo/))
	   {
               
             
             # Run the armlink in dryrun mode here.
             # This will generate $pboot_sizes.
             # $pboot_sizes contains RO RW section sizes of all objects and libraries.
             # some errors are generated during this process because linker wont be able to resolve linker generated
             # symbols, this command is run only to find the RO and RW section sizes, so we can ignore these errors.
             # All the errrors are written to $pboot_errors and deleted at the end of the script 

             @ARMLINK_PARAM = split(/\s/,$_);
             
             
             for(my $i=0; $i<scalar(@ARMLINK_PARAM); $i++)
	     {
             
             	 if(($ARMLINK_PARAM[$i] =~ /\.o/) || ($ARMLINK_PARAM[$i] =~ /\.$lib_exts$/) || ($ARMLINK_PARAM[$i] =~ /-VIA/) || ($ARMLINK_PARAM[$i] =~ /\.lf/) ||($ARMLINK_PARAM[$i] =~ /armlink/) )
		 {
             	       $armlink_cmd = $armlink_cmd.$ARMLINK_PARAM[$i]." ";
              	 }
             }
             
            #$armlink_cmd =~ s/armlink/armlink -info sizes,totals -errors $pboot_errors -list $pboot_sizes -noremove/;
            $armlink_cmd =~ s/armlink/armlink  -map  -info sizes,totals -errors $pboot_errors -list $pboot_sizes -scatter $ref_scl_file_temp -noremove/;
            #$armlink_cmd =~ s/armlink/armlink -info sizes,totals -symbols -errors $pboot_errors -list $pboot_sizes -scatter $pboot_sclfile_in -noremove/;
            
            system("$armlink_cmd");
		
			
			#If there is any link error, above command wont be able to create the $pboot_sizes file
			#So read the error from the $pboot_errors and output it to the build<BUILDID>.log file
			if (!(-e "$pboot_sizes"))
			{
			 open(ERRFILE,"$pboot_errors") || die "Cannot open file $pboot_errors\n";
			 foreach(<ERRFILE>)
			 {
			  if((/Error/) && !(/\$\$/))
			  { 
			    print " \n ************************************************************************\n";
			    print " **************  The Scatter Loader file is not Created *****************\n";
				print " **************  Due to Link Error Below                *****************\n";
			    print " ************************************************************************\n";
				print " LINK ERROR:: \n";
			    print;
				print "\n";
				&delTempFiles;
				exit;
			   }
			 }
			
			}
			
            
             # Create the file with only "Image component sizes"
             # This optimization helps in finding the RO RW sizes of Objs faster.
             open(MAPFILE,"$pboot_sizes") || die "Cannot open file $pboot_sizes\n";
             open(OBJSIZEFILE,">$pboot_sizes_temp") || die "Cannot open file $pboot_sizes_temp\n";
             open(OBJSIZEFILE,">>$pboot_sizes_temp") || die "Cannot open file $pboot_sizes_temp\n";
             while(<MAPFILE>)
             {

               if($print_to_temp_file == 1)
               {
                 print OBJSIZEFILE "$_" ;
                 next;

               }
               elsif(/Image\s+component\s+sizes/)
               {
                  $print_to_temp_file = 1; 
               }

             }
	     close(MAPFILE); 
             close(OBJSIZEFILE);

            
             # Get the Precompiled LIBRARIES HERE          
             
         foreach $lib(@ARMLINK_PARAM)
	     {
              
               # Get precompiled libs from the VIA/lf files here 
	       if($lib =~ /\w+\.lf$/)
	       {
                 open(LFFILE,"$lib") || die "Cannot open file $lib\n";
                 foreach(<LFFILE>){
		       s#\\#\/#g;
		       @TEMP_LIB_OBJECTS = split(/\s+/,$_);
		     }
                 close(LFFILE);	
                 foreach $lib(@TEMP_LIB_OBJECTS)
	         {
	           if($lib =~ /\w+\.$lib_exts$/){
		   	  &addPrecompiledLibs("$lib");
	           }
	         }
                 
                 
	       }
	       elsif($lib =~ /\w+\.$lib_exts$/){
	       	       &addPrecompiledLibs("$lib");
	       }
                        
             } #Library Searching ends here
             
           }
         
      }

      
          
   
  }


#-----------------------------------------------------------------------------------------
# SUBROUTINE: addPrecompiledLibs
# Adds the precompiled lib to corresponding Hash 
#-----------------------------------------------------------------------------------------  

sub addPrecompiledLibs{

my ($lib) = @_;

        # Get the BREW libraries here         
	if($lib =~ /$brewLibPath\/(\w+\.$lib_exts)$/)
	{

             $found_lib = &check_exists_dirs_array("$lib");
             
	     if($found_lib == 1)
	     {
	       $BREWLIBRARIES{"$lib"} = 1;
	     }
	     else{
	       $BREWLIBRARIES{"$lib"} = -1;
	     }

	}

	# Get the ARM LIBRARIES HERE
	elsif($lib =~ /\"$arm_home\"\/.+\/(\w+\.$lib_exts)$/)
	{

	  $lib =~ s/"//g;
	  $CLIBRARIES{"$lib"} = 1;

	}

	# Get other precompiled libraries here 
	elsif($lib =~ /\w+\.$lib_exts$/)
	{

	  if(!defined($LIBRARIES{"$lib"}))
	  {

                $found_lib = &check_exists_dirs_array("$lib");

                 if($found_lib == 1)
		 {
		     $OTHER_PRECOMPILED_LIBRARIES{"$lib"} = 1;
		 } 
		 else{
		     $OTHER_PRECOMPILED_LIBRARIES{"$lib"} = -1;
		 }

	   }       

	}
 }
    

    
#-------------------------------------------------------------------------------------------------
# SUBROUTINE: check_exists_dirs_array 
#
# Checks to see if atleast one element(path) in @dirs is equal to $path or substring of $path
# and return's one if it is true
#-------------------------------------------------------------------------------------------------
    
   sub check_exists_dirs_array{
    
      my ($srch_str) = @_;
      my $path = "";
      my $exclude_path = "";

      $srch_str =~ s#\\#\/#g;
      
      
      for(my $i=0;$i <= $#dirs;$i++)
      {
         
         $path = $dirs[$i];
         $path =~ s/\./\\\./g;
         $path =~ s/\//\\\//g;
		 
         if($srch_str =~ /$path/i)
	 {
            for(my $j=0; $j <= $#exclude_dirs; $j++)
	    {
                $exclude_path = $exclude_dirs[$j];
                $exclude_path =~ s/\./\\\./g;
                $exclude_path =~ s/\//\\\//g;
                
                if($srch_str =~ /$exclude_path/i) 
		{
                 
                  # Avoid the error in specification in incpaths.min
                  #if((length($exclude_path) > length($path)) && (index($exclude_path,$path) == 0)){
                  if(length($exclude_path) > length($path))
		  {
                     return 0;
                  } 
                  
                }
            }
	    return 1;
	        
         }
      }
            
     return 0;
   }
     

     
#-----------------------------------------------------------------------------------------------
#  SUBROUTINE: print_modem_code_regions   
#  
#  Loops through the reference array and prints the keys to modem code regions
#  starts a new modem code region if the value of key in the array
#  is 77 or 970 or 978
#-----------------------------------------------------------------------------------------------

sub print_modem_code_regions{ 
 
 my ($file_handle) = shift;
 my ($srch_str) = shift;
 my ($hashref) =  shift;
 my ($key,$value,$lib) = (0,0,0);
 
 while (($key,$value) = each(%$hashref))
 {  
    $key =~ /\/$srch_str/;
    $lib = "$1";
    if(($value == 7) || ($value == 9)){
        if($srch_str =~ /\.o/){
	   print $file_handle "      $lib (+RO) \n";
	}
	else{
	   print $file_handle "      *$lib (+RO) \n";
	}  
    }
    elsif(($value == 77) || ($value == 970) || ($value == 978)){
	
	print $file_handle "}\n";
	print $file_handle "\n\n";
	$code_exec_region_num = $code_exec_region_num + 1;
	print $file_handle "     AUTOGENERATED_CODE_".$code_exec_region_num." +0x0 0x400000 \n";
	print $file_handle "     {\n";
		
	if($srch_str =~ /\.o/){      
	      print $file_handle "      $lib (+RO) \n";
	}
	else{
	      print $file_handle "      *$lib (+RO) \n";
	}
	

    }
}

} 


#-----------------------------------------------------------------------------------------------
#  SUBROUTINE: print_modem_data_regions   
#  
#  Loops through the reference array($hashref) and prints the keys to modem data regions
#  starts a new modem data region if the value of key in the array
#  is 88 or 908 or 978
#-----------------------------------------------------------------------------------------------

sub print_modem_data_regions{ 
 
 my ($file_handle) = shift;
 my ($srch_str) = shift;
 my ($hashref) =  shift;
 my ($key,$value,$lib) = (0,0,0);
 
 
 while (($key,$value) = each(%$hashref))
 {  
    $key =~ /\/$srch_str/;
    $lib = "$1";
    if(($value == 8) || ($value == 9) || ($value == 970)){
        if($srch_str =~ /\.o/){
	  print $file_handle "      $lib (+RW) \n";
	}
	else{
	  print $file_handle "      *$lib (+RW) \n";
	}  
    }
    elsif(($value == 88) || ($value == 908) || ($value == 978)){
        
	print $file_handle "}\n";
	print $file_handle "\n\n";
	$data_exec_region_num = $data_exec_region_num + 1;
	print $file_handle "     MODEM_DATA_".$data_exec_region_num." +0x0 0x400000 \n";
	print $file_handle "     {\n";

	if($srch_str =~ /\.o/){      
	       print $file_handle "      $lib (+RW) \n";
	}
	else{
	       print $file_handle "      *$lib (+RW) \n";
	}
	
	

    }
}

} 

     
     
     
     
#------------------------------------------------------------------------------------------------
#  SUBROUTINE: filter_libraries
#  
#  Loops through the reference array($hashref) and checks for each key(library) for RO and RW sections.
#  Also partitions all the libraries based on 4MB limit of each execution region. Keeps track of the size
#  of RO and RW sections of Libs eccountered till now. IF it exceed's 4MB limit marks the lib as the end of 
#  execution region.
#  Possible output of values for each key(library) 
#  1    --  IF it doesnt have both RO and RW section
#  1    --  If it is already inlcuded in the base scatter Loader
#  7    --  Has only RO section.  
#  8    --  Has only RW section.
#  9    --  Has both RO + RW section.
#  77   --  Has only RO section + start of new modem code execution region
#  88   --  Has only RW section + start of new modem data execution region
#  970  --  Has both RO + RW section + start of new modem code execution region
#  908  --  Has both RO + RW section + start of new modem data execution region 
#  978  --  Has both RO + RW section + start of new modem code execution region + start of new modem data execution region
#------------------------------------------------------------------------------------------------
     
       
   sub filter_libraries{
     
       my ($hashref) = @_;
       my @section_sizes;
       my ($key, $value) = (0,0);
       my $ro_size = 0;
       my $rw_size = 0;
       my $lib = "";
       my $lib_str = "";
       my $found = 0;
       my $srch_lib = 0;
     
      	while (($key, $value) = each(%$hashref)){
     	     
     	if($value == 1){ 
     	   	
     		
     		# this is also called with clibraries
     		if($key =~ /\/(\w+\.$lib_exts)/){
     		    $lib= $1;
     		    $lib_str = $1;
     		}
     		     		
     		$lib_str =~ s/\./\\\./;
     		$found = 0;
     		
     		open(INFO,"$pboot_sizes_temp") || die "Cannot open file $pboot_sizes\n" ;
     		#foreach(<INFO>){
                while(<INFO>){

                 if($srch_lib == 1){
                      if(/\s+$lib_str\s*/){
     		        		   
     		        @section_sizes = split(/\s+/);
     		        $found = 1;
                        $srch_lib = 0;
                        last;
     		      }
                   }
                   #Code    RO Data    RW Data    ZI Data      Debug   Library Name
                   elsif(/Code\s+RO\sData\s+RW\sData\s+ZI\sData\s+Debug\s+Library\sName/){
                       $srch_lib = 1;
                   }
                   
     		}
     		close(INFO);
     		
     if($found == 1){
     	$ro_size =  $section_sizes[1] + $section_sizes[2];
     	$rw_size =  $section_sizes[3];
     	
     	if($ro_size){
     
     	   if(!defined($RO_LIB_EXCLUDE{"$lib"})){
     	   
                    $modem_code_partition_size = $modem_code_partition_size + $ro_size;
                    if($modem_code_partition_size > $LIMIT_EXEC_REGION_SIZE){
     	     	          $hashref->{"$key"} = 77;
     	     	          $modem_code_partition_size = $ro_size;
     	     	  }
     	     	  else{
     	     	          $hashref->{"$key"} = 7;
     	     	  }        
     	   }       
     	}
     
     	if($rw_size){
     	     	      
     	   if(!defined($RW_LIB_EXCLUDE{"$lib"})){
     	     
     	     $modem_data_partition_size = $modem_data_partition_size + $rw_size;
     	     
     	     if($modem_data_partition_size > $LIMIT_EXEC_REGION_SIZE){
     	        
     	        $modem_data_partition_size = $rw_size;
     	        if($hashref->{"$key"} == 7){
     	     		 $hashref->{"$key"} = 908;
     	     	}
     	     	elsif($hashref->{"$key"} == 77){
     	     		 $hashref->{"$key"} = 978;
     	     	}
     	     	elsif($hashref->{"$key"} == 1){
     	     		 $hashref->{"$key"} = 88;
     	     	} 
     	    
     	     }
     	     else{
     	     
     	     	if($hashref->{"$key"} == 7){
     	     		 $hashref->{"$key"} = 9;
     	     	}
     	     	elsif($hashref->{"$key"} == 77){
     	     		 $hashref->{"$key"} = 970;
     	     	}
     	     	elsif($hashref->{"$key"} == 1){
     	     		 $hashref->{"$key"} = 8;
     	     	} 
     	     
     	     }
     	     }	
     	   }  
     	       	      
     	 }
     	}
     	
     	}
     	  	     
   }
     	 
     
#------------------------------------------------------------------------------------------------
#  SUBROUTINE: filter_objects
#  
#  Loops through the reference array(%OBJECTS) and checks for each key(object) for RO and RW sections.
#  Also partitions all the libraries based on 4MB limit of each execution region. Keeps track of the size
#  of RO and RW sections of Libs eccountered till now. IF it exceed's 4MB limit marks the lib as the end of 
#  execution region.
#  Possible output of values for each key(object) 
#  1    --  IF it doesnt have both RO and RW section
#  1    --  If it is already inlcuded in the base scatter Loader
#  7    --  Has only RO section.  
#  8    --  Has only RW section.
#  9    --  Has both RO + RW section.
#  77   --  Has only RO section + start of new modem code execution region
#  88   --  Has only RW section + start of new modem data execution region
#  970  --  Has both RO + RW section + start of new modem code execution region
#  908  --  Has both RO + RW section + start of new modem data execution region 
#  978  --  Has both RO + RW section + start of new modem code execution region + start of new modem data execution region
#------------------------------------------------------------------------------------------------
      
      
    sub filter_objects{
        
         
         my @section_sizes;
         my ($key, $value) = (0,0);
         my $ro_size = 0;
         my $rw_size = 0;
         my $obj = "";
         my $obj_str = "";
         my $found = 0;
         my $srch_obj = 0;
           
         chdir($script_dir);
         
           
           while (($key, $value) = each(%OBJECTS)){
             
             if($value == 1){
              	
                          	
              	$key =~ /\/(\w+\.o)/;
              	$obj = $1;
              	$obj_str = $1;
                # Do this so that perl doesnt include every thing for "."
              	$obj_str =~ s/\./\\\./;
              	$found = 0;
              	
              	open(INFO,"$pboot_sizes_temp")  || die "Cannot open file $pboot_sizes\n";
              	while(<INFO>){

                 if($srch_obj == 1){
                      if(/\s+$obj_str\s*/){
              	        @section_sizes = split(/\s+/);
              	        $found = 1;
                        $srch_obj = 0;
                        last;
     		      }
                   }
                   #Code    RO Data    RW Data    ZI Data      Debug   Object Name
                   elsif(/Code\s+RO\sData\s+RW\sData\s+ZI\sData\s+Debug\s+Object\sName/){
                       $srch_obj = 1;
                   }
                
              	}
              	close(INFO);
              	
           if($found == 1){
           
                        
               
               
   		$ro_size =  $section_sizes[1] + $section_sizes[2];
   		$rw_size =  $section_sizes[3];
   		
   		
              	if($ro_size){
              	     
              	     if(!defined($RO_OBJ_EXCLUDE{"$obj"})){
              	     
              	           $modem_code_partition_size = ($modem_code_partition_size + $ro_size);
              	           
              	     	   if($modem_code_partition_size > $LIMIT_EXEC_REGION_SIZE){   # Approx 3.0MB
              	     	           $OBJECTS{"$key"} = 77;
              	     	           $modem_code_partition_size = $ro_size;
              	     	   }
              	     	   else{
              	     	           $OBJECTS{"$key"} = 7;
              	     	   }        
              	             
              	     }      
              	}
              	
              	if($rw_size){
              	    
              	   if(!defined($RW_OBJ_EXCLUDE{"$obj"})){
        	    	      
        	    	      $modem_data_partition_size = $modem_data_partition_size + $rw_size;
        	    	      
        	    	      if($modem_data_partition_size > $LIMIT_EXEC_REGION_SIZE){     # Approx 3.0MB
        	    	         
        	    	        $modem_data_partition_size = $rw_size;
        	    	        print " rw+4 $key \n";
        	    	        if($OBJECTS{"$key"} == 7){
        	    	      		 $OBJECTS{"$key"} = 908;
        	    	      	}
        	    	      	elsif($OBJECTS{"$key"} == 77){
        	    	      		 $OBJECTS{"$key"} = 978;
        	    	      	}
        	    	      	elsif($OBJECTS{"$key"} == 1){
        	    	      		 $OBJECTS{"$key"} = 88;
        	    	      	} 
        	    	     
        	    	      }
        	    	      else{
        	    	      
        	    	      	if($OBJECTS{"$key"} == 7){
        	    	      		 $OBJECTS{"$key"} = 9;
        	    	      	}
        	    	      	elsif($OBJECTS{"$key"} == 77){
        	    	      		 $OBJECTS{"$key"} = 970;
        	    	      	}
        	    	      	elsif($OBJECTS{"$key"} == 1){
        	    	      		 $OBJECTS{"$key"} = 8;
        	    	      	} 
        	    	      
        	    	      }
        	    	     
        	    	     
        	    	     
        	    	   }
        	    	}
        	    	
        	    	
        	    }	
        	         
        	  }  
        	 }
        	 
         
         }
        
# ------------------------------------------------------------------------
# SUBROUTINE: Usage 
#
# ------------------------------------------------------------------------
sub Usage 
{
   (my $sec, my $min, my $hour, my $mday, my $mon, my $year, my $wday, my $yday, my $isdst) = localtime(time);
   $year += 1900;

   print <<usage;

$0 - Copyright (c) $year QUALCOMM Inc.
   % perl create_pboot_scl 
                      
               REQUIRED
                      
               -build <BUILDID>         - Build Id for the Build
	       -pbootinputscl <SCLFILE> - Input Scatter Loader File
	       -pbootoutputscl <SCLFILE> - Output Scatter Loader File
               -targetdir <TARGETDIR>   - Specify the name of the target dir.
	       -asic <ASIC>             - Asic 
	       -armhome <ARMHOME>       - ARM Home for example c:/apps/ADS120/
	       -brewlibdir <BREW_LIB>   - Path to BREW Libraries
	       -pbootdirs <FILE>        - File containing the list of Directories (All the object files and libs from these dirs will be in the non paged secion)
               -pbootexcludedirs <FILE> - The directories form this file are excluded from above mentioned directories.
	       -pbootexcludelibs <FILE> - The libs form this file are excluded partition1 (NONPAGED)
               -noclean                 - Does not delete the temporary files created by the script. Useful for debugging.

   Example:
      % perl $0 -build SMBRRA -targetdir SXBRRA -asic M6800A -armhome c:/apps/ads120/ -brewlibdir ../../apps/BREW3.1/lib/Chipset/ADS12arm9 -pbootdirs pboot_dirs.lf -pbootexcludedirs pboot_excludedirs.lf -pbootexcludelibs pboot_excludelibs.lf -pbootinputscl <SCL file> -pbootoutputscl <SCL file>
     
usage
   return;
} # END Usage     


 
#--------------------------------------------------------------------------
# SUBROUTINE: ProcessCommandLine   
#  
#  Parses the command line to get build_id and asic information  
#--------------------------------------------------------------------------
  
sub ProcessCommandLine{
    
   for( my $i=0; $i<$#ARGV+1; $i++)
   {
      my $arg = $ARGV[$i];
      
      if ( $arg eq "-build" )
      {
         $i++;
         $build_id = $ARGV[$i];
      }	
      elsif( $arg eq "-targetdir" )
      {
         $i++;
         $build_dir = $ARGV[$i];
                  
      }
     elsif( $arg eq "-asic" )
      {
         $i++;
         $asic = $ARGV[$i];
                  
      }
     elsif( $arg eq "-armhome" )
      {
         $i++;
         $arm_home = $ARGV[$i];
                  
      }
      elsif( $arg eq "-brewlibdir" )
      {
         $i++;
         $brewLibPath = $ARGV[$i];
                  
      } 
      elsif( $arg eq "-pbootdirs" )
      {
         $i++;
         $pboot_dirs_lf = $ARGV[$i];
                  
      } 
      elsif( $arg eq "-pbootexcludedirs" )
      {
         $i++;
         $pboot_excludedirs_lf = $ARGV[$i];
                  
      }
      elsif( $arg eq "-pbootexcludelibs" )
      {
         $i++;
         $pboot_excludelibs_lf = $ARGV[$i];
                  
      }  
      elsif( $arg eq "-pbootinputscl" )
      {
         $i++;
         $pboot_sclfile_in = $ARGV[$i];
                  
      }  
      elsif( $arg eq "-pbootoutputscl" )
      {
               $i++;
               $pboot_sclfile_out = $ARGV[$i];
                        
      }  
      elsif ( $arg eq "-noclean" )
      {
         $no_clean = 1;
      }	
   }

      
  if(( $arm_home  eq "NONE"  ) || ( $build_dir eq "NONE" ) || ( $asic eq "NONE" ) || ( $build_dir eq "NONE" ) || ($brewLibPath eq "NONE" ) || ($pboot_dirs_lf eq "NONE") || ($pboot_excludedirs_lf eq "NONE") || ($pboot_excludelibs_lf eq "NONE") || ($pboot_sclfile_in eq "NONE") || ($pboot_sclfile_out eq "NONE"))
   {
      Usage();
      exit;
   } 
	 
 
}  


#--------------------------------------------------------------------------
# SUBROUTINE: createDryRunTxtFile   
#  
#  Parses the command file and creates $pboot_list  using make 3.80
#--------------------------------------------------------------------------
sub createDryRunTxtFile{

 my $current_dir = cwd;

 open(CMDFILE,"$build_id\.cmd") || die "Cannot open file $build_id\.cmd  \n";
   
    while(<CMDFILE>){
     if(/(make.+$build_dir)/){
       
       my $mak_str = $1;
       my $path = $ENV{'PATH'};
       $ENV{'PATH'} = "$path\;\.";
       ##$mak_str =~ s/make/\.\\pboot_make\.exe -n -B/;
       $mak_str =~ s/make/pboot_make\.exe -n -B/;
       $mak_str .= ' > ';
       $mak_str .= "$pboot_list";
       $mak_str .= ' 2>&1';
       
       my $current_dir = cwd;
       $current_dir =~ s/\//\\/g;
       $mak_str = $current_dir.'\\'.$mak_str;

       system("$mak_str");
       
     }
  }
  close(CMDFILE);
}


#---------------------------------------------------------------------------------
#  SUBROUTINE: parseTemplate
#  
#  Parses the template "m6550a_pboot.scl" and creates the Scatter loader file  
#---------------------------------------------------------------------------------

sub parseTemplate{
   
       my  $modem_code_data_started = 0;
       my  $load_region = "";
       my  $exec_region = 0;
       my  @TEMP_LINE;
       my  $line_part = "";
       my  ($key,$value) = (0,0);
       my  $braces = 0;
       my  $lib = "";
       my $first_code_nonpaged_load_region = "NONE";
       my $first_data_nonpaged_load_region = "NONE";
         
         
   
       open(REFERENCEFILE,$ref_scl_file) || die "Cannot open $ref_scl_file\n";
       open(SCATTERLOADER,">$scl_des_file") || die "Cannot open $scl_des_file \n";    # open the scatter loader des file for output
       open(SCATTERLOADER,">>$scl_des_file");	     # open the scatter loader des file for APPEND
       
       # Read the progressive_boot_template.scl and form the asic_progressive_boot.scl
       while (<REFERENCEFILE>)
       {
       
	       
	       #print "$_\n";	
       if((/(\S+_CODE_NOTPAGED)\s+/) && ($first_code_nonpaged_load_region eq "NONE")){
	    
	    $load_region = $1;
	    $first_code_nonpaged_load_region = $1;
	      
          
        }
	elsif((/(\S+_DATA_NOTPAGED)\s+/) && ($first_data_nonpaged_load_region eq "NONE")){
           
	   $load_region = $1;
	   $first_data_nonpaged_load_region = $1;
	  

        }
        elsif($load_region eq $first_code_nonpaged_load_region )
	{

	  if((/\*\.o\s*\(\+RO\)/)  ||  (/\*\.o\s*\(\+RW\)$/)  ||  (/\*\s*\(\+RO\)$/)  ||  (/\*\s*\(\+RW\)$/)  ||  (/\.ANY\s*\(\+RO\)/)  ||  (/\.ANY\s*\(\+RW\)/))
	  {  
             # There should be no *.o (+RO) || *.o (+RW) || * (+RO) || * (+RW) || .ANY (+RO) || .ANY (+RW)  IN MODEM_CODE_DATA_NOTPAGED load region
             # If there is one, it will be ignored.
	     #next;   
          }
	  elsif(/\S+\s+(\+0|\+0x0)/){
                
		print SCATTERLOADER "\n    AUTOGENERATED_CODE_".$code_exec_region_num." +0x0 0x400000 \n";
        	print SCATTERLOADER "     {\n";
	     	  
             	&print_modem_code_regions(\*SCATTERLOADER,"(\\w+\\.$lib_exts)",\%CLIBRARIES);
		&print_modem_code_regions(\*SCATTERLOADER,"(\\w+\\.$lib_exts)",\%BREWLIBRARIES);
		&print_modem_code_regions(\*SCATTERLOADER,"(\\w+\\.$lib_exts)",\%OTHER_PRECOMPILED_LIBRARIES);
		&print_modem_code_regions(\*SCATTERLOADER,"(\\w+\\.$lib_exts)",\%LIBRARIES);
		&print_modem_code_regions(\*SCATTERLOADER,"(\\w+\\.o)",\%OBJECTS);

		print SCATTERLOADER "     }\n\n";
		$first_code_nonpaged_load_region =  "FINISH";
	  }	  

	  

	}
	elsif($load_region eq $first_data_nonpaged_load_region){


	  if((/\*\.o\s*\(\+RO\)/)  ||  (/\*\.o\s*\(\+RW\)$/)  ||  (/\*\s*\(\+RO\)$/)  ||  (/\*\s*\(\+RW\)$/)  ||  (/\.ANY\s*\(\+RO\)/)  ||  (/\.ANY\s*\(\+RW\)/))
	  {  
             # There should be no *.o (+RO) || *.o (+RW) || * (+RO) || * (+RW) || .ANY (+RO) || .ANY (+RW)  IN MODEM_CODE_DATA_NOTPAGED load region
             # If there is one, it will be ignored.
	     # next;   
          }
	  elsif(/\S+\s+(\+0|\+0x0)/){
                
		print SCATTERLOADER "\n     MODEM_DATA_".$data_exec_region_num." +0x0 0x400000 \n";
        	print SCATTERLOADER "      {\n";
	     	  
             	&print_modem_data_regions(\*SCATTERLOADER,"(\\w+\\.$lib_exts)",\%CLIBRARIES);
		&print_modem_data_regions(\*SCATTERLOADER,"(\\w+\\.$lib_exts)",\%BREWLIBRARIES);
		&print_modem_data_regions(\*SCATTERLOADER,"(\\w+\\.$lib_exts)",\%OTHER_PRECOMPILED_LIBRARIES);
		&print_modem_data_regions(\*SCATTERLOADER,"(\\w+\\.$lib_exts)",\%LIBRARIES);
		&print_modem_data_regions(\*SCATTERLOADER,"(\\w+\\.o)",\%OBJECTS);

		print SCATTERLOADER "     }\n\n";
		$first_data_nonpaged_load_region =  "FINISH";
	  }	  



	}

	print SCATTERLOADER;

}
}

#---------------------------------------------------------------------------------
#  SUBROUTINE: delTempFiles
#  
#  Delete the Temporary Files Created by the script
#---------------------------------------------------------------------------------
sub delTempFiles{
 

if(!$no_clean){

  # Delete the temporary files created.
  system("rm -f $pboot_sizes");
  system("rm -f $pboot_sizes_temp");
  system("rm -f $pboot_errors");
  system("rm -f $pboot_list");
  system("rm -f $ref_scl_file_temp");
  system("rm -f $scl_des_file");

}
  
}

#---------------------------------------------------------------------------------
#  SUBROUTINE: alignSize
#  
#  Given a parameter, alignes it to the size specified
#---------------------------------------------------------------------------------
sub alignSize{

my ($size) = shift;
my ($align_to) = shift;

  if (($size & ($align_to - 1)) != 0)
  {
    return (($size & ~($align_to - 1)) + $align_to);
  }

  return $size;

}


#---------------------------------------------------------------------------------
#  SUBROUTINE: calHashSegmentSize
#  
#  Calculates the size of Hash Segment from the SCL file.
#---------------------------------------------------------------------------------
sub calHashSegmentSize{

my $num_load_regions_nonpaged = 0;
my $num_load_regions_paged = 0;
my %EXEC_REGIONS = ();
my @LOAD_REGIONS;
my $total_rom_size = 0;
my @SCL_FILE_ARRAY;
my $curr_exec_region = 0;
my $curr_load_region = 0;
my $next_load_region = 0;
my $find_exec_region = 0;
my $non_paged_seg_size = 0;
my $paged_seg_size = 0;



  open(MAPFILE,"$pboot_sizes") || die "Cannot open file $pboot_sizes\n";
  while(<MAPFILE>)
  {
    #Load Region HASH_SEGMENT_NOTPAGED (Base: 0x001a0000, Size: 0x00001000, Max: 0xffffffff, ABSOLUTE)
    if(/Load\s+Region.+_$PAGEABLE.+ /)
    {
       $num_load_regions_paged++; 
    }
    elsif(/Load\s+Region.+_$NOTPAGEABLE.+/) 
    {
       $num_load_regions_nonpaged++;
    }

  }
  close(MAPFILE);

  
  # Check if there are no PAGED EXEC Regions 
  if($num_load_regions_paged == 0)
  {
     $hash_tbl_size = (($num_load_regions_nonpaged + $num_l4_nonpaged_segments) * $PROG_BOOT_DIGEST_SIZE);
     $hash_tbl_size = $hash_tbl_size + $HASH_TABLE_CAL_ERROR_NOTPAGED;
     $hash_tbl_size = alignSize($hash_tbl_size,$SIZE4K);
  }
  else
  {

    # Calculate the Total ROM size here
    open(OBJSIZEFILE,"$pboot_sizes_temp") || die "Cannot open file $pboot_sizes_temp\n";
    while(<OBJSIZEFILE>)
    {
       #Total ROM Size(Code + RO Data + RW Data)   23893294 (23333.29kB)
       if(/Total\s+ROM\s+Size\(Code\s+\+\s+RO\s+Data\s+\+\s+RW\s+Data\)\s+(\d+)\s+/)
       {
          $total_rom_size = $1;
       }
    }
    close(OBJSIZEFILE);




    # Get a list of all the Load and Execution Regions from the Map file
    open(MAPFILE,"$pboot_sizes") || die "Cannot open file $pboot_sizes\n";
    while(<MAPFILE>)
    {
      #Load Region MSM_NOTPAGED (Base: 0x001a0000, Size: 0x00003000, Max: 0xffffffff, ABSOLUTE)
      if(/Load\s+Region\s+(\S+)\s+\(Base/)
      {
         $curr_load_region = "$1";
         if($curr_load_region !~ /LR\$\$Debug/)
         {
            push(@LOAD_REGIONS, $curr_load_region);
         }
         else
         {
            $curr_load_region = "NULL";
         }
         
      }
      #Execution Region UNUSED_CODE_PAD (Base: 0x001a0000, Size: 0x00001000, Max: 0xffffffff, ABSOLUTE)
      elsif((/Execution\s+Region\s+(\S+).+Size\:\s+0x(\S+)\,/) && ($curr_load_region ne "NULL"))
      {
         $EXEC_REGIONS{"$1"}{size} = hex($2); 
         $EXEC_REGIONS{"$1"}{loadreg} = $curr_load_region; 
      }
    
     
    }
    close(MAPFILE);

    # Calculate the Size of NONPAGED segment
    # Size of PAGED segments = (TOTAL ROM Size - Size of NONPAGED segments)
    for(my $i =0; $i <= $#LOAD_REGIONS;$i++)
    {
     $curr_load_region = $LOAD_REGIONS[$i];
     $next_load_region = $LOAD_REGIONS[$i+1];
     $find_exec_region = 0;

     # We dont need to look at the execution Regions of PAGED SEGMENTS
     if(($curr_load_region !~ /$NOTPAGEABLE/) || ($curr_load_region =~ /$ZI/) || ($curr_load_region =~ /$NOTUSED/))
     {
       next;
     }

     # Mark the $next_load_region as "END" if $curr_load_region is the last region in SCL file
     if($i == $#LOAD_REGIONS)
     {
       $next_load_region = "END" ;
     }

      open(SCATTERLOADER,"$scl_des_file") || die "Cannot open $scl_des_file \n";
      while(<SCATTERLOADER>)
      {
        #Ignore Comments
        if((/^\s*\#/) || (/^\s*\/\*/) || (/^\s*\/\//))
        {
           next;
        }
       
        elsif(/$curr_load_region+\s+/)
        {
           $find_exec_region = 1;
           next;
        }

        elsif(/$next_load_region+\s+/)
        {
           $find_exec_region = 2;
           last;
        }

        #CODE 0x0 0x80000
        #MODEM_CODE_PAD +0
        # Need to find a good Regular Expression for Hexadecimal matching
        elsif((/(\S+)\s+\+?(0x|)(0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f)+/) && ($find_exec_region == 1))
        {
           $curr_exec_region = $1;

           if(($curr_exec_region =~ /AUTOGENERATED/) || ($curr_exec_region =~ /MODEM_DATA_[2-9]/))
           {
             $non_paged_seg_size = $non_paged_seg_size + $LIMIT_EXEC_REGION_SIZE;
           }
           elsif(exists($EXEC_REGIONS{$curr_exec_region}))
           { 
             if($EXEC_REGIONS{$curr_exec_region}{loadreg} eq $curr_load_region)
             {
               $non_paged_seg_size = $non_paged_seg_size + $EXEC_REGIONS{$curr_exec_region}{size};
             }
             
           }
           
         }



        }
        close(SCATTERLOADER);

        if($find_exec_region == 0)
        {
           print " \n ************************************************************************\n";
           print " \n ************************************************************************\n";
           print " \n ************** Unable to find the Load Region  *************************\n";
           print " \n ************$curr_load_region in SCL File $scl_des_file*****************\n";
           print " \n ************************************************************************\n";
           exit;

        }
        #Check if we did not find the execution region
        elsif(($find_exec_region != 2) && ($next_load_region ne "END"))
        {
           # We dont modify the number of execution Regions in the Temp SCL file
           # This condition should Never Happen.
           print " \n ************************************************************************\n";
           print " \n ************************************************************************\n";
           print " \n ************** Unable to find the Load Region  *************************\n";
           print " \n ************$next_load_region in SCL File $scl_des_file*****************\n";
           print " \n ************************************************************************\n";
           exit;
        }


     } #for Ends
    
      $paged_seg_size =  ($total_rom_size - $non_paged_seg_size);
      $hash_tbl_size = (($num_load_regions_nonpaged + $num_l4_nonpaged_segments + int($paged_seg_size/$SIZE4K)) * $PROG_BOOT_DIGEST_SIZE);
      $hash_tbl_size = $hash_tbl_size + $HASH_TABLE_CAL_ERROR_PAGED;
      $hash_tbl_size = alignSize($hash_tbl_size,$SIZE4K);

  } #else Ends


} #calHashSegmentSize Ends


#---------------------------------------------------------------------------------
#  SUBROUTINE: createSCL4armlinkcmd
#  
#  Adds the Hash Segment Size to the SCL file.
#---------------------------------------------------------------------------------

sub createSCL4armlinkcmd {

my $stop_printing = 0;
my $found_print_seg = 0;
my $print_dummy_exec_regions = "NOT_PRINTED";

 open(REFERENCEFILE,$ref_scl_file) || die "Cannot open $ref_scl_file\n";
 open(ARMLINK_SCATTERLOADER,">$ref_scl_file_temp") || die "Cannot open $ref_scl_file_temp \n";    # open the scatter loader des file for output
 open(ARMLINK_SCATTERLOADER,">>$ref_scl_file_temp");	     # open the scatter loader des file for APPEND
       
    # Read the progressive_boot_template.scl and form the asic_progressive_boot.scl
    while (<REFERENCEFILE>)
    {
        #Ignore Comments
        if((/^\s*\#/) || (/^\s*\/\*/) || (/^\s*\/\//))
        {
           next;
        }
       #HASH_SEGMENT_NOTPAGED HASH_SEGMENT_ADDRESS HASH_SEGMENT_SIZE
       if(/HASH_SEGMENT_NOTPAGED\s+\S+\s+HASH_SEGMENT_SIZE/)
       {
         $stop_printing = 1;
       }
       #MODEM_CODE_NOTPAGED FIRST_SEGMENT_AFTER_HASH_SEGMENT_ADDRESS
       elsif(/FIRST_SEGMENT_AFTER_HASH_SEGMENT_ADDRESS/)
       {
         $stop_printing = 0;
         $found_print_seg = 1;
       }
       elsif(( $found_print_seg == 1) && (/{/))
       {
         if($print_dummy_exec_regions eq "NOT_PRINTED")
         {
            $print_dummy_exec_regions = "START_PRINTING";
         }
       }

       if(!$stop_printing)
       { 
          if(/FIRST_SEGMENT_AFTER_HASH_SEGMENT_ADDRESS/)
          {
             s/FIRST_SEGMENT_AFTER_HASH_SEGMENT_ADDRESS/\+0x0/;
          }

          print ARMLINK_SCATTERLOADER "$_";

          if($print_dummy_exec_regions eq "START_PRINTING")
          {
             for(my $i=0; $i<10; $i++)
	     {
                print ARMLINK_SCATTERLOADER "   DUMMY_EXEC_RO_$i +0x0 \n";
                print ARMLINK_SCATTERLOADER "   { \n";
                print ARMLINK_SCATTERLOADER "     .ANY (+RO) \n";
                print ARMLINK_SCATTERLOADER "   } \n\n";
             }
             for(my $i=0; $i<10; $i++)
	     {
                print ARMLINK_SCATTERLOADER "   DUMMY_EXEC_RW_$i +0x0 \n";
                print ARMLINK_SCATTERLOADER "   { \n";
                print ARMLINK_SCATTERLOADER "     .ANY (+RW) \n";
                print ARMLINK_SCATTERLOADER "   } \n\n";
             }

             $print_dummy_exec_regions = "PRINTED";
          }
       }

    }

  close(REFERENCEFILE);
  close(ARMLINK_SCATTERLOADER);
       
 } 

#---------------------------------------------------------------------------------
#  SUBROUTINE: replaceHashSegParam
#  
#  Replaces the Variables HASH_SEGMENT_ADDRESS, HASH_SEGMENT_SIZE,FIRST_SEGMENT_AFTER_HASH_SEGMENT_ADDRESS
#  In the SCL file
#---------------------------------------------------------------------------------

sub replaceHashSegParam {

my $num_load_region = 0;
my $second_load_region_start_addr = 0;
my $hash_tbl_size_hex = 0;
my $second_Load_region_shift_address = 0;
my $second_Load_region_shift_address_hex = 0; 
my $hash_Load_region_fixed_address = 0;  #For Rex Builds
my $hash_Load_region_fixed_address_hex = 0;
my $hash_table_address = 0;
my $hash_table_address_hex = 0;

    #Get the address of the second Load Region
    open(MAPFILE,"$pboot_sizes") || die "Cannot open file $pboot_sizes\n";
    while(<MAPFILE>)
    {
      #Load Region MSM_NOTPAGED (Base: 0x001a0000, Size: 0x00003000, Max: 0xffffffff, ABSOLUTE)
      if(/Load\s+Region\s+(\S+)\s+\(Base:\s+0x(\S+)\,/)
      {
        $num_load_region++;
        if($num_load_region == 2)
        {
          $second_load_region_start_addr = $2;
          last;
        }
      }

    }

   


 open(SCATTERLOADER,$scl_des_file) || die "Cannot open $ref_scl_file\n";
 open(SCATTERLOADER_FINAL,">$scl_final") || die "Cannot open $scl_final \n";    # open the scatter loader des file for output
 open(SCATTERLOADER_FINAL,">>$scl_final");	     # open the scatter loader des file for APPEND

  while (<SCATTERLOADER>)
  {
        #Ignore Comments
        if((/^\s*\#/) || (/^\s*\/\*/) || (/^\s*\/\//))
        {
           #print SCATTERLOADER_FINAL "$_";
           next;
        }
        #HASH_SEGMENT_NOTPAGED HASH_SEGMENT_ADDRESS HASH_SEGMENT_SIZE
        elsif(/HASH_SEGMENT_NOTPAGED\s+(\S+)\s+HASH_SEGMENT_SIZE/)
        {
           if($1 =~ /HASH_SEGMENT_ADDRESS/)
           {
            
               $hash_table_address = (hex($second_load_region_start_addr) + $BUFFER_FIRST_SEGMENT_AND_HASH_SEGMENT);
               $hash_table_address_hex = sprintf("%x", $hash_table_address);
               
               $second_Load_region_shift_address = ($hash_table_address + $hash_tbl_size);
               $second_Load_region_shift_address_hex = sprintf("%x", $second_Load_region_shift_address);

               s/HASH_SEGMENT_ADDRESS/0x$hash_table_address_hex/;
           }
           else
           {
              $hash_Load_region_fixed_address_hex = $1;
              $hash_Load_region_fixed_address = $hash_Load_region_fixed_address_hex;
              $hash_Load_region_fixed_address =~ s/0x//;
              $hash_Load_region_fixed_address = hex($hash_Load_region_fixed_address);

              $second_Load_region_shift_address = ($hash_Load_region_fixed_address + $hash_tbl_size);
              $second_Load_region_shift_address_hex = sprintf("%x", $second_Load_region_shift_address);

           }

           #Replace the Hash Table Size
           $hash_tbl_size_hex = sprintf("%x", $hash_tbl_size);
           s/HASH_SEGMENT_SIZE/0x$hash_tbl_size_hex/;

        }
        #MODEM_CODE_NOTPAGED FIRST_SEGMENT_AFTER_HASH_SEGMENT_ADDRESS
        elsif(/\s+FIRST_SEGMENT_AFTER_HASH_SEGMENT_ADDRESS\s+/)
        {
           s/FIRST_SEGMENT_AFTER_HASH_SEGMENT_ADDRESS/0x$second_Load_region_shift_address_hex/;
        }

        print SCATTERLOADER_FINAL "$_";

  }

 close(SCATTERLOADER);
 close(SCATTERLOADER_FINAL);

}
 
 
################################################
# Main Script Starts Here
################################################
 
    # Local Variables
       
    my $dir = "";
    
    
    #==========================================
    # Process the command line arguments here 
    #==========================================
    &ProcessCommandLine;

  
    $ref_scl_file = $pboot_sclfile_in;
    $scl_final = $pboot_sclfile_out;
    
    # Replace backward by forward slashes for compatability with UNIX
    $arm_home =~ s/\\/\//g;
    $arm_lib = "$arm_home/Lib";

    $pboot_sizes = $build_id."_pboot_objs_libs_section_sizes.txt";
    $pboot_sizes_temp = $build_id."_pboot_objs_libs_section_sizes_temp.txt";
    $pboot_list = $build_id."_pboot_objs_libs_list.txt";
    $pboot_errors = $build_id."_pboot_armlink_RORW_size_cal_errors.txt";  
    $ref_scl_file_temp = $build_id."_scl_armlink_temp.txt";
    $scl_des_file = $build_id."_scl_hash_temp.txt";
    
      
    #================================================================================================
    # Check if the Scatter Loader for Progressive Boot exists, If it already exists dont create it;
    #================================================================================================
    
    
    if (-e $scl_final)
    { 
      print "Scatter Loader file for PROGRESSIVE BOOT exists.. \n";
      exit;
    }

    $now = localtime time;
    print "$0 : Creating Scatter Loader file for PROGRESSIVE BOOT.. $now \n";
    print "This will take approximately 10-15 minutes.. \n";



    #================================================================================================
    # Create the CMD file if it doesnt exist. totally self sufficient script now.
    #================================================================================================
    
     if (!(-e "$build_id\.cmd"))
     { 
         system("build $build_id cmd > /null 2>&1");
         print "ECHO builds $build_id cmd > /null 2>&1\n";
         print "$asic ---- Dragon 4\n";
         &createDryRunTxtFile;
	 system ("rm -f $build_id\.cmd");
         
     }
     else{
        # tkdebug 
	&createDryRunTxtFile;
     }	
   
    #========================================================================
    # Extract Pboot_dirs and Pboot_exclude_dirs from the list files here
    #========================================================================
    open(PBOOTDIRS,"$pboot_dirs_lf") || die "Cannot open file  $pboot_dirs_lf  \n";
    
       while(<PBOOTDIRS>){
      s#\\#\/#g;
      @dirs = split(/\s+/,$_);
    }
    close(PBOOTDIRS);

    open(PBOOTEXCLUDEDIRS,"$pboot_excludedirs_lf") || die "Cannot open file  $pboot_excludedirs_lf  \n";
    while(<PBOOTEXCLUDEDIRS>){
      s#\\#\/#g;
      @exclude_dirs = split(/\s+/,$_);
    }
    close(PBOOTEXCLUDEDIRS);
     
    @exclude_dirs_absolute_paths = @exclude_dirs; 
    #change relative to absolute paths
    foreach $dir(@exclude_dirs_absolute_paths){
        chdir($script_dir);	      # change to script dir
        chdir($dir);
        $dir = cwd;
    }
    chdir($script_dir);	      # change to script dir

    open(PBOOTEXCLUDELIBS,"$pboot_excludelibs_lf") || die "Cannot open file  $pboot_excludelibs_lf  \n";
    while(<PBOOTEXCLUDELIBS>){
      s#\\#\/#g;
      @EXCLUDELIBS = split(/\s+/,$_);
    }
    close(PBOOTEXCLUDELIBS);


    #================================================================================================
    # Create the Scl file that will be passed to the armlink cmd by parsing the Template SCL file
    #================================================================================================
    &createSCL4armlinkcmd;

    #========================================================================================================   
    # Read the make dryrun text file and Get all the Objects and Libraries to include in the Scatter Loader
    #========================================================================================================
    &find_objs_libs;

    #=====================================================================
    # Hardcoded libs and objects that should be excluded from partition 1.
    #=====================================================================
    &exclude_libs;
    

    #==================================================================
    # Parses the template file to get objs and libs
    # This is done to not include them again in the scatter loader file
    #==================================================================
    &create_exclude_objects_libs;
    
    
    #=================================================
    #Filter the objects based on ro and rw sections.
    #=================================================

    &filter_libraries(\%CLIBRARIES);
    &filter_libraries(\%BREWLIBRARIES);
    &filter_libraries(\%OTHER_PRECOMPILED_LIBRARIES);
    &filter_libraries(\%LIBRARIES);
    &filter_objects;
    
    
    #================================================================
    # Parse the Template and create the Scatter Loader file here 
    #================================================================
    &parseTemplate;

    #================================================================
    # Calculates the size of Hash Segment
    #================================================================
    &calHashSegmentSize;

    #================================================================
    # Create the final SCL by replacing the HASH SEGMENT VARIABLES
    #================================================================
    &replaceHashSegParam;

    &delTempFiles;

    $now = localtime time;
    print "$0 : Finished Creating Scatter Loader file for PROGRESSIVE BOOT.. $now \n";
  
  
  exit;


  
  
  
  
 
