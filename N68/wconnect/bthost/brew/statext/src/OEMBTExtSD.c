/*===========================================================================

FILE:      OEMBTExtSD.c

SERVICES:  BlueTooth Service Discovery QCT extension

GENERAL DESCRIPTION: BREW OEM interface to the Bluetooth Service Discovery

PUBLIC CLASSES:  Not Applicable

INITIALIZATION AND SEQUENCING REQUIREMENTS:  N/A

        Copyright © 2004, 2005 QUALCOMM Incorporated.
               All Rights Reserved.
            QUALCOMM Proprietary/GTDR
===========================================================================*/
/*===========================================================================
$Header: //source/qcom/qct/wconnect/bthost/brew/statext/rel/00.00.26/src/OEMBTExtSD.c#1 $
$DateTime: 2009/01/07 18:14:54 $
when      who  what, where, why
--------  ---  ------------------------------------------------------------

08/09/08   ap   Fixed Critical Errs generated by superlint.
07/28/08   sa   Resolved compiler warning because of unused variables.
08/23/07   rs    SDP Shall exit the database population on 
                 BT_SD_MAX_NUM_OF_PROTO_DESC iteration for the protocol des
				 case thereby avoiding a never ending for loop.
===========================================================================*/

#include "OEMFeatures.h"

#if defined(FEATURE_IBT)
#include "bt.h"
#include "btsd.h"
#include "msg.h"

#include "AEEBTExt_priv.h"
#include "OEMBTExtSD.h"

//==========================================================================
//   Macro definitions
//==========================================================================
#define OEMBTExtSD_OP_NONE     0 // no SD operation like browse, search etc
#define OEMBTExtSD_OP_PENDING  1 // operation pending
#define OEMBTExtSD_OP_CANCEL   2 // operation needs to be cancelled

//==========================================================================
//   Type definitions
//==========================================================================

typedef struct OEMBTExtSD_struct
{
  bt_app_id_type      appId;

  // valid from DiscoverDevices to DISCOVERY_COMPLETE
  AEEBTDeviceRecord*  pDevRec;
  uint8               uMaxNumDevRecs;

  // valid from SearchService to SEARCH_RESP
  AEEBTServiceRecord* pSvcRec;

  // valid from BrowseService to BROWSE_RESP
  AEEBTBrowseRecord*  pBrowseRec;
  uint8               uMaxNumSvcRecs;

  // valid from GetDeviceName to NAME_RCVD
  AECHAR*             pDevName;
  uint8               uMaxNameLen;
  AEEBTBDAddr         getNameAddr;

  // valid from ServiceDBEnumInit to the very last ServiceDBEnumNext
  boolean             bIterFirst;

  ACONTEXT*           m_pac;
  IBTExtNotifier*     m_pNotifier;

  struct OEMBTExtSD_struct* pNextSD;  // linked into mgr
} OEMBTExtSDobj_t;

// one of these
typedef struct
{
  OEMBTExtSDobj_t*     pNextSD;    // singly linked list of SDs

  // valid from SearchService to SEARCH_RESP
  boolean       bSearchPending;

  // valid from BrowseService to BROWSE_RESP
  uint32        browseState;
  AEEBTBDAddr   searchAddr;

  // valid for  AddServiceRecord
  boolean             bAddingServiceRecord;
  AEEBTServiceRecord  svcRec;
 
} OEMBTExtSD_Mgr;

//==========================================================================
//   Function prototypes
//==========================================================================

// static helper functions
static int OEMBTExtSD_Brew2CoreServiceAttributeUpdate
(
  const AEEBTServiceAttribute*  pBrewSvcAttr,
  bt_sd_srv_attr_rec_type*      pCoreSvcAttr
);

static int OEMBTExtSD_Brew2CoreServiceAttributeAdd
(
  const AEEBTServiceAttribute*  pBrewSvcAttr,
  bt_sd_srv_rec_type*           pCoreSvcRec
);

static void OEMBTExtSD_GetSearchResult
(
  AEEBTServiceRecord*           pDestRec,
  bt_sd_srv_rec_type*           pSrcRec
);

static void OEMBTExtSD_Brew2CoreUUID128
(
  bt_sd_uuid128_type*           pCoreUUID128,
  const AEEBTUUID128*           pBrewUUID128
);

static void OEMBTExtSD_Core2BrewUUID128
(
  AEEBTUUID128*                 pBrewUUID128,
  const bt_sd_uuid128_type*     pCoreUUID128
);

static void OEMBTExtSD_EventCallback(struct bt_ev_msg_struct* bt_ev_msg_ptr);
static int OEMBTExtSD_CheckCmdStatus( bt_cmd_status_type stat );
static OEMBTExtSDobj_t* OEMBTExtSD_CheckParentPtr( IBTExtSD* pParent );

//==========================================================================
//   Static data
//==========================================================================

static OEMBTExtSD_Mgr   gMgr;               // manager object
static uint16           gDeviceRecordsIdx = 0;
static rex_crit_sect_type  gSdCritSect; 

//==========================================================================
//   Public Funtions
//==========================================================================

/*===========================================================================

Function:  OEMBTExtSD_Init()

Description:
   This is called from AEE when an app tries to create an instance of a
   class ID associated with this module.

Parameters:
   IBTExtSD *pParent: Pointer to the IBTExtSD structure allocated by AEE

Return Value:  AEE_SUCCESS if object created and initialized
               ENOMEMORY if unable to create object
               EFAILED if unable to initialize object

Componts:      None

Side Effects:  Allocates APP memory for an object

===========================================================================*/
int OEMBTExtSD_Init( IBTExtSD* pParent )
{
  OEMBTExtSDobj_t* pMe;
  IShell*          ps = AEE_GetShell();

  if ( pParent == NULL )
  {
    return EBADPARM;
  }

  // allocate pMe
  pMe = MALLOCREC(OEMBTExtSDobj_t);
  if ( pMe == NULL )
  {
    return ENOMEMORY;
  }

  if ( ISHELL_CreateInstance( ps, AEECLSID_BLUETOOTH_NOTIFIER, 
                              (void**) &pMe->m_pNotifier ) != SUCCESS )
  {
    FREE( pMe );
    return EFAILED;
  }

  if ( AEEHandle_To( &gOEMBTExtHandleList, (OEMINSTANCE*)pMe,
                     &(pParent->m_hBT) ) == FALSE )
  {
    FREE( pMe );
    return EFAILED;
  }

  // init BT layer
  pMe->appId = bt_cmd_ec_get_app_id_and_register(OEMBTExtSD_EventCallback);
  if ( pMe->appId == BT_APP_ID_NULL )
  {
    IBTEXTNOTIFIER_Release( pMe->m_pNotifier );
    FREE( pMe );
    return EFAILED;
  }  

  pMe->m_pac   = AEE_GetAppContext();

  // link into mgr
  pMe->pNextSD = gMgr.pNextSD;
  gMgr.pNextSD = pMe;

  return SUCCESS;
}


//==========================================================================
//   IBTExtSD VTABLE (see header files for documentation)
//==========================================================================

// IBase (see AEE.h)
uint32 OEMBTExtSD_Release( IBTExtSD* pParent )
{
  OEMBTExtSDobj_t*  pMe;
  OEMBTExtSDobj_t** ppc;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EFAILED;
  }

  // unlink from mgr
  for (ppc = &gMgr.pNextSD; *ppc != NULL; ppc = &(*ppc)->pNextSD)
  {
    if ((*ppc)->appId == pMe->appId)
    {
      *ppc = pMe->pNextSD;
      pMe->pNextSD = NULL;
      break;
    }
  }

  (void)bt_cmd_ec_free_application_id( pMe->appId );
  pMe->appId = BT_APP_ID_NULL;

  IBTEXTNOTIFIER_Release( pMe->m_pNotifier );
  pMe->m_pNotifier = NULL;
  pMe->m_pac = NULL;

  FREE( pMe );
  (void) AEEHandle_Clear( &gOEMBTExtHandleList, pParent->m_hBT );

  return SUCCESS;
}

// IBTEXTSD_DiscoverDevices (see AEEBTExtSD.h)
int OEMBTExtSD_DiscoverDevices( 
  IBTExtSD*           pParent,
  AEEBTServiceClass   svcCls,
  const AEEBTBDAddr*  pAddr,
  AEEBTDeviceRecord*  pDevRec,
  uint8               uMaxNumRec
)
{
  int                         result;
  bt_cmd_status_type          stat;
  bt_service_class_enum_type  bitmap;
  bt_bd_addr_type             addr;
  OEMBTExtSDobj_t*            pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( (pMe == NULL) || (pDevRec == NULL) ||
       ((svcCls == AEEBT_COD_SC_UNKNOWN) && (pAddr == NULL)) )
  {
    return EBADPARM;
  }

  // pointer validation
  if ( ! AEE_CHECK_PTR( "OEMBTExtSD_DiscoverDevices", pDevRec, 
                        sizeof(AEEBTDeviceRecord), TRUE) )
  {
    return EMEMPTR;
  }

  switch(svcCls)
  {
    case AEEBT_COD_SC_UNKNOWN:
      bitmap = BT_SERVICE_CLASS_UNKNOWN;
      addr = *((bt_bd_addr_type*)pAddr);
      break;
    case AEEBT_COD_SC_LIMITED_DISCOVERABLE_MODE:
      bitmap = BT_SERVICE_CLASS_LIMITED_DISCOVERABLE_MODE;
      break;
    case AEEBT_COD_SC_NETWORKING:
      bitmap = BT_SERVICE_CLASS_NETWORKING;
      break;
    case AEEBT_COD_SC_RENDERING:
      bitmap = BT_SERVICE_CLASS_RENDERING;
      break;
    case AEEBT_COD_SC_CAPTURING:
      bitmap = BT_SERVICE_CLASS_CAPTURING;
      break;
    case AEEBT_COD_SC_OBJECT_TRANSFER:
      bitmap = BT_SERVICE_CLASS_OBJECT_TRANSFER;
      break;
    case AEEBT_COD_SC_AUDIO:
      bitmap = BT_SERVICE_CLASS_AUDIO;
      break;
    case AEEBT_COD_SC_TELEPHONY:
      bitmap = BT_SERVICE_CLASS_TELEPHONY;
      break;
    case AEEBT_COD_SC_INFORMATION:
      bitmap = BT_SERVICE_CLASS_INFORMATION;
      break;
    case AEEBT_COD_SC_ALL:
      bitmap = BT_SERVICE_CLASS_ALL;
      break;
    default:
      return EBADPARM;
  }

  pMe->pDevRec           = pDevRec;
  pMe->uMaxNumDevRecs    = uMaxNumRec;
  stat = bt_cmd_sd_discover_devices( pMe->appId, bitmap, &addr, 
                                     uMaxNumRec );

  if ( (result = OEMBTExtSD_CheckCmdStatus( stat )) != SUCCESS )
  {
    pMe->pDevRec = NULL;
  }
  return result;
}

// IBTEXTSD_StopDeviceDiscovery (see AEEBTExtSD.h)
int OEMBTExtSD_StopDeviceDiscovery( IBTExtSD* pParent )
{
  bt_cmd_status_type stat;
  OEMBTExtSDobj_t*   pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  stat = bt_cmd_sd_stop_device_discovery( pMe->appId );

  return (OEMBTExtSD_CheckCmdStatus( stat ));
}

// IBTEXTSD_SetDiscoverable (see AEEBTExtSD.h)
int OEMBTExtSD_SetDiscoverable( IBTExtSD* pParent, boolean discoverable )
{
  bt_cmd_status_type                   stat;
  bt_sd_service_discoverable_mode_type mode;
  OEMBTExtSDobj_t*                     pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  MSG_FATAL("***zzg OEMBTExtSD_SetDiscoverable discoverable=%d***",  discoverable, 0, 0);

  if ( pMe == NULL )
  {
    MSG_FATAL("***zzg OEMBTExtSD_SetDiscoverable pMe == NULL***",  0, 0, 0);
    return EBADPARM;
  }

  mode = discoverable ? BT_SD_SERVICE_DISCOVERABLE_MODE_GENERAL : 
                        BT_SD_SERVICE_DISCOVERABLE_MODE_NONE;
  stat = bt_cmd_sd_set_service_discoverable_mode( pMe->appId, mode );

  MSG_FATAL("***zzg bt_cmd_sd_set_service_discoverable_mode  stat = %x***",  stat, 0, 0);

  return (OEMBTExtSD_CheckCmdStatus( stat ));
}


// IBTExtSD_GetDeviceName (see AEEBTExtSD.h)
int OEMBTExtSD_GetDeviceName(
  IBTExtSD*           pParent, 
  const AEEBTBDAddr*  pBDAddr,
  AECHAR*             pDevName,
  uint8               uMaxLen
)
{
  int                 result;
  bt_cmd_status_type  stat;
  bt_bd_addr_type     addr;
  OEMBTExtSDobj_t*    pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  // pointer validation
  if ( !AEE_CHECK_PTR( "OEMBTExtSD_GetDeviceName", pBDAddr,
                       sizeof(AEEBTBDAddr), FALSE) )
  {
    return EMEMPTR;
  }
  if ( !AEE_CHECK_PTR( "OEMBTExtSD_GetDeviceName", pDevName,
                       sizeof(AECHAR)*uMaxLen, FALSE) )
  {
    return EMEMPTR;
  }

  addr = *((bt_bd_addr_type*)pBDAddr);
  pMe->getNameAddr  = *pBDAddr;
  pMe->pDevName     = pDevName;
  pMe->uMaxNameLen  = uMaxLen;
  stat = bt_cmd_sd_get_device_name( pMe->appId, &addr );

  if ( (result = OEMBTExtSD_CheckCmdStatus( stat )) != SUCCESS )
  {
    pMe->pDevName = NULL;
  }
  return result;
}


// IBTExtSD_GetDeviceNameCancel (see AEEBTExtSD.h)
int OEMBTExtSD_GetDeviceNameCancel(
  IBTExtSD*           pParent, 
  const AEEBTBDAddr*  pBDAddr
)
{
  bt_cmd_status_type  stat;
  bt_bd_addr_type     addr;
  OEMBTExtSDobj_t*    pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  // pointer validation
  if ( !AEE_CHECK_PTR( "OEMBTExtSD_GetDeviceNameCancel", pBDAddr,
                       sizeof(AEEBTBDAddr), FALSE) )
  {
    return EMEMPTR;
  }

  if ( AEEBT_BD_ADDRS_EQUAL( pBDAddr, &pMe->getNameAddr ) == FALSE )
  {
     return EBADPARM;
  }

  addr = *((bt_bd_addr_type*)pBDAddr);
  
  stat = bt_cmd_sd_get_device_name_cancel( pMe->appId, &addr );

  return OEMBTExtSD_CheckCmdStatus( stat );

}

// IBTEXTSD_BrowseService (see AEEBTExtSD.h)
int OEMBTExtSD_BrowseService( 
  IBTExtSD*           pParent,
  const AEEBTBDAddr*  pBDAddr,
  AEEBTBrowseRecord*  pBrowseRec,
  uint8               uMaxNumRecs
)
{
  int                               result;
  bt_cmd_status_type                stat;
  bt_bd_addr_type                   addr;
  bt_sd_srch_pat_uuid_list_type     uuid_list;
  bt_sd_srch_pat_attr_id_list_type  attr_id_list;
  OEMBTExtSDobj_t*                  pMe;
  
#ifdef IBT_SWDEV_TEST_SD_UUID128
  /* Begin test code for service search using 128-bit UUID */
  bt_sd_uuid128_type    uuid128 = { 0xDB, 0x1D, 0x8F, 0x12,
                                    0x95, 0xF3, 0x40, 0x2C,
                                    0x9B, 0x97, 0xBC, 0x50,
                                    0x4C, 0x9A, 0x55, 0xC4 };
  /* End test code for service search using 128-bit UUID */
#endif /* IBT_SWDEV_TEST_SD_UUID128 */


  pMe = OEMBTExtSD_CheckParentPtr( pParent );
  
  if ( (pMe == NULL) || (pBDAddr == NULL) || (pBrowseRec == NULL ) )
  {
    return EBADPARM;
  }

  // pointer validation
  if ( ! AEE_CHECK_PTR( "OEMBTExtSD_BrowseService", pBrowseRec, 
                        sizeof(AEEBTBrowseRecord), TRUE) )
  {
    return EMEMPTR;
  }
  
  if ( gMgr.bSearchPending ||  (gMgr.browseState != OEMBTExtSD_OP_NONE) )
  {
    return EBADSTATE;
  }

  addr = *((bt_bd_addr_type*)pBDAddr);

  uuid_list.num_uuid128 = 0;
  uuid_list.num_uuid    = 1;
  uuid_list.uuid[0]     = BT_SD_PROTOCOL_L2CAP;

#ifdef IBT_SWDEV_TEST_SD_UUID128
  /* Begin test code for service search using 128-bit UUID */
  uuid_list.num_uuid128 = 1;
  uuid_list.uuid128[0]  = uuid128;
  /* End test code for service search using 128-bit UUID */
#endif /* IBT_SWDEV_TEST_SD_UUID128 */
 
  attr_id_list.num_attr_id          = 3;
  attr_id_list.attr_id[0].is_range  = FALSE;
  attr_id_list.attr_id[0].value     = 
    BT_SD_ATTR_ID_SERVICE_CLASS_ID_LIST;

  attr_id_list.attr_id[1].is_range  = FALSE;
  attr_id_list.attr_id[1].value     = 
    BT_SD_ATTR_ID_PROTOCOL_DESCRIPTOR_LIST;

  attr_id_list.attr_id[2].is_range  = FALSE;
  attr_id_list.attr_id[2].value     = 
    BT_SD_ATTR_ID_SERVICE_NAME;

  gMgr.browseState    = OEMBTExtSD_OP_PENDING;
  gMgr.searchAddr     = *pBDAddr;
  pMe->pBrowseRec     = pBrowseRec;
  pMe->uMaxNumSvcRecs = uMaxNumRecs;
  stat = bt_cmd_sd_search_service( pMe->appId, &addr, &uuid_list, &attr_id_list,
                                   BT_SD_DEFAULT_MAX_ATTR_BYTE_COUNT );

  if ( (result = OEMBTExtSD_CheckCmdStatus( stat )) != SUCCESS )
  {
    gMgr.browseState    = OEMBTExtSD_OP_NONE;
    pMe->pBrowseRec     = NULL;
  }
  return result;

}

// IBTEXTSD_BrowseServiceCancel (see AEEBTExtSD.h)
int OEMBTExtSD_BrowseServiceCancel( 
  IBTExtSD*           pParent,
  const AEEBTBDAddr*  pBDAddr
)
{
  bt_bd_addr_type                   addr;
  OEMBTExtSDobj_t*                  pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( (pMe == NULL) || (pBDAddr == NULL) )
  {
    return EBADPARM;
  }

  rex_enter_crit_sect( &gSdCritSect );

  if ( gMgr.browseState != OEMBTExtSD_OP_PENDING )
  {
    rex_leave_crit_sect( &gSdCritSect );
    return EBADSTATE;
  }

  if ( AEEBT_BD_ADDRS_EQUAL( pBDAddr, &gMgr.searchAddr ) == FALSE )
  {
     rex_leave_crit_sect( &gSdCritSect );
     return EBADPARM;
  }

  gMgr.browseState    = OEMBTExtSD_OP_CANCEL;

  rex_leave_crit_sect( &gSdCritSect );

  addr = *((bt_bd_addr_type*)pBDAddr);

  // since we have already set the state to CANCEL,
  // even if the cmd enqueue fails, we will return success
  // but the event generated would be EVT_CANCELLED.
  bt_cmd_rm_connect_cancel( pMe->appId, &addr);

  return SUCCESS;
}

// IBTEXTSD_SearchService (see AEEBTExtSD.h)
int OEMBTExtSD_SearchService( 
  IBTExtSD*                 pParent, 
  const AEEBTBDAddr*        pBDAddr,
  const AEEBTSearchPattern* pSrchPttrn,
  AEEBTServiceRecord*       pSvcRec,
  uint8                     uMaxNumRecs
)
{
  int                              result;
  bt_cmd_status_type               stat;
  bt_bd_addr_type                  addr;
  uint8                            i;
  bt_sd_srch_pat_uuid_list_type    uuid_list;
  bt_sd_srch_pat_attr_id_list_type attr_id_list;
  OEMBTExtSDobj_t*                 pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );
  
  if ( (pMe == NULL) || (pBDAddr == NULL) || 
       (pSrchPttrn == NULL) || (pSvcRec == NULL ) )
  {
    return EBADPARM;
  }

  // pointer validation
  if ( ! AEE_CHECK_PTR( "OEMBTExtSD_SearchService", pSrchPttrn, 
                        sizeof(AEEBTSearchPattern), FALSE) )
  {
    return EMEMPTR;
  }
  
  if ( ! AEE_CHECK_PTR( "OEMBTExtSD_SearchService", pSvcRec, 
                        sizeof(AEEBTServiceRecord), TRUE) )
  {
    return EMEMPTR;
  }
  
  if ( gMgr.bSearchPending || (gMgr.browseState != OEMBTExtSD_OP_NONE) )
  {
    return EBADSTATE;
  }

  if ( ( pSrchPttrn->uNumUUID128s > AEEBT_SD_MAX_SEARCH_UUID128 ) ||
       ( pSrchPttrn->uNumUUIDs > AEEBT_SD_MAX_SEARCH_UUID ) )
  {
    return EBADPARM;
  }

  addr = *((bt_bd_addr_type*)pBDAddr);

  gMgr.bSearchPending = TRUE;
  gMgr.searchAddr     = *pBDAddr;
  pMe->pSvcRec        = pSvcRec;
  pMe->uMaxNumSvcRecs = uMaxNumRecs;

  uuid_list.num_uuid128 = pSrchPttrn->uNumUUID128s;
  for ( i=0; 
        i<pSrchPttrn->uNumUUID128s && i<BT_SD_MAX_NUM_OF_SRV_SRCH_PAT_UUID128; 
        i++)
  {
    OEMBTExtSD_Brew2CoreUUID128( &uuid_list.uuid128[i],
                                 &pSrchPttrn->aUUID128[i] );
  }

  uuid_list.num_uuid = pSrchPttrn->uNumUUIDs;
  for ( i=0; 
        i<pSrchPttrn->uNumUUIDs && i<BT_SD_MAX_NUM_OF_SRV_SRCH_PAT_UUID; 
        i++)
  {
    uuid_list.uuid[i] = pSrchPttrn->aUUID[i];
  }
  
  attr_id_list.num_attr_id = pSrchPttrn->uNumAttrIDs;
  for ( i=0; 
        i<pSrchPttrn->uNumAttrIDs && i<AEEBT_SD_MAX_SEARCH_ATTR_ID; 
        i++)
  {
    attr_id_list.attr_id[i].is_range = pSrchPttrn->aAttrID[i].bIsRange;
    attr_id_list.attr_id[i].value    = pSrchPttrn->aAttrID[i].uValue;
  }

  stat = bt_cmd_sd_search_service(
    pMe->appId, &addr, &uuid_list, &attr_id_list,
    BT_SD_DEFAULT_MAX_ATTR_BYTE_COUNT );

  if ( (result = OEMBTExtSD_CheckCmdStatus( stat )) != SUCCESS )
  {
    gMgr.bSearchPending = FALSE;
    pMe->pSvcRec        = NULL;
  }
  return result;
}

// IBTEXTSD_RegisterService (see AEEBTExtSD.h)
int OEMBTExtSD_RegisterService(
  IBTExtSD* pParent, 
  uint16 uuid, 
  uint16 version, 
  uint8 scn, 
  const AECHAR* pwSvcName
)
{
  bt_cmd_status_type stat;
  char               svcName[ BT_SD_MAX_SERVICE_NAME_LEN + 1 ];
  OEMBTExtSDobj_t*   pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );
  
  if ( (pMe == NULL) || (pwSvcName == NULL) )
  {
    return EBADPARM;
  }

  AEEBT_FROM_WSTR( pwSvcName, svcName, sizeof( svcName ) );

  stat = bt_cmd_sd_register_service(pMe->appId, uuid, version, scn, svcName );

  return (OEMBTExtSD_CheckCmdStatus( stat ));
}


// IBTEXTSD_RegisterCustomService (see AEEBTExtSD.h)
int OEMBTExtSD_RegisterCustomService(
  IBTExtSD*            pParent, 
  const AEEBTUuidList* pCustomSvc,
  uint16               version, 
  uint8                scn, 
  uint16               psm,
  const AECHAR*        pwSvcName
)
{
  bt_cmd_status_type    stat;
  bt_sd_uuid_list_type  uuid_list;
  char                  svcName[ BT_SD_MAX_SERVICE_NAME_LEN + 1 ];
  uint8                 i, j;
  OEMBTExtSDobj_t*      pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );
  
  if ( (pMe == NULL) || (pwSvcName == NULL) ||
       (pCustomSvc->uNumUUID128s > BT_SD_MAX_NUM_OF_UUID128) ||
       (pCustomSvc->uNumUUIDs > BT_SD_MAX_NUM_OF_UUID) )
  {
    return EBADPARM;
  }

  uuid_list.num_uuid128 = pCustomSvc->uNumUUID128s;
  for ( i = 0; i < pCustomSvc->uNumUUID128s; i++ )
  {
    for ( j = 0; j < 16; j++ )
    {
      uuid_list.uuid128[i].uuid_byte[j] = pCustomSvc->aUUID128[i].aUUIDByte[j];
    }
  }

  uuid_list.num_uuid = pCustomSvc->uNumUUIDs;
  for ( i = 0; i < pCustomSvc->uNumUUIDs; i++ )
  {
    uuid_list.uuid[i] = pCustomSvc->aUUID[i];
  }

  AEEBT_FROM_WSTR( pwSvcName, svcName, sizeof( svcName ) );

  stat = bt_cmd_sd_register_custom_service(
           pMe->appId, &uuid_list, version, scn, psm, svcName );

  return (OEMBTExtSD_CheckCmdStatus( stat ));
}


// IBTEXTSD_UnregisterService (see AEEBTExtSD.h)
int OEMBTExtSD_UnregisterService(
  IBTExtSD* pParent, 
  uint16 uuid
)
{
  bt_cmd_status_type stat;
  OEMBTExtSDobj_t*   pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );
  
  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  stat = bt_cmd_sd_unregister_service(pMe->appId, uuid );

  return (OEMBTExtSD_CheckCmdStatus( stat ));
}


// IBTEXTSD_UnregisterCustomService (see AEEBTExtSD.h)
int OEMBTExtSD_UnregisterCustomService(
  IBTExtSD* pParent, 
  const AEEBTUUID128* pCustomUUID
)
{
  bt_sd_uuid128_type uuid128;
  bt_cmd_status_type stat;
  OEMBTExtSDobj_t*   pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );
  
  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  OEMBTExtSD_Brew2CoreUUID128( &uuid128, pCustomUUID );
  stat = bt_cmd_sd_unregister_custom_service( pMe->appId, &uuid128 );

  return (OEMBTExtSD_CheckCmdStatus( stat ));
}


// IBTEXTSD_SetLimitedDiscoverable (see AEEBTExtSD.h)
int OEMBTExtSD_SetLimitedDiscoverable( IBTExtSD* pParent, AEEBTLIAC uLIAC )
{
  bt_cmd_status_type                    stat;
  bt_sd_service_discoverable_mode_type  mode;
  OEMBTExtSDobj_t                       *pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  switch( uLIAC )
  {
    case AEEBT_LIAC_0:
      mode = BT_SD_SERVICE_DISCOVERABLE_MODE_LIMITED;
      break;

    /* Add to this switch as other reserved LIACs get defined by the SIG */

    default:
      mode = BT_SD_SERVICE_DISCOVERABLE_MODE_LIMITED;
      break;
  }

  stat = bt_cmd_sd_set_service_discoverable_mode( pMe->appId, mode );

  switch (stat)
  {
    case BT_CS_GN_SUCCESS:
    case BT_CS_GN_PENDING:
      return SUCCESS;
    case BT_CS_GN_CMD_Q_FULL:
      return ENOMEMORY;
    default:
      return EFAILED;
  }
}


// IBTEXTSD_GetDiscoverableMode (see AEEBTExtSD.h)
int OEMBTExtSD_GetDiscoverableMode( IBTExtSD* pParent )
{
  bt_cmd_status_type  stat;
  OEMBTExtSDobj_t     *pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  stat = bt_cmd_sd_get_discoverable_mode( pMe->appId );

  switch (stat)
  {
    case BT_CS_GN_SUCCESS:
    case BT_CS_GN_PENDING:
      return SUCCESS;
    case BT_CS_GN_CMD_Q_FULL:
      return ENOMEMORY;
    default:
      return EFAILED;
  }
}


// IBTEXTSD_AddServiceRecord (see AEEBTExtSD.h)
int OEMBTExtSD_AddServiceRecord(
  IBTExtSD*                  pParent, 
  uint16                     uuid,
  const AEEBTServiceRecord*  pSvcRec
)
{
  OEMBTExtSDobj_t*      pMe;
  bt_cmd_status_type    stat;
  bt_sd_uuid_list_type  uuid_list;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( ( pMe == NULL ) || ( pSvcRec == NULL ) )
  {
    return EBADPARM;
  }

  gMgr.bAddingServiceRecord = TRUE; 
  gMgr.svcRec = *pSvcRec;    /* Save the service record */ 
  gMgr.svcRec.uUUID = uuid;  /* Save the UUID */

  if ( pSvcRec->bCustomSvc == FALSE )
  {
    stat = bt_cmd_sd_register_service( pMe->appId, uuid, 0x0, 0x0, "" );
  }
  else
  {
    uuid_list.num_uuid128 = 1;
    uuid_list.num_uuid = 0;

    OEMBTExtSD_Brew2CoreUUID128(
      &( uuid_list.uuid128[0] ),
      &( pSvcRec->uUUID128 ) );

    stat = bt_cmd_sd_register_custom_service(
             pMe->appId, &uuid_list, 0x0, 0x0, 0x0, "" );
  }

  switch( stat )
  {
    case BT_CS_GN_SUCCESS:
    case BT_CS_GN_PENDING:
      return SUCCESS;
    case BT_CS_GN_CMD_Q_FULL:
      gMgr.bAddingServiceRecord = FALSE; 
      return ENOMEMORY;
    default:
      gMgr.bAddingServiceRecord = FALSE; 
      return EFAILED;
  }
}


// IBTEXTSD_AddServiceAttribute (see AEEBTExtSD.h)
int OEMBTExtSD_AddServiceAttribute(
  IBTExtSD*                     pParent,
  uint32                        uSvcRecHandle,
  const AEEBTServiceAttribute*  pSvcAttr
)
{
  int                       status = SUCCESS;
  OEMBTExtSDobj_t*          pMe;
  bt_sd_srv_rec_type*       pCoreSvcRec;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  if ( ( pCoreSvcRec =
           bt_sd_find_service_record_by_handle( uSvcRecHandle ) ) != 0 )
  {
    status = OEMBTExtSD_Brew2CoreServiceAttributeAdd( pSvcAttr, pCoreSvcRec );
  }
  else
  {
    return AEEBT_ENOREC;
  }
  
  return status;
}


// IBTEXTSD_UpdateServiceRecord (see AEEBTExtSD.h)
int OEMBTExtSD_UpdateServiceAttribute(
  IBTExtSD*                     pParent,
  uint32                        uSvcRecHandle,
  const AEEBTServiceAttribute*  pSvcAttr
)
{
  int                       status = SUCCESS;
  OEMBTExtSDobj_t*          pMe;
  bt_sd_srv_rec_type*       pCoreSvcRec;
  bt_sd_srv_attr_rec_type*  pCoreSvcAttr;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  if ( ( pCoreSvcRec =
           bt_sd_find_service_record_by_handle( uSvcRecHandle ) ) != 0 )
  {
    if ( ( pCoreSvcAttr = bt_sd_find_service_attribute(
                            pCoreSvcRec,
                            pSvcAttr->uAttrID ) ) != 0 )
    {
      if ( bt_sd_service_record_init_attribute(
             pCoreSvcAttr,
             pCoreSvcAttr->attr_id,
             pCoreSvcAttr->attr_type ) != FALSE )
      {
        status = OEMBTExtSD_Brew2CoreServiceAttributeUpdate(
                   pSvcAttr, pCoreSvcAttr );
      }
      else
      {
        status = EBADPARM;
      }
    }
    else
    {
      status = AEEBT_ENOATTR;
    }
  }
  else
  {
	status = AEEBT_ENOREC;
  }
  
  return status;
}


// IBTEXTSD_ServiceDBEnumInit (see AEEBTExtSD.h)
int OEMBTExtSD_ServiceDBEnumInit(
  IBTExtSD* pParent
)
{
  OEMBTExtSDobj_t*          pMe;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  pMe->bIterFirst = TRUE;

  bt_sd_srv_rec_iter.init( BT_SD_DB_TYPE_LOCAL_DB, BT_SD_ITER_ALL );

  return SUCCESS;
}


// IBTEXTSD_ServiceDBEnumNext (see AEEBTExtSD.h)
int OEMBTExtSD_ServiceDBEnumNext(
  IBTExtSD*            pParent,
  AEEBTServiceRecord*  pSvcRec
)
{
  OEMBTExtSDobj_t*     pMe;
  bt_sd_srv_rec_type*  pCoreSvcRec;

  pMe = OEMBTExtSD_CheckParentPtr( pParent );

  if ( pMe == NULL )
  {
    return EBADPARM;
  }

  if ( pMe->bIterFirst )
  {
    pCoreSvcRec = (bt_sd_srv_rec_type*) bt_sd_srv_rec_iter.first();

    pMe->bIterFirst = FALSE;
  }
  else
  {
    pCoreSvcRec = (bt_sd_srv_rec_type*) bt_sd_srv_rec_iter.next();
  }

  if ( pCoreSvcRec != NULL )
  {
    OEMBTExtSD_GetSearchResult( pSvcRec, pCoreSvcRec );
  }
  else
  {
    return AEEBT_EENDOFREC;
  }

  return SUCCESS;
}


//==========================================================================
//   static helper functions
//==========================================================================


static OEMBTExtSDobj_t* OEMBTExtSD_CheckParentPtr( IBTExtSD* pParent )
{
  OEMBTExtSDobj_t *rv;

  if( AEEHandle_From( &gOEMBTExtHandleList, pParent->m_hBT, (OEMINSTANCE*)&rv ) != TRUE )
  {
    rv = NULL;
  }
  
  return rv;
}

static OEMBTExtSDobj_t* OEMBTExtSD_FindMe(bt_app_id_type appId)
{
  OEMBTExtSDobj_t* pMe;

  for (pMe = gMgr.pNextSD; pMe != NULL; pMe = pMe->pNextSD)
  {
    if (pMe->appId == appId)
    {
      return pMe;
    }
  }
  return NULL;
}

static int OEMBTExtSD_CheckCmdStatus( bt_cmd_status_type stat )
{
  switch (stat)
  {
    case BT_CS_GN_SUCCESS:
    case BT_CS_GN_PENDING:
      return SUCCESS;
    case BT_CS_GN_CMD_Q_FULL:
      return ENOMEMORY;
    default:
      return EFAILED;
  }
}


static void OEMBTExtSD_GetBrowseResult( 
  AEEBTBrowseRecord* pDestRec,
  bt_sd_srv_rec_type* pSrcRec
)
{
  uint8 i;
  for ( i=0; i<pSrcRec->num_srv_attr; i++ )
  {
    switch ( pSrcRec->srv_attr[i].attr_id )
    {
      case BT_SD_ATTR_ID_SERVICE_CLASS_ID_LIST:
      {
        pDestRec->uSvcClsId = bt_sd_extract_srvc_cls( &pSrcRec->srv_attr[i] );
        break;
      }
      case BT_SD_ATTR_ID_PROTOCOL_DESCRIPTOR_LIST:
      {
        pDestRec->uSrvChanNum = bt_sd_extract_scn( &pSrcRec->srv_attr[i] );
        break;
      }
      case BT_SD_ATTR_ID_SERVICE_NAME:
      {
        AEEBT_TO_WSTR( pSrcRec->srv_attr[i].attr_value.str,
                       pDestRec->wSvcName, sizeof( pDestRec->wSvcName ) );
        break;
      }
      default:
      {
        MSG_ERROR( "GetBrowseResult - attrib ID %x\n", 
                   pSrcRec->srv_attr[i].attr_id, 0, 0 );
        break;
      }
    }
  }
}

static void OEMBTExtSD_GetSearchResult(
  AEEBTServiceRecord* pDestRec,
  bt_sd_srv_rec_type* pSrcRec
)
{
  bt_sd_srv_attr_rec_type*  pAttr;
  uint8 i,j,k,l;

  if ( pSrcRec->is_custom_srv )
  {
    pDestRec->bCustomSvc = TRUE;
    OEMBTExtSD_Core2BrewUUID128( &pDestRec->uUUID128, &pSrcRec->srv_uuid128 );
  }
  else
  {
    pDestRec->bCustomSvc = FALSE;
    pDestRec->uUUID = pSrcRec->srv_uuid;
  }
  pDestRec->uNumAttr  = pSrcRec->num_srv_attr;

  bt_sd_srv_attr_iter.init( pSrcRec, BT_SD_ITER_ALL );
  for ( pAttr = (bt_sd_srv_attr_rec_type*) bt_sd_srv_attr_iter.first(), j = 0;
        pAttr != 0 && (j < AEEBT_SD_MAX_SVC_ATTR_ID);
        pAttr = (bt_sd_srv_attr_rec_type*) bt_sd_srv_attr_iter.next(), j++ )
  {
    pDestRec->svcAttr[j].uAttrID  = pAttr->attr_id;
    pDestRec->svcAttr[j].attrType = (AEEBTAttributeType) pAttr->attr_type;

    switch ( pAttr->attr_type )
    {
      case BT_SD_ATTR_TYPE_UUID_LIST:
      {
        pDestRec->svcAttr[j].value.uuidList.uNumUUID128s =
          pAttr->attr_value.uuid_list.num_uuid128;
        for ( k=0; k<pAttr->attr_value.uuid_list.num_uuid128 &&
                   k<AEEBT_SD_MAX_UUID128; k++ )
        {
          OEMBTExtSD_Core2BrewUUID128(
            &pDestRec->svcAttr[j].value.uuidList.aUUID128[ k ],
            &pAttr->attr_value.uuid_list.uuid128[ k ] );
        }
        
        pDestRec->svcAttr[j].value.uuidList.uNumUUIDs =
          pAttr->attr_value.uuid_list.num_uuid;
        for ( k=0; k<pAttr->attr_value.uuid_list.num_uuid &&
                   k<AEEBT_SD_MAX_UUID; k++ )
        {
          pDestRec->svcAttr[j].value.uuidList.aUUID[ k ] = 
            pAttr->attr_value.uuid_list.uuid[ k ];
        }
        break;
      }
      case BT_SD_ATTR_TYPE_PROTO_DESC_LIST:
        pDestRec->svcAttr[j].value.protoDescList.uNumProtoDesc = 
          pAttr->attr_value.proto_desc_list.num_proto_desc;
        for ( k=0; k<pAttr->attr_value.proto_desc_list.num_proto_desc && 
                   k<AEEBT_SD_MAX_PROTO_DESC; k++ )
        {
          AEEBTSDProtoDesc* pProtoDesc = 
            &pDestRec->svcAttr[j].value.protoDescList.aProtoDesc[ k ];
          bt_sd_proto_desc_type *pSrcPD = 
            &pAttr->attr_value.proto_desc_list.proto_desc[ k ];

          if ( pSrcPD->is_uuid128 )
          {
            pProtoDesc->bUUID128 = TRUE;
            OEMBTExtSD_Core2BrewUUID128(
              &pProtoDesc->aUUID128,
              &pSrcPD->uuid128 );
          }
          else
          {
            pProtoDesc->bUUID128 = FALSE;
            pProtoDesc->uUUID    = pSrcPD->uuid;
          }
          pProtoDesc->uNumParam = pSrcPD->num_param;
          memcpy( pProtoDesc->aParam, pSrcPD->param, sizeof( pSrcPD->param ) );
        }
        break;
      case BT_SD_ATTR_TYPE_ADD_PROTO_DESC_LISTS:
        pDestRec->svcAttr[j].value.addlProtoDescLists.uNumProtoDescList = 0;
        for ( k=0; k<BT_SD_MAX_NUM_OF_ADD_PROTO_DESC_LISTS && 
                   k<AEEBT_SD_MAX_PROTO_DESC_LISTS; k++ )
        {
          AEEBTSDProtoDescList* pDestPDL =
            &pDestRec->svcAttr[j].value.addlProtoDescLists.aProtoDescList[ k ];
          bt_sd_proto_desc_list_type* pSrcPDL =
            &pAttr->attr_value.add_proto_desc_lists[ k ];

          pDestRec->svcAttr[j].value.addlProtoDescLists.uNumProtoDescList++;

          pDestPDL->uNumProtoDesc = pSrcPDL->num_proto_desc;
          for ( l = 0; l < pSrcPDL->num_proto_desc &&
                       l < AEEBT_SD_MAX_PROTO_DESC; l++ )
          {
            AEEBTSDProtoDesc* pDestPD = &pDestPDL->aProtoDesc[l];
            bt_sd_proto_desc_type* pSrcPD = &pSrcPDL->proto_desc[l];
            if ( pSrcPD->is_uuid128 )
            {
              pDestPD->bUUID128 = TRUE;
              OEMBTExtSD_Core2BrewUUID128(
                &pDestPD->aUUID128,
                &pSrcPD->uuid128 );
            }
            else
            {
              pDestPD->bUUID128 = FALSE;
              pDestPD->uUUID    = pSrcPD->uuid;
            }
            pDestPD->uNumParam = pSrcPD->num_param;
            memcpy( pDestPD->aParam, pSrcPD->param, sizeof( pSrcPD->param ) );
          }
        }
        break;
      case BT_SD_ATTR_TYPE_LANG_BASE_ATTR_ID_LIST:
        pDestRec->svcAttr[j].value.langBaseAttrIdList =
          *((AEEBTLangBaseAttribIdList*)&pAttr->attr_value.lang_base_attr_id_list);
        break;

      case BT_SD_ATTR_TYPE_UINT_LIST:
        pDestRec->svcAttr[j].value.uintList.uNumVal = 
          MAX( pAttr->attr_value.uint_list.num_val, AEEBT_SD_MAX_UINT );

        for ( i=0; i<pDestRec->svcAttr[j].value.uintList.uNumVal; i++)
        {
          pDestRec->svcAttr[j].value.uintList.uVal[i] =
            pAttr->attr_value.uint_list.val[i];
        }
        break;

      case BT_SD_ATTR_TYPE_STRING:
        AEEBT_TO_WSTR( pAttr->attr_value.str, pDestRec->svcAttr[j].value.wStr,
                       sizeof( pDestRec->svcAttr[j].value.wStr ) );
        break;

      case BT_SD_ATTR_TYPE_UINT8:
      case BT_SD_ATTR_TYPE_UINT16:
      case BT_SD_ATTR_TYPE_UINT32:
      case BT_SD_ATTR_TYPE_UINT64:
        pDestRec->svcAttr[j].value.uPrimitiveValue =
          pAttr->attr_value.primitive_value;
        break;

      case BT_SD_ATTR_TYPE_BOOL:
        pDestRec->svcAttr[j].value.bFlag = pAttr->attr_value.bool_flag;
        break;

      case BT_SD_ATTR_TYPE_HID_DESC_LIST:
        pDestRec->svcAttr[j].value.hidDescList.uNumHIDClassDesc = 
          pAttr->attr_value.hid_desc_list.num_hid_class_desc;
        for ( k=0; k<pAttr->attr_value.hid_desc_list.num_hid_class_desc && 
                   k<AEEBT_SD_MAX_NUM_OF_HID_CLASS_DESC; k++ )
        {
          AEEBTHIDClassDescType* pHIDClassDesc = 
            &pDestRec->svcAttr[j].value.hidDescList.aHIDClassDesc[ k ];
          bt_sd_hid_class_desc_type* pSrcHIDClassDesc = 
            &pAttr->attr_value.hid_desc_list.hid_class_desc[ k ];

          pHIDClassDesc->uVal = pSrcHIDClassDesc->val;
          pHIDClassDesc->uLen = pSrcHIDClassDesc->len;
          memcpy( pHIDClassDesc->str,
                  pSrcHIDClassDesc->str,
                  AEEBT_SD_MAX_HID_CLASS_DESC_STRING_LEN );
        }
        break;

      case BT_SD_ATTR_TYPE_UUID128:
        OEMBTExtSD_Core2BrewUUID128(
          &pDestRec->svcAttr[j].value.uuid128,
          &pAttr->attr_value.uuid128 );
        break;

      default:
        break;
    }
  } /* foreach service attribute */
}

static uint8 OEMBTExtSD_ExtractSvcRecs( 
  OEMBTExtSDobj_t* pMe,
  bt_ev_sd_service_search_resp_type *pEvt )
{
  uint8 numRecs;
  bt_sd_srv_rec_type*       pRec;

  if ( pEvt->srv_rec_count == 0 )
  {
    return 0;
  }

  bt_sd_srv_rec_iter.init( BT_SD_DB_TYPE_SRV_SRCH_RESULT_DB,
                           BT_SD_ITER_ALL );
  for ( pRec = (bt_sd_srv_rec_type*) bt_sd_srv_rec_iter.first(), numRecs = 0;
        pRec != 0 && (numRecs < pMe->uMaxNumSvcRecs);
        pRec = (bt_sd_srv_rec_type*) bt_sd_srv_rec_iter.next(), numRecs++ )
  {
    if ( gMgr.browseState == OEMBTExtSD_OP_PENDING )
    {
      OEMBTExtSD_GetBrowseResult( &(pMe->pBrowseRec[numRecs]), pRec );
    }
    else if ( gMgr.bSearchPending )
    {
      OEMBTExtSD_GetSearchResult( &(pMe->pSvcRec[numRecs]), pRec );
    }
  }
  return (numRecs);
}

static int OEMBTExtSD_Brew2CoreServiceAttributeUpdate(
  const AEEBTServiceAttribute*  pBrewSvcAttr,
  bt_sd_srv_attr_rec_type*      pCoreSvcAttr
)
{
  uint16                        i, j, k;
  const AEEBTSDProtoDesc*      pBrewProtoDesc;
  const AEEBTSDProtoDescList*  pBrewProtoDescList;
  bt_sd_proto_desc_type*       pCoreProtoDesc;
  bt_sd_proto_desc_list_type*  pCoreProtoDescList;
  char                         str[ BT_SD_MAX_TEXT_STRING_LEN + 1 ];
  bt_sd_srv_attr_rec_type      temp_attr;
  bt_sd_srv_attr_enum_type     attr_type = BT_SD_ATTR_TYPE_UNKNOWN;
  bt_sd_uuid_type              uuid16;
  bt_sd_uuid128_type           uuid128;
  bt_sd_uuid128_type*          uuid128_ptr;

  switch( pBrewSvcAttr->attrType )
  {
    case AEEBT_SD_ATTR_TYPE_UUID_LIST:
      for ( j = 0;
            ( j < pBrewSvcAttr->value.uuidList.uNumUUID128s &&
              j < AEEBT_SD_MAX_UUID128 );
            j++ )
      {
        OEMBTExtSD_Brew2CoreUUID128(
          &uuid128,
          &pBrewSvcAttr->value.uuidList.aUUID128[j] );
        bt_sd_service_attribute_set_uuid128( pCoreSvcAttr, &uuid128 );
      }
      for ( j = 0;
            ( j < pBrewSvcAttr->value.uuidList.uNumUUIDs &&
              j < AEEBT_SD_MAX_UUID );
            j++ )
      {
        bt_sd_service_attribute_add_uuid(
          pCoreSvcAttr,
          pBrewSvcAttr->value.uuidList.aUUID[j] );
      }
      break;
    case AEEBT_SD_ATTR_TYPE_PROTO_DESC_LIST:
      for ( j = 0;
            ( j < pBrewSvcAttr->value.protoDescList.uNumProtoDesc &&
              j < AEEBT_SD_MAX_PROTO_DESC );
            j++ )
      {
        pBrewProtoDesc = &pBrewSvcAttr->value.protoDescList.aProtoDesc[j];

        MSG_LOW( "bool bUUID128 is %x",pBrewProtoDesc->bUUID128, 0, 0 );
        if ( pBrewProtoDesc->bUUID128 )
        {
          OEMBTExtSD_Brew2CoreUUID128( &uuid128, &pBrewProtoDesc->aUUID128 );
          uuid128_ptr = &uuid128;
          uuid16 = BT_SD_INVALID_UUID;
        }
        else
        {
          uuid128_ptr = NULL;
          uuid16 = pBrewProtoDesc->uUUID;
        }

        if ( ( pCoreProtoDesc =
                 bt_sd_service_attribute_add_proto_desc(
                   pCoreSvcAttr, uuid16, uuid128_ptr ) ) != 0 )
        {

          if (pBrewProtoDesc->uNumParam > BT_SD_MAX_NUM_OF_PROTO_PARAM) {
            MSG_ERROR("More num of param fed, %x, than the DB can hold",
                      pBrewProtoDesc->uNumParam,0,0);
          }

          // The loop runs till the Maximum number of Protocol descriptor  
          // parameter can be stored in the database 
          for ( k = 0; ((k < pBrewProtoDesc->uNumParam) && 
                        (k < BT_SD_MAX_NUM_OF_PROTO_PARAM)); k++)
          {
            bt_sd_service_attribute_proto_desc_add_param( 
              pCoreProtoDesc,
              pBrewProtoDesc->aParam[k].uValue,
              pBrewProtoDesc->aParam[k].uSize );
          }
        }
      }
      break;
    case AEEBT_SD_ATTR_TYPE_ADDL_PROTO_DESC_LISTS:
    {
      for ( i = 0;
            ( i < pBrewSvcAttr->value.addlProtoDescLists.uNumProtoDescList &&
              i < AEEBT_SD_MAX_PROTO_DESC_LISTS );
            i++ )
      {
        pBrewProtoDescList =
          &pBrewSvcAttr->value.addlProtoDescLists.aProtoDescList[i];
        pCoreProtoDescList =
          &pCoreSvcAttr->attr_value.add_proto_desc_lists[i];

        /* Initialize the temporary service attribute as a proto desc list */
        bt_sd_service_record_init_attribute(
          &temp_attr,
          BT_SD_ATTR_ID_PROTOCOL_DESCRIPTOR_LIST,
          BT_SD_ATTR_TYPE_PROTO_DESC_LIST );

        for ( j = 0;
              ( j < pBrewProtoDescList->uNumProtoDesc &&
                j < AEEBT_SD_MAX_PROTO_DESC );
              j++ )
        {
          pBrewProtoDesc = &pBrewProtoDescList->aProtoDesc[j];
          if ( pBrewProtoDesc->bUUID128 )
          {
            OEMBTExtSD_Brew2CoreUUID128( &uuid128, &pBrewProtoDesc->aUUID128 );
            uuid128_ptr = &uuid128;
            uuid16 = BT_SD_INVALID_UUID;
          }
          else
          {
            uuid128_ptr = NULL;
            uuid16 = pBrewProtoDesc->uUUID;
          }

          if ( ( pCoreProtoDesc =
                   bt_sd_service_attribute_add_proto_desc(
                     &temp_attr, uuid16, uuid128_ptr ) ) != 0 )
          {
            for ( k = 0; k < pBrewProtoDesc->uNumParam; k++)
            {
              bt_sd_service_attribute_proto_desc_add_param(
                pCoreProtoDesc,
                pBrewProtoDesc->aParam[k].uValue,
                pBrewProtoDesc->aParam[k].uSize );
            }
          }
        }

        /* copy temp_attr to the actual attribute */
        memcpy( (void*) pCoreProtoDescList,
                (void*)(&temp_attr.attr_value.proto_desc_list),
                sizeof( bt_sd_proto_desc_list_type ) );
        pCoreProtoDescList->header.attr_value_len +=
          temp_attr.header.attr_value_len;
        pCoreSvcAttr->header.attr_value_len += 2 +
          temp_attr.header.attr_value_len;
      }
      break;
    }
    case AEEBT_SD_ATTR_TYPE_LANG_BASE_ATTR_ID_LIST:
      for ( j = 0;
            ( j < pBrewSvcAttr->value.langBaseAttrIdList.uNumLangBase &&
              j < AEEBT_SD_MAX_LANG_BASE_REC );
            j++ )
      {
        bt_sd_service_attribute_add_lang_base_attr_id(
          pCoreSvcAttr,
          pBrewSvcAttr->value.langBaseAttrIdList.aLangBase[j].uLangId,
          pBrewSvcAttr->value.langBaseAttrIdList.aLangBase[j].uCharEncId,
          pBrewSvcAttr->value.langBaseAttrIdList.aLangBase[j].uBaseAttrId );
      }
      break;
    case AEEBT_SD_ATTR_TYPE_UINT_LIST:
      for ( j = 0;
            ( j < pBrewSvcAttr->value.uintList.uNumVal &&
              j < AEEBT_SD_MAX_UINT );
            j++ )
      {
        bt_sd_service_attribute_uint_list_add_val(
          pCoreSvcAttr,
          sizeof( uint64 ), /* RYUEN: Fixme */
          pBrewSvcAttr->value.uintList.uVal[j] );
      }
      break;
    case AEEBT_SD_ATTR_TYPE_STRING:
      WSTRTOSTR( pBrewSvcAttr->value.wStr, str, BT_SD_MAX_TEXT_STRING_LEN );

      bt_sd_service_attribute_set_str( pCoreSvcAttr, str );
      break;
      
    case AEEBT_SD_ATTR_TYPE_UINT8:
      attr_type = BT_SD_ATTR_TYPE_UINT8;
    case AEEBT_SD_ATTR_TYPE_UINT16:
      if ( attr_type == BT_SD_ATTR_TYPE_UNKNOWN )
      {
        attr_type = BT_SD_ATTR_TYPE_UINT16;
      }
    case AEEBT_SD_ATTR_TYPE_UINT32:
      if ( attr_type == BT_SD_ATTR_TYPE_UNKNOWN )
      {
        attr_type = BT_SD_ATTR_TYPE_UINT32;
      }
    case AEEBT_SD_ATTR_TYPE_UINT64:
      if ( attr_type == BT_SD_ATTR_TYPE_UNKNOWN )
      {
        attr_type = BT_SD_ATTR_TYPE_UINT64;
      }
      bt_sd_service_attribute_set_value(
        pCoreSvcAttr,
        pBrewSvcAttr->value.uPrimitiveValue
      );
      break;
    case AEEBT_SD_ATTR_TYPE_BOOL:
      bt_sd_service_attribute_set_bool(
        pCoreSvcAttr,
        pBrewSvcAttr->value.bFlag
      );
      break;
    case AEEBT_SD_ATTR_TYPE_HID_DESC_LIST:
      for ( i = 0;
            ( i < pBrewSvcAttr->value.hidDescList.uNumHIDClassDesc &&
              i < BT_SD_MAX_NUM_OF_HID_CLASS_DESC );
            i++ )
      {
        const AEEBTHIDClassDescType*  pBrewHIDClassDesc =
          &pBrewSvcAttr->value.hidDescList.aHIDClassDesc[i];

        bt_sd_service_attribute_add_hid_class_desc(
          pCoreSvcAttr,
          pBrewHIDClassDesc->uVal,
          pBrewHIDClassDesc->uLen,
          pBrewHIDClassDesc->str );
      }
      break;
    case AEEBT_SD_ATTR_TYPE_UUID128:
      OEMBTExtSD_Brew2CoreUUID128(
        &uuid128,
        &pBrewSvcAttr->value.uuid128 );
      bt_sd_service_attribute_set_uuid128( pCoreSvcAttr, &uuid128 );
      break;
    /* RYUEN: Fixme
    BT_SD_ATTR_TYPE_UUID:
    BT_SD_ATTR_TYPE_UINT128: */
  }

  return SUCCESS;
}


static int OEMBTExtSD_Brew2CoreServiceAttributeAdd(
  const AEEBTServiceAttribute*  pBrewSvcAttr,
  bt_sd_srv_rec_type*           pCoreSvcRec
)
{
  bt_sd_srv_attr_rec_type*  pCoreSvcAttr = 0;
  bt_sd_srv_attr_enum_type  attr_type = BT_SD_ATTR_TYPE_UNKNOWN;
  
  switch( pBrewSvcAttr->attrType )
  {
    case AEEBT_SD_ATTR_TYPE_UUID_LIST:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_UUID_LIST );
      break;
    case AEEBT_SD_ATTR_TYPE_PROTO_DESC_LIST:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_PROTO_DESC_LIST );
      break;
    case AEEBT_SD_ATTR_TYPE_ADDL_PROTO_DESC_LISTS:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_ADD_PROTO_DESC_LISTS );
      break;
    case AEEBT_SD_ATTR_TYPE_LANG_BASE_ATTR_ID_LIST:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_LANG_BASE_ATTR_ID_LIST );
      break;
    case AEEBT_SD_ATTR_TYPE_UINT_LIST:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_UINT_LIST );
      break;
    case AEEBT_SD_ATTR_TYPE_STRING:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_STRING );
      break;
    
    case AEEBT_SD_ATTR_TYPE_UINT8:
      attr_type = BT_SD_ATTR_TYPE_UINT8;
    case AEEBT_SD_ATTR_TYPE_UINT16:
      if ( attr_type == BT_SD_ATTR_TYPE_UNKNOWN )
      {
        attr_type = BT_SD_ATTR_TYPE_UINT16;
      }
    case AEEBT_SD_ATTR_TYPE_UINT32:
      if ( attr_type == BT_SD_ATTR_TYPE_UNKNOWN )
      {
        attr_type = BT_SD_ATTR_TYPE_UINT32;
      }
    case AEEBT_SD_ATTR_TYPE_UINT64:
      if ( attr_type == BT_SD_ATTR_TYPE_UNKNOWN )
      {
        attr_type = BT_SD_ATTR_TYPE_UINT64;
      }
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       attr_type );
      break;
    case AEEBT_SD_ATTR_TYPE_BOOL:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_BOOL );
      break;
    case AEEBT_SD_ATTR_TYPE_HID_DESC_LIST:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_HID_DESC_LIST );
      break;
    case BT_SD_ATTR_TYPE_UUID128:
      pCoreSvcAttr = bt_sd_service_record_add_attribute(
                       pCoreSvcRec,
                       pBrewSvcAttr->uAttrID,
                       BT_SD_ATTR_TYPE_UUID128 );
      break;
    /* RYUEN: Fixme
    BT_SD_ATTR_TYPE_UUID:
    BT_SD_ATTR_TYPE_ADD_PROTO_DESC_LISTS:
    BT_SD_ATTR_TYPE_UINT128: */
  }
  
  if ( pCoreSvcAttr != 0 )
  {
    OEMBTExtSD_Brew2CoreServiceAttributeUpdate( pBrewSvcAttr, pCoreSvcAttr );
  }
  else
  {
	return AEEBT_ERECFULL;
  }

  return SUCCESS;
}

static void OEMBTExtSD_FinishServiceRecordAdd( AEEBTNotification* pN )
{
  bt_sd_srv_rec_type*       pCoreSvcRec;
  bt_sd_srv_attr_rec_type*  pCoreSvcAttr;
  bt_sd_uuid128_type        uuid128;
  int                       i;

  pN->uID = AEEBT_SD_EVT_SERVICE_RECORD_ADDED;

  if ( gMgr.svcRec.bCustomSvc == FALSE )
  {
    pCoreSvcRec = bt_sd_find_service_record_by_uuid(
                    BT_SD_DB_TYPE_LOCAL_DB,
                    gMgr.svcRec.uUUID,
                    BT_RC_SCN_NOT_SPECIFIED,
                    BT_L2_PSM_INVALID );
  }
  else
  {
    OEMBTExtSD_Brew2CoreUUID128( &uuid128, &( gMgr.svcRec.uUUID128 ) );

    pCoreSvcRec = bt_sd_find_service_record_by_uuid128(
                    BT_SD_DB_TYPE_LOCAL_DB,
                    &uuid128,
                    BT_RC_SCN_NOT_SPECIFIED,
                    BT_L2_PSM_INVALID );
  }

  if ( pCoreSvcRec != NULL )
  {
    for ( i = 0; i < gMgr.svcRec.uNumAttr; i++ )
    {
      if ( ( pCoreSvcAttr =
               bt_sd_find_service_attribute(
                 pCoreSvcRec,
                 gMgr.svcRec.svcAttr[i].uAttrID ) ) == 0 )
      {
        OEMBTExtSD_Brew2CoreServiceAttributeAdd(
          &( gMgr.svcRec.svcAttr[i] ),
          pCoreSvcRec );
      }
      else
      {
        /* Prep the service attribute for update */
        (void) bt_sd_service_record_init_attribute(
                 pCoreSvcAttr,
                 pCoreSvcAttr->attr_id,
                 pCoreSvcAttr->attr_type );

        OEMBTExtSD_Brew2CoreServiceAttributeUpdate(
          &( gMgr.svcRec.svcAttr[i] ),
          pCoreSvcAttr );
      }
    }

    pN->data.uSvcRecHandle = pCoreSvcRec->srv_rec_id;
  }
  else /* UUID not found - service registration must have failed */
  {
    pN->data.uSvcRecHandle = 0xFFFFFFFF;
  }
}

static void OEMBTExtSD_Brew2CoreUUID128
(
  bt_sd_uuid128_type*           pCoreUUID128,
  const AEEBTUUID128*           pBrewUUID128
)
{
  int  i;

  for ( i = 0; i < 16; i++ )
  {
    pCoreUUID128->uuid_byte[i] = pBrewUUID128->aUUIDByte[i];
  }
}

static void OEMBTExtSD_Core2BrewUUID128
(
  AEEBTUUID128*                 pBrewUUID128,
  const bt_sd_uuid128_type*     pCoreUUID128
)
{
  int  i;

  for ( i = 0; i < 16; i++ )
  {
    pBrewUUID128->aUUIDByte[i] = pCoreUUID128->uuid_byte[i];
  }
}

// called from BT task context; so just queue the event
static void OEMBTExtSD_EventCallback(bt_ev_msg_type* bt_ev_msg_ptr)
{
  OEMBTExtSDobj_t*    pMe  = OEMBTExtSD_FindMe(bt_ev_msg_ptr->ev_hdr.bt_app_id);
  AEEBTNotification*  pN   = NULL;
  AEEBTDeviceRecord*  pRec = NULL;

  if ( pMe == NULL )
  {
    return; // probably for an app that no longer exists
  }

  pN = IBTEXTNOTIFIER_GetFreeNotification( pMe->m_pNotifier );
  if( pN == NULL )
  {
    MSG_ERROR( "SDEvCb - Can't get free not.",
               0, 0, 0 );
    return;
  }

  pN->data.uError  = AEEBT_SD_ERR_NONE;

  switch (bt_ev_msg_ptr->ev_hdr.ev_type)
  {
    case BT_EV_GN_CMD_DONE:
    {
      bt_ev_gn_cmd_done_type* pm = 
        (bt_ev_gn_cmd_done_type*)&bt_ev_msg_ptr->ev_msg;

      switch ( pm->cmd_type )
      {
        case BT_CMD_SD_DISCOVER_DEVICES:
        {
          pN->uID = AEEBT_SD_EVT_DEVICE_DISCOVERY_STARTED;
          if ( pm->cmd_status == BT_CS_GN_SUCCESS )
          {
            gDeviceRecordsIdx = 0;
          }
          else
          {
            pN->data.uError = AEEBT_SD_ERR_DEVICE_DISCOVERY_ALREADY_IN_PROGRESS;
          }
          break;
        }

        case BT_CMD_SD_STOP_DEVICE_DISCOVERY:
        {
          // just in case DEVICE_DISCOVERY_COMPLETE does not happen

          pN->uID = AEEBT_SD_EVT_DEVICE_DISCOVERY_STOPPED;
          if ( pm->cmd_status != BT_CS_GN_SUCCESS )
          {
            pN->data.uError = AEEBT_SD_ERR_DEVICE_DISCOVERY_NOT_IN_PROGRESS;
          }
          else
          {
            pMe->pDevRec = NULL;
          }
          break;
        }

        case BT_CMD_SD_SET_SERVICE_DISCOVERABLE_MODE:
        {
          // always success, no BT event expected
          pN->uID    = AEEBT_SD_EVT_DISCOVERABLE_MODE_SET;
          break;
        }

        case BT_CMD_SD_GET_DISCOVERABLE_MODE:
        {
          if ( pm->cmd_status == BT_CS_GN_SUCCESS )
          {
            IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
            return;
          }
          pN->uID = AEEBT_SD_EVT_DISCOVERABLE_MODE_RESP;
          pN->data.sDiscoverableModeResp.uError =
                    AEEBT_SD_ERR_GET_DISCOVERABLE_MODE_FAILED;
          break;
        }

        case BT_CMD_SD_SEARCH_SERVICE:
        {
          // always success; wait for BT event SERVICE_SEARCH_RESP
          IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
          return;
        }

        case BT_CMD_SD_GET_DEVICE_NAME:
        {
          if ( pm->cmd_status == BT_CS_GN_SUCCESS )
          {
            IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
            return;
          }
          pN->uID         = AEEBT_SD_EVT_DEVICE_NAME_RESP;
          pN->data.uError = AEEBT_SD_ERR_GET_DEVICE_NAME_FAILED;
          break;
        }
        case BT_CMD_SD_GET_DEVICE_NAME_CANCEL:
        {
          MSG_LOW( "SDEvCb Cmd Done dev name cancel cmd stat %x", pm->cmd_status,0, 0 );
          // this event dosent have to be sent to the app
          IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
          return;
        }
        case BT_CMD_SD_REGISTER_SERVICE:
        case BT_CMD_SD_REGISTER_CUSTOM_SERVICE:
        {
          if ( gMgr.bAddingServiceRecord )
          {
            if ( pm->cmd_status == BT_CS_GN_SUCCESS )
            {
              OEMBTExtSD_FinishServiceRecordAdd( pN );
            }
            else
            {
              pN->uID         = AEEBT_SD_EVT_SERVICE_RECORD_ADDED;
              /* Return the error, service registration failed */
              pN->data.uSvcRecHandle = 0xFFFFFFFF;
            }

            gMgr.bAddingServiceRecord = FALSE;
          }
          else
          {
            // no BT event expected
            pN->uID    = AEEBT_SD_EVT_SERVICE_REGISTERED;
            if ( pm->cmd_status != BT_CS_GN_SUCCESS )
            {
              pN->data.uError = AEEBT_SD_ERR_SERVICE_DB_FULL;
            }
          }
          break;
        }

        case BT_CMD_SD_UNREGISTER_SERVICE:
        case BT_CMD_SD_UNREGISTER_CUSTOM_SERVICE:
        {
          // no BT event expected
          pN->uID = AEEBT_SD_EVT_SERVICE_UNREGISTERED;
          if ( pm->cmd_status != BT_CS_GN_SUCCESS )
          {
            pN->data.uError = AEEBT_SD_ERR_SERVICE_RECORD_NOT_FOUND;
          }
          break;
        }
        case BT_CMD_RM_CONNECT_CANCEL:
        {
          MSG_LOW( "SDEvCb SD cmd done rm acl cancel , stat 0x%x", pm->cmd_status, 0, 0 );
          // this event dosent have to be sent to the app
          IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
          return;
        }
        default:
        {
          MSG_ERROR( "SDEvCb - unexpect Cmd Done %x", pm->cmd_type, 0, 0 );
          IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
          return;
        }
      }
      break;
    } // end of case BT_EV_GN_CMD_DONE

    case BT_EV_SD_DEVICE_DISCOVERY_RESP:
    {
      bt_ev_sd_device_discovery_resp_type *pEvt =
        &bt_ev_msg_ptr->ev_msg.ev_sd_dev_discv_resp;

      if ( pMe->pDevRec == NULL )
      {
        IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
        return; // ignore left over responses
      }
      pRec = &pMe->pDevRec[ gDeviceRecordsIdx ];

      if ( gDeviceRecordsIdx >= pMe->uMaxNumDevRecs )
      {
        IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
        return;
      }
      gDeviceRecordsIdx++;
      memcpy ( (void*)&pRec->bdAddr, (void*)&pEvt->bd_addr, 
               sizeof(AEEBTBDAddr) );
      pRec->serviceClass  = pEvt->service_class;
      pRec->majorDevClass = pEvt->major_device_class;
      pRec->minorDevClass = pEvt->minor_device_class;

      pN->uID                        = AEEBT_SD_EVT_DEVICE_DISCOVERY_RESP;
      pN->data.uNumDevicesDiscovered = gDeviceRecordsIdx;
      break;
    }

    case BT_EV_SD_DEVICE_DISCOVERY_COMPLETE:
    {
      pMe->pDevRec                   = NULL;
      pN->uID                        = AEEBT_SD_EVT_DEVICE_DISCOVERY_COMPLETE;
      pN->data.sDevDiscComplete.uNumDevicesDiscovered =
        bt_ev_msg_ptr->ev_msg.ev_sd_dev_discv_cmplt.num_discvd_dev;
      if ( bt_ev_msg_ptr->ev_msg.ev_sd_dev_discv_cmplt.reason == 
           BT_EVR_GN_SUCCESS )
      {
        pN->data.sDevDiscComplete.uError = AEEBT_SD_ERR_NONE;
      }
      else
      {
        pN->data.sDevDiscComplete.uError = AEEBT_SD_ERR_DEVICE_DISCOVERY_FAILED;
      }
      break;
    }

    case BT_EV_SD_SERVICE_SEARCH_RESP:
    {
      bt_ev_sd_service_search_resp_type *pEvt =
        &bt_ev_msg_ptr->ev_msg.ev_sd_service_search_resp;

      if ( AEEBT_BD_ADDRS_EQUAL( &pEvt->bd_addr, &gMgr.searchAddr ) )
      {
        pN->data.uNumSvcRecsFound = OEMBTExtSD_ExtractSvcRecs( pMe, pEvt );

        rex_enter_crit_sect( &gSdCritSect );

        if ( gMgr.browseState == OEMBTExtSD_OP_PENDING )
        {
          gMgr.browseState  = OEMBTExtSD_OP_NONE;
          pN->uID = AEEBT_SD_EVT_BROWSE_RESP;
        }
        else if ( gMgr.browseState == OEMBTExtSD_OP_CANCEL )
        {
          gMgr.browseState  = OEMBTExtSD_OP_NONE;
          pN->uID = AEEBT_SD_EVT_BROWSE_SERVICE_CANCELED;
          pN->data.uError  = AEEBT_SD_ERR_NONE;
        }
        else // must be searching
        {
          gMgr.bSearchPending = FALSE;
          pN->uID = AEEBT_SD_EVT_SEARCH_RESP;
        }

        rex_leave_crit_sect( &gSdCritSect );
      }
      break;
    }

    case BT_EV_SD_ERROR_RESP:
    {
      MSG_LOW( "SDEvCb - error resp %x", 
               bt_ev_msg_ptr->ev_msg.ev_sd_error_resp.error_code, 0, 0 );

      if ( AEEBT_BD_ADDRS_EQUAL( &bt_ev_msg_ptr->ev_msg.ev_sd_error_resp.bd_addr, 
                                 &gMgr.searchAddr ) )
      {
        switch ( bt_ev_msg_ptr->ev_msg.ev_sd_error_resp.error_code &
                 ~BT_CMD_EV_SDP_BASE)
        {
          case BT_SD_EV_ERROR_INVALID_RESPONSE_SYNTAX:
            pN->data.uError = AEEBT_SD_ERR_INVALID_RESPONSE_SYNTAX;
            break;
          case BT_SD_EV_ERROR_MAX_SDP_CONN_EXCEEDED:
            pN->data.uError = AEEBT_SD_ERR_MAX_SDP_CONN;
            break;
          case BT_SD_EV_ERROR_REQUEST_PENDING:
            pN->data.uError = AEEBT_SD_ERR_REQUEST_PENDING;
            break;
          case BT_SD_EV_ERROR_CONNECTION_FAILED:
            pN->data.uError = AEEBT_SD_ERR_CONN_FAILED;
            break;
          case BT_SD_EV_ERROR_SERVICE_NOT_FOUND:
            pN->data.uError = AEEBT_SD_ERR_SERVICE_NOT_FOUND;
            break;
          case BT_SD_EV_ERROR_CONNECTION_TERMINATED:
            pN->data.uError = AEEBT_SD_ERR_CONN_TERMINATED;
            break;
          default:
            pN->data.uError = AEEBT_SD_ERR_UNKNOWN;
            break;
        }

        rex_enter_crit_sect( &gSdCritSect );

        if ( gMgr.browseState == OEMBTExtSD_OP_PENDING )
        {
          gMgr.browseState = OEMBTExtSD_OP_NONE;
          pN->uID = AEEBT_SD_EVT_BROWSE_FAILED;
        }
        else if ( gMgr.browseState == OEMBTExtSD_OP_CANCEL )
        {
           gMgr.browseState = OEMBTExtSD_OP_NONE;
           pN->uID = AEEBT_SD_EVT_BROWSE_SERVICE_CANCELED;
           pN->data.uError = AEEBT_SD_ERR_NONE;
        }
        else if ( gMgr.bSearchPending )
        {
          gMgr.bSearchPending = FALSE;
          pN->uID = AEEBT_SD_EVT_SEARCH_FAILED;
        }
        else // must be for getting name
        {
          pN->uID = AEEBT_SD_EVT_DEVICE_NAME_FAILED;
        }

        rex_leave_crit_sect( &gSdCritSect );
      }
      break;
    }

    case BT_EV_SD_TIMEOUT_RESP:
    {
      MSG_LOW( "SDEvCb - timeout resp", 0, 0, 0 );
      if ( AEEBT_BD_ADDRS_EQUAL( 
             &bt_ev_msg_ptr->ev_msg.ev_sd_timeout_resp.bd_addr, 
             &gMgr.searchAddr ) )
      {
        pN->data.uError = AEEBT_SD_ERR_TIMEOUT;

        rex_enter_crit_sect( &gSdCritSect );

        if ( gMgr.browseState == OEMBTExtSD_OP_PENDING )
        {
          gMgr.browseState = OEMBTExtSD_OP_NONE;
          pN->uID = AEEBT_SD_EVT_BROWSE_FAILED;
        }
        if ( gMgr.browseState == OEMBTExtSD_OP_CANCEL )
        {
           gMgr.browseState = OEMBTExtSD_OP_NONE;
           pN->uID = AEEBT_SD_EVT_BROWSE_SERVICE_CANCELED;
           pN->data.uError = AEEBT_SD_ERR_NONE;
        }
        else if ( gMgr.bSearchPending )
        {
          gMgr.bSearchPending = FALSE;
          pN->uID = AEEBT_SD_EVT_SEARCH_FAILED;
        }
        else
        {
          MSG_ERROR( "SDEvCb - unexpected timeout resp %x %x %x",
            bt_ev_msg_ptr->ev_msg.ev_sd_timeout_resp.bd_addr.bd_addr_bytes[ 0 ],
            bt_ev_msg_ptr->ev_msg.ev_sd_timeout_resp.bd_addr.bd_addr_bytes[ 1 ],
            bt_ev_msg_ptr->ev_msg.ev_sd_timeout_resp.bd_addr.bd_addr_bytes[ 2 ] );
          IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );

          rex_leave_crit_sect( &gSdCritSect );
          return;
        }
        rex_leave_crit_sect( &gSdCritSect );
      }
      break;
    }

    case BT_EV_SD_DEVICE_NAME_RESP:
    {
      bt_ev_sd_dev_name_resp_type *pEvt = &bt_ev_msg_ptr->ev_msg.ev_sd_dname;

      if ( (pEvt->reason == BT_EVR_GN_SUCCESS) &&
           AEEBT_BD_ADDRS_EQUAL( &pEvt->bd_addr, &pMe->getNameAddr ) )
      {
        AEEBT_TO_WSTR( (char *)pEvt->device_name_str, pMe->pDevName,
                       pMe->uMaxNameLen * sizeof( AECHAR ) );
        pN->uID = AEEBT_SD_EVT_DEVICE_NAME_RESP;
      }
      else if ( pEvt->reason != BT_EVR_GN_SUCCESS )
      {
        pN->uID = AEEBT_SD_EVT_DEVICE_NAME_FAILED;
      }
      else
      {
        MSG_ERROR( "SDEvCb - unexp name rsp from %x%x%x",
                   pEvt->bd_addr.bd_addr_bytes[0],
                   pEvt->bd_addr.bd_addr_bytes[1],
                   pEvt->bd_addr.bd_addr_bytes[2] );
        IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
        return; // no notifications
      }
      break;
    }
    
    case BT_EV_SD_DISCOVERABLE_MODE_RESP:
    {
      bt_ev_sd_discoverable_mode_resp_type *pEvt = &bt_ev_msg_ptr->ev_msg.ev_sd_discv_mode_resp;

      pN->uID = AEEBT_SD_EVT_DISCOVERABLE_MODE_RESP;
      pN->data.sDiscoverableModeResp.uError = AEEBT_SD_ERR_NONE;

      if ( pEvt->discv_mode == BT_SD_SERVICE_DISCOVERABLE_MODE_NONE )
      {
        pN->data.sDiscoverableModeResp.mode = AEEBT_DISCOVERABLE_MODE_NONE;
      }
      else if ( pEvt->discv_mode == BT_SD_SERVICE_DISCOVERABLE_MODE_GENERAL )
      {
        pN->data.sDiscoverableModeResp.mode = AEEBT_DISCOVERABLE_MODE_GENERAL;
      }
      else if ( pEvt->discv_mode == BT_SD_SERVICE_DISCOVERABLE_MODE_LIMITED )
      {
        pN->data.sDiscoverableModeResp.mode = AEEBT_DISCOVERABLE_MODE_LIMITED;
      }

      break;
    }

    default:
    {
      MSG_ERROR( "SDEvCb - unexpect event %x", 
                 bt_ev_msg_ptr->ev_hdr.ev_type, 0, 0 );
      IBTEXTNOTIFIER_ReleaseNotification( pMe->m_pNotifier, pN );
      return;
    }
  }

  pN->uID = (pN->uID << 16) | GET_NOTIFIER_MASK( NMASK_BT_SD );
  IBTEXTNOTIFIER_DoNotify( pMe->m_pNotifier, pN, pMe->m_pac );
}

#endif // defined(FEATURE_IBT)
