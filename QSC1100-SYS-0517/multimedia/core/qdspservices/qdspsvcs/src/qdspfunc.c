/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                   Q D S P   S E R V I C E S   M O D U L E
                         A P I   F U N C T I O N S
                     
GENERAL DESCRIPTION
  This module provides the software interface that allows applications to
  download selected firmware images, enable and disable QDSP operation and
  gain access to the QDSP/ARM shared memory area.

EXTERNALIZED FUNCTIONS
  qdsp_peek
    Read a block of data from the QDSP/ARM shared memory. Enables DSP clocks if
    necessary.
  qdsp_poke
    Write a block of data to the QDSP/ARM shared memory. Enables DSP clocks if
    necessary.
  qdsp_register_app
    Register an application with the QDSP Services.
  qdsp_register_isr
    Register an ISR with the QDSP Services.
  qdsp_enable
    Activate the a DSP module.
  qdsp_disable
    De-activate a DSP module.
  qdsp_reset_and_enable
    Force the DSP to be reset before enabling a DSP module (Debugging use only).
  qdsp_disable_event_rsp
    Notifies QDSP Services that the calling Application's DSP module may be
    disabled.

INITIALIZATION AND SEQUENCING REQUIREMENTS
  None

Copyright(c) 2000 - 2005 by QUALCOMM, Incorporated. All Rights Reserved.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/* <EJECT> */
/*===========================================================================

                      EDIT HISTORY FOR FILE

  This section contains comments describing changes made to this file.
  Notice that changes are listed in reverse chronological order.

  $Header: //source/qcom/qct/multimedia/core/qdspservices/6k/ver1/qdspsvcs/main/latest/src/qdspfunc.c#3 $ $DateTime: 2008/05/20 10:06:21 $ $Author: vparasar $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
11/08/06    sp     Included string.h to eliminate compiler warnings.
05/16/05    sg     Added additional debug messages.
11/19/04    sg     Merged module-based QDSP services from 00.00.13.01. Added
                   support for concurrent images.
03/13/03    sg     Updated peek and poke to use INTLOCK instead of INLOCK_SAV.
04/27/02    sg     Modified to allow the specification of zero interrupts in the
                   qdspext configuration file.
02/21/02    sm     Added qdsp_reset() function.
11/06/00    ro     Supports new image parser:
                     - Removed access functions (now generated by parser)
                   Remove image_reset_mask.
10/27/00    st     Modified code to remove compiler warnings.
10/18/00    sm     Changed qdsp_peek/poke() to use int as length.
10/04/00    sm     Added qdsp_block_read(), qdsp_block_write().
                   Added app_id to events.
09/07/00    ro     Change qdsp_dsp_address to divide the address by 2.
08/28/00    ro     Unit integration.
08/17/00   spf     Initial revision.

===========================================================================*/

/* <EJECT> */
/*===========================================================================

                           INCLUDE FILES FOR MODULE

===========================================================================*/

#include "target.h"    /* Target specific definitions            */
#include "comdef.h"    /* Common stuff                           */
#include "err.h"       /* Error reporting                        */
#include "msg.h"       /* Diagnostic error messages              */
#include "qdspext.h"   /* QDSP firmware images and access        */
#include "qdspi.h"     /* Internal QDSP Services definitions     */
#include <string.h>    /* Provides declarations for mem* funcs   */

/* <EJECT> */
/*===========================================================================

                    DEFINITIONS AND DECLARATIONS FOR MODULE

This section contains definitions for constants, macros, types, variables
and other items needed to interface with the QDSP Services module.

===========================================================================*/

/* Mask to track application clock usage */
extern uint32 qdsp_clock_mask;

/*===========================================================================

FUNCTION QDSP_PEEK

DESCRIPTION
  Reads a block of data from the QDSP/ARM shared memory area.  This function
  will activate the clocks if they are not active so it can be called at any
  time.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_peek (
  void*    src_ptr,    /* The start address of the QDSP memory block to read */
  void*    dst_ptr,    /* The address of the ARM destination buffer          */
  uint32   byte_length /* The length in bytes of the memory block            */
)
{
  /* Critical section.  Do not want QDSP task to perform any memory 
  ** accesses while peek operation is in progress.
  */
  INTLOCK();

  if (!qdsp_clock_mask)
  {
    /* Turn on the clock if it not already on */
    qdsp_clocks_enable( QDSP_APP_MAX );
  }
    
  qdsp_byte_read(src_ptr, dst_ptr, byte_length);
  
  /* Disable QDSP clocks */
  qdsp_clocks_disable( QDSP_APP_MAX );

  INTFREE();

} /* qdsp_peek */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_POKE

DESCRIPTION
  Writes a block of data to the QDSP/ARM shared memory area.  This function
  will activate the QDSP clocks if they are not active so it can be called 
  at any time.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_poke (
  void*  src_ptr,    /* The address of the source buffer to write to the QDSP */
  void*  dst_ptr,    /* The start address of the QDSP memory block to write   */
  uint32 byte_length /* The length in bytes of the memory block               */
)
{
  /* Critical section.  Do not want QDSP task to perform any memory 
  ** accesses while poke operation is in progress.
  */
  INTLOCK();
  
  if (!qdsp_clock_mask)
  {
    /* Turn on the clock if it not already on */
    qdsp_clocks_enable( QDSP_APP_MAX );
  }
    
  qdsp_byte_write(src_ptr, dst_ptr, byte_length);
  
  /* Disable QDSP clocks */
  qdsp_clocks_disable( QDSP_APP_MAX );

  INTFREE();

} /* qdsp_poke */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_REGISTER_APP

DESCRIPTION
  Applications use this function to register interrupt handler functions,
  event callback function and event mask. Once registered, applications will
  begin receiving all events in their event mask. The application's
  interrupt handlers will only be called when the application has enabled the
  QDSP by calling qdsp_enable().

  Note on registering ISRs:
    If the client does not wish to register for any DSP interrupts, then
       the isrs_ptr parameter must be set to NULL.
    If interrupts are registered, they must be passed using 
       qdsp_isr_func_type pointers in an array of size QDSP_ISR_MAX.
     
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  A QDSP_EV_COMMAND event will issued to the calling application once the
  command has completed.

===========================================================================*/
void qdsp_register_app (
  qdsp_app_type      app_id,    /* Application ID                            */
  qdsp_isr_func_type *isrs_ptr, /* Pointer to a table of ISRs for the App    */
  qdsp_event_cb_type cb_ptr,    /* Application's event callback function     */
  uint16 event_mask  /* Mask of events that the application needs to receive */
)
{
  qdsp_command_status_type status = QDSP_CMD_FAIL;
  qdsp_packet_type         *packet;

  MSG_HIGH("qdsp_register_app(%d)", app_id, 0, 0);

  if ( app_id < QDSP_APP_MAX )
  {
    packet = qdsp_get_packet();

    if ( packet != NULL )
    {
      packet->hdr.cmd                     = QDSP_CMD_REGISTER_APP;
      packet->register_app_cmd.app_id     = app_id;
      packet->register_app_cmd.cb_ptr     = cb_ptr;
      packet->register_app_cmd.event_mask = event_mask;
      if (isrs_ptr == NULL)
      {
        memset(packet->register_app_cmd.isrs, NULL,
               sizeof(qdsp_app_table[app_id].isrs));
      }
      else
      {
        memcpy(packet->register_app_cmd.isrs, isrs_ptr,
               sizeof(qdsp_app_table[app_id].isrs));
      }

      qdsp_cmd( packet );
      status = QDSP_CMD_ACCEPT;
    }
    /* else ran out of packets */
  }
  else
  {
    /* Can't issue failure callback, since the app_id is invalid. */
    ERR_FATAL("Invalid QDSP AppId %d", app_id, 0, 0);
  }

  if ( status == QDSP_CMD_FAIL && cb_ptr != NULL )
  {
    /* Can't use qdsp_send_cmd_event() here, since the app. is unregistered. */
    qdsp_ev_cmd_type cmd_event;
    cmd_event.event      = QDSP_EV_COMMAND;
    cmd_event.app_id     = app_id;
    cmd_event.cmd_status = status;

    cb_ptr((qdsp_event_data_type*)&cmd_event);
  }
} /* qdsp_register_app */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_REGISTER_ISR

DESCRIPTION
  Applications use this function to register an interrupt handler function
  for the specified DSP interrupt. The application's interrupt handler will
  only be called when the application has enabled the QDSP by calling
  qdsp_enable(). This function may be used to change the client's registered
  ISRs even after the client is enabled using qdsp_enable().

DEPENDENCIES
  The client must have been previously registered using qdsp_register_app().

RETURN VALUE
  None

SIDE EFFECTS
  A QDSP_EV_COMMAND event will issued to the calling application once the
  command has completed.

===========================================================================*/
void qdsp_register_isr (
  qdsp_app_type            app_id,  /* Application ID                      */
  qdsp_isr_func_type       isr_ptr, /* ISR function pointer                */
  qdsp_isr_type            isr_type /* Interrupt to register with          */
)
{
  qdsp_command_status_type status = QDSP_CMD_FAIL;
  qdsp_packet_type         *packet;

  MSG_HIGH("qdsp_register_isr(%d)", app_id, 0, 0);

  if ( app_id < QDSP_APP_MAX )
  {
    if ( isr_type < QDSP_ISR_MAX )
    {
      packet = qdsp_get_packet();

      if ( packet != NULL )
      {
        packet->hdr.cmd                     = QDSP_CMD_REGISTER_ISR;
        packet->register_isr_cmd.app_id     = app_id;
        packet->register_isr_cmd.isr_ptr    = isr_ptr;
        packet->register_isr_cmd.isr_type   = isr_type;

        qdsp_cmd( packet );
        status = QDSP_CMD_ACCEPT;
      }
      /* else ran out of packets */
    }
    else
    {
      MSG_HIGH("Invalid ISR type %d", (int)isr_type, 0, 0);
    }
  }
  else
  {
    /* Can't issue failure callback, since the app_id is invalid. */
    ERR_FATAL("Invalid QDSP AppId %d", app_id, 0, 0);
  }

  if ( status == QDSP_CMD_FAIL  )
  {
    /* Issue a Event callback to indicate failure */
    qdsp_send_cmd_event(app_id, status);
  }

} /* qdsp_register_isr */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_ENABLE

DESCRIPTION
  Applications use this function to indicate which QDSP module should be
  enabled. When the calling application's priority is high enough,
  QDSP Services will issue a callback to the application, indicating that it
  has been enabled. When the "MOD_READY" event is received, the QDSP clocks are
  on, the current firmware image is running and the requested module is ready
  for use on the QDSP.

  When QDSP-to-ARM interrupts occur, QDSP Services will call the registered
  interrupt handlers (highest priority first) of each application is currently
  enabled.

DEPENDENCIES
  It is important that applications call qdsp_disable() when they finish using
  the QDSP.  If the QDSP is left enabled, excessive power comsumption will
  result.

RETURN VALUE
  None

SIDE EFFECTS
  A QDSP_EV_COMMAND event will issued to the calling application immediately
  after the command is accepted. Note however, that this does not mean that
  the requested module has been enabled. The client application _must_ wait
  to receive the QDSP_MOD_READY event.

===========================================================================*/
void qdsp_enable (
  qdsp_app_type    app_id,  /* Application ID       */
  qdsp_module_type module   /* The module to enable */
)
{
  qdsp_command_status_type cmd_status = QDSP_CMD_FAIL;
  qdsp_packet_type         *packet;

  MSG_HIGH("qdsp_enable(app=%d, mod=%d)", app_id, module, 0);

  if ( app_id < QDSP_APP_MAX )
  {
    if( module < QDSP_MODULE_MAX )
    {
      packet = qdsp_get_packet();

      if ( packet != NULL )
      {
        packet->hdr.cmd           = QDSP_CMD_ENABLE;
        packet->enable_cmd.app_id = app_id;
        packet->enable_cmd.module = module;

        qdsp_cmd( packet );
        cmd_status = QDSP_CMD_ACCEPT;
      }
      /* else ran out of packets */
    }
    else
    {
      MSG_HIGH("Invalid module %d", module, 0, 0);
    }
  }
  else
  {
    /* Can't issue failure callback, since the app_id is invalid. */
    ERR_FATAL("Invalid QDSP AppId %d", app_id, 0, 0);
  }

  if (cmd_status == QDSP_CMD_FAIL)
  {
    /* Send failure indication right away. */
    qdsp_send_cmd_event(app_id, cmd_status);
  }

} /* qdsp_enable */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_DISABLE

DESCRIPTION
  Applications use this function to disable the QDSP.  QDSP Services disables
  the QDSP when no application require it to be enabled.  When the QDSP is
  disabled, its clocks are off and the current firmware image is not running.
  The QDSP draws minimum current when it is disabled.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  A QDSP_EV_COMMAND event will issued to the calling application once the
  command has completed.

===========================================================================*/
void qdsp_disable (
  qdsp_app_type app_id /* Application ID */
)
{
  qdsp_packet_type  *packet;

  MSG_HIGH("qdsp_disable(app=%d)", app_id, 0, 0);

  if ( app_id < QDSP_APP_MAX )
  {
    packet = qdsp_get_packet();

    if ( packet != NULL )
    {
      packet->hdr.cmd            = QDSP_CMD_DISABLE;
      packet->disable_cmd.app_id = app_id;

      qdsp_cmd( packet );
    }
    else
    {
      /* Ran out of command packets. */
      qdsp_send_cmd_event(app_id, QDSP_CMD_FAIL);
    }
  }
  else
  {
    /* Can't issue failure callback, since the app_id is invalid. */
    ERR_FATAL("Invalid QDSP AppId %d", app_id, 0, 0);
  }
} /* qdsp_disable */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_RESET_AND_ENABLE

DESCRIPTION
  Applications use this function to reset the DSP and enable a module.
  This is useful when the client wants to ensure that QDSP services actually
  does a reset and redownload of the image, before it is enabled. In the
  normal scenario, the DSP is not reset between successive calls to
  qdsp_enable() and qdsp_disable(), if the image has not changed.

  NOTE: This interface must used only as a debugging aid, since resetting the
  DSP may cause other QDSP Services clients to react adversely.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  A QDSP_EV_COMMAND event will issued to the calling application once the
  command has completed.

===========================================================================*/
void qdsp_reset_and_enable (
  qdsp_app_type    app_id,  /* Application ID       */
  qdsp_module_type module   /* The module to enable */
)
{
  qdsp_command_status_type cmd_status = QDSP_CMD_FAIL;
  qdsp_packet_type         *packet;

  MSG_HIGH("qdsp_reset_and_enable(app=%d, mod=%d)", app_id, module, 0);

  if ( app_id < QDSP_APP_MAX )
  {
    if( module < QDSP_MODULE_MAX )
    {
      packet = qdsp_get_packet();

      if ( packet != NULL )
      {
        packet->hdr.cmd = QDSP_CMD_RESET_AND_ENABLE;
        packet->reset_and_enable_cmd.app_id = app_id;
        packet->reset_and_enable_cmd.module = module;

        qdsp_cmd( packet );
        cmd_status = QDSP_CMD_ACCEPT;
      }
      /* else ran out of packets */
    }
    else
    {
      MSG_HIGH("Invalid module %d", module, 0, 0);
    }
  }
  else
  {
    /* Can't issue failure callback, since the app_id is invalid. */
    ERR_FATAL("Invalid QDSP AppId %d", app_id, 0, 0);
  }

  if (cmd_status == QDSP_CMD_FAIL)
  {
    /* Send failure indication right away. */
    qdsp_send_cmd_event(app_id, cmd_status);
  }

} /* qdsp_reset_and_enable */

/* <EJECT> */
/*===========================================================================

FUNCTION QDSP_DISABLE_EVENT_RSP

DESCRIPTION
  Applications should call this function in response to a QDSP_EV_MODULE event
  with QDSP_MOD_DISABLE status. QDSP Services issues this event whenever the
  client application's use of the QDSP will be preempted temporarily. Once the
  client receives this event, it may possibly save any context information and
  stop using the DSP. It should then call this function to indicate to QDSP
  Services that it is ready to be disabled.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void qdsp_disable_event_rsp (
  qdsp_app_type app_id /* Application ID */
)
{
  qdsp_packet_type  *packet;

  MSG_HIGH("qdsp_disable_event_rsp(app=%d)", app_id, 0, 0);

  if ( app_id < QDSP_APP_MAX )
  {
    packet = qdsp_get_packet();

    if ( packet != NULL )
    {
      packet->hdr.cmd = QDSP_CMD_DISABLE_EVENT_RSP;
      packet->disable_event_rsp_cmd.app_id = app_id;

      qdsp_cmd( packet );
    }
    else
    {
      /* Ran out of command packets. */
      qdsp_send_cmd_event(app_id, QDSP_CMD_FAIL);
    }
  }
  else
  {
    /* Can't issue failure callback, since the app_id is invalid. */
    ERR_FATAL("Invalid QDSP AppId %d", app_id, 0, 0);
  }
} /* qdsp_disable_event_rsp */

